<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mapbox Line Drag Test - Desktop & Mobile</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif;
        }
        #map { 
            position: absolute; 
            top: 80px; 
            bottom: 0; 
            width: 100%; 
        }
        .info-panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            box-sizing: border-box;
            font-size: 14px;
            z-index: 1000;
            overflow-y: auto;
        }
        .status {
            font-weight: bold;
            margin-bottom: 5px;
            color: #00FF00;
        }
        .debug {
            font-family: monospace;
            font-size: 11px;
            color: #CCCCCC;
        }
        .approach {
            color: #FFD700;
            font-weight: bold;
        }
        
        /* Critical CSS for touch handling */
        .mapboxgl-canvas-container {
            touch-action: none !important;
        }
        
        .mapboxgl-canvas {
            touch-action: none !important;
        }
        
        /* Prevent text selection during drag */
        .mapboxgl-map {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="info-panel">
        <div class="status" id="status">üöÄ Ready - Drag BETWEEN pins to insert | Drag END pin to extend | Click map to add segment</div>
        <div class="debug" id="debug">üîç Debug info will appear here...</div>
    </div>
    <div id="map"></div>

    <script>
        // Using the actual Mapbox token from FastPlanner project
        mapboxgl.accessToken = 'pk.eyJ1IjoiZGlya3N0ZXIxMDEiLCJhIjoiY204YW9mdm4yMTliMTJscXVnaXRqNmptNyJ9.VDLt_kE5BnAV8S4vXjFMlg';
        
        const statusEl = document.getElementById('status');
        const debugEl = document.getElementById('debug');
        
        function updateStatus(message) {
            statusEl.innerHTML = `üéØ ${message}`;
            console.log('STATUS:', message);
        }
        
        function updateDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugEl.innerHTML = `[${timestamp}] ${message}`;
            console.log('DEBUG:', message);
        }
        
        // Detect device type
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isIPad = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        
        updateDebug(`üì± Device: ${isIPad ? 'iPad' : isTouchDevice ? 'Touch Device' : 'Desktop'} | Touch Points: ${navigator.maxTouchPoints}`);
        
        // Initialize map - using Gulf Coast area like FastPlanner
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            center: [-94.8, 29.3], // Gulf Coast
            zoom: 8,
            // Disable some interactions that might interfere
            dragRotate: false,
            pitchWithRotate: false,
            touchZoomRotate: true
        });
        
        // Initial line coordinates (Gulf Coast helicopter route style)
        // More realistic route with multiple segments for better middle-drag testing
        let lineCoordinates = [
            [-94.9, 29.2],   // Start (near shore)
            [-94.7, 29.3],   // Waypoint 1
            [-94.5, 29.4],   // Waypoint 2
            [-94.3, 29.5],   // Waypoint 3
            [-94.1, 29.6]    // End (offshore)
        ];
        
        let isDragging = false;
        let dragStartCoord = null;
        let originalLineCoordinates = [];
        let activeApproach = 'none';
        let waypointMarkers = []; // Store waypoint markers like FastPlanner
        let dragMode = 'none'; // 'insert', 'extend', 'none'
        let draggedPinIndex = -1; // Which pin is being dragged
        
        // Create the line data
        const lineGeoJSON = {
            'type': 'Feature',
            'properties': {},
            'geometry': {
                'type': 'LineString',
                'coordinates': lineCoordinates
            }
        };
        
        // Create waypoint markers data
        const waypointsGeoJSON = {
            'type': 'FeatureCollection',
            'features': lineCoordinates.map((coord, index) => ({
                'type': 'Feature',
                'properties': {
                    'index': index,
                    'name': `WP${index + 1}`,
                    'isStart': index === 0,
                    'isEnd': index === lineCoordinates.length - 1
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': coord
                }
            }))
        };
        
        // Add source and layer when map loads
        map.on('load', () => {
            updateStatus('Map loaded - Adding route with waypoint pins');
            
            // Add line source
            map.addSource('draggable-line', {
                'type': 'geojson',
                'data': lineGeoJSON
            });
            
            // Add waypoint pins source
            map.addSource('waypoint-pins', {
                'type': 'geojson',
                'data': waypointsGeoJSON
            });
            
            // Add line layer with hover-friendly styling
            map.addLayer({
                'id': 'line',
                'type': 'line',
                'source': 'draggable-line',
                'layout': {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                'paint': {
                    'line-color': '#FF0000',
                    'line-width': 4, // Thinner line, pins will be the main visual
                    'line-opacity': 0.8
                }
            });
            
            // Add invisible wider line for easier touch detection
            map.addLayer({
                'id': 'line-touch-area',
                'type': 'line',
                'source': 'draggable-line',
                'layout': {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                'paint': {
                    'line-color': 'transparent',
                    'line-width': 20, // Much wider for touch
                    'line-opacity': 0
                }
            });
            
            // Add waypoint pins (like FastPlanner)
            map.addLayer({
                'id': 'waypoint-pins',
                'type': 'circle',
                'source': 'waypoint-pins',
                'paint': {
                    'circle-radius': 8,
                    'circle-color': [
                        'case',
                        ['get', 'isStart'], '#00FF00', // Green for start
                        ['get', 'isEnd'], '#FF0000',   // Red for end
                        '#0080FF'                       // Blue for waypoints
                    ],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#FFFFFF',
                    'circle-opacity': 0.9
                }
            });
            
            // Add pin labels
            map.addLayer({
                'id': 'waypoint-labels',
                'type': 'symbol',
                'source': 'waypoint-pins',
                'layout': {
                    'text-field': ['get', 'name'],
                    'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'],
                    'text-offset': [0, 1.5],
                    'text-anchor': 'top',
                    'text-size': 12
                },
                'paint': {
                    'text-color': '#FFFFFF',
                    'text-halo-color': '#000000',
                    'text-halo-width': 1
                }
            });
            
            updateStatus('Route with pins added - Drag BETWEEN pins to add waypoints');
            setupDragHandlers();
        });
        
        function setupDragHandlers() {
            updateDebug(`üîß Setting up drag handlers for ${isTouchDevice ? 'touch' : 'mouse'} device...`);
            
            // APPROACH 1: Mapbox Native Events (Primary)
            setupMapboxEvents();
            
            // APPROACH 2: DOM Events with proper configuration (Fallback for touch)
            if (isTouchDevice) {
                setupDOMTouchEvents();
            }
        }
        
        function setupMapboxEvents() {
            updateDebug('üì° <span class="approach">APPROACH 1</span>: Setting up Mapbox native events...');
            
            // Use both visible line and touch area for detection
            const layers = ['line', 'line-touch-area'];
            
            // Mouse events for desktop
            layers.forEach(layer => {
                map.on('mousedown', layer, onMapboxMouseStart);
                map.on('touchstart', layer, onMapboxTouchStart);
            });
            
            // Add endpoint dragging functionality
            map.on('mousedown', 'waypoint-pins', onPinMouseDown);
            map.on('touchstart', 'waypoint-pins', onPinTouchStart);
            
            // Add click to extend route functionality
            map.on('click', onMapClick);
            
            // Hover effects for the line (not the pins)
            map.on('mouseenter', 'line', () => {
                map.getCanvas().style.cursor = 'grab';
                map.setPaintProperty('line', 'line-color', '#FF4444');
                updateDebug('üñ±Ô∏è Mouse entered line - ready to drag between waypoints');
            });
            
            map.on('mouseleave', 'line', () => {
                if (!isDragging) {
                    map.getCanvas().style.cursor = '';
                    map.setPaintProperty('line', 'line-color', '#FF0000');
                    updateDebug('üñ±Ô∏è Mouse left line');
                }
            });
            
            // Add hover effects for pins
            map.on('mouseenter', 'waypoint-pins', (e) => {
                const pinIndex = e.features[0].properties.index;
                const isEndpoint = e.features[0].properties.isEnd;
                
                if (isEndpoint) {
                    map.getCanvas().style.cursor = 'grab';
                    updateDebug(`üìç Hover over END pin (WP${pinIndex + 1}) - draggable to extend route`);
                } else {
                    map.getCanvas().style.cursor = 'pointer';
                    updateDebug(`üìç Hover over waypoint (WP${pinIndex + 1}) - not draggable in this test`);
                }
            });
            
            map.on('mouseleave', 'waypoint-pins', () => {
                if (!isDragging) {
                    map.getCanvas().style.cursor = '';
                }
            });
        }
        
        function setupDOMTouchEvents() {
            updateDebug('üì± <span class="approach">APPROACH 2</span>: Setting up DOM touch events with passive:false...');
            
            const canvas = map.getCanvasContainer();
            
            // DOM touch events with proper passive configuration
            canvas.addEventListener('touchstart', onDOMTouchStart, { 
                passive: false, 
                capture: true 
            });
            
            updateDebug('‚úÖ DOM touch events registered with passive:false');
        }
        
        function onPinMouseDown(e) {
            const pinIndex = e.features[0].properties.index;
            const isEndpoint = e.features[0].properties.isEnd;
            
            if (!isEndpoint) {
                updateDebug(`‚ùå Pin ${pinIndex + 1} is not draggable (only endpoint can be dragged)`);
                return;
            }
            
            activeApproach = 'pin-drag-mouse';
            dragMode = 'extend';
            draggedPinIndex = pinIndex;
            
            updateStatus(`üéØ DRAGGING ENDPOINT: Moving WP${pinIndex + 1} to extend route`);
            updateDebug(`üìç Started dragging endpoint pin ${pinIndex + 1}`);
            
            e.preventDefault();
            startDrag(e.lngLat, 'pin-drag-mouse');
            
            map.on('mousemove', onMapboxDragMove);
            map.once('mouseup', onMapboxDragEnd);
        }
        
        function onPinTouchStart(e) {
            const pinIndex = e.features[0].properties.index;
            const isEndpoint = e.features[0].properties.isEnd;
            
            if (!isEndpoint) {
                updateDebug(`‚ùå Pin ${pinIndex + 1} is not draggable (only endpoint can be dragged)`);
                return;
            }
            
            if (e.points.length !== 1) {
                updateDebug('‚ùå Multi-touch detected, ignoring');
                return;
            }
            
            activeApproach = 'pin-drag-touch';
            dragMode = 'extend';
            draggedPinIndex = pinIndex;
            
            updateStatus(`üì± TOUCH DRAGGING ENDPOINT: Moving WP${pinIndex + 1}`);
            updateDebug(`üì± Started touch dragging endpoint pin ${pinIndex + 1}`);
            
            try {
                e.preventDefault();
                updateDebug('‚úÖ e.preventDefault() called successfully on pin touch event');
            } catch (error) {
                updateDebug(`‚ùå e.preventDefault() failed: ${error.message}`);
            }
            
            startDrag(e.lngLat, 'pin-drag-touch');
            
            map.on('touchmove', onMapboxDragMove);
            map.once('touchend', onMapboxDragEnd);
        }
        
        function onMapClick(e) {
            if (isDragging) return; // Don't add points while dragging
            
            // Check if click is on the map (not on pins or line)
            const features = map.queryRenderedFeatures(e.point, { 
                layers: ['waypoint-pins', 'line', 'line-touch-area'] 
            });
            
            if (features.length > 0) {
                updateDebug('üñ±Ô∏è Click on existing feature, ignoring');
                return; // Click was on a pin or line
            }
            
            // Add new waypoint at end of route
            const newCoord = [e.lngLat.lng, e.lngLat.lat];
            lineCoordinates.push(newCoord);
            
            // Update the line
            lineGeoJSON.geometry.coordinates = lineCoordinates;
            map.getSource('draggable-line').setData(lineGeoJSON);
            
            // Update waypoint markers
            updateWaypointMarkers();
            
            updateStatus(`‚úÖ NEW SEGMENT: Added WP${lineCoordinates.length} by clicking`);
            updateDebug(`üñ±Ô∏è Click-to-add: New waypoint at ${newCoord[0].toFixed(4)}, ${newCoord[1].toFixed(4)}`);
        }
        
        function onMapboxMouseStart(e) {
            activeApproach = 'mapbox-mouse';
            dragMode = 'insert';
            draggedPinIndex = -1;
            
            updateStatus('üñ±Ô∏è LINE DRAG: Adding waypoint between pins');
            updateDebug(`üñ±Ô∏è Line drag started: ${e.lngLat.lng.toFixed(4)}, ${e.lngLat.lat.toFixed(4)}`);
            
            e.preventDefault();
            startDrag(e.lngLat, 'mapbox-mouse');
            
            map.on('mousemove', onMapboxDragMove);
            map.once('mouseup', onMapboxDragEnd);
        }
        
        function onMapboxTouchStart(e) {
            activeApproach = 'mapbox-touch';
            dragMode = 'insert';
            draggedPinIndex = -1;
            
            updateStatus('üì± LINE TOUCH: Adding waypoint between pins');
            updateDebug(`üì± Line touch started: Points=${e.points.length}, LngLat=${e.lngLat.lng.toFixed(4)}, ${e.lngLat.lat.toFixed(4)}`);
            
            if (e.points.length !== 1) {
                updateDebug('‚ùå Multi-touch detected, ignoring');
                return;
            }
            
            try {
                e.preventDefault();
                updateDebug('‚úÖ e.preventDefault() called successfully on line touch event');
            } catch (error) {
                updateDebug(`‚ùå e.preventDefault() failed: ${error.message}`);
            }
            
            startDrag(e.lngLat, 'mapbox-touch');
            
            map.on('touchmove', onMapboxDragMove);
            map.once('touchend', onMapboxDragEnd);
        }
        
        function onDOMTouchStart(e) {
            activeApproach = 'dom-touch';
            updateStatus('üì± DOM TOUCH: Touch detected');
            updateDebug(`üì± DOM Touch Event: ${e.touches.length} touches, cancelable=${e.cancelable}`);
            
            if (e.touches.length !== 1) {
                updateDebug('‚ùå Multi-touch detected in DOM event, ignoring');
                return;
            }
            
            // Check if touch is on the line
            const rect = e.target.getBoundingClientRect();
            const point = {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
            
            const features = map.queryRenderedFeatures(point, { layers: ['line', 'line-touch-area'] });
            if (features.length === 0) {
                updateDebug('‚ùå Touch not on line, ignoring');
                return;
            }
            
            updateStatus('üì± DOM TOUCH: Drag started');
            updateDebug(`üì± Touch on line detected at pixel: ${point.x}, ${point.y}`);
            
            // Try to prevent default
            if (e.cancelable) {
                e.preventDefault();
                updateDebug('‚úÖ e.preventDefault() called successfully on DOM touch event');
            } else {
                updateDebug('‚ùå DOM touch event not cancelable - cannot preventDefault()');
            }
            
            const lngLat = map.unproject(point);
            startDrag(lngLat, 'dom-touch');
            
            // Add DOM move/end listeners
            document.addEventListener('touchmove', onDOMTouchMove, { passive: false });
            document.addEventListener('touchend', onDOMTouchEnd, { passive: false });
        }
        
        function onDOMTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            
            updateDebug(`üì± DOM touchmove: cancelable=${e.cancelable}`);
            
            if (e.cancelable) {
                e.preventDefault();
            }
            
            const rect = map.getCanvasContainer().getBoundingClientRect();
            const point = {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
            
            const lngLat = map.unproject(point);
            updateDrag(lngLat);
        }
        
        function onDOMTouchEnd(e) {
            updateDebug('üì± DOM touchend event');
            endDrag();
            document.removeEventListener('touchmove', onDOMTouchMove);
            document.removeEventListener('touchend', onDOMTouchEnd);
        }
        
        function startDrag(lngLat, approach) {
            isDragging = true;
            activeApproach = approach;
            dragStartCoord = [lngLat.lng, lngLat.lat];
            originalLineCoordinates = [...lineCoordinates];
            
            map.getCanvas().style.cursor = 'grabbing';
            map.setPaintProperty('line', 'line-color', '#00FF00'); // Green when dragging
            
            const modeText = dragMode === 'extend' ? 'EXTENDING ROUTE' : 'INSERTING WAYPOINT';
            updateStatus(`üéØ ${modeText} via ${approach.toUpperCase()}...`);
            updateDebug(`üöÄ Drag started: mode=${dragMode}, approach=${approach}`);
        }
        
        function onMapboxDragMove(e) {
            if (!isDragging) return;
            updateDebug(`üìç Mapbox drag move: ${e.lngLat.lng.toFixed(4)}, ${e.lngLat.lat.toFixed(4)}`);
            updateDrag(e.lngLat);
        }
        
        function updateDrag(lngLat) {
            if (!isDragging) return;
            
            const currentCoord = [lngLat.lng, lngLat.lat];
            
            if (dragMode === 'extend') {
                // Endpoint dragging - update the last coordinate
                const newCoordinates = [...originalLineCoordinates];
                newCoordinates[draggedPinIndex] = currentCoord;
                
                // Update the line to show the drag in real-time
                lineGeoJSON.geometry.coordinates = newCoordinates;
                map.getSource('draggable-line').setData(lineGeoJSON);
                
                updateDebug(`üìç Extending route: moving WP${draggedPinIndex + 1} to ${currentCoord[0].toFixed(4)}, ${currentCoord[1].toFixed(4)}`);
                
            } else if (dragMode === 'insert') {
                // Line insertion - find closest point for insertion (like FastPlanner)
                const closestPoint = findClosestPointOnLine(currentCoord);
                if (!closestPoint) {
                    updateDebug('‚ùå Could not find closest point on line');
                    return;
                }
                
                // Create new line with point inserted at the correct position
                const newCoordinates = [...originalLineCoordinates];
                newCoordinates.splice(closestPoint.insertIndex, 0, currentCoord);
                
                // Update the line to show the drag in real-time
                lineGeoJSON.geometry.coordinates = newCoordinates;
                map.getSource('draggable-line').setData(lineGeoJSON);
                
                updateDebug(`üìç Inserting waypoint: position ${closestPoint.insertIndex} between segments (${newCoordinates.length} total points)`);
            }
        }
        
        function onMapboxDragEnd(e) {
            updateDebug('üèÅ Mapbox drag end event');
            endDrag();
        }
        
        function endDrag() {
            if (!isDragging) return;
            
            const wasApproach = activeApproach;
            const wasMode = dragMode;
            isDragging = false;
            activeApproach = 'none';
            dragMode = 'none';
            dragStartCoord = null;
            draggedPinIndex = -1;
            
            // Update permanent coordinates
            lineCoordinates = [...lineGeoJSON.geometry.coordinates];
            
            // Recreate waypoint markers with new coordinates
            updateWaypointMarkers();
            
            map.getCanvas().style.cursor = '';
            map.setPaintProperty('line', 'line-color', '#FF0000');
            
            // Remove event listeners
            map.off('mousemove', onMapboxDragMove);
            map.off('touchmove', onMapboxDragMove);
            
            const actionText = wasMode === 'extend' ? 'endpoint moved' : 'waypoint inserted';
            updateStatus(`‚úÖ ${wasApproach.toUpperCase()}: ${actionText}!`);
            updateDebug(`üéâ Success! Route now has ${lineCoordinates.length} waypoints (was ${lineCoordinates.length - (wasMode === 'extend' ? 0 : 1)})`);
        }
        
        function updateWaypointMarkers() {
            // Update waypoint markers to match new coordinates (like FastPlanner)
            waypointsGeoJSON.features = lineCoordinates.map((coord, index) => ({
                'type': 'Feature',
                'properties': {
                    'index': index,
                    'name': `WP${index + 1}`,
                    'isStart': index === 0,
                    'isEnd': index === lineCoordinates.length - 1
                },
                'geometry': {
                    'type': 'Point',
                    'coordinates': coord
                }
            }));
            
            // Update the waypoint source
            map.getSource('waypoint-pins').setData(waypointsGeoJSON);
        }
        
        function findClosestPointOnLine(coord) {
            if (!originalLineCoordinates || originalLineCoordinates.length < 2) {
                updateDebug('‚ùå No original coordinates for closest point calculation');
                return null;
            }
            
            let minDistance = Infinity;
            let insertIndex = 1; // Default to insert after first point
            let bestSegment = -1;
            
            // Check each segment to find where to insert the new point
            for (let i = 0; i < originalLineCoordinates.length - 1; i++) {
                try {
                    const line = turf.lineString([originalLineCoordinates[i], originalLineCoordinates[i + 1]]);
                    const point = turf.point(coord);
                    const snapped = turf.nearestPointOnLine(line, point);
                    
                    if (snapped.properties.dist < minDistance) {
                        minDistance = snapped.properties.dist;
                        insertIndex = i + 1; // Insert after the start of this segment
                        bestSegment = i;
                    }
                } catch (error) {
                    updateDebug(`‚ùå Turf calculation error on segment ${i}: ${error.message}`);
                }
            }
            
            updateDebug(`üéØ Closest segment: ${bestSegment} (${originalLineCoordinates[bestSegment]} ‚Üí ${originalLineCoordinates[bestSegment + 1]}), insert at position ${insertIndex}`);
            return { insertIndex, distance: minDistance, segment: bestSegment };
        }
        
        // Debug: Add click handler to test basic interaction
        map.on('click', (e) => {
            if (!isDragging) {
                updateDebug(`üëÜ Map click: ${e.lngLat.lng.toFixed(4)}, ${e.lngLat.lat.toFixed(4)}`);
            }
        });
        
        // Error handling
        map.on('error', (e) => {
            updateDebug(`‚ùå Map error: ${e.error.message}`);
        });
        
        // Additional debug info
        window.addEventListener('load', () => {
            updateDebug(`üåê Page loaded. User agent: ${navigator.userAgent.substring(0, 50)}...`);
        });
        
        // Test touch events specifically
        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('#map')) {
                console.log('üî• GLOBAL touchstart on map area:', {
                    touches: e.touches.length,
                    cancelable: e.cancelable,
                    passive: e.passive,
                    target: e.target.className
                });
            }
        }, { passive: false });
    </script>
</body>
</html>