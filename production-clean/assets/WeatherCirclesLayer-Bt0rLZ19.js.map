{"version":3,"file":"WeatherCirclesLayer-Bt0rLZ19.js","sources":["../../src/components/fast-planner/modules/layers/WeatherCirclesLayer.js"],"sourcesContent":["/**\n * WeatherCirclesLayer.js\n * \n * 3D weather circles lying flat on the ground under all other elements\n * Color-coded by weather ranking using aviation-specific colors\n */\n\nclass WeatherCirclesLayer {\n  constructor(map) {\n    this.map = map;\n    this.sourceId = 'weather-circles-source';\n    this.layerId = 'weather-circles-layer';\n    this.isVisible = false;\n    this.currentWeatherSegments = [];\n  }\n\n  /**\n   * Add weather circles to the map\n   * @param {Array} weatherSegments - Array of weather segments with coordinates and rankings\n   */\n  addWeatherCircles(weatherSegments) {\n    if (!weatherSegments || !this.map) {\n      console.warn('WeatherCirclesLayer: Missing weatherSegments or map');\n      return;\n    }\n    \n    // ENHANCED RACE CONDITION PROTECTION: Check if another process is already creating weather circles\n    const lockStartTime = Date.now();\n    if (window.weatherCirclesCreationInProgress) {\n      const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n      console.log(`ðŸ”„ WeatherCirclesLayer: Creation lock active for ${lockAge}ms`);\n      \n      // If lock is older than 10 seconds OR this is a legitimate retry, clear it\n      if (lockAge > 10000) {\n        console.log('ðŸ”“ WeatherCirclesLayer: Clearing stale lock (older than 10s)');\n        window.weatherCirclesCreationInProgress = false;\n        window.weatherCirclesLockTime = null;\n      } else {\n        console.log('ðŸ”„ WeatherCirclesLayer: Recent lock detected, skipping duplicate request');\n        return;\n      }\n    }\n    \n    // Set the lock with timestamp\n    window.weatherCirclesCreationInProgress = true;\n    window.weatherCirclesLockTime = lockStartTime;\n    console.log(`ðŸ”’ WeatherCirclesLayer: Setting creation lock at ${lockStartTime}`);\n    \n    // Clear the lock after completion (with failsafe timeout)\n    const clearLock = () => {\n      if (window.weatherCirclesCreationInProgress && window.weatherCirclesLockTime === lockStartTime) {\n        window.weatherCirclesCreationInProgress = false;\n        window.weatherCirclesLockTime = null;\n        console.log(`ðŸ”“ WeatherCirclesLayer: Clearing creation lock (held for ${Date.now() - lockStartTime}ms)`);\n      }\n    };\n    \n    // Failsafe: Clear lock after 5 seconds if something goes wrong\n    setTimeout(clearLock, 5000);\n    \n    console.log('ðŸŸ¡ WeatherCirclesLayer: Adding', weatherSegments.length, 'weather circles to map');\n    \n    this.currentWeatherSegments = weatherSegments;\n    this.removeWeatherCircles();\n    \n    // CONSOLIDATED ARROW SYSTEM: Collect all arrow data first, then create all arrows at once\n    const allArrowData = [];\n    \n    // Rest of the method continues unchanged...\n    // ENHANCED APPROACH: Handle alternates, rigs, and split points\n    const validSegments = [];\n    \n    // DEDUPLICATION: First pass - identify all alternates to prioritize them\n    const alternateLocations = new Set();\n    const processedLocations = new Set();\n    \n    // First pass: collect all alternate locations\n    weatherSegments.forEach(segment => {\n      if (segment.alternateGeoShape && (segment.airportIcao || segment.locationName)) {\n        alternateLocations.add(segment.airportIcao || segment.locationName);\n      }\n    });\n    \n    console.log('ðŸ”„ DEDUP: Found alternates for locations:', Array.from(alternateLocations));\n    \n    weatherSegments.forEach((segment, index) => {\n      console.log(`ðŸ” Segment ${index}:`, {\n        airportIcao: segment.airportIcao,\n        locationName: segment.locationName,\n        isRig: segment.isRig,\n        alternateGeoShape: segment.alternateGeoShape,\n        ranking2: segment.ranking2,\n        hasAlternateCoords: !!(segment.alternateGeoShape?.coordinates?.length >= 2),\n        hasGeoPoint: !!segment.geoPoint,\n        geoPoint: segment.geoPoint\n      });\n      \n      const hasValidRanking = (segment.ranking2 !== undefined && segment.ranking2 !== null);\n      \n      if (!hasValidRanking) {\n        console.log(`âŒ Invalid segment ${index}: no valid ranking`);\n        return;\n      }\n      \n      // DUPLICATE CHECK: Skip destinations if there's an alternate for the same location\n      const locationKey = segment.airportIcao || segment.locationName;\n      if (locationKey) {\n        // If this is a destination (no alternateGeoShape) and there's an alternate for this location, skip it\n        if (!segment.isRig && !segment.alternateGeoShape && alternateLocations.has(locationKey)) {\n          console.log(`ðŸ”„ DEDUP: Skipping destination ${locationKey} - alternate exists for same location`);\n          return;\n        }\n        \n        // If we already processed this exact location, skip it\n        if (processedLocations.has(locationKey)) {\n          console.log(`ðŸ”„ DEDUP: Skipping duplicate ${locationKey} - already processed`);\n          return;\n        }\n        \n        // Mark this location as processed\n        processedLocations.add(locationKey);\n      }\n      \n      // Handle ALTERNATE destinations (have alternateGeoShape)\n      if (segment.alternateGeoShape && \n          segment.alternateGeoShape.coordinates && \n          Array.isArray(segment.alternateGeoShape.coordinates) &&\n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        const ranking = segment.ranking2;\n        \n        // Add alternate destination circle (coordinates[1])\n        const alternateSegment = {\n          ...segment,\n          ranking2: ranking,\n          extractedCoordinates: segment.alternateGeoShape.coordinates[1],\n          circleType: 'alternate'\n        };\n        validSegments.push(alternateSegment);\n        console.log(`âœ… Alternate ${index}: ${segment.airportIcao} at ${JSON.stringify(segment.alternateGeoShape.coordinates[1])} with ranking ${ranking}`);\n        console.log(`ðŸš¨ COORDINATE DEBUG: Full alternateGeoShape.coordinates for ${segment.airportIcao}:`, JSON.stringify(segment.alternateGeoShape.coordinates, null, 2));\n        \n        // COLLECT ALTERNATE ARROW DATA: Store for batch creation later\n        console.log(`ðŸŒ¬ï¸ COLLECTING: Alternate arrow data for ${segment.airportIcao}`);\n        \n        // Extract wind data for this alternate\n        let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n        \n        // Try METAR first (for airports)\n        let comprehensiveMetarData = null;\n        if (segment.rawMetar && window.weatherVisualizationManager) {\n          const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n          const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n          const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n          \n          // Parse comprehensive METAR data for alternates\n          comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n          \n          if (metarSpeed !== null && metarDir !== null) {\n            windSpeed = metarSpeed;\n            windDirection = metarDir;\n            windGust = metarGust;\n            windSource = 'METAR';\n          }\n        }\n        \n        // Use segment wind data if no METAR\n        if (windSpeed === null && segment.windSpeed) {\n          windSpeed = segment.windSpeed;\n          windDirection = segment.windDirection;\n          windGust = segment.windGust;\n          windSource = 'Segment';\n        }\n        \n        if (windSpeed !== null) {\n          allArrowData.push({\n            rigName: segment.airportIcao,\n            latitude: segment.alternateGeoShape.coordinates[1][1],\n            longitude: segment.alternateGeoShape.coordinates[1][0],\n            isAirport: !segment.isRig,\n            windSpeed: windSpeed,\n            windDirection: windDirection,\n            windGust: windGust,\n            windSource: windSource,\n            flightCategory: segment.flightCategory || 'VFR',\n            visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n            temperature: comprehensiveMetarData?.temperature || segment.temperature,\n            conditions: segment.conditions || segment.weather || 'Clear',\n            stationId: segment.airportIcao,\n            locationType: 'alternate',\n            // Enhanced METAR data for better popups\n            comprehensiveMetar: comprehensiveMetarData,\n            rawMetar: segment.rawMetar,\n            rawTaf: segment.rawTaf,\n            clouds: comprehensiveMetarData?.clouds || [],\n            weatherConditions: comprehensiveMetarData?.conditions || [],\n            altimeter: comprehensiveMetarData?.altimeter,\n            dewpoint: comprehensiveMetarData?.dewpoint\n          });\n          console.log(`ðŸŒ¬ï¸ COLLECTED: Alternate ${segment.airportIcao} arrow data`);\n        } else {\n          console.log(`ðŸŒ¬ï¸ SKIP: No wind data for alternate ${segment.airportIcao}`);\n        }\n        \n        // ðŸŽ¯ SPLIT POINT: Skip creating individual split point arrows here\n        // Split points get duplicated because each alternate creates its own split point arrow\n        // The split point should only have ONE arrow regardless of how many alternates use it\n        console.log(`ðŸŽ¯ SKIP: Not creating separate split point arrow for ${segment.airportIcao} - prevents duplicates`);\n      }\n      \n      // Handle RIGS - find coordinates from current waypoints/route\n      else if (segment.isRig) {\n        console.log(`ðŸ›¢ï¸ Processing rig weather: ${segment.airportIcao}`);\n        \n        // Try to get rig coordinates from multiple sources\n        let rigCoordinates = null;\n        \n        // Method 1: Check current waypoints (most reliable)\n        if (window.currentWaypoints && Array.isArray(window.currentWaypoints)) {\n          const matchingWaypoint = window.currentWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from currentWaypoints:`, rigCoordinates);\n          }\n        }\n        \n        // Method 2: Check waypoint manager\n        if (!rigCoordinates && window.waypointManager?.getWaypoints) {\n          const waypoints = window.waypointManager.getWaypoints();\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from waypointManager:`, rigCoordinates);\n          }\n        }\n        \n        // Method 3: Check global waypoints state (from React)\n        if (!rigCoordinates && window.globalWaypoints && Array.isArray(window.globalWaypoints)) {\n          const matchingWaypoint = window.globalWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from globalWaypoints:`, rigCoordinates);\n          }\n        }\n        \n        // Method 4: Check stop cards for coordinates (they have all the lat/lng data!)\n        if (!rigCoordinates && window.debugStopCards && Array.isArray(window.debugStopCards)) {\n          const matchingStopCard = window.debugStopCards.find(card => \n            card.name === segment.airportIcao || \n            card.name?.toUpperCase() === segment.airportIcao?.toUpperCase() ||\n            card.stop === segment.airportIcao ||\n            card.stop?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingStopCard && matchingStopCard.coordinates) {\n            rigCoordinates = matchingStopCard.coordinates;\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from stopCards:`, rigCoordinates);\n          }\n        }\n        \n        if (rigCoordinates) {\n          const rigSegment = {\n            ...segment,\n            ranking2: segment.ranking2,\n            extractedCoordinates: rigCoordinates,\n            circleType: 'rig'\n          };\n          validSegments.push(rigSegment);\n          console.log(`âœ… Rig ${segment.airportIcao}: Found coordinates ${JSON.stringify(rigCoordinates)} with ranking ${segment.ranking2}`);\n          \n          // COLLECT RIG ARROW DATA: Store for batch creation later\n          console.log(`ðŸŒ¬ï¸ COLLECTING: Rig arrow data for ${segment.airportIcao}`);\n          \n          // Extract wind data for this rig\n          let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n          \n          // DEBUG: Log all available wind fields for rigs\n          console.log(`ðŸŒ¬ï¸ RIG DEBUG: Available wind fields for ${segment.airportIcao}:`, {\n            rawMetar: segment.rawMetar,\n            rawTaf: segment.rawTaf,\n            windSpeed: segment.windSpeed,\n            windDirection: segment.windDirection,\n            windGust: segment.windGust,\n            wind: segment.wind,\n            allKeys: Object.keys(segment).filter(key => key.toLowerCase().includes('wind'))\n          });\n          \n          // Try METAR first (for airports AND rigs - they both have METAR data!)\n          let comprehensiveMetarData = null;\n          if (segment.rawMetar && window.weatherVisualizationManager) {\n            console.log(`ðŸŒ¬ï¸ RIG METAR: Parsing METAR for ${segment.airportIcao}: \"${segment.rawMetar}\"`);\n            \n            // Parse wind data\n            const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n            const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n            const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n            \n            // Parse comprehensive METAR data  \n            comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n            \n            console.log(`ðŸŒ¬ï¸ RIG METAR: Parsed values - Speed: ${metarSpeed}, Dir: ${metarDir}, Gust: ${metarGust}`);\n            console.log(`ðŸŒ¬ï¸ RIG METAR: Comprehensive data:`, comprehensiveMetarData);\n            \n            if (metarSpeed !== null && metarDir !== null) {\n              windSpeed = metarSpeed;\n              windDirection = metarDir;\n              windGust = metarGust;\n              windSource = 'METAR';\n              console.log(`ðŸŒ¬ï¸ RIG METAR: âœ… Successfully extracted wind from METAR for ${segment.airportIcao}`);\n            } else {\n              console.log(`ðŸŒ¬ï¸ RIG METAR: âŒ METAR parsing failed for ${segment.airportIcao}`);\n            }\n          }\n          \n          // Try TAF data for rigs (pseudo TAF)\n          if (windSpeed === null && segment.rawTaf && window.weatherVisualizationManager) {\n            console.log(`ðŸŒ¬ï¸ RIG TAF: Parsing TAF for ${segment.airportIcao}: \"${segment.rawTaf}\"`);\n            \n            // TAF uses same wind format as METAR\n            const tafSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawTaf);\n            const tafDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawTaf);\n            const tafGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawTaf);\n            \n            console.log(`ðŸŒ¬ï¸ RIG TAF: Parsed values - Speed: ${tafSpeed}, Dir: ${tafDir}, Gust: ${tafGust}`);\n            \n            if (tafSpeed !== null && tafDir !== null) {\n              windSpeed = tafSpeed;\n              windDirection = tafDir;\n              windGust = tafGust;\n              windSource = 'Pseudo TAF';\n              console.log(`ðŸŒ¬ï¸ RIG TAF: âœ… Successfully extracted wind from TAF for ${segment.airportIcao}`);\n            }\n          }\n          \n          // Use direct segment wind data (for rigs)\n          if (windSpeed === null && segment.windSpeed !== undefined && segment.windSpeed !== null) {\n            windSpeed = segment.windSpeed;\n            windDirection = segment.windDirection;\n            windGust = segment.windGust;\n            windSource = 'Rig Model Data';\n          }\n          \n          // Try alternative wind field names for rigs\n          if (windSpeed === null && segment.wind) {\n            if (typeof segment.wind === 'object') {\n              windSpeed = segment.wind.speed || segment.wind.windSpeed;\n              windDirection = segment.wind.direction || segment.wind.windDirection;\n              windGust = segment.wind.gust || segment.wind.windGust;\n              windSource = 'Rig Wind Object';\n            }\n          }\n          \n          // Try other possible wind field names\n          if (windSpeed === null) {\n            const possibleSpeedFields = ['windSpeedKts', 'windSpeedMps', 'speed', 'wspd'];\n            const possibleDirFields = ['windDirectionDeg', 'direction', 'wdir'];\n            \n            for (const field of possibleSpeedFields) {\n              if (segment[field] !== undefined && segment[field] !== null) {\n                windSpeed = segment[field];\n                windSource = `Rig Field: ${field}`;\n                break;\n              }\n            }\n            \n            for (const field of possibleDirFields) {\n              if (segment[field] !== undefined && segment[field] !== null) {\n                windDirection = segment[field];\n                break;\n              }\n            }\n          }\n          \n          if (windSpeed !== null) {\n            allArrowData.push({\n              rigName: segment.airportIcao,\n              latitude: rigCoordinates[1],\n              longitude: rigCoordinates[0],\n              isAirport: false,\n              windSpeed: windSpeed,\n              windDirection: windDirection,\n              windGust: windGust,\n              windSource: windSource,\n              flightCategory: segment.flightCategory || 'VFR',\n              visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n              temperature: comprehensiveMetarData?.temperature || segment.temperature,\n              conditions: segment.conditions || segment.weather || 'Clear',\n              stationId: segment.airportIcao,\n              locationType: 'rig',\n              // Enhanced METAR data for better popups\n              comprehensiveMetar: comprehensiveMetarData,\n              rawMetar: segment.rawMetar,\n              rawTaf: segment.rawTaf,\n              clouds: comprehensiveMetarData?.clouds || [],\n              weatherConditions: comprehensiveMetarData?.conditions || [],\n              altimeter: comprehensiveMetarData?.altimeter,\n              dewpoint: comprehensiveMetarData?.dewpoint\n            });\n            console.log(`ðŸŒ¬ï¸ COLLECTED: Rig ${segment.airportIcao} arrow data`);\n          } else {\n            console.log(`ðŸŒ¬ï¸ SKIP: No wind data for rig ${segment.airportIcao}`);\n          }\n        } else {\n          console.log(`âŒ Rig ${segment.airportIcao}: Could not find coordinates in any source`);\n        }\n      \n      // Handle DESTINATIONS (airports that are not rigs)\n      } else if (!segment.isRig) {\n        console.log(`âœˆï¸ Processing destination weather: ${segment.airportIcao || segment.locationName}`);\n        \n        // Try to get destination coordinates from multiple sources\n        let destinationCoordinates = null;\n        \n        // Method 1: Try geoPoint first if available\n        if (segment.geoPoint) {\n          destinationCoordinates = this.parseGeoPoint(segment.geoPoint);\n          if (destinationCoordinates) {\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from geoPoint:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 2: Check current waypoints if geoPoint failed\n        if (!destinationCoordinates && window.currentWaypoints && Array.isArray(window.currentWaypoints)) {\n          const matchingWaypoint = window.currentWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            destinationCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from currentWaypoints:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 3: Check waypoint manager\n        if (!destinationCoordinates && window.waypointManager?.getWaypoints) {\n          const waypoints = window.waypointManager.getWaypoints();\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            destinationCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from waypointManager:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 4: Check stop cards for coordinates\n        if (!destinationCoordinates && window.debugStopCards && Array.isArray(window.debugStopCards)) {\n          const matchingStopCard = window.debugStopCards.find(card => \n            card.name === segment.airportIcao || \n            card.name?.toUpperCase() === segment.airportIcao?.toUpperCase() ||\n            card.stop === segment.airportIcao ||\n            card.stop?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingStopCard && matchingStopCard.coordinates) {\n            destinationCoordinates = matchingStopCard.coordinates;\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from stopCards:`, destinationCoordinates);\n          }\n        }\n        \n        if (destinationCoordinates) {\n          const destinationSegment = {\n            ...segment,\n            ranking2: segment.ranking2,\n            extractedCoordinates: destinationCoordinates,\n            circleType: 'destination'\n          };\n          validSegments.push(destinationSegment);\n          console.log(`âœ… Destination ${segment.airportIcao || segment.locationName}: Found coordinates ${JSON.stringify(destinationCoordinates)} with ranking ${segment.ranking2}`);\n          \n          // COLLECT DESTINATION ARROW DATA: Store for batch creation later\n          console.log(`ðŸŒ¬ï¸ COLLECTING: Destination arrow data for ${segment.airportIcao}`);\n          \n          // Extract wind data for this destination\n          let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n          \n          // Try METAR first (airports should have METAR)\n          let comprehensiveMetarData = null;\n          if (segment.rawMetar && window.weatherVisualizationManager) {\n            const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n            const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n            const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n            \n            // Parse comprehensive METAR data for destinations\n            comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n            \n            if (metarSpeed !== null && metarDir !== null) {\n              windSpeed = metarSpeed;\n              windDirection = metarDir;\n              windGust = metarGust;\n              windSource = 'METAR';\n            }\n          }\n          \n          // Use segment wind data if no METAR\n          if (windSpeed === null && segment.windSpeed) {\n            windSpeed = segment.windSpeed;\n            windDirection = segment.windDirection;\n            windGust = segment.windGust;\n            windSource = 'Segment';\n          }\n          \n          if (windSpeed !== null) {\n            allArrowData.push({\n              rigName: segment.airportIcao || segment.locationName,\n              latitude: destinationCoordinates[1],\n              longitude: destinationCoordinates[0],\n              isAirport: true,\n              windSpeed: windSpeed,\n              windDirection: windDirection,\n              windGust: windGust,\n              windSource: windSource,\n              flightCategory: segment.flightCategory || 'VFR',\n              visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n              temperature: comprehensiveMetarData?.temperature || segment.temperature,\n              conditions: segment.conditions || segment.weather || 'Clear',\n              stationId: segment.airportIcao || segment.locationName,\n              locationType: 'destination',\n              // Enhanced METAR data for better popups\n              comprehensiveMetar: comprehensiveMetarData,\n              rawMetar: segment.rawMetar,\n              rawTaf: segment.rawTaf,\n              clouds: comprehensiveMetarData?.clouds || [],\n              weatherConditions: comprehensiveMetarData?.conditions || [],\n              altimeter: comprehensiveMetarData?.altimeter,\n              dewpoint: comprehensiveMetarData?.dewpoint\n            });\n            console.log(`ðŸŒ¬ï¸ COLLECTED: Destination ${segment.airportIcao} arrow data`);\n          } else {\n            console.log(`ðŸŒ¬ï¸ SKIP: No wind data for destination ${segment.airportIcao}`);\n          }\n        } else {\n          console.log(`âŒ Destination ${segment.airportIcao || segment.locationName}: Could not find coordinates from any source (geoPoint: ${segment.geoPoint})`);\n        }\n      \n      } else {\n        console.log(`âŒ Segment ${index} (${segment.airportIcao || segment.locationName}) has no coordinates and is not a rig or destination`);\n      }\n    });\n    \n    // DEDUPLICATE circles at same locations (only keep one circle per location)\n    const deduplicatedSegments = this.deduplicateCirclesByLocation(validSegments);\n    \n    console.log(`ðŸŸ¡ Found ${validSegments.length} total segments, deduplicated to ${deduplicatedSegments.length} unique locations`);\n    \n    if (deduplicatedSegments.length === 0) {\n      console.log('ðŸ”´ No valid segments found, adding test circles instead');\n      clearLock(); // Clear lock before test circles\n      this.addTestCircles();\n      return;\n    }\n    \n    console.log('ðŸŸ¢ WeatherCirclesLayer: Processing', deduplicatedSegments.length, 'deduplicated segments');\n    \n    // Create concentric ring features for each deduplicated weather segment (MORE RINGS!)\n    const outerMostFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'outermost')).filter(f => f !== null);\n    const outerFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'outer')).filter(f => f !== null);\n    const middleFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'middle')).filter(f => f !== null);\n    const innerFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'inner')).filter(f => f !== null);\n    const innerMostFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'innermost')).filter(f => f !== null);\n    \n    if (outerFeatures.length === 0) {\n      console.log('ðŸ”´ No valid ring features created');\n      clearLock(); // Clear lock on error\n      return;\n    }\n    \n    console.log(`ðŸŸ¢ Created ${outerFeatures.length} concentric ring sets`);\n    \n    // Also add dotted lines to alternate destinations if available (use ORIGINAL segments for lines)\n    this.addAlternateLines(weatherSegments);\n    \n    // Add sources for each ring layer (MORE RINGS!)\n    this.map.addSource(this.sourceId + '-outermost', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: outerMostFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId, {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: outerFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-middle', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: middleFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-inner', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: innerFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-innermost', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: innerMostFeatures\n      }\n    });\n    \n    // Determine layer type based on geometry type\n    const hasCircleGeometry = outerFeatures.some(f => f.geometry.type === 'Polygon');\n    const hasPointGeometry = outerFeatures.some(f => f.geometry.type === 'Point');\n    \n    console.log('WeatherCirclesLayer: Geometry types found:', { hasCircleGeometry, hasPointGeometry });\n    \n    // Add concentric ring layers for weather area effect (BELOW route layers)\n    // Find the first route layer to insert weather rings before it\n    let beforeLayer = this.findFirstRouteLayer();\n    \n    if (hasCircleGeometry) {\n      // Add multiple ring layers for fading effect (MORE RINGS!)\n      \n      // Outermost ring (biggest, most transparent)\n      this.map.addLayer({\n        id: this.layerId + '-outermost',\n        type: 'line',\n        source: this.sourceId + '-outermost',\n        filter: ['==', '$type', 'Polygon'],\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.15 // Very faint\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Outer ring (large, transparent)\n      this.map.addLayer({\n        id: this.layerId + '-outer',\n        type: 'line',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Polygon'],\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.25 // Faint\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Middle ring (medium opacity)\n      this.map.addLayer({\n        id: this.layerId + '-middle',\n        type: 'line',\n        source: this.sourceId + '-middle',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.5\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Inner ring (bright)\n      this.map.addLayer({\n        id: this.layerId + '-inner',\n        type: 'line',\n        source: this.sourceId + '-inner',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.75\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Innermost ring (brightest, most visible)\n      this.map.addLayer({\n        id: this.layerId + '-innermost',\n        type: 'line',\n        source: this.sourceId + '-innermost',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.95 // Brightest\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      console.log('WeatherCirclesLayer: Added 5 concentric ring layers');\n      \n      // ðŸ”— UNIFIED POPUP: New RigWeatherGraphics popup system handles all popups (has more detailed data)\n      console.log('ðŸ”— POPUP: WeatherCirclesLayer popup disabled - RigWeatherGraphics has more detailed weather data');\n    }\n    \n    if (hasPointGeometry) {\n      // Add concentric ring layers for point features\n      const pointLayerId = this.layerId + '-points';\n      \n      // Outer ring\n      this.map.addLayer({\n        id: pointLayerId + '-outer',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 80], 60],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 3,\n          'circle-stroke-opacity': 0.3\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Middle ring\n      this.map.addLayer({\n        id: pointLayerId + '-middle',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 120], 40],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 2,\n          'circle-stroke-opacity': 0.5\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Inner ring (BRIGHTENED)\n      this.map.addLayer({\n        id: pointLayerId + '-inner',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 160], 25],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 2,\n          'circle-stroke-opacity': 0.95 // Brightened from 0.8 to 0.95\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      console.log('WeatherCirclesLayer: Added concentric ring layers for points');\n      \n      // ðŸ”— UNIFIED POPUP: New RigWeatherGraphics popup system handles all popups (has more detailed data)\n      console.log('ðŸ”— POPUP: WeatherCirclesLayer popup disabled - RigWeatherGraphics has more detailed weather data');\n    }\n    \n    this.isVisible = true;\n    console.log('WeatherCirclesLayer: Added', outerFeatures.length, 'weather circles');\n    \n    // ðŸŒ¬ï¸ ARROW SYSTEM: Create wind arrows (weather/RigWeatherGraphics handles arrows and popups)\n    if (allArrowData.length > 0 && window.rigWeatherIntegration && window.rigWeatherIntegration.updateRigWeather) {\n      console.log(`ðŸŒ¬ï¸ CREATING ARROWS: ${allArrowData.length} wind arrows for all locations:`, \n        allArrowData.map(a => `${a.rigName}(${a.locationType})`));\n      \n      try {\n        // Create ALL arrows in one batch operation - this is the weather/RigWeatherGraphics system\n        window.rigWeatherIntegration.updateRigWeather(allArrowData);\n        console.log(`ðŸŒ¬ï¸ ARROWS: âœ… Successfully created ${allArrowData.length} wind arrows`);\n        \n        // Debug: Log what types of arrows were created\n        const arrowTypes = allArrowData.reduce((acc, arrow) => {\n          acc[arrow.locationType] = (acc[arrow.locationType] || 0) + 1;\n          return acc;\n        }, {});\n        console.log(`ðŸŒ¬ï¸ ARROWS: Arrow breakdown:`, arrowTypes);\n        \n      } catch (error) {\n        console.error(`ðŸŒ¬ï¸ ARROWS: Error creating wind arrows:`, error);\n      }\n    } else {\n      console.log(`ðŸŒ¬ï¸ ARROWS: Cannot create arrows - rigWeatherIntegration not available or missing updateRigWeather method`);\n      console.log(`ðŸŒ¬ï¸ DEBUG: rigWeatherIntegration exists: ${!!window.rigWeatherIntegration}`);\n      console.log(`ðŸŒ¬ï¸ DEBUG: updateRigWeather method exists: ${!!window.rigWeatherIntegration?.updateRigWeather}`);\n    }\n    \n    // Clear the creation lock on successful completion\n    clearLock();\n    \n    // Debug: Check if layers were actually added\n    setTimeout(() => {\n      // Check for any of the weather circle layers that should exist\n      const layersToCheck = [\n        this.layerId + '-outermost',\n        this.layerId + '-outer', \n        this.layerId + '-middle',\n        this.layerId + '-inner',\n        this.layerId + '-innermost',\n        this.layerId + '-points-outer',\n        this.layerId + '-points-middle',\n        this.layerId + '-points-inner',\n        this.layerId + '-lines'\n      ];\n      \n      const foundLayers = layersToCheck.filter(layerId => this.map.getLayer(layerId));\n      \n      if (foundLayers.length > 0) {\n        console.log(`âœ… WeatherCirclesLayer: ${foundLayers.length} layers successfully added to map:`, foundLayers);\n      } else {\n        console.warn('âš ï¸ WeatherCirclesLayer: No weather circle layers found in map after adding - this may be normal if no features were created');\n        console.log('ðŸ” WeatherCirclesLayer: Available layers:', layersToCheck.map(id => ({ id, exists: !!this.map.getLayer(id) })));\n      }\n    }, 200); // Slightly longer delay to ensure layers are fully processed\n  }\n  \n  /**\n   * Create a ring feature for a weather segment with specific size\n   * @param {Object} segment - Weather segment with extractedCoordinates and ranking\n   * @param {string} ringType - 'outer', 'middle', or 'inner'\n   * @returns {Object} GeoJSON feature\n   */\n  createRingFeature(segment, ringType) {\n    // FIXED: Use extractedCoordinates from alternateGeoShape instead of parsing geoPoint\n    const coords = segment.extractedCoordinates;\n    \n    if (!coords || !Array.isArray(coords) || coords.length !== 2) {\n      console.warn('WeatherCirclesLayer: Invalid extractedCoordinates:', coords);\n      return null;\n    }\n    \n    // Use ranking2 for color\n    const ranking = segment.ranking2;\n    const color = this.getAviationRankingColor(ranking);\n    \n    console.log(`ðŸŽ¨ RING CREATION: ${ringType} ring for ${segment.airportIcao} (${segment.circleType}) at ${coords} with ranking ${segment.ranking2} = COLOR ${color}`);\n    \n    // Get radius based on ring type (MORE RINGS!)\n    const baseRadius = this.getCircleRadius(ranking);\n    let radius;\n    switch (ringType) {\n      case 'outermost':\n        radius = baseRadius * 1.8; // Biggest ring (new)\n        break;\n      case 'outer':\n        radius = baseRadius * 1.4; // Large ring\n        break;\n      case 'middle':\n        radius = baseRadius * 1.0; // Medium ring\n        break;\n      case 'inner':\n        radius = baseRadius * 0.7; // Small ring\n        break;\n      case 'innermost':\n        radius = baseRadius * 0.4; // Smallest ring (new)\n        break;\n      default:\n        radius = baseRadius;\n    }\n    \n    // Check if Turf.js is available for circles\n    if (!window.turf) {\n      console.warn('WeatherCirclesLayer: Turf.js not available, creating simple point feature');\n      return {\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: coords\n        },\n        properties: {\n          airportIcao: segment.airportIcao || 'Unknown',\n          ranking: ranking,\n          color: color,\n          isRig: segment.isRig || false,\n          radius: radius * 1000, // Convert km to meters for point display\n          ringType: ringType\n        }\n      };\n    }\n    \n    // Create a circle polygon using Turf.js buffer\n    const center = window.turf.point(coords);\n    const circle = window.turf.buffer(center, radius, { units: 'kilometers' });\n    \n    return {\n      type: 'Feature',\n      geometry: circle.geometry,\n      properties: {\n        airportIcao: segment.airportIcao || 'Unknown',\n        ranking: ranking,\n        color: color,\n        isRig: segment.isRig || false,\n        ringType: ringType\n      }\n    };\n  }\n  \n  /**\n   * Parse geoPoint string to coordinates\n   * @param {string} geoPoint - Comma-separated lat,lng string\n   * @returns {Array} [longitude, latitude] coordinates or null\n   */\n  parseGeoPoint(geoPoint) {\n    if (!geoPoint) return null;\n    \n    console.log('WeatherCirclesLayer: Parsing geoPoint:', geoPoint);\n    \n    try {\n      const parts = geoPoint.split(',');\n      if (parts.length === 2) {\n        const lat = parseFloat(parts[0].trim());\n        const lon = parseFloat(parts[1].trim());\n        \n        console.log('WeatherCirclesLayer: Parsed coordinates:', { lat, lon, isValidLat: !isNaN(lat), isValidLon: !isNaN(lon) });\n        \n        if (!isNaN(lat) && !isNaN(lon)) {\n          // GeoJSON format: [longitude, latitude]\n          const coords = [lon, lat];\n          console.log('WeatherCirclesLayer: Final coordinates (GeoJSON format):', coords);\n          \n          // Validate coordinates are in reasonable ranges\n          if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {\n            return coords;\n          } else {\n            console.warn('WeatherCirclesLayer: Coordinates out of valid range:', { lat, lon });\n            return null;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('WeatherCirclesLayer: Error parsing geoPoint:', geoPoint, error);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get circle radius based on weather ranking\n   * @param {number} ranking - Weather ranking (5, 8, 10, 15, 20)\n   * @returns {number} Radius in kilometers\n   */\n  getCircleRadius(ranking) {\n    // Base radius that makes circles visible but not overwhelming\n    const baseRadius = 8; // 8km base radius\n    \n    // Adjust size slightly based on ranking importance\n    switch (ranking) {\n      case 5:  // Below minimums - larger, more attention\n        return baseRadius * 1.2;\n      case 8:  // ARA needed - slightly larger\n        return baseRadius * 1.1;\n      case 10: // Warning - normal size\n        return baseRadius;\n      case 15: // Good - slightly smaller\n        return baseRadius * 0.9;\n      case 20: // N/A - smaller, less prominent\n        return baseRadius * 0.8;\n      default:\n        return baseRadius;\n    }\n  }\n  \n  /**\n   * Get aviation ranking color using the centralized color system from WeatherCard.jsx\n   * @param {number} ranking - Weather ranking\n   * @returns {string} Hex color code\n   */\n  getAviationRankingColor(ranking) {\n    switch (ranking) {\n      case 5:\n        return '#D32F2F'; // Red - Below alternate minimums\n      case 8:\n        return '#8E24AA'; // Brighter purple - ARA fuel needed at rig\n      case 10:\n        return '#F57C00'; // Orange - Warning conditions\n      case 15:\n        return '#66BB6A'; // Much brighter green - Good conditions\n      case 20:\n        return '#616161'; // Grey - Not applicable to landing time\n      default:\n        return '#1976D2'; // Blue - Default/unknown\n    }\n  }\n  \n  /**\n   * Remove weather circles from map\n   */\n  removeWeatherCircles() {\n    // Clear any creation lock when removing\n    if (window.weatherCirclesCreationInProgress) {\n      console.log('ðŸ”“ WeatherCirclesLayer: Clearing creation lock during removal');\n      window.weatherCirclesCreationInProgress = false;\n      window.weatherCirclesLockTime = null;\n    }\n    \n    // ðŸš¨ SAFETY CHECK: Ensure map exists before attempting removal\n    if (!this.map) {\n      console.warn('ðŸ§¹ WeatherCirclesLayer: Cannot remove weather circles - map reference is null/undefined');\n      return;\n    }\n    \n    try {\n      // Remove event listeners BEFORE removing layers\n      const hoverLayer = this.layerId + '-hover-areas';\n      if (this.map.getLayer && this.map.getLayer(hoverLayer)) {\n        this.map.off('mouseenter', hoverLayer);\n        this.map.off('mouseleave', hoverLayer);\n        console.log('ðŸ§¹ Removed weather hover event listeners');\n      }\n      \n      // Clean up popup instance\n      if (this.popup) {\n        this.popup.remove();\n        this.popup = null;\n        console.log('ðŸ§¹ Removed weather popup instance');\n      }\n      \n      // Remove all ring layers (polygon-based) - MORE RINGS!\n      const ringLayers = ['-outermost', '-outer', '-middle', '-inner', '-innermost'];\n      ringLayers.forEach(suffix => {\n        if (this.map.getLayer(this.layerId + suffix)) {\n          this.map.removeLayer(this.layerId + suffix);\n        }\n      });\n      \n      // Remove all point ring layers\n      const pointRingLayers = ['-points-outer', '-points-middle', '-points-inner'];\n      pointRingLayers.forEach(suffix => {\n        if (this.map.getLayer(this.layerId + suffix)) {\n          this.map.removeLayer(this.layerId + suffix);\n        }\n      });\n      \n      // Remove legacy layers if they exist\n      if (this.map.getLayer(this.layerId)) {\n        this.map.removeLayer(this.layerId);\n      }\n      if (this.map.getLayer(this.layerId + '-points')) {\n        this.map.removeLayer(this.layerId + '-points');\n      }\n      \n      // Remove alternate lines and their shadows\n      if (this.map.getLayer(this.layerId + '-lines')) {\n        this.map.removeLayer(this.layerId + '-lines');\n      }\n      if (this.map.getLayer(this.layerId + '-lines-shadow')) {\n        this.map.removeLayer(this.layerId + '-lines-shadow');\n      }\n      if (this.map.getSource(this.sourceId + '-lines')) {\n        this.map.removeSource(this.sourceId + '-lines');\n      }\n      if (this.map.getSource(this.sourceId + '-lines-shadow')) {\n        this.map.removeSource(this.sourceId + '-lines-shadow');\n      }\n      \n      // Remove hover areas\n      if (this.map.getLayer(this.layerId + '-hover-areas')) {\n        this.map.removeLayer(this.layerId + '-hover-areas');\n      }\n      if (this.map.getSource(this.sourceId + '-hover-areas')) {\n        this.map.removeSource(this.sourceId + '-hover-areas');\n      }\n\n      // Remove all sources - MORE RINGS!\n      const sources = ['-outermost', '', '-middle', '-inner', '-innermost'];\n      sources.forEach(suffix => {\n        if (this.map.getSource(this.sourceId + suffix)) {\n          this.map.removeSource(this.sourceId + suffix);\n        }\n      });\n    } catch (error) {\n      console.error('WeatherCirclesLayer: Error removing weather circles:', error);\n    }\n  }\n  \n  /**\n   * Toggle layer visibility\n   */\n  toggle() {\n    this.isVisible = !this.isVisible;\n    const visibility = this.isVisible ? 'visible' : 'none';\n    \n    if (this.map.getLayer(this.layerId)) {\n      this.map.setLayoutProperty(this.layerId, 'visibility', visibility);\n    }\n  }\n  \n  /**\n   * Add test weather circles for debugging\n   */\n  addTestCircles() {\n    console.log('WeatherCirclesLayer: Adding test circles for debugging');\n    console.log('WeatherCirclesLayer: Map state:', {\n      hasMap: !!this.map,\n      mapLoaded: this.map ? (this.map.loaded ? this.map.loaded() : 'checking...') : false,\n      mapStyle: this.map ? this.map.getStyle() : null\n    });\n    \n    // Create test weather segments for Gulf of Mexico\n    // Format: \"lat, lon\" - these should appear in the Gulf of Mexico around Louisiana/Texas coast\n    const testSegments = [\n      {\n        geoPoint: \"27.5, -90.5\", // Should be in Gulf of Mexico southwest of New Orleans\n        airportIcao: \"TEST1\",\n        ranking2: 5, // Use ranking2 to match real data structure\n        isRig: false\n      },\n      {\n        geoPoint: \"28.0, -89.5\", // Should be in Gulf of Mexico south of New Orleans\n        airportIcao: \"TEST2\", \n        ranking2: 8, // Use ranking2 to match real data structure\n        isRig: true\n      },\n      {\n        geoPoint: \"26.8, -91.2\", // Should be in Gulf of Mexico southwest of Louisiana\n        airportIcao: \"TEST3\",\n        ranking2: 15, // Use ranking2 to match real data structure\n        isRig: false\n      },\n      {\n        geoPoint: \"27.8, -88.5\", // Should be in Gulf of Mexico southeast of New Orleans\n        airportIcao: \"TEST4\",\n        ranking2: 10, // Use ranking2 to match real data structure\n        isRig: false\n      }\n    ];\n    \n    console.log('WeatherCirclesLayer: Created test segments:', testSegments);\n    this.addWeatherCircles(testSegments);\n  }\n  \n  /**\n   * Add curved dotted lines from split points to alternate destinations\n   * @param {Array} validSegments - Weather segments with coordinates\n   */\n  addAlternateLines(validSegments) {\n    console.log('ðŸ”— Adding curved dotted lines for weather alternate routes');\n    \n    // ðŸš¨ SAFETY CHECK: Ensure map exists before attempting to add lines\n    if (!this.map) {\n      console.warn('ðŸ”— WeatherCirclesLayer: Cannot add alternate lines - map reference is null/undefined');\n      return;\n    }\n    \n    // CRITICAL FIX: Get correct split point from flight data, not weather segments\n    const flightAlternateData = window.flightAlternateData;\n    let correctSplitPoint = null;\n    \n    if (flightAlternateData && flightAlternateData.splitPoint) {\n      // Parse the split point from flight data\n      if (typeof flightAlternateData.splitPoint === 'string') {\n        const parts = flightAlternateData.splitPoint.split(',');\n        if (parts.length === 2) {\n          const lat = parseFloat(parts[0].trim());\n          const lng = parseFloat(parts[1].trim());\n          correctSplitPoint = [lng, lat]; // GeoJSON format: [lng, lat]\n          console.log('ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point:', correctSplitPoint);\n        }\n      } else if (Array.isArray(flightAlternateData.splitPoint)) {\n        correctSplitPoint = flightAlternateData.splitPoint;\n        console.log('ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point array:', correctSplitPoint);\n      }\n    }\n    \n    if (!correctSplitPoint) {\n      console.warn('ðŸŽ¯ WARNING: No correct split point available from flight data - alternate lines may be incorrect');\n      console.warn('ðŸŽ¯ Available flight alternate data:', flightAlternateData);\n    }\n    \n    // Create curved line features for each weather segment with coordinates\n    const lineFeatures = [];\n    \n    validSegments.forEach(segment => {\n      if (segment.alternateGeoShape && segment.alternateGeoShape.coordinates && \n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        // Use correct split point from flight data, fallback to segment data if unavailable\n        const splitPoint = correctSplitPoint || segment.alternateGeoShape.coordinates[0];\n        const destination = segment.alternateGeoShape.coordinates[1]; // End point\n        \n        console.log(`ðŸ”— Creating curved line from split ${JSON.stringify(splitPoint)} to ${segment.airportIcao} ${JSON.stringify(destination)}`);\n        console.log(`ðŸŽ¯ SPLIT POINT SOURCE: ${correctSplitPoint ? 'Flight Data (CORRECT)' : 'Weather Segment (FALLBACK)'}`);\n        console.log(`ðŸš¨ LINE DEBUG: Full coordinates array for ${segment.airportIcao}:`, JSON.stringify(segment.alternateGeoShape.coordinates, null, 2));\n        \n        // Create straight line for alternate routes (cleaner look)\n        const straightCoordinates = [splitPoint, destination];\n        \n        const lineFeature = {\n          type: 'Feature',\n          geometry: {\n            type: 'LineString',\n            coordinates: straightCoordinates\n          },\n          properties: {\n            type: 'weather-alternate-line',\n            airportIcao: segment.airportIcao,\n            ranking: segment.ranking2,\n            isRig: segment.isRig || false\n          }\n        };\n        \n        lineFeatures.push(lineFeature);\n      }\n    });\n    \n    if (lineFeatures.length > 0) {\n      // Add alternate lines source and layer\n      const linesSourceId = this.sourceId + '-lines';\n      const linesLayerId = this.layerId + '-lines';\n      \n      try {\n        // Remove existing lines\n        if (this.map.getLayer && this.map.getLayer(linesLayerId)) {\n          this.map.removeLayer(linesLayerId);\n        }\n        if (this.map.getSource && this.map.getSource(linesSourceId)) {\n          this.map.removeSource(linesSourceId);\n        }\n        \n        // Add new lines with drop shadow\n        this.map.addSource(linesSourceId, {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection',\n            features: lineFeatures\n          }\n        });\n        \n        // Add STRAIGHT shadow layer first (3D effect) - FIXED FOR VISIBILITY\n        this.map.addSource(linesSourceId + '-shadow', {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection',\n            features: this.createStraightShadowLines(validSegments)\n          }\n        });\n        \n        this.map.addLayer({\n          id: linesLayerId + '-shadow',\n          type: 'line',\n          source: linesSourceId + '-shadow',\n          paint: {\n            'line-color': 'rgba(0, 0, 0, 0.2)', // LIGHTER shadow (was 0.6, now 0.2)\n            'line-width': 2, // THINNER shadow (was 3, now 2)\n            'line-blur': 1 // BLURRIER shadow effect\n            // REMOVED line-dasharray - solid line for shadow\n          },\n          layout: {\n            'visibility': 'visible'\n          }\n        });\n        \n        // Add main line layer on top (BRIGHTENED)\n        this.map.addLayer({\n          id: linesLayerId,\n          type: 'line',\n          source: linesSourceId,\n          paint: {\n            'line-color': '#999999', // Brighter grey (was #666666)\n            'line-width': 1, // Single pixel width\n            'line-dasharray': [3, 3] // Dotted pattern\n          },\n          layout: {\n            'visibility': 'visible'\n          }\n        });\n        \n        console.log('ðŸ”— Added', lineFeatures.length, 'curved dotted weather alternate lines');\n      } catch (error) {\n        console.error('ðŸ”— Error adding alternate lines:', error);\n      }\n    } else {\n      console.log('ðŸ”— No valid segments found for alternate lines');\n    }\n  }\n  \n  // ðŸ—‘ï¸ OLD POPUP SYSTEM REMOVED\n  // The old popup system has been permanently removed to prevent confusion.\n  // All popups are now handled by RigWeatherGraphics which has more detailed weather data.\n\n  // ðŸ—‘ï¸ OLD HOVER AREAS REMOVED\n  // Hover areas are now handled by RigWeatherGraphics\n\n  // ðŸ—‘ï¸ OLD HOVER FEATURE CREATION REMOVED\n\n  // ðŸ—‘ï¸ OLD POPUP HELPER METHODS REMOVED\n  // All popup functionality now handled by RigWeatherGraphics\n\n  /**\n   * Deduplicate circles by location (only keep one circle per unique location)\n   * @param {Array} segments - Array of weather segments with coordinates\n   * @returns {Array} Deduplicated segments\n   */\n  deduplicateCirclesByLocation(segments) {\n    const locationMap = new Map();\n    \n    segments.forEach(segment => {\n      if (!segment.extractedCoordinates) return;\n      \n      // Create a location key from coordinates (rounded to avoid floating point issues)\n      const [lng, lat] = segment.extractedCoordinates;\n      const locationKey = `${Math.round(lng * 10000)},${Math.round(lat * 10000)}`;\n      \n      // If we haven't seen this location before, or this segment has higher priority, keep it\n      const existing = locationMap.get(locationKey);\n      \n      if (!existing || this.getCirclePriority(segment) > this.getCirclePriority(existing)) {\n        const color = this.getAviationRankingColor(segment.ranking2);\n        locationMap.set(locationKey, segment);\n        console.log(`ðŸŽ¯ Deduplicate: Keeping ${segment.airportIcao} (${segment.circleType}) at ${locationKey} with ranking ${segment.ranking2} = COLOR ${color}`);\n      } else {\n        const existingColor = this.getAviationRankingColor(existing.ranking2);\n        const segmentColor = this.getAviationRankingColor(segment.ranking2);\n        console.log(`ðŸŽ¯ Deduplicate: Skipping ${segment.airportIcao} (${segment.circleType}) ranking=${segment.ranking2} color=${segmentColor} - already have ${existing.airportIcao} (${existing.circleType}) ranking=${existing.ranking2} color=${existingColor}`);\n      }\n    });\n    \n    return Array.from(locationMap.values());\n  }\n  \n  /**\n   * Get priority for circle deduplication (higher number = higher priority)\n   * @param {Object} segment - Weather segment\n   * @returns {number} Priority score\n   */\n  getCirclePriority(segment) {\n    // SIMPLIFIED: Since we're skipping rigs, only prioritize alternates vs splits\n    let basePriority = 0;\n    \n    switch (segment.circleType) {\n      case 'alternate':\n        basePriority = 200; // Higher priority for alternates\n        break;\n      case 'split':\n        basePriority = 100; // Lower priority for split points\n        break;\n      default:\n        basePriority = 150;\n    }\n    \n    // Add weather ranking priority (worse weather = higher priority)\n    // Rankings: 5=worst, 8=ara, 10=warning, 15=good, 20=n/a\n    const weatherPriority = segment.ranking2 ? (25 - segment.ranking2) : 0;\n    \n    return basePriority + weatherPriority;\n  }\n\n  /**\n   * Find the first route layer to ensure weather rings go underneath\n   * @returns {string|undefined} Layer ID to insert before, or undefined for top\n   */\n  findFirstRouteLayer() {\n    if (!this.map) return undefined;\n    \n    // Common route layer names to look for (in order of preference)\n    const routeLayerPatterns = [\n      'route-shadow',      // Route shadows (lowest route layer)\n      'route-glow',        // Route glow effects\n      'route-line',        // Main route lines\n      'route',             // Generic route layers\n      'alternate-shadow',  // Alternate route shadows\n      'alternate-glow',    // Alternate glow\n      'alternate-line',    // Alternate lines\n      'alternate',         // Generic alternate layers\n      'waypoint',          // Waypoint layers\n      'platform',          // Platform layers\n      'airfield'           // Airfield layers\n    ];\n    \n    // Get all layer IDs from the map\n    const allLayers = this.map.getStyle()?.layers || [];\n    \n    // Find the first matching route layer\n    for (const pattern of routeLayerPatterns) {\n      const matchingLayer = allLayers.find(layer => \n        layer.id.toLowerCase().includes(pattern.toLowerCase())\n      );\n      \n      if (matchingLayer) {\n        console.log(`ðŸŽ¯ Weather rings will be placed before route layer: ${matchingLayer.id}`);\n        return matchingLayer.id;\n      }\n    }\n    \n    console.log(`ðŸŽ¯ No route layers found, weather rings will be on top`);\n    return undefined; // Add on top if no route layers found\n  }\n\n  /**\n   * Get rig coordinates from waypoints data\n   * @param {string} rigIcao - Rig ICAO code to find\n   * @returns {Array|null} [lng, lat] coordinates or null\n   */\n  getRigCoordinatesFromWaypoints(rigIcao) {\n    // FIXED: Use waypointManager to get coordinates\n    console.log(`ðŸ”§ DEBUG: Looking for rig coordinates for ${rigIcao}...`);\n    console.log(`ðŸ”§ DEBUG: Available window objects:`, Object.keys(window).filter(k => k.includes('waypoint') || k.includes('route')));\n    \n    // Try waypointManager first\n    if (window.waypointManager) {\n      try {\n        // Check if waypointManager has a method to get waypoints\n        const waypoints = window.waypointManager.waypoints || \n                         window.waypointManager.getWaypoints?.() ||\n                         window.waypointManager.currentWaypoints;\n        \n        console.log(`ðŸ”§ DEBUG: WaypointManager waypoints:`, waypoints);\n        \n        if (waypoints && Array.isArray(waypoints)) {\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === rigIcao || \n            wp.id === rigIcao ||\n            wp.airportIcao === rigIcao\n          );\n          \n          if (matchingWaypoint && matchingWaypoint.lat && matchingWaypoint.lng) {\n            console.log(`âœ… Found coordinates for rig ${rigIcao} in waypointManager:`, [matchingWaypoint.lng, matchingWaypoint.lat]);\n            return [matchingWaypoint.lng, matchingWaypoint.lat]; // GeoJSON format\n          }\n        }\n        \n        // Try alternative waypoint manager properties\n        const waypointManagerKeys = Object.keys(window.waypointManager);\n        console.log(`ðŸ” WaypointManager available methods/properties:`, waypointManagerKeys);\n        \n        // Look for any property that might contain waypoints\n        for (const key of waypointManagerKeys) {\n          const value = window.waypointManager[key];\n          if (Array.isArray(value) && value.length > 0) {\n            console.log(`ðŸ” Checking waypointManager.${key}:`, value);\n            const match = value.find(wp => \n              (wp.name === rigIcao || wp.id === rigIcao || wp.airportIcao === rigIcao) &&\n              wp.lat && wp.lng\n            );\n            if (match) {\n              console.log(`âœ… Found coordinates for rig ${rigIcao} in waypointManager.${key}:`, [match.lng, match.lat]);\n              return [match.lng, match.lat];\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Error accessing waypointManager:`, error);\n      }\n    }\n    \n    // Try route calculator as fallback\n    if (window.routeCalculator) {\n      try {\n        const routeWaypoints = window.routeCalculator.waypoints || \n                              window.routeCalculator.getWaypoints?.() ||\n                              window.routeCalculator.currentRoute?.waypoints;\n        \n        if (routeWaypoints && Array.isArray(routeWaypoints)) {\n          const match = routeWaypoints.find(wp => \n            (wp.name === rigIcao || wp.id === rigIcao || wp.airportIcao === rigIcao) &&\n            wp.lat && wp.lng\n          );\n          if (match) {\n            console.log(`âœ… Found coordinates for rig ${rigIcao} in routeCalculator:`, [match.lng, match.lat]);\n            return [match.lng, match.lat];\n          }\n        }\n      } catch (error) {\n        console.warn(`Error accessing routeCalculator:`, error);\n      }\n    }\n    \n    console.warn(`âŒ Could not find coordinates for rig ${rigIcao} in any waypoint source`);\n    return null;\n  }\n\n  /**\n   * Create straight shadow lines for 3D effect\n   * @param {Array} validSegments - Weather segments with coordinates\n   * @returns {Array} Array of straight line features for shadows\n   */\n  createStraightShadowLines(validSegments) {\n    const shadowFeatures = [];\n    \n    // CRITICAL FIX: Get correct split point from flight data for shadows too\n    const flightAlternateData = window.flightAlternateData;\n    let correctSplitPoint = null;\n    \n    if (flightAlternateData && flightAlternateData.splitPoint) {\n      // Parse the split point from flight data\n      if (typeof flightAlternateData.splitPoint === 'string') {\n        const parts = flightAlternateData.splitPoint.split(',');\n        if (parts.length === 2) {\n          const lat = parseFloat(parts[0].trim());\n          const lng = parseFloat(parts[1].trim());\n          correctSplitPoint = [lng, lat]; // GeoJSON format: [lng, lat]\n        }\n      } else if (Array.isArray(flightAlternateData.splitPoint)) {\n        correctSplitPoint = flightAlternateData.splitPoint;\n      }\n    }\n    \n    validSegments.forEach(segment => {\n      if (segment.alternateGeoShape && segment.alternateGeoShape.coordinates && \n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        // Use correct split point from flight data, fallback to segment data if unavailable\n        const splitPoint = correctSplitPoint || segment.alternateGeoShape.coordinates[0];\n        const destination = segment.alternateGeoShape.coordinates[1];\n        \n        // Create STRAIGHT line for shadow (3D effect)\n        const shadowFeature = {\n          type: 'Feature',\n          geometry: {\n            type: 'LineString',\n            coordinates: [splitPoint, destination] // Straight line for shadow\n          },\n          properties: {\n            type: 'weather-alternate-shadow',\n            airportIcao: segment.airportIcao\n          }\n        };\n        \n        shadowFeatures.push(shadowFeature);\n      }\n    });\n    \n    return shadowFeatures;\n  }\n\n  /**\n   * Create curved line coordinates between two points (same as route curves)\n   * @param {Array} start - [lng, lat] start coordinates\n   * @param {Array} end - [lng, lat] end coordinates\n   * @returns {Array} Array of curved coordinates\n   */\n  createCurvedLine(start, end) {\n    // Simple curved line implementation\n    // Uses a control point offset perpendicular to the line for the curve\n    \n    const [startLng, startLat] = start;\n    const [endLng, endLat] = end;\n    \n    // Calculate midpoint\n    const midLng = (startLng + endLng) / 2;\n    const midLat = (startLat + endLat) / 2;\n    \n    // Calculate perpendicular offset for curve (smaller for weather lines)\n    const deltaLng = endLng - startLng;\n    const deltaLat = endLat - startLat;\n    const distance = Math.sqrt(deltaLng * deltaLng + deltaLat * deltaLat);\n    \n    // Curve offset proportional to distance (MUCH LOWER curve for weather alternate lines)\n    const curveOffset = distance * 0.035; // Reduced from 0.075 to 0.035 (much flatter curves)\n    \n    // FIXED: Always curve upward/right - ensure positive direction\n    // Calculate perpendicular direction and force it upward\n    let perpLng = -deltaLat / distance * curveOffset;\n    let perpLat = deltaLng / distance * curveOffset;\n    \n    // Force curve to always go \"up\" (positive latitude direction) or \"right\" (positive longitude)\n    // This ensures consistent curve direction regardless of route direction\n    if (perpLat < 0) {\n      perpLng = -perpLng;\n      perpLat = -perpLat;\n    }\n    \n    // Control point offset from midpoint\n    const controlLng = midLng + perpLng;\n    const controlLat = midLat + perpLat;\n    \n    // Generate curved line with multiple points\n    const steps = 25; // Increased steps for smoother curve\n    const coordinates = [];\n    \n    for (let i = 0; i <= steps; i++) {\n      const t = i / steps;\n      const t2 = t * t;\n      const oneMinusT = 1 - t;\n      const oneMinusT2 = oneMinusT * oneMinusT;\n      \n      // Quadratic Bezier curve formula\n      const lng = oneMinusT2 * startLng + 2 * oneMinusT * t * controlLng + t2 * endLng;\n      const lat = oneMinusT2 * startLat + 2 * oneMinusT * t * controlLat + t2 * endLat;\n      \n      coordinates.push([lng, lat]);\n    }\n    \n    return coordinates;\n  }\n  \n  /**\n   * Update weather circles with new data\n   * @param {Array} weatherSegments - New weather segments data\n   */\n  updateWeatherCircles(weatherSegments) {\n    this.addWeatherCircles(weatherSegments);\n  }\n\n  /**\n   * Static method to auto-create weather circles when segments are loaded\n   * Call this when weather segments are first loaded for a new flight\n   */\n  static autoCreateOnWeatherLoad(map, weatherSegments) {\n    if (!map || !weatherSegments || weatherSegments.length === 0) {\n      return;\n    }\n\n    console.log('ðŸ”„ AUTO-CREATE: Weather segments loaded, creating weather circles automatically');\n    \n    // Create weather circles layer if it doesn't exist\n    if (!window.currentWeatherCirclesLayer) {\n      const weatherCirclesLayer = new WeatherCirclesLayer(map);\n      weatherCirclesLayer.addWeatherCircles(weatherSegments);\n      window.currentWeatherCirclesLayer = weatherCirclesLayer;\n      console.log('ðŸ”„ AUTO-CREATE: Weather circles created automatically for new flight');\n    } else {\n      // Update existing layer\n      window.currentWeatherCirclesLayer.addWeatherCircles(weatherSegments);\n      console.log('ðŸ”„ AUTO-CREATE: Weather circles updated automatically');\n    }\n  }\n  \n  /**\n   * Global helper function to refresh weather circles from any available data\n   * Useful for debugging and manual testing\n   */\n  static refreshFromAvailableData(map) {\n    try {\n      console.log('ðŸ”„ REFRESH: Attempting to refresh weather circles from available data');\n      \n      // Find any available weather data\n      let weatherData = null;\n      let dataSource = 'none';\n      \n      if (window.loadedWeatherSegments?.length > 0) {\n        weatherData = window.loadedWeatherSegments;\n        dataSource = 'window.loadedWeatherSegments';\n      }\n      \n      console.log(`ðŸ”„ REFRESH: Found data from ${dataSource}, segments:`, weatherData?.length || 0);\n      \n      if (weatherData && weatherData.length > 0 && map) {\n        // Clean up existing layer\n        if (window.currentWeatherCirclesLayer) {\n          try {\n            window.currentWeatherCirclesLayer.removeWeatherCircles();\n          } catch (cleanupError) {\n            console.warn('ðŸ”„ REFRESH: Error during cleanup:', cleanupError);\n          }\n        }\n        \n        // Create new layer\n        const weatherCirclesLayer = new WeatherCirclesLayer(map);\n        weatherCirclesLayer.addWeatherCircles(weatherData);\n        window.currentWeatherCirclesLayer = weatherCirclesLayer;\n        console.log('ðŸ”„ REFRESH: Weather circles refreshed successfully');\n        return true;\n      } else {\n        console.log('ðŸ”„ REFRESH: No weather data available to refresh from');\n        return false;\n      }\n    } catch (error) {\n      console.error('ðŸ”„ REFRESH: Error refreshing weather circles:', error);\n      return false;\n    }\n  }\n}\n\n// Make refresh function globally available for debugging\nwindow.refreshWeatherCircles = () => {\n  if (window.mapManager?.map) {\n    return WeatherCirclesLayer.refreshFromAvailableData(window.mapManager.map);\n  } else {\n    console.error('ðŸ”„ REFRESH: Map not available for refresh');\n    return false;\n  }\n};\n\n// Global function to clear stuck locks\nwindow.clearWeatherCirclesLock = () => {\n  if (window.weatherCirclesCreationInProgress) {\n    const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n    console.log(`ðŸ”“ MANUAL: Clearing weather circles lock (was active for ${lockAge}ms)`);\n    window.weatherCirclesCreationInProgress = false;\n    window.weatherCirclesLockTime = null;\n    return true;\n  } else {\n    console.log('ðŸ”“ MANUAL: No active lock to clear');\n    return false;\n  }\n};\n\n// Global function to check lock status\nwindow.checkWeatherCirclesLock = () => {\n  if (window.weatherCirclesCreationInProgress) {\n    const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n    console.log(`ðŸ”’ LOCK STATUS: Active for ${lockAge}ms (set at ${new Date(window.weatherCirclesLockTime).toLocaleTimeString()})`);\n    return { active: true, ageMs: lockAge, setAt: window.weatherCirclesLockTime };\n  } else {\n    console.log('ðŸ”“ LOCK STATUS: No active lock');\n    return { active: false };\n  }\n};\n\nexport default WeatherCirclesLayer;"],"names":["_a","_b","_c","_d"],"mappings":"AAOA,MAAM,oBAAoB;AAAA,EACxB,YAAY,KAAK;AACf,SAAK,MAAM;AACX,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,SAAK,yBAAyB,CAAE;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,kBAAkB,iBAAiB;AApBrC;AAqBI,QAAI,CAAC,mBAAmB,CAAC,KAAK,KAAK;AACjC,cAAQ,KAAK,qDAAqD;AAClE;AAAA,IACN;AAGI,UAAM,gBAAgB,KAAK,IAAK;AAChC,QAAI,OAAO,kCAAkC;AAC3C,YAAM,UAAU,KAAK,IAAK,KAAI,OAAO,0BAA0B;AAC/D,cAAQ,IAAI,oDAAoD,OAAO,IAAI;AAG3E,UAAI,UAAU,KAAO;AACnB,gBAAQ,IAAI,8DAA8D;AAC1E,eAAO,mCAAmC;AAC1C,eAAO,yBAAyB;AAAA,MACxC,OAAa;AACL,gBAAQ,IAAI,0EAA0E;AACtF;AAAA,MACR;AAAA,IACA;AAGI,WAAO,mCAAmC;AAC1C,WAAO,yBAAyB;AAChC,YAAQ,IAAI,oDAAoD,aAAa,EAAE;AAG/E,UAAM,YAAY,MAAM;AACtB,UAAI,OAAO,oCAAoC,OAAO,2BAA2B,eAAe;AAC9F,eAAO,mCAAmC;AAC1C,eAAO,yBAAyB;AAChC,gBAAQ,IAAI,4DAA4D,KAAK,QAAQ,aAAa,KAAK;AAAA,MAC/G;AAAA,IACK;AAGD,eAAW,WAAW,GAAI;AAE1B,YAAQ,IAAI,kCAAkC,gBAAgB,QAAQ,wBAAwB;AAE9F,SAAK,yBAAyB;AAC9B,SAAK,qBAAsB;AAG3B,UAAM,eAAe,CAAE;AAIvB,UAAM,gBAAgB,CAAE;AAGxB,UAAM,qBAAqB,oBAAI,IAAK;AACpC,UAAM,qBAAqB,oBAAI,IAAK;AAGpC,oBAAgB,QAAQ,aAAW;AACjC,UAAI,QAAQ,sBAAsB,QAAQ,eAAe,QAAQ,eAAe;AAC9E,2BAAmB,IAAI,QAAQ,eAAe,QAAQ,YAAY;AAAA,MAC1E;AAAA,IACA,CAAK;AAED,YAAQ,IAAI,6CAA6C,MAAM,KAAK,kBAAkB,CAAC;AAEvF,oBAAgB,QAAQ,CAAC,SAAS,UAAU;AArFhD,UAAAA,KAAA;AAsFM,cAAQ,IAAI,cAAc,KAAK,KAAK;AAAA,QAClC,aAAa,QAAQ;AAAA,QACrB,cAAc,QAAQ;AAAA,QACtB,OAAO,QAAQ;AAAA,QACf,mBAAmB,QAAQ;AAAA,QAC3B,UAAU,QAAQ;AAAA,QAClB,oBAAoB,CAAC,IAAE,MAAAA,MAAA,QAAQ,sBAAR,gBAAAA,IAA2B,gBAA3B,mBAAwC,WAAU;AAAA,QACzE,aAAa,CAAC,CAAC,QAAQ;AAAA,QACvB,UAAU,QAAQ;AAAA,MAC1B,CAAO;AAED,YAAM,kBAAmB,QAAQ,aAAa,UAAa,QAAQ,aAAa;AAEhF,UAAI,CAAC,iBAAiB;AACpB,gBAAQ,IAAI,qBAAqB,KAAK,oBAAoB;AAC1D;AAAA,MACR;AAGM,YAAM,cAAc,QAAQ,eAAe,QAAQ;AACnD,UAAI,aAAa;AAEf,YAAI,CAAC,QAAQ,SAAS,CAAC,QAAQ,qBAAqB,mBAAmB,IAAI,WAAW,GAAG;AACvF,kBAAQ,IAAI,kCAAkC,WAAW,uCAAuC;AAChG;AAAA,QACV;AAGQ,YAAI,mBAAmB,IAAI,WAAW,GAAG;AACvC,kBAAQ,IAAI,gCAAgC,WAAW,sBAAsB;AAC7E;AAAA,QACV;AAGQ,2BAAmB,IAAI,WAAW;AAAA,MAC1C;AAGM,UAAI,QAAQ,qBACR,QAAQ,kBAAkB,eAC1B,MAAM,QAAQ,QAAQ,kBAAkB,WAAW,KACnD,QAAQ,kBAAkB,YAAY,UAAU,GAAG;AAErD,cAAM,UAAU,QAAQ;AAGxB,cAAM,mBAAmB;AAAA,UACvB,GAAG;AAAA,UACH,UAAU;AAAA,UACV,sBAAsB,QAAQ,kBAAkB,YAAY,CAAC;AAAA,UAC7D,YAAY;AAAA,QACb;AACD,sBAAc,KAAK,gBAAgB;AACnC,gBAAQ,IAAI,eAAe,KAAK,KAAK,QAAQ,WAAW,OAAO,KAAK,UAAU,QAAQ,kBAAkB,YAAY,CAAC,CAAC,CAAC,iBAAiB,OAAO,EAAE;AACjJ,gBAAQ,IAAI,+DAA+D,QAAQ,WAAW,KAAK,KAAK,UAAU,QAAQ,kBAAkB,aAAa,MAAM,CAAC,CAAC;AAGjK,gBAAQ,IAAI,4CAA4C,QAAQ,WAAW,EAAE;AAG7E,YAAI,YAAY,MAAM,gBAAgB,MAAM,WAAW,MAAM,aAAa;AAG1E,YAAI,yBAAyB;AAC7B,YAAI,QAAQ,YAAY,OAAO,6BAA6B;AAC1D,gBAAM,aAAa,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAC9F,gBAAM,WAAW,OAAO,4BAA4B,4BAA4B,QAAQ,QAAQ;AAChG,gBAAM,YAAY,OAAO,4BAA4B,uBAAuB,QAAQ,QAAQ;AAG5F,mCAAyB,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAEpG,cAAI,eAAe,QAAQ,aAAa,MAAM;AAC5C,wBAAY;AACZ,4BAAgB;AAChB,uBAAW;AACX,yBAAa;AAAA,UACzB;AAAA,QACA;AAGQ,YAAI,cAAc,QAAQ,QAAQ,WAAW;AAC3C,sBAAY,QAAQ;AACpB,0BAAgB,QAAQ;AACxB,qBAAW,QAAQ;AACnB,uBAAa;AAAA,QACvB;AAEQ,YAAI,cAAc,MAAM;AACtB,uBAAa,KAAK;AAAA,YAChB,SAAS,QAAQ;AAAA,YACjB,UAAU,QAAQ,kBAAkB,YAAY,CAAC,EAAE,CAAC;AAAA,YACpD,WAAW,QAAQ,kBAAkB,YAAY,CAAC,EAAE,CAAC;AAAA,YACrD,WAAW,CAAC,QAAQ;AAAA,YACpB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB,QAAQ,kBAAkB;AAAA,YAC1C,aAAY,iEAAwB,eAAc,QAAQ,cAAc;AAAA,YACxE,cAAa,iEAAwB,gBAAe,QAAQ;AAAA,YAC5D,YAAY,QAAQ,cAAc,QAAQ,WAAW;AAAA,YACrD,WAAW,QAAQ;AAAA,YACnB,cAAc;AAAA;AAAA,YAEd,oBAAoB;AAAA,YACpB,UAAU,QAAQ;AAAA,YAClB,QAAQ,QAAQ;AAAA,YAChB,SAAQ,iEAAwB,WAAU,CAAE;AAAA,YAC5C,oBAAmB,iEAAwB,eAAc,CAAE;AAAA,YAC3D,WAAW,iEAAwB;AAAA,YACnC,UAAU,iEAAwB;AAAA,UAC9C,CAAW;AACD,kBAAQ,IAAI,4BAA4B,QAAQ,WAAW,aAAa;AAAA,QAClF,OAAe;AACL,kBAAQ,IAAI,wCAAwC,QAAQ,WAAW,EAAE;AAAA,QACnF;AAKQ,gBAAQ,IAAI,wDAAwD,QAAQ,WAAW,wBAAwB;AAAA,MACvH,WAGe,QAAQ,OAAO;AACtB,gBAAQ,IAAI,+BAA+B,QAAQ,WAAW,EAAE;AAGhE,YAAI,iBAAiB;AAGrB,YAAI,OAAO,oBAAoB,MAAM,QAAQ,OAAO,gBAAgB,GAAG;AACrE,gBAAM,mBAAmB,OAAO,iBAAiB;AAAA,YAAK,QAAE;AA3NlE,kBAAAA,KAAAC;AA4NY,wBAAG,SAAS,QAAQ,iBACpBD,MAAA,GAAG,SAAH,gBAAAA,IAAS,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACjD;AACD,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,6BAAiB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AAC5D,oBAAQ,IAAI,iBAAiB,QAAQ,WAAW,uCAAuC,cAAc;AAAA,UACjH;AAAA,QACA;AAGQ,YAAI,CAAC,oBAAkB,YAAO,oBAAP,mBAAwB,eAAc;AAC3D,gBAAM,YAAY,OAAO,gBAAgB,aAAc;AACvD,gBAAM,mBAAmB,UAAU;AAAA,YAAK,QAAE;AAxOpD,kBAAAD,KAAAC;AAyOY,wBAAG,SAAS,QAAQ,iBACpBD,MAAA,GAAG,SAAH,gBAAAA,IAAS,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACjD;AACD,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,6BAAiB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AAC5D,oBAAQ,IAAI,iBAAiB,QAAQ,WAAW,sCAAsC,cAAc;AAAA,UAChH;AAAA,QACA;AAGQ,YAAI,CAAC,kBAAkB,OAAO,mBAAmB,MAAM,QAAQ,OAAO,eAAe,GAAG;AACtF,gBAAM,mBAAmB,OAAO,gBAAgB;AAAA,YAAK,QAAE;AApPjE,kBAAAD,KAAAC;AAqPY,wBAAG,SAAS,QAAQ,iBACpBD,MAAA,GAAG,SAAH,gBAAAA,IAAS,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACjD;AACD,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,6BAAiB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AAC5D,oBAAQ,IAAI,iBAAiB,QAAQ,WAAW,sCAAsC,cAAc;AAAA,UAChH;AAAA,QACA;AAGQ,YAAI,CAAC,kBAAkB,OAAO,kBAAkB,MAAM,QAAQ,OAAO,cAAc,GAAG;AACpF,gBAAM,mBAAmB,OAAO,eAAe;AAAA,YAAK,UAAI;AAhQlE,kBAAAD,KAAAC,KAAAC,KAAAC;AAiQY,0BAAK,SAAS,QAAQ,iBACtBH,MAAA,KAAK,SAAL,gBAAAA,IAAW,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB,kBAClD,KAAK,SAAS,QAAQ,iBACtBC,MAAA,KAAK,SAAL,gBAAAA,IAAW,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACnD;AACD,cAAI,oBAAoB,iBAAiB,aAAa;AACpD,6BAAiB,iBAAiB;AAClC,oBAAQ,IAAI,iBAAiB,QAAQ,WAAW,gCAAgC,cAAc;AAAA,UAC1G;AAAA,QACA;AAEQ,YAAI,gBAAgB;AAClB,gBAAM,aAAa;AAAA,YACjB,GAAG;AAAA,YACH,UAAU,QAAQ;AAAA,YAClB,sBAAsB;AAAA,YACtB,YAAY;AAAA,UACb;AACD,wBAAc,KAAK,UAAU;AAC7B,kBAAQ,IAAI,SAAS,QAAQ,WAAW,uBAAuB,KAAK,UAAU,cAAc,CAAC,iBAAiB,QAAQ,QAAQ,EAAE;AAGhI,kBAAQ,IAAI,sCAAsC,QAAQ,WAAW,EAAE;AAGvE,cAAI,YAAY,MAAM,gBAAgB,MAAM,WAAW,MAAM,aAAa;AAG1E,kBAAQ,IAAI,4CAA4C,QAAQ,WAAW,KAAK;AAAA,YAC9E,UAAU,QAAQ;AAAA,YAClB,QAAQ,QAAQ;AAAA,YAChB,WAAW,QAAQ;AAAA,YACnB,eAAe,QAAQ;AAAA,YACvB,UAAU,QAAQ;AAAA,YAClB,MAAM,QAAQ;AAAA,YACd,SAAS,OAAO,KAAK,OAAO,EAAE,OAAO,SAAO,IAAI,cAAc,SAAS,MAAM,CAAC;AAAA,UAC1F,CAAW;AAGD,cAAI,yBAAyB;AAC7B,cAAI,QAAQ,YAAY,OAAO,6BAA6B;AAC1D,oBAAQ,IAAI,oCAAoC,QAAQ,WAAW,MAAM,QAAQ,QAAQ,GAAG;AAG5F,kBAAM,aAAa,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAC9F,kBAAM,WAAW,OAAO,4BAA4B,4BAA4B,QAAQ,QAAQ;AAChG,kBAAM,YAAY,OAAO,4BAA4B,uBAAuB,QAAQ,QAAQ;AAG5F,qCAAyB,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAEpG,oBAAQ,IAAI,yCAAyC,UAAU,UAAU,QAAQ,WAAW,SAAS,EAAE;AACvG,oBAAQ,IAAI,sCAAsC,sBAAsB;AAExE,gBAAI,eAAe,QAAQ,aAAa,MAAM;AAC5C,0BAAY;AACZ,8BAAgB;AAChB,yBAAW;AACX,2BAAa;AACb,sBAAQ,IAAI,+DAA+D,QAAQ,WAAW,EAAE;AAAA,YAC9G,OAAmB;AACL,sBAAQ,IAAI,6CAA6C,QAAQ,WAAW,EAAE;AAAA,YAC5F;AAAA,UACA;AAGU,cAAI,cAAc,QAAQ,QAAQ,UAAU,OAAO,6BAA6B;AAC9E,oBAAQ,IAAI,gCAAgC,QAAQ,WAAW,MAAM,QAAQ,MAAM,GAAG;AAGtF,kBAAM,WAAW,OAAO,4BAA4B,wBAAwB,QAAQ,MAAM;AAC1F,kBAAM,SAAS,OAAO,4BAA4B,4BAA4B,QAAQ,MAAM;AAC5F,kBAAM,UAAU,OAAO,4BAA4B,uBAAuB,QAAQ,MAAM;AAExF,oBAAQ,IAAI,uCAAuC,QAAQ,UAAU,MAAM,WAAW,OAAO,EAAE;AAE/F,gBAAI,aAAa,QAAQ,WAAW,MAAM;AACxC,0BAAY;AACZ,8BAAgB;AAChB,yBAAW;AACX,2BAAa;AACb,sBAAQ,IAAI,2DAA2D,QAAQ,WAAW,EAAE;AAAA,YAC1G;AAAA,UACA;AAGU,cAAI,cAAc,QAAQ,QAAQ,cAAc,UAAa,QAAQ,cAAc,MAAM;AACvF,wBAAY,QAAQ;AACpB,4BAAgB,QAAQ;AACxB,uBAAW,QAAQ;AACnB,yBAAa;AAAA,UACzB;AAGU,cAAI,cAAc,QAAQ,QAAQ,MAAM;AACtC,gBAAI,OAAO,QAAQ,SAAS,UAAU;AACpC,0BAAY,QAAQ,KAAK,SAAS,QAAQ,KAAK;AAC/C,8BAAgB,QAAQ,KAAK,aAAa,QAAQ,KAAK;AACvD,yBAAW,QAAQ,KAAK,QAAQ,QAAQ,KAAK;AAC7C,2BAAa;AAAA,YAC3B;AAAA,UACA;AAGU,cAAI,cAAc,MAAM;AACtB,kBAAM,sBAAsB,CAAC,gBAAgB,gBAAgB,SAAS,MAAM;AAC5E,kBAAM,oBAAoB,CAAC,oBAAoB,aAAa,MAAM;AAElE,uBAAW,SAAS,qBAAqB;AACvC,kBAAI,QAAQ,KAAK,MAAM,UAAa,QAAQ,KAAK,MAAM,MAAM;AAC3D,4BAAY,QAAQ,KAAK;AACzB,6BAAa,cAAc,KAAK;AAChC;AAAA,cAChB;AAAA,YACA;AAEY,uBAAW,SAAS,mBAAmB;AACrC,kBAAI,QAAQ,KAAK,MAAM,UAAa,QAAQ,KAAK,MAAM,MAAM;AAC3D,gCAAgB,QAAQ,KAAK;AAC7B;AAAA,cAChB;AAAA,YACA;AAAA,UACA;AAEU,cAAI,cAAc,MAAM;AACtB,yBAAa,KAAK;AAAA,cAChB,SAAS,QAAQ;AAAA,cACjB,UAAU,eAAe,CAAC;AAAA,cAC1B,WAAW,eAAe,CAAC;AAAA,cAC3B,WAAW;AAAA,cACX;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,gBAAgB,QAAQ,kBAAkB;AAAA,cAC1C,aAAY,iEAAwB,eAAc,QAAQ,cAAc;AAAA,cACxE,cAAa,iEAAwB,gBAAe,QAAQ;AAAA,cAC5D,YAAY,QAAQ,cAAc,QAAQ,WAAW;AAAA,cACrD,WAAW,QAAQ;AAAA,cACnB,cAAc;AAAA;AAAA,cAEd,oBAAoB;AAAA,cACpB,UAAU,QAAQ;AAAA,cAClB,QAAQ,QAAQ;AAAA,cAChB,SAAQ,iEAAwB,WAAU,CAAE;AAAA,cAC5C,oBAAmB,iEAAwB,eAAc,CAAE;AAAA,cAC3D,WAAW,iEAAwB;AAAA,cACnC,UAAU,iEAAwB;AAAA,YAChD,CAAa;AACD,oBAAQ,IAAI,sBAAsB,QAAQ,WAAW,aAAa;AAAA,UAC9E,OAAiB;AACL,oBAAQ,IAAI,kCAAkC,QAAQ,WAAW,EAAE;AAAA,UAC/E;AAAA,QACA,OAAe;AACL,kBAAQ,IAAI,SAAS,QAAQ,WAAW,4CAA4C;AAAA,QAC9F;AAAA,MAGA,WAAiB,CAAC,QAAQ,OAAO;AACzB,gBAAQ,IAAI,sCAAsC,QAAQ,eAAe,QAAQ,YAAY,EAAE;AAG/F,YAAI,yBAAyB;AAG7B,YAAI,QAAQ,UAAU;AACpB,mCAAyB,KAAK,cAAc,QAAQ,QAAQ;AAC5D,cAAI,wBAAwB;AAC1B,oBAAQ,IAAI,wBAAwB,QAAQ,WAAW,+BAA+B,sBAAsB;AAAA,UACxH;AAAA,QACA;AAGQ,YAAI,CAAC,0BAA0B,OAAO,oBAAoB,MAAM,QAAQ,OAAO,gBAAgB,GAAG;AAChG,gBAAM,mBAAmB,OAAO,iBAAiB;AAAA,YAAK,QAAE;AA/alE,kBAAAH,KAAAC;AAgbY,wBAAG,SAAS,QAAQ,iBACpBD,MAAA,GAAG,SAAH,gBAAAA,IAAS,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACjD;AACD,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,qCAAyB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AACpE,oBAAQ,IAAI,wBAAwB,QAAQ,WAAW,uCAAuC,sBAAsB;AAAA,UAChI;AAAA,QACA;AAGQ,YAAI,CAAC,4BAA0B,YAAO,oBAAP,mBAAwB,eAAc;AACnE,gBAAM,YAAY,OAAO,gBAAgB,aAAc;AACvD,gBAAM,mBAAmB,UAAU;AAAA,YAAK,QAAE;AA5bpD,kBAAAD,KAAAC;AA6bY,wBAAG,SAAS,QAAQ,iBACpBD,MAAA,GAAG,SAAH,gBAAAA,IAAS,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACjD;AACD,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,qCAAyB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AACpE,oBAAQ,IAAI,wBAAwB,QAAQ,WAAW,sCAAsC,sBAAsB;AAAA,UAC/H;AAAA,QACA;AAGQ,YAAI,CAAC,0BAA0B,OAAO,kBAAkB,MAAM,QAAQ,OAAO,cAAc,GAAG;AAC5F,gBAAM,mBAAmB,OAAO,eAAe;AAAA,YAAK,UAAI;AAxclE,kBAAAD,KAAAC,KAAAC,KAAAC;AAycY,0BAAK,SAAS,QAAQ,iBACtBH,MAAA,KAAK,SAAL,gBAAAA,IAAW,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB,kBAClD,KAAK,SAAS,QAAQ,iBACtBC,MAAA,KAAK,SAAL,gBAAAA,IAAW,qBAAkBC,MAAA,QAAQ,gBAAR,gBAAAA,IAAqB;AAAA;AAAA,UACnD;AACD,cAAI,oBAAoB,iBAAiB,aAAa;AACpD,qCAAyB,iBAAiB;AAC1C,oBAAQ,IAAI,wBAAwB,QAAQ,WAAW,gCAAgC,sBAAsB;AAAA,UACzH;AAAA,QACA;AAEQ,YAAI,wBAAwB;AAC1B,gBAAM,qBAAqB;AAAA,YACzB,GAAG;AAAA,YACH,UAAU,QAAQ;AAAA,YAClB,sBAAsB;AAAA,YACtB,YAAY;AAAA,UACb;AACD,wBAAc,KAAK,kBAAkB;AACrC,kBAAQ,IAAI,iBAAiB,QAAQ,eAAe,QAAQ,YAAY,uBAAuB,KAAK,UAAU,sBAAsB,CAAC,iBAAiB,QAAQ,QAAQ,EAAE;AAGxK,kBAAQ,IAAI,8CAA8C,QAAQ,WAAW,EAAE;AAG/E,cAAI,YAAY,MAAM,gBAAgB,MAAM,WAAW,MAAM,aAAa;AAG1E,cAAI,yBAAyB;AAC7B,cAAI,QAAQ,YAAY,OAAO,6BAA6B;AAC1D,kBAAM,aAAa,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAC9F,kBAAM,WAAW,OAAO,4BAA4B,4BAA4B,QAAQ,QAAQ;AAChG,kBAAM,YAAY,OAAO,4BAA4B,uBAAuB,QAAQ,QAAQ;AAG5F,qCAAyB,OAAO,4BAA4B,wBAAwB,QAAQ,QAAQ;AAEpG,gBAAI,eAAe,QAAQ,aAAa,MAAM;AAC5C,0BAAY;AACZ,8BAAgB;AAChB,yBAAW;AACX,2BAAa;AAAA,YAC3B;AAAA,UACA;AAGU,cAAI,cAAc,QAAQ,QAAQ,WAAW;AAC3C,wBAAY,QAAQ;AACpB,4BAAgB,QAAQ;AACxB,uBAAW,QAAQ;AACnB,yBAAa;AAAA,UACzB;AAEU,cAAI,cAAc,MAAM;AACtB,yBAAa,KAAK;AAAA,cAChB,SAAS,QAAQ,eAAe,QAAQ;AAAA,cACxC,UAAU,uBAAuB,CAAC;AAAA,cAClC,WAAW,uBAAuB,CAAC;AAAA,cACnC,WAAW;AAAA,cACX;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,gBAAgB,QAAQ,kBAAkB;AAAA,cAC1C,aAAY,iEAAwB,eAAc,QAAQ,cAAc;AAAA,cACxE,cAAa,iEAAwB,gBAAe,QAAQ;AAAA,cAC5D,YAAY,QAAQ,cAAc,QAAQ,WAAW;AAAA,cACrD,WAAW,QAAQ,eAAe,QAAQ;AAAA,cAC1C,cAAc;AAAA;AAAA,cAEd,oBAAoB;AAAA,cACpB,UAAU,QAAQ;AAAA,cAClB,QAAQ,QAAQ;AAAA,cAChB,SAAQ,iEAAwB,WAAU,CAAE;AAAA,cAC5C,oBAAmB,iEAAwB,eAAc,CAAE;AAAA,cAC3D,WAAW,iEAAwB;AAAA,cACnC,UAAU,iEAAwB;AAAA,YAChD,CAAa;AACD,oBAAQ,IAAI,8BAA8B,QAAQ,WAAW,aAAa;AAAA,UACtF,OAAiB;AACL,oBAAQ,IAAI,0CAA0C,QAAQ,WAAW,EAAE;AAAA,UACvF;AAAA,QACA,OAAe;AACL,kBAAQ,IAAI,iBAAiB,QAAQ,eAAe,QAAQ,YAAY,2DAA2D,QAAQ,QAAQ,GAAG;AAAA,QAChK;AAAA,MAEA,OAAa;AACL,gBAAQ,IAAI,aAAa,KAAK,KAAK,QAAQ,eAAe,QAAQ,YAAY,sDAAsD;AAAA,MAC5I;AAAA,IACA,CAAK;AAGD,UAAM,uBAAuB,KAAK,6BAA6B,aAAa;AAE5E,YAAQ,IAAI,YAAY,cAAc,MAAM,oCAAoC,qBAAqB,MAAM,mBAAmB;AAE9H,QAAI,qBAAqB,WAAW,GAAG;AACrC,cAAQ,IAAI,yDAAyD;AACrE;AACA,WAAK,eAAgB;AACrB;AAAA,IACN;AAEI,YAAQ,IAAI,sCAAsC,qBAAqB,QAAQ,uBAAuB;AAGtG,UAAM,oBAAoB,qBAAqB,IAAI,aAAW,KAAK,kBAAkB,SAAS,WAAW,CAAC,EAAE,OAAO,OAAK,MAAM,IAAI;AAClI,UAAM,gBAAgB,qBAAqB,IAAI,aAAW,KAAK,kBAAkB,SAAS,OAAO,CAAC,EAAE,OAAO,OAAK,MAAM,IAAI;AAC1H,UAAM,iBAAiB,qBAAqB,IAAI,aAAW,KAAK,kBAAkB,SAAS,QAAQ,CAAC,EAAE,OAAO,OAAK,MAAM,IAAI;AAC5H,UAAM,gBAAgB,qBAAqB,IAAI,aAAW,KAAK,kBAAkB,SAAS,OAAO,CAAC,EAAE,OAAO,OAAK,MAAM,IAAI;AAC1H,UAAM,oBAAoB,qBAAqB,IAAI,aAAW,KAAK,kBAAkB,SAAS,WAAW,CAAC,EAAE,OAAO,OAAK,MAAM,IAAI;AAElI,QAAI,cAAc,WAAW,GAAG;AAC9B,cAAQ,IAAI,mCAAmC;AAC/C;AACA;AAAA,IACN;AAEI,YAAQ,IAAI,cAAc,cAAc,MAAM,uBAAuB;AAGrE,SAAK,kBAAkB,eAAe;AAGtC,SAAK,IAAI,UAAU,KAAK,WAAW,cAAc;AAAA,MAC/C,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU;AAAA,MAClB;AAAA,IACA,CAAK;AAED,SAAK,IAAI,UAAU,KAAK,UAAU;AAAA,MAChC,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU;AAAA,MAClB;AAAA,IACA,CAAK;AAED,SAAK,IAAI,UAAU,KAAK,WAAW,WAAW;AAAA,MAC5C,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU;AAAA,MAClB;AAAA,IACA,CAAK;AAED,SAAK,IAAI,UAAU,KAAK,WAAW,UAAU;AAAA,MAC3C,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU;AAAA,MAClB;AAAA,IACA,CAAK;AAED,SAAK,IAAI,UAAU,KAAK,WAAW,cAAc;AAAA,MAC/C,MAAM;AAAA,MACN,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU;AAAA,MAClB;AAAA,IACA,CAAK;AAGD,UAAM,oBAAoB,cAAc,KAAK,OAAK,EAAE,SAAS,SAAS,SAAS;AAC/E,UAAM,mBAAmB,cAAc,KAAK,OAAK,EAAE,SAAS,SAAS,OAAO;AAE5E,YAAQ,IAAI,8CAA8C,EAAE,mBAAmB,iBAAgB,CAAE;AAIjG,QAAI,cAAc,KAAK,oBAAqB;AAE5C,QAAI,mBAAmB;AAIrB,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,KAAK,UAAU;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK,WAAW;AAAA,QACxB,QAAQ,CAAC,MAAM,SAAS,SAAS;AAAA,QACjC,OAAO;AAAA,UACL,cAAc,CAAC,OAAO,OAAO;AAAA,UAC7B,cAAc;AAAA,UACd,gBAAgB;AAAA;AAAA,QACjB;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,KAAK,UAAU;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK;AAAA,QACb,QAAQ,CAAC,MAAM,SAAS,SAAS;AAAA,QACjC,OAAO;AAAA,UACL,cAAc,CAAC,OAAO,OAAO;AAAA,UAC7B,cAAc;AAAA,UACd,gBAAgB;AAAA;AAAA,QACjB;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,KAAK,UAAU;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK,WAAW;AAAA,QACxB,OAAO;AAAA,UACL,cAAc,CAAC,OAAO,OAAO;AAAA,UAC7B,cAAc;AAAA,UACd,gBAAgB;AAAA,QACjB;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,KAAK,UAAU;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK,WAAW;AAAA,QACxB,OAAO;AAAA,UACL,cAAc,CAAC,OAAO,OAAO;AAAA,UAC7B,cAAc;AAAA,UACd,gBAAgB;AAAA,QACjB;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,KAAK,UAAU;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK,WAAW;AAAA,QACxB,OAAO;AAAA,UACL,cAAc,CAAC,OAAO,OAAO;AAAA,UAC7B,cAAc;AAAA,UACd,gBAAgB;AAAA;AAAA,QACjB;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAEd,cAAQ,IAAI,qDAAqD;AAGjE,cAAQ,IAAI,kGAAkG;AAAA,IACpH;AAEI,QAAI,kBAAkB;AAEpB,YAAM,eAAe,KAAK,UAAU;AAGpC,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,eAAe;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK;AAAA,QACb,QAAQ,CAAC,MAAM,SAAS,OAAO;AAAA,QAC/B,OAAO;AAAA,UACL,gBAAgB;AAAA,UAChB,iBAAiB,CAAC,QAAQ,CAAC,OAAO,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,QAAQ,GAAG,EAAE,GAAG,EAAE;AAAA,UAC7E,uBAAuB,CAAC,OAAO,OAAO;AAAA,UACtC,uBAAuB;AAAA,UACvB,yBAAyB;AAAA,QAC1B;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,eAAe;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK;AAAA,QACb,QAAQ,CAAC,MAAM,SAAS,OAAO;AAAA,QAC/B,OAAO;AAAA,UACL,gBAAgB;AAAA,UAChB,iBAAiB,CAAC,QAAQ,CAAC,OAAO,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,QAAQ,GAAG,GAAG,GAAG,EAAE;AAAA,UAC9E,uBAAuB,CAAC,OAAO,OAAO;AAAA,UACtC,uBAAuB;AAAA,UACvB,yBAAyB;AAAA,QAC1B;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAGd,WAAK,IAAI,SAAS;AAAA,QAChB,IAAI,eAAe;AAAA,QACnB,MAAM;AAAA,QACN,QAAQ,KAAK;AAAA,QACb,QAAQ,CAAC,MAAM,SAAS,OAAO;AAAA,QAC/B,OAAO;AAAA,UACL,gBAAgB;AAAA,UAChB,iBAAiB,CAAC,QAAQ,CAAC,OAAO,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,QAAQ,GAAG,GAAG,GAAG,EAAE;AAAA,UAC9E,uBAAuB,CAAC,OAAO,OAAO;AAAA,UACtC,uBAAuB;AAAA,UACvB,yBAAyB;AAAA;AAAA,QAC1B;AAAA,QACD,QAAQ;AAAA,UACN,cAAc;AAAA,QACxB;AAAA,MACO,GAAE,WAAW;AAEd,cAAQ,IAAI,8DAA8D;AAG1E,cAAQ,IAAI,kGAAkG;AAAA,IACpH;AAEI,SAAK,YAAY;AACjB,YAAQ,IAAI,8BAA8B,cAAc,QAAQ,iBAAiB;AAGjF,QAAI,aAAa,SAAS,KAAK,OAAO,yBAAyB,OAAO,sBAAsB,kBAAkB;AAC5G,cAAQ;AAAA,QAAI,wBAAwB,aAAa,MAAM;AAAA,QACrD,aAAa,IAAI,OAAK,GAAG,EAAE,OAAO,IAAI,EAAE,YAAY,GAAG;AAAA,MAAC;AAE1D,UAAI;AAEF,eAAO,sBAAsB,iBAAiB,YAAY;AAC1D,gBAAQ,IAAI,sCAAsC,aAAa,MAAM,cAAc;AAGnF,cAAM,aAAa,aAAa,OAAO,CAAC,KAAK,UAAU;AACrD,cAAI,MAAM,YAAY,KAAK,IAAI,MAAM,YAAY,KAAK,KAAK;AAC3D,iBAAO;AAAA,QACR,GAAE,EAAE;AACL,gBAAQ,IAAI,gCAAgC,UAAU;AAAA,MAEvD,SAAQ,OAAO;AACd,gBAAQ,MAAM,2CAA2C,KAAK;AAAA,MACtE;AAAA,IACA,OAAW;AACL,cAAQ,IAAI,2GAA2G;AACvH,cAAQ,IAAI,4CAA4C,CAAC,CAAC,OAAO,qBAAqB,EAAE;AACxF,cAAQ,IAAI,8CAA8C,CAAC,GAAC,YAAO,0BAAP,mBAA8B,iBAAgB,EAAE;AAAA,IAClH;AAGI,cAAW;AAGX,eAAW,MAAM;AAEf,YAAM,gBAAgB;AAAA,QACpB,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,QACf,KAAK,UAAU;AAAA,MAChB;AAED,YAAM,cAAc,cAAc,OAAO,aAAW,KAAK,IAAI,SAAS,OAAO,CAAC;AAE9E,UAAI,YAAY,SAAS,GAAG;AAC1B,gBAAQ,IAAI,0BAA0B,YAAY,MAAM,sCAAsC,WAAW;AAAA,MACjH,OAAa;AACL,gBAAQ,KAAK,6HAA6H;AAC1I,gBAAQ,IAAI,6CAA6C,cAAc,IAAI,SAAO,EAAE,IAAI,QAAQ,CAAC,CAAC,KAAK,IAAI,SAAS,EAAE,EAAG,EAAC,CAAC;AAAA,MACnI;AAAA,IACK,GAAE,GAAG;AAAA,EACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,kBAAkB,SAAS,UAAU;AAEnC,UAAM,SAAS,QAAQ;AAEvB,QAAI,CAAC,UAAU,CAAC,MAAM,QAAQ,MAAM,KAAK,OAAO,WAAW,GAAG;AAC5D,cAAQ,KAAK,sDAAsD,MAAM;AACzE,aAAO;AAAA,IACb;AAGI,UAAM,UAAU,QAAQ;AACxB,UAAM,QAAQ,KAAK,wBAAwB,OAAO;AAElD,YAAQ,IAAI,qBAAqB,QAAQ,aAAa,QAAQ,WAAW,KAAK,QAAQ,UAAU,QAAQ,MAAM,iBAAiB,QAAQ,QAAQ,YAAY,KAAK,EAAE;AAGlK,UAAM,aAAa,KAAK,gBAAgB,OAAO;AAC/C,QAAI;AACJ,YAAQ,UAAQ;AAAA,MACd,KAAK;AACH,iBAAS,aAAa;AACtB;AAAA,MACF,KAAK;AACH,iBAAS,aAAa;AACtB;AAAA,MACF,KAAK;AACH,iBAAS,aAAa;AACtB;AAAA,MACF,KAAK;AACH,iBAAS,aAAa;AACtB;AAAA,MACF,KAAK;AACH,iBAAS,aAAa;AACtB;AAAA,MACF;AACE,iBAAS;AAAA,IACjB;AAGI,QAAI,CAAC,OAAO,MAAM;AAChB,cAAQ,KAAK,2EAA2E;AACxF,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,UACR,MAAM;AAAA,UACN,aAAa;AAAA,QACd;AAAA,QACD,YAAY;AAAA,UACV,aAAa,QAAQ,eAAe;AAAA,UACpC;AAAA,UACA;AAAA,UACA,OAAO,QAAQ,SAAS;AAAA,UACxB,QAAQ,SAAS;AAAA;AAAA,UACjB;AAAA,QACV;AAAA,MACO;AAAA,IACP;AAGI,UAAM,SAAS,OAAO,KAAK,MAAM,MAAM;AACvC,UAAM,SAAS,OAAO,KAAK,OAAO,QAAQ,QAAQ,EAAE,OAAO,cAAc;AAEzE,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,OAAO;AAAA,MACjB,YAAY;AAAA,QACV,aAAa,QAAQ,eAAe;AAAA,QACpC;AAAA,QACA;AAAA,QACA,OAAO,QAAQ,SAAS;AAAA,QACxB;AAAA,MACR;AAAA,IACK;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,cAAc,UAAU;AACtB,QAAI,CAAC,SAAU,QAAO;AAEtB,YAAQ,IAAI,0CAA0C,QAAQ;AAE9D,QAAI;AACF,YAAM,QAAQ,SAAS,MAAM,GAAG;AAChC,UAAI,MAAM,WAAW,GAAG;AACtB,cAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AACtC,cAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AAEtC,gBAAQ,IAAI,4CAA4C,EAAE,KAAK,KAAK,YAAY,CAAC,MAAM,GAAG,GAAG,YAAY,CAAC,MAAM,GAAG,EAAC,CAAE;AAEtH,YAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG;AAE9B,gBAAM,SAAS,CAAC,KAAK,GAAG;AACxB,kBAAQ,IAAI,4DAA4D,MAAM;AAG9E,cAAI,OAAO,OAAO,OAAO,MAAM,OAAO,QAAQ,OAAO,KAAK;AACxD,mBAAO;AAAA,UACnB,OAAiB;AACL,oBAAQ,KAAK,wDAAwD,EAAE,KAAK,IAAG,CAAE;AACjF,mBAAO;AAAA,UACnB;AAAA,QACA;AAAA,MACA;AAAA,IACK,SAAQ,OAAO;AACd,cAAQ,MAAM,gDAAgD,UAAU,KAAK;AAAA,IACnF;AAEI,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,gBAAgB,SAAS;AAEvB,UAAM,aAAa;AAGnB,YAAQ,SAAO;AAAA,MACb,KAAK;AACH,eAAO,aAAa;AAAA,MACtB,KAAK;AACH,eAAO,aAAa;AAAA,MACtB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO,aAAa;AAAA,MACtB,KAAK;AACH,eAAO,aAAa;AAAA,MACtB;AACE,eAAO;AAAA,IACf;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,wBAAwB,SAAS;AAC/B,YAAQ,SAAO;AAAA,MACb,KAAK;AACH,eAAO;AAAA;AAAA,MACT,KAAK;AACH,eAAO;AAAA;AAAA,MACT,KAAK;AACH,eAAO;AAAA;AAAA,MACT,KAAK;AACH,eAAO;AAAA;AAAA,MACT,KAAK;AACH,eAAO;AAAA;AAAA,MACT;AACE,eAAO;AAAA,IACf;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAKE,uBAAuB;AAErB,QAAI,OAAO,kCAAkC;AAC3C,cAAQ,IAAI,+DAA+D;AAC3E,aAAO,mCAAmC;AAC1C,aAAO,yBAAyB;AAAA,IACtC;AAGI,QAAI,CAAC,KAAK,KAAK;AACb,cAAQ,KAAK,yFAAyF;AACtG;AAAA,IACN;AAEI,QAAI;AAEF,YAAM,aAAa,KAAK,UAAU;AAClC,UAAI,KAAK,IAAI,YAAY,KAAK,IAAI,SAAS,UAAU,GAAG;AACtD,aAAK,IAAI,IAAI,cAAc,UAAU;AACrC,aAAK,IAAI,IAAI,cAAc,UAAU;AACrC,gBAAQ,IAAI,0CAA0C;AAAA,MAC9D;AAGM,UAAI,KAAK,OAAO;AACd,aAAK,MAAM,OAAQ;AACnB,aAAK,QAAQ;AACb,gBAAQ,IAAI,mCAAmC;AAAA,MACvD;AAGM,YAAM,aAAa,CAAC,cAAc,UAAU,WAAW,UAAU,YAAY;AAC7E,iBAAW,QAAQ,YAAU;AAC3B,YAAI,KAAK,IAAI,SAAS,KAAK,UAAU,MAAM,GAAG;AAC5C,eAAK,IAAI,YAAY,KAAK,UAAU,MAAM;AAAA,QACpD;AAAA,MACA,CAAO;AAGD,YAAM,kBAAkB,CAAC,iBAAiB,kBAAkB,eAAe;AAC3E,sBAAgB,QAAQ,YAAU;AAChC,YAAI,KAAK,IAAI,SAAS,KAAK,UAAU,MAAM,GAAG;AAC5C,eAAK,IAAI,YAAY,KAAK,UAAU,MAAM;AAAA,QACpD;AAAA,MACA,CAAO;AAGD,UAAI,KAAK,IAAI,SAAS,KAAK,OAAO,GAAG;AACnC,aAAK,IAAI,YAAY,KAAK,OAAO;AAAA,MACzC;AACM,UAAI,KAAK,IAAI,SAAS,KAAK,UAAU,SAAS,GAAG;AAC/C,aAAK,IAAI,YAAY,KAAK,UAAU,SAAS;AAAA,MACrD;AAGM,UAAI,KAAK,IAAI,SAAS,KAAK,UAAU,QAAQ,GAAG;AAC9C,aAAK,IAAI,YAAY,KAAK,UAAU,QAAQ;AAAA,MACpD;AACM,UAAI,KAAK,IAAI,SAAS,KAAK,UAAU,eAAe,GAAG;AACrD,aAAK,IAAI,YAAY,KAAK,UAAU,eAAe;AAAA,MAC3D;AACM,UAAI,KAAK,IAAI,UAAU,KAAK,WAAW,QAAQ,GAAG;AAChD,aAAK,IAAI,aAAa,KAAK,WAAW,QAAQ;AAAA,MACtD;AACM,UAAI,KAAK,IAAI,UAAU,KAAK,WAAW,eAAe,GAAG;AACvD,aAAK,IAAI,aAAa,KAAK,WAAW,eAAe;AAAA,MAC7D;AAGM,UAAI,KAAK,IAAI,SAAS,KAAK,UAAU,cAAc,GAAG;AACpD,aAAK,IAAI,YAAY,KAAK,UAAU,cAAc;AAAA,MAC1D;AACM,UAAI,KAAK,IAAI,UAAU,KAAK,WAAW,cAAc,GAAG;AACtD,aAAK,IAAI,aAAa,KAAK,WAAW,cAAc;AAAA,MAC5D;AAGM,YAAM,UAAU,CAAC,cAAc,IAAI,WAAW,UAAU,YAAY;AACpE,cAAQ,QAAQ,YAAU;AACxB,YAAI,KAAK,IAAI,UAAU,KAAK,WAAW,MAAM,GAAG;AAC9C,eAAK,IAAI,aAAa,KAAK,WAAW,MAAM;AAAA,QACtD;AAAA,MACA,CAAO;AAAA,IACF,SAAQ,OAAO;AACd,cAAQ,MAAM,wDAAwD,KAAK;AAAA,IACjF;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAKE,SAAS;AACP,SAAK,YAAY,CAAC,KAAK;AACvB,UAAM,aAAa,KAAK,YAAY,YAAY;AAEhD,QAAI,KAAK,IAAI,SAAS,KAAK,OAAO,GAAG;AACnC,WAAK,IAAI,kBAAkB,KAAK,SAAS,cAAc,UAAU;AAAA,IACvE;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EAKE,iBAAiB;AACf,YAAQ,IAAI,wDAAwD;AACpE,YAAQ,IAAI,mCAAmC;AAAA,MAC7C,QAAQ,CAAC,CAAC,KAAK;AAAA,MACf,WAAW,KAAK,MAAO,KAAK,IAAI,SAAS,KAAK,IAAI,OAAQ,IAAG,gBAAiB;AAAA,MAC9E,UAAU,KAAK,MAAM,KAAK,IAAI,SAAQ,IAAK;AAAA,IACjD,CAAK;AAID,UAAM,eAAe;AAAA,MACnB;AAAA,QACE,UAAU;AAAA;AAAA,QACV,aAAa;AAAA,QACb,UAAU;AAAA;AAAA,QACV,OAAO;AAAA,MACR;AAAA,MACD;AAAA,QACE,UAAU;AAAA;AAAA,QACV,aAAa;AAAA,QACb,UAAU;AAAA;AAAA,QACV,OAAO;AAAA,MACR;AAAA,MACD;AAAA,QACE,UAAU;AAAA;AAAA,QACV,aAAa;AAAA,QACb,UAAU;AAAA;AAAA,QACV,OAAO;AAAA,MACR;AAAA,MACD;AAAA,QACE,UAAU;AAAA;AAAA,QACV,aAAa;AAAA,QACb,UAAU;AAAA;AAAA,QACV,OAAO;AAAA,MACf;AAAA,IACK;AAED,YAAQ,IAAI,+CAA+C,YAAY;AACvE,SAAK,kBAAkB,YAAY;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,kBAAkB,eAAe;AAC/B,YAAQ,IAAI,4DAA4D;AAGxE,QAAI,CAAC,KAAK,KAAK;AACb,cAAQ,KAAK,sFAAsF;AACnG;AAAA,IACN;AAGI,UAAM,sBAAsB,OAAO;AACnC,QAAI,oBAAoB;AAExB,QAAI,uBAAuB,oBAAoB,YAAY;AAEzD,UAAI,OAAO,oBAAoB,eAAe,UAAU;AACtD,cAAM,QAAQ,oBAAoB,WAAW,MAAM,GAAG;AACtD,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AACtC,gBAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AACtC,8BAAoB,CAAC,KAAK,GAAG;AAC7B,kBAAQ,IAAI,0DAA0D,iBAAiB;AAAA,QACjG;AAAA,MACO,WAAU,MAAM,QAAQ,oBAAoB,UAAU,GAAG;AACxD,4BAAoB,oBAAoB;AACxC,gBAAQ,IAAI,gEAAgE,iBAAiB;AAAA,MACrG;AAAA,IACA;AAEI,QAAI,CAAC,mBAAmB;AACtB,cAAQ,KAAK,kGAAkG;AAC/G,cAAQ,KAAK,uCAAuC,mBAAmB;AAAA,IAC7E;AAGI,UAAM,eAAe,CAAE;AAEvB,kBAAc,QAAQ,aAAW;AAC/B,UAAI,QAAQ,qBAAqB,QAAQ,kBAAkB,eACvD,QAAQ,kBAAkB,YAAY,UAAU,GAAG;AAGrD,cAAM,aAAa,qBAAqB,QAAQ,kBAAkB,YAAY,CAAC;AAC/E,cAAM,cAAc,QAAQ,kBAAkB,YAAY,CAAC;AAE3D,gBAAQ,IAAI,sCAAsC,KAAK,UAAU,UAAU,CAAC,OAAO,QAAQ,WAAW,IAAI,KAAK,UAAU,WAAW,CAAC,EAAE;AACvI,gBAAQ,IAAI,0BAA0B,oBAAoB,0BAA0B,4BAA4B,EAAE;AAClH,gBAAQ,IAAI,6CAA6C,QAAQ,WAAW,KAAK,KAAK,UAAU,QAAQ,kBAAkB,aAAa,MAAM,CAAC,CAAC;AAG/I,cAAM,sBAAsB,CAAC,YAAY,WAAW;AAEpD,cAAM,cAAc;AAAA,UAClB,MAAM;AAAA,UACN,UAAU;AAAA,YACR,MAAM;AAAA,YACN,aAAa;AAAA,UACd;AAAA,UACD,YAAY;AAAA,YACV,MAAM;AAAA,YACN,aAAa,QAAQ;AAAA,YACrB,SAAS,QAAQ;AAAA,YACjB,OAAO,QAAQ,SAAS;AAAA,UACpC;AAAA,QACS;AAED,qBAAa,KAAK,WAAW;AAAA,MACrC;AAAA,IACA,CAAK;AAED,QAAI,aAAa,SAAS,GAAG;AAE3B,YAAM,gBAAgB,KAAK,WAAW;AACtC,YAAM,eAAe,KAAK,UAAU;AAEpC,UAAI;AAEF,YAAI,KAAK,IAAI,YAAY,KAAK,IAAI,SAAS,YAAY,GAAG;AACxD,eAAK,IAAI,YAAY,YAAY;AAAA,QAC3C;AACQ,YAAI,KAAK,IAAI,aAAa,KAAK,IAAI,UAAU,aAAa,GAAG;AAC3D,eAAK,IAAI,aAAa,aAAa;AAAA,QAC7C;AAGQ,aAAK,IAAI,UAAU,eAAe;AAAA,UAChC,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,UAAU;AAAA,UACtB;AAAA,QACA,CAAS;AAGD,aAAK,IAAI,UAAU,gBAAgB,WAAW;AAAA,UAC5C,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,UAAU,KAAK,0BAA0B,aAAa;AAAA,UAClE;AAAA,QACA,CAAS;AAED,aAAK,IAAI,SAAS;AAAA,UAChB,IAAI,eAAe;AAAA,UACnB,MAAM;AAAA,UACN,QAAQ,gBAAgB;AAAA,UACxB,OAAO;AAAA,YACL,cAAc;AAAA;AAAA,YACd,cAAc;AAAA;AAAA,YACd,aAAa;AAAA;AAAA;AAAA,UAEd;AAAA,UACD,QAAQ;AAAA,YACN,cAAc;AAAA,UAC1B;AAAA,QACA,CAAS;AAGD,aAAK,IAAI,SAAS;AAAA,UAChB,IAAI;AAAA,UACJ,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,OAAO;AAAA,YACL,cAAc;AAAA;AAAA,YACd,cAAc;AAAA;AAAA,YACd,kBAAkB,CAAC,GAAG,CAAC;AAAA;AAAA,UACxB;AAAA,UACD,QAAQ;AAAA,YACN,cAAc;AAAA,UAC1B;AAAA,QACA,CAAS;AAED,gBAAQ,IAAI,YAAY,aAAa,QAAQ,uCAAuC;AAAA,MACrF,SAAQ,OAAO;AACd,gBAAQ,MAAM,oCAAoC,KAAK;AAAA,MAC/D;AAAA,IACA,OAAW;AACL,cAAQ,IAAI,gDAAgD;AAAA,IAClE;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBE,6BAA6B,UAAU;AACrC,UAAM,cAAc,oBAAI,IAAK;AAE7B,aAAS,QAAQ,aAAW;AAC1B,UAAI,CAAC,QAAQ,qBAAsB;AAGnC,YAAM,CAAC,KAAK,GAAG,IAAI,QAAQ;AAC3B,YAAM,cAAc,GAAG,KAAK,MAAM,MAAM,GAAK,CAAC,IAAI,KAAK,MAAM,MAAM,GAAK,CAAC;AAGzE,YAAM,WAAW,YAAY,IAAI,WAAW;AAE5C,UAAI,CAAC,YAAY,KAAK,kBAAkB,OAAO,IAAI,KAAK,kBAAkB,QAAQ,GAAG;AACnF,cAAM,QAAQ,KAAK,wBAAwB,QAAQ,QAAQ;AAC3D,oBAAY,IAAI,aAAa,OAAO;AACpC,gBAAQ,IAAI,2BAA2B,QAAQ,WAAW,KAAK,QAAQ,UAAU,QAAQ,WAAW,iBAAiB,QAAQ,QAAQ,YAAY,KAAK,EAAE;AAAA,MAChK,OAAa;AACL,cAAM,gBAAgB,KAAK,wBAAwB,SAAS,QAAQ;AACpE,cAAM,eAAe,KAAK,wBAAwB,QAAQ,QAAQ;AAClE,gBAAQ,IAAI,4BAA4B,QAAQ,WAAW,KAAK,QAAQ,UAAU,aAAa,QAAQ,QAAQ,UAAU,YAAY,mBAAmB,SAAS,WAAW,KAAK,SAAS,UAAU,aAAa,SAAS,QAAQ,UAAU,aAAa,EAAE;AAAA,MACnQ;AAAA,IACA,CAAK;AAED,WAAO,MAAM,KAAK,YAAY,OAAM,CAAE;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,kBAAkB,SAAS;AAEzB,QAAI,eAAe;AAEnB,YAAQ,QAAQ,YAAU;AAAA,MACxB,KAAK;AACH,uBAAe;AACf;AAAA,MACF,KAAK;AACH,uBAAe;AACf;AAAA,MACF;AACE,uBAAe;AAAA,IACvB;AAII,UAAM,kBAAkB,QAAQ,WAAY,KAAK,QAAQ,WAAY;AAErE,WAAO,eAAe;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,sBAAsB;AA91CxB;AA+1CI,QAAI,CAAC,KAAK,IAAK,QAAO;AAGtB,UAAM,qBAAqB;AAAA,MACzB;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,MACA;AAAA;AAAA,IACD;AAGD,UAAM,cAAY,UAAK,IAAI,SAAU,MAAnB,mBAAqB,WAAU,CAAE;AAGnD,eAAW,WAAW,oBAAoB;AACxC,YAAM,gBAAgB,UAAU;AAAA,QAAK,WACnC,MAAM,GAAG,YAAW,EAAG,SAAS,QAAQ,YAAa,CAAA;AAAA,MACtD;AAED,UAAI,eAAe;AACjB,gBAAQ,IAAI,uDAAuD,cAAc,EAAE,EAAE;AACrF,eAAO,cAAc;AAAA,MAC7B;AAAA,IACA;AAEI,YAAQ,IAAI,wDAAwD;AACpE,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,+BAA+B,SAAS;AAx4C1C;AA04CI,YAAQ,IAAI,6CAA6C,OAAO,KAAK;AACrE,YAAQ,IAAI,uCAAuC,OAAO,KAAK,MAAM,EAAE,OAAO,OAAK,EAAE,SAAS,UAAU,KAAK,EAAE,SAAS,OAAO,CAAC,CAAC;AAGjI,QAAI,OAAO,iBAAiB;AAC1B,UAAI;AAEF,cAAM,YAAY,OAAO,gBAAgB,eACxB,kBAAO,iBAAgB,iBAAvB,gCACA,OAAO,gBAAgB;AAExC,gBAAQ,IAAI,wCAAwC,SAAS;AAE7D,YAAI,aAAa,MAAM,QAAQ,SAAS,GAAG;AACzC,gBAAM,mBAAmB,UAAU;AAAA,YAAK,QACtC,GAAG,SAAS,WACZ,GAAG,OAAO,WACV,GAAG,gBAAgB;AAAA,UACpB;AAED,cAAI,oBAAoB,iBAAiB,OAAO,iBAAiB,KAAK;AACpE,oBAAQ,IAAI,+BAA+B,OAAO,wBAAwB,CAAC,iBAAiB,KAAK,iBAAiB,GAAG,CAAC;AACtH,mBAAO,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AAAA,UAC9D;AAAA,QACA;AAGQ,cAAM,sBAAsB,OAAO,KAAK,OAAO,eAAe;AAC9D,gBAAQ,IAAI,oDAAoD,mBAAmB;AAGnF,mBAAW,OAAO,qBAAqB;AACrC,gBAAM,QAAQ,OAAO,gBAAgB,GAAG;AACxC,cAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,GAAG;AAC5C,oBAAQ,IAAI,+BAA+B,GAAG,KAAK,KAAK;AACxD,kBAAM,QAAQ,MAAM;AAAA,cAAK,SACtB,GAAG,SAAS,WAAW,GAAG,OAAO,WAAW,GAAG,gBAAgB,YAChE,GAAG,OAAO,GAAG;AAAA,YACd;AACD,gBAAI,OAAO;AACT,sBAAQ,IAAI,+BAA+B,OAAO,uBAAuB,GAAG,KAAK,CAAC,MAAM,KAAK,MAAM,GAAG,CAAC;AACvG,qBAAO,CAAC,MAAM,KAAK,MAAM,GAAG;AAAA,YAC1C;AAAA,UACA;AAAA,QACA;AAAA,MACO,SAAQ,OAAO;AACd,gBAAQ,KAAK,oCAAoC,KAAK;AAAA,MAC9D;AAAA,IACA;AAGI,QAAI,OAAO,iBAAiB;AAC1B,UAAI;AACF,cAAM,iBAAiB,OAAO,gBAAgB,eACxB,kBAAO,iBAAgB,iBAAvB,kCACA,YAAO,gBAAgB,iBAAvB,mBAAqC;AAE3D,YAAI,kBAAkB,MAAM,QAAQ,cAAc,GAAG;AACnD,gBAAM,QAAQ,eAAe;AAAA,YAAK,SAC/B,GAAG,SAAS,WAAW,GAAG,OAAO,WAAW,GAAG,gBAAgB,YAChE,GAAG,OAAO,GAAG;AAAA,UACd;AACD,cAAI,OAAO;AACT,oBAAQ,IAAI,+BAA+B,OAAO,wBAAwB,CAAC,MAAM,KAAK,MAAM,GAAG,CAAC;AAChG,mBAAO,CAAC,MAAM,KAAK,MAAM,GAAG;AAAA,UACxC;AAAA,QACA;AAAA,MACO,SAAQ,OAAO;AACd,gBAAQ,KAAK,oCAAoC,KAAK;AAAA,MAC9D;AAAA,IACA;AAEI,YAAQ,KAAK,wCAAwC,OAAO,yBAAyB;AACrF,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOE,0BAA0B,eAAe;AACvC,UAAM,iBAAiB,CAAE;AAGzB,UAAM,sBAAsB,OAAO;AACnC,QAAI,oBAAoB;AAExB,QAAI,uBAAuB,oBAAoB,YAAY;AAEzD,UAAI,OAAO,oBAAoB,eAAe,UAAU;AACtD,cAAM,QAAQ,oBAAoB,WAAW,MAAM,GAAG;AACtD,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AACtC,gBAAM,MAAM,WAAW,MAAM,CAAC,EAAE,KAAI,CAAE;AACtC,8BAAoB,CAAC,KAAK,GAAG;AAAA,QACvC;AAAA,MACO,WAAU,MAAM,QAAQ,oBAAoB,UAAU,GAAG;AACxD,4BAAoB,oBAAoB;AAAA,MAChD;AAAA,IACA;AAEI,kBAAc,QAAQ,aAAW;AAC/B,UAAI,QAAQ,qBAAqB,QAAQ,kBAAkB,eACvD,QAAQ,kBAAkB,YAAY,UAAU,GAAG;AAGrD,cAAM,aAAa,qBAAqB,QAAQ,kBAAkB,YAAY,CAAC;AAC/E,cAAM,cAAc,QAAQ,kBAAkB,YAAY,CAAC;AAG3D,cAAM,gBAAgB;AAAA,UACpB,MAAM;AAAA,UACN,UAAU;AAAA,YACR,MAAM;AAAA,YACN,aAAa,CAAC,YAAY,WAAW;AAAA;AAAA,UACtC;AAAA,UACD,YAAY;AAAA,YACV,MAAM;AAAA,YACN,aAAa,QAAQ;AAAA,UACjC;AAAA,QACS;AAED,uBAAe,KAAK,aAAa;AAAA,MACzC;AAAA,IACA,CAAK;AAED,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQE,iBAAiB,OAAO,KAAK;AAI3B,UAAM,CAAC,UAAU,QAAQ,IAAI;AAC7B,UAAM,CAAC,QAAQ,MAAM,IAAI;AAGzB,UAAM,UAAU,WAAW,UAAU;AACrC,UAAM,UAAU,WAAW,UAAU;AAGrC,UAAM,WAAW,SAAS;AAC1B,UAAM,WAAW,SAAS;AAC1B,UAAM,WAAW,KAAK,KAAK,WAAW,WAAW,WAAW,QAAQ;AAGpE,UAAM,cAAc,WAAW;AAI/B,QAAI,UAAU,CAAC,WAAW,WAAW;AACrC,QAAI,UAAU,WAAW,WAAW;AAIpC,QAAI,UAAU,GAAG;AACf,gBAAU,CAAC;AACX,gBAAU,CAAC;AAAA,IACjB;AAGI,UAAM,aAAa,SAAS;AAC5B,UAAM,aAAa,SAAS;AAG5B,UAAM,QAAQ;AACd,UAAM,cAAc,CAAE;AAEtB,aAAS,IAAI,GAAG,KAAK,OAAO,KAAK;AAC/B,YAAM,IAAI,IAAI;AACd,YAAM,KAAK,IAAI;AACf,YAAM,YAAY,IAAI;AACtB,YAAM,aAAa,YAAY;AAG/B,YAAM,MAAM,aAAa,WAAW,IAAI,YAAY,IAAI,aAAa,KAAK;AAC1E,YAAM,MAAM,aAAa,WAAW,IAAI,YAAY,IAAI,aAAa,KAAK;AAE1E,kBAAY,KAAK,CAAC,KAAK,GAAG,CAAC;AAAA,IACjC;AAEI,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,qBAAqB,iBAAiB;AACpC,SAAK,kBAAkB,eAAe;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,OAAO,wBAAwB,KAAK,iBAAiB;AACnD,QAAI,CAAC,OAAO,CAAC,mBAAmB,gBAAgB,WAAW,GAAG;AAC5D;AAAA,IACN;AAEI,YAAQ,IAAI,iFAAiF;AAG7F,QAAI,CAAC,OAAO,4BAA4B;AACtC,YAAM,sBAAsB,IAAI,oBAAoB,GAAG;AACvD,0BAAoB,kBAAkB,eAAe;AACrD,aAAO,6BAA6B;AACpC,cAAQ,IAAI,sEAAsE;AAAA,IACxF,OAAW;AAEL,aAAO,2BAA2B,kBAAkB,eAAe;AACnE,cAAQ,IAAI,uDAAuD;AAAA,IACzE;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,OAAO,yBAAyB,KAAK;AA7mDvC;AA8mDI,QAAI;AACF,cAAQ,IAAI,uEAAuE;AAGnF,UAAI,cAAc;AAClB,UAAI,aAAa;AAEjB,YAAI,YAAO,0BAAP,mBAA8B,UAAS,GAAG;AAC5C,sBAAc,OAAO;AACrB,qBAAa;AAAA,MACrB;AAEM,cAAQ,IAAI,+BAA+B,UAAU,gBAAe,2CAAa,WAAU,CAAC;AAE5F,UAAI,eAAe,YAAY,SAAS,KAAK,KAAK;AAEhD,YAAI,OAAO,4BAA4B;AACrC,cAAI;AACF,mBAAO,2BAA2B,qBAAsB;AAAA,UACzD,SAAQ,cAAc;AACrB,oBAAQ,KAAK,qCAAqC,YAAY;AAAA,UAC1E;AAAA,QACA;AAGQ,cAAM,sBAAsB,IAAI,oBAAoB,GAAG;AACvD,4BAAoB,kBAAkB,WAAW;AACjD,eAAO,6BAA6B;AACpC,gBAAQ,IAAI,oDAAoD;AAChE,eAAO;AAAA,MACf,OAAa;AACL,gBAAQ,IAAI,uDAAuD;AACnE,eAAO;AAAA,MACf;AAAA,IACK,SAAQ,OAAO;AACd,cAAQ,MAAM,iDAAiD,KAAK;AACpE,aAAO;AAAA,IACb;AAAA,EACA;AACA;AAGA,OAAO,wBAAwB,MAAM;AAxpDrC;AAypDE,OAAI,YAAO,eAAP,mBAAmB,KAAK;AAC1B,WAAO,oBAAoB,yBAAyB,OAAO,WAAW,GAAG;AAAA,EAC7E,OAAS;AACL,YAAQ,MAAM,2CAA2C;AACzD,WAAO;AAAA,EACX;AACA;AAGA,OAAO,0BAA0B,MAAM;AACrC,MAAI,OAAO,kCAAkC;AAC3C,UAAM,UAAU,KAAK,IAAK,KAAI,OAAO,0BAA0B;AAC/D,YAAQ,IAAI,4DAA4D,OAAO,KAAK;AACpF,WAAO,mCAAmC;AAC1C,WAAO,yBAAyB;AAChC,WAAO;AAAA,EACX,OAAS;AACL,YAAQ,IAAI,oCAAoC;AAChD,WAAO;AAAA,EACX;AACA;AAGA,OAAO,0BAA0B,MAAM;AACrC,MAAI,OAAO,kCAAkC;AAC3C,UAAM,UAAU,KAAK,IAAK,KAAI,OAAO,0BAA0B;AAC/D,YAAQ,IAAI,8BAA8B,OAAO,cAAc,IAAI,KAAK,OAAO,sBAAsB,EAAE,mBAAoB,CAAA,GAAG;AAC9H,WAAO,EAAE,QAAQ,MAAM,OAAO,SAAS,OAAO,OAAO,uBAAwB;AAAA,EACjF,OAAS;AACL,YAAQ,IAAI,gCAAgC;AAC5C,WAAO,EAAE,QAAQ,MAAO;AAAA,EAC5B;AACA;"}