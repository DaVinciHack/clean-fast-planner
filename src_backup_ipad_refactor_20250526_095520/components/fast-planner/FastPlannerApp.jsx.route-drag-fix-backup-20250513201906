    // Initialize the AppSettingsManager
    if (!appSettingsManagerRef.current) {
      console.log("FastPlannerApp: Creating AppSettingsManager instance");
      appSettingsManagerRef.current = new AppSettingsManager();

      // Set callbacks for settings changes
      appSettingsManagerRef.current.setCallback('onRegionChange', (regionId) => {
        console.log(`AppSettingsManager: Region changed to ${regionId}`);
        // We don't automatically change the region here to avoid infinite loops
        // The region is changed via the changeRegion function which also updates the setting
      });

      appSettingsManagerRef.current.setCallback('onAircraftChange', (aircraft) => {
        console.log(`AppSettingsManager: Aircraft changed to ${aircraft.type} ${aircraft.registration}`);
        // Update aircraft selection if it doesn't match current selection
        if (aircraft.type !== aircraftType) {
          setAircraftType(aircraft.type);
        }
        if (aircraft.registration !== aircraftRegistration) {
          setAircraftRegistration(aircraft.registration);
        }
      });

      appSettingsManagerRef.current.setCallback('onFlightSettingsChange', (settings) => {
        console.log('AppSettingsManager: Flight settings changed');
        setFlightSettings(settings);
      });

      appSettingsManagerRef.current.setCallback('onUISettingsChange', (uiSettings) => {
        console.log('AppSettingsManager: UI settings changed');
        // Update UI visibility settings
        if (leftPanelVisible !== uiSettings.leftPanelVisible) {
          setLeftPanelVisible(uiSettings.leftPanelVisible);
        }
        if (rightPanelVisible !== uiSettings.rightPanelVisible) {
          setRightPanelVisible(uiSettings.rightPanelVisible);
        }
        if (platformsVisible !== uiSettings.platformsVisible) {
          setPlatformsVisible(uiSettings.platformsVisible);
        }
      });

      // Load any saved settings
      const savedSettings = appSettingsManagerRef.current.getAllSettings();

      // Apply flight settings
      const flightSettings = savedSettings.flightSettings;
      setFlightSettings(flightSettings); // Set the entire flightSettings object from saved settings

      // Apply UI settings
      const uiSettings = savedSettings.uiSettings;
      setLeftPanelVisible(uiSettings.leftPanelVisible);
      setRightPanelVisible(uiSettings.rightPanelVisible);
      setPlatformsVisible(uiSettings.platformsVisible);
    }

    // Create the map interaction handler last, after other managers are initialized
    if (!mapInteractionHandlerRef.current &&
        mapManagerRef.current &&
        waypointManagerRef.current &&
        platformManagerRef.current) {
      console.log("FastPlannerApp: Creating MapInteractionHandler instance");
      mapInteractionHandlerRef.current = new MapInteractionHandler(
        mapManagerRef.current,
        waypointManagerRef.current,
        platformManagerRef.current
      );
      
      // üö® EMERGENCY FIX: Update global reference
      window.mapInteractionHandler = mapInteractionHandlerRef.current;

      // Set up callbacks
      mapInteractionHandlerRef.current.setCallback('onLeftPanelOpen', () => {
        if (!leftPanelVisible) {
          console.log('Opening left panel due to map click');
          setLeftPanelVisible(true);
        }
      });

      mapInteractionHandlerRef.current.setCallback('onMapClick', async (data) => {
        console.log('üó∫Ô∏è Map click callback received', data);
        // Don't return anything from this callback to avoid async issues
        try {
          // Create a local copy of the data to avoid reference issues
          const clickData = {...data};
          // Process the waypoint addition
          await addWaypoint(clickData); // addWaypoint will trigger the centralized calculation
        } catch (error) {
          console.error('Error processing map click:', error);
        }
      });

      mapInteractionHandlerRef.current.setCallback('onPlatformClick', async (data) => {
        console.log('üè¢ Platform click callback received', data);
        // Don't return anything from this callback to avoid async issues
        try {
          // Create a local copy of the data to avoid reference issues
          const clickData = {...data};
          // Process the waypoint addition
          await addWaypoint(clickData); // addWaypoint will trigger the centralized calculation
        } catch (error) {
          console.error('Error processing platform click:', error);
        }
      });

      mapInteractionHandlerRef.current.setCallback('onRouteClick', async (data) => {
        console.log('üõ£Ô∏è Route click callback received', data);

        try {
          // Create a local copy of the data
          const clickData = {...data};
          
          // Check if we're in waypoint mode
          const isWaypointMode = window.isWaypointModeActive === true;
          
          // If in waypoint mode and we have a nearest waypoint available, use that
          if (isWaypointMode && clickData.nearestWaypoint && clickData.nearestWaypoint.distance < 2) {
            console.log('üõ£Ô∏è Adding navigation waypoint at route click:', clickData.nearestWaypoint.name);
            waypointManagerRef.current.addWaypointAtIndex(
              clickData.nearestWaypoint.coordinates,
              clickData.nearestWaypoint.name,
              clickData.insertIndex,
              { isWaypoint: true, type: 'WAYPOINT' }
            );
          }
          // If not in waypoint mode and we have a nearest rig and it's close
          else if (!isWaypointMode && clickData.nearestRig && clickData.nearestRig.distance < 1) {
            // Add the rig instead of the clicked point
            console.log('üõ£Ô∏è Adding rig at route click:', clickData.nearestRig.name);
            waypointManagerRef.current.addWaypointAtIndex(
              clickData.nearestRig.coordinates,
              clickData.nearestRig.name,
              clickData.insertIndex,
              { isWaypoint: isWaypointMode, type: isWaypointMode ? 'WAYPOINT' : 'STOP' }
            );
          } else {
            // Add the clicked point
            console.log(`üõ£Ô∏è Adding ${isWaypointMode ? 'waypoint' : 'stop'} at route click`);
            waypointManagerRef.current.addWaypointAtIndex(
              [clickData.lngLat.lng, clickData.lngLat.lat],
              null,
              clickData.insertIndex,
              { isWaypoint: isWaypointMode, type: isWaypointMode ? 'WAYPOINT' : 'STOP' }
            );
          }

          // Get updated waypoints
          const updatedWaypoints = waypointManagerRef.current.getWaypoints();

          // Update the state - wait for it to complete
          await new Promise(resolve => {
            setWaypoints([...updatedWaypoints]); // Updating waypoints state will trigger the centralized useEffect
            setTimeout(resolve, 0);
          });

          // The centralized useEffect will handle recalculation
          console.log('üõ£Ô∏è Waypoints updated. Centralized useEffect will recalculate fuel.');

        } catch (error) {
          console.error('Error processing route click:', error);
        }
      });

      mapInteractionHandlerRef.current.setCallback('onError', (error) => {
        console.error(`MapInteractionHandler error: ${error}`);
      });

      // We'll initialize it in the handleMapReady function when the map is ready
    }

    // ADD EVENT LISTENER FOR SAVING AIRCRAFT SETTINGS
    // This handles the custom event from the SettingsCard to save aircraft-specific settings
    const handleSaveAircraftSettings = (event) => {
      const { key, settings } = event.detail;
      console.log(`Saving settings for ${key}:`, settings);

      try {
        // Save the settings to localStorage
        localStorage.setItem(`fastPlanner_settings_${key}`, JSON.stringify(settings));
        console.log(`Successfully saved settings for ${key}`);

        // If this is also the current aircraft, update the active settings
        if (selectedAircraft && key === `aircraft_${selectedAircraft.registration}`) {
          console.log('Updating current flight settings with saved aircraft settings');

          // Update the flightSettings state with saved settings
          setFlightSettings(prev => ({
            ...prev,
            passengerWeight: settings.passengerWeight ?? prev.passengerWeight,
            contingencyFuelPercent: settings.contingencyFuelPercent ?? prev.contingencyFuelPercent,
            taxiFuel: settings.taxiFuel ?? prev.taxiFuel,
            reserveFuel: settings.reserveFuel ?? prev.reserveFuel,
            deckTimePerStop: settings.deckTimePerStop ?? prev.deckTimePerStop,
            deckFuelFlow: settings.deckFuelFlow ?? prev.deckFuelFlow,
            cargoWeight: settings.cargoWeight ?? prev.cargoWeight,
          }));

          // Update AppSettingsManager if it exists
          if (appSettingsManagerRef.current) {
            appSettingsManagerRef.current.updateFlightSettings(settings);
          }
        }
      } catch (error) {
        console.error(`Error saving settings for ${key}:`, error);
      }
    };

    // Add event listener for settings-changed to force UI update
    // This listener might become redundant if all settings changes go through updateFlightSetting
    // and the centralized useEffect handles UI updates. Review if this is still needed.
    const handleSettingsChanged = () => {
      console.log("Settings changed event received. Centralized useEffect should handle updates.");
      // The centralized useEffect hook should now handle the recalculation and UI update
      // based on changes to flightSettings state.
    };

    // Add event listener for aircraft settings
    window.addEventListener('save-aircraft-settings', handleSaveAircraftSettings);
    window.addEventListener('settings-changed', handleSettingsChanged);

    // Force a rerender after initializing all managers
    setForceUpdate(prev => prev + 1);

    // Clean up event listener on unmount
    return () => {
      window.removeEventListener('save-aircraft-settings', handleSaveAircraftSettings);
      window.removeEventListener('settings-changed', handleSettingsChanged);
    };
  }, [selectedAircraft, waypointManagerRef, routeCalculatorRef, weather, flightSettings]); // Added flightSettings to dependencies

  // Map initialization handler
  const handleMapReady = (mapInstance) => {
    console.log("üó∫Ô∏è Map is ready", mapInstance);

    // When map is ready, initialize other components that depend on the map
    if (regionManagerRef.current) {
      console.log("üó∫Ô∏è Initializing regions...");
      setRegionLoading(true);

      // Get available regions
      setRegions(regionManagerRef.current.getRegions());

      // Get the initial region from settings if available
      const initialRegion = appSettingsManagerRef.current ?
        appSettingsManagerRef.current.getRegion() : 'gulf-of-mexico';

      console.log(`üó∫Ô∏è Initializing with region: ${initialRegion}`);
      regionManagerRef.current.initialize(initialRegion);
    }

    // Initialize the map interaction handler
    if (mapInteractionHandlerRef.current) {
      console.log("üó∫Ô∏è Initializing map interaction handler...");

      // Make sure the waypointManager is properly connected
      if (waypointManagerRef.current) {
        // Set up the waypoint manager's callbacks
        waypointManagerRef.current.setCallback('onChange', (updatedWaypoints) => {
          console.log(`üó∫Ô∏è Waypoints changed, now ${updatedWaypoints.length} waypoints`);

          // Update the waypoints state
          setWaypoints([...updatedWaypoints]); // Updating waypoints state will trigger the centralized useEffect
        });

        waypointManagerRef.current.setCallback('onRouteUpdated', (routeData) => {
          console.log(`üó∫Ô∏è Route updated with ${routeData.waypoints.length} waypoints`);
        });
      }

      // CRITICAL FIX: Force re-initialization of map handler to apply our fixes
      console.log("üö® CRITICAL FIX: Force re-initializing map interaction handler");
      
      // First, make sure global flags are properly set
      window.isWaypointModeActive = waypointModeActive;
      
      // Then, add a small delay to ensure the map is fully loaded
      setTimeout(() => {
        // Initialize map interactions - our fixed version will run
        const initSuccess = mapInteractionHandlerRef.current.initialize();
        
        if (!initSuccess) {
          console.error("Failed to initialize map interaction handler");
          
          // Try again after a longer delay
          setTimeout(() => {
            console.log("üö® CRITICAL FIX: Second attempt at initializing map handler");
            mapInteractionHandlerRef.current.initialize();
          }, 1000);
        } else {
          console.log("Map interaction handler initialized successfully");
        }
      }, 500);
    }
  };

  // Panel visibility handlers
  const toggleLeftPanel = () => {
    const newState = !leftPanelVisible;
    setLeftPanelVisible(newState);

    // Save to settings
    if (appSettingsManagerRef.current) {
      appSettingsManagerRef.current.updateUISettings({
        leftPanelVisible: newState
      });
    }

    // Trigger animation by adding and removing classes
    const panel = document.querySelector('.route-editor-panel');
    if (panel) {
      if (newState) {
        // Panel becoming visible - slide in
        panel.style.animation = 'slideInFromLeft 0.4s cubic-bezier(0.22, 1, 0.36, 1) forwards';
      } else {
        // Panel becoming hidden - slide out
        panel.style.animation = 'slideOutToLeft 0.4s cubic-bezier(0.22, 1, 0.36, 1) forwards';
      }
    }
  };

  const toggleRightPanel = () => {
    const newState = !rightPanelVisible;
    setRightPanelVisible(newState);

    // Save to settings
    if (appSettingsManagerRef.current) {
      appSettingsManagerRef.current.updateUISettings({
        rightPanelVisible: newState
      });
    }

    // Trigger animation by adding and removing classes
    const panel = document.querySelector('.info-panel');
    if (panel) {
      if (newState) {
        // Panel becoming visible - slide in
        panel.style.animation = 'slideInFromRight 0.4s cubic-bezier(0.22, 1, 0.36, 1) forwards';
      } else {
        // Panel becoming hidden - slide out
        panel.style.animation = 'slideOutToRight 0.4s cubic-bezier(0.22, 1, 0.36, 1) forwards';
      }
    }
  };

  const handleRouteInputChange = (value) => {
    setRouteInput(value);
  };

  /**
   * Updates weather settings for the application
   * IMPORTANT: This function is used by both MainCard and WeatherCard components
   * to update wind speed and direction.
   *
   * @param {number} windSpeed - Wind speed in knots
   * @param {number} windDirection - Direction wind is coming FROM in degrees (0-359)
   */
  const updateWeatherSettings = (windSpeed, windDirection) => {
    console.log('üå¨Ô∏è updateWeatherSettings called with:', windSpeed, windDirection);

    // Ensure we have valid numbers
    const windSpeedNum = parseInt(windSpeed) || 0;
    // Normalize direction to 0-359 range
    const windDirectionNum = ((parseInt(windDirection) || 0) % 360 + 360) % 360;

    const newWeather = {
      windSpeed: windSpeedNum,
      windDirection: windDirectionNum
    };

    console.log(`üå¨Ô∏è Updating weather settings: Wind ${newWeather.windSpeed} kts from ${newWeather.windDirection}¬∞`);
    console.log('üå¨Ô∏è Old weather state:', weather);

    // IMPORTANT FIX: Two-step update process to ensure correct wind calculations
    
    // Step 1: Clear the route display first
    if (waypointManagerRef.current) {
      console.log('üå¨Ô∏è Step 1: Clearing route display to force redraw');
      waypointManagerRef.current.updateRoute(null);
    }
    
    // Step 2: Immediately set the new weather state
    setWeather(newWeather);
    
    // Step 3: Force an immediate UI update
    setForceUpdate(prev => prev + 1);
    
    // Step 4: Manually recalculate the route with the new wind settings
    if (waypoints && waypoints.length >= 2 && selectedAircraft) {
      console.log('üå¨Ô∏è Manually recalculating route with new wind settings...');
      
      try {
        // Verify WindCalculations is available globally
        if (!window.WindCalculations) {
          console.log('üå¨Ô∏è Making WindCalculations available globally');
          window.WindCalculations = WindCalc;
        }
        
        // First, use RouteCalculator for quick calculation with wind
        // This ensures the route lines and top card get proper wind-adjusted times
        if (routeCalculatorRef.current) {
          console.log('üå¨Ô∏è Step 4a: Calculating wind-adjusted route with RouteCalculator');
          
          // Extract coordinates from waypoints
          const coordinates = waypoints.map(wp => wp.coords);
          
          // Calculate route stats with wind effects
          const basicRouteStats = routeCalculatorRef.current.calculateRouteStats(
            coordinates, 
            {
              selectedAircraft: selectedAircraft, 
              weather: newWeather,
              forceTimeCalculation: true // Force time calculation flag
            }
          );
          
          console.log('üå¨Ô∏è RouteCalculator wind-adjusted results:', {
            timeHours: basicRouteStats?.timeHours,
            estimatedTime: basicRouteStats?.estimatedTime,
            windAdjusted: basicRouteStats?.windAdjusted || false,
            avgHeadwind: basicRouteStats?.windData?.avgHeadwind
          });
          
          // Ensure this calculated data is available globally
          window.currentRouteStats = basicRouteStats;
          
          // Update route display immediately with the basic wind-adjusted stats
          if (waypointManagerRef.current) {
            waypointManagerRef.current.updateRoute(basicRouteStats);
          }
        }
        
        // Step 5: Run comprehensive calculation for stop cards and full stats
        console.log('üå¨Ô∏è Step 5: Running comprehensive calculation with wind effects');
        
        // Prepare numeric settings for calculation
        const numericSettings = {
          passengerWeight: Number(flightSettings.passengerWeight),
          taxiFuel: Number(flightSettings.taxiFuel),
          contingencyFuelPercent: Number(flightSettings.contingencyFuelPercent),
          reserveFuel: Number(flightSettings.reserveFuel),
          deckTimePerStop: Number(flightSettings.deckTimePerStop),
          deckFuelFlow: Number(flightSettings.deckFuelFlow),
          cargoWeight: Number(flightSettings.cargoWeight || 0)
        };
        
        console.log('üå¨Ô∏è Using numeric settings for comprehensive calculation:', numericSettings);
        
        // Calculate with the new wind settings - use imported module directly
        const { enhancedResults, stopCards: newStopCards } = ComprehensiveFuelCalculator.calculateAllFuelData(
          waypoints,
          selectedAircraft,
          numericSettings,
          newWeather
        );

        if (enhancedResults) {
          console.log('üå¨Ô∏è Comprehensive calculation complete with wind settings:', newWeather);
          
          // CRITICAL: Ensure wind data is properly set in all necessary places
          enhancedResults.windAdjusted = true;
          
          // Set wind data in the main object
          enhancedResults.windData = {
            windSpeed: newWeather.windSpeed,
            windDirection: newWeather.windDirection,
            avgHeadwind: enhancedResults.windData?.avgHeadwind || 0
          };
          
          // Also ensure each leg has proper wind data
          if (enhancedResults.legs && enhancedResults.legs.length > 0) {
            enhancedResults.legs.forEach((leg, index) => {
              // Calculate headwind for each leg if missing
              if (leg.headwind === undefined) {
                // If WindCalculations is available, try to calculate headwind
                if (window.WindCalculations && leg.course !== undefined) {
                  leg.headwind = window.WindCalculations.calculateHeadwindComponent(
                    newWeather.windSpeed, 
                    leg.course, 
                    newWeather.windDirection
                  );
                  console.log(`üå¨Ô∏è Added headwind data to leg ${index+1}: ${leg.headwind.toFixed(2)} knots`);
                }
              }
            });
          }
          
          console.log('üå¨Ô∏è Comprehensive calculation results:', {
            timeHours: enhancedResults.timeHours,
            estimatedTime: enhancedResults.estimatedTime,
            windAdjusted: enhancedResults.windAdjusted
          });
          
          // CRITICAL FIX: Transfer wind-adjusted time from enhancedResults to window.currentRouteStats
          // This ensures consistency between route display and stop cards
          if (window.currentRouteStats) {
            window.currentRouteStats.timeHours = enhancedResults.timeHours;
            window.currentRouteStats.estimatedTime = enhancedResults.estimatedTime;
            window.currentRouteStats.windAdjusted = true;
            window.currentRouteStats.windData = enhancedResults.windData;
            
            console.log('üå¨Ô∏è Synchronized enhancedResults with window.currentRouteStats');
          }
          
          // Update state with new calculations
          setRouteStats(enhancedResults);
          setStopCards(newStopCards);
          
          // Step 6: Update the route display again with the comprehensive stats
          setTimeout(() => {
            if (waypointManagerRef.current) {
              console.log('üå¨Ô∏è Step 6: Final route display update with comprehensive stats');
              waypointManagerRef.current.updateRoute(enhancedResults);
            }
          }, 100);
        }
      } catch (error) {
        console.error('üå¨Ô∏è Error in wind calculation:', error);
        
        // Fallback: Update with current stats but with updated wind data
        if (window.currentRouteStats) {
          window.currentRouteStats.windAdjusted = true;
          window.currentRouteStats.windData = {
            windSpeed: newWeather.windSpeed,
            windDirection: newWeather.windDirection,
            avgHeadwind: window.currentRouteStats.windData?.avgHeadwind || 0
          };
          
          if (waypointManagerRef.current) {
            waypointManagerRef.current.updateRoute(window.currentRouteStats);
          }
        }
      }
    } else {
      // No waypoints or aircraft, just update the weather state
      console.log('üå¨Ô∏è No waypoints or aircraft, just updating weather state');
    }
  };

  // Basic handlers
  const addWaypoint = async (waypointData) => {
    if (waypointManagerRef.current) {
      // Handle different input formats
      let coords, name, isWaypoint = false;

      console.log('üåê FastPlannerApp: Adding waypoint with data:', waypointData);

      // UPDATED LOGIC: Extract waypoint flag and coordinate formats
      if (Array.isArray(waypointData)) {
        // Direct coordinates array: [lng, lat]
        coords = waypointData;
        name = null;
      } else if (typeof waypointData === 'string') {
        // It's just a name - try to find a location with that name
        console.log(`üåê Looking for location with name: ${waypointData}`);

        if (platformManagerRef.current) {
          console.log(`üåê Searching for platform with name: ${waypointData}`);
          const platform = platformManagerRef.current.findPlatformByName(waypointData);

          if (platform) {
            console.log(`üåê Found platform: ${platform.name} at ${platform.coordinates}`);
            coords = platform.coordinates;
            name = platform.name;
          } else {
            console.log(`üåê Platform not found with name: ${waypointData}`);
            // Show error message to user
            if (window.LoadingIndicator) {
              window.LoadingIndicator.updateStatusIndicator(`Platform "${waypointData}" not found. Please check spelling or click on map.`, 'error');
            }
            // Set coords to null so we'll return early
            coords = null;
            name = waypointData;
          }
        } else {
          console.log(`üåê Platform manager not available`);
          coords = null;
          name = waypointData;
        }
      } else if (waypointData && typeof waypointData === 'object') {
        // NEW: Check if this has isWaypoint flag
        if (waypointData.isWaypoint === true) {
          console.log('üåê This is a navigation waypoint, not a regular stop');
          isWaypoint = true;
        }
        
        // Extract coordinates from various possible formats
        if (waypointData.coordinates) {
          coords = waypointData.coordinates;
        } else if (waypointData.coords) {
          coords = waypointData.coords;
        } else if (waypointData.lngLat) {
          coords = [waypointData.lngLat.lng, waypointData.lngLat.lat];
        } else if (waypointData.nearestRig && waypointData.nearestRig.distance <= 2) {
          // Check if we have a nearest rig within range
          console.log(`üåê Snapping to nearest rig: ${waypointData.nearestRig.name} (${waypointData.nearestRig.distance.toFixed(2)} nm away)`);

          // Get rig coordinates
          if (waypointData.nearestRig.coordinates) {
            coords = waypointData.nearestRig.coordinates;
          } else if (waypointData.nearestRig.coords) {
            coords = waypointData.nearestRig.coords;
          } else if (waypointData.nearestRig.lng !== undefined && waypointData.nearestRig.lat !== undefined) {
            coords = [waypointData.nearestRig.lng, waypointData.nearestRig.lat];
          } else {
            console.error('Invalid nearestRig coordinates format:', waypointData.nearestRig);
            // Use click coordinates as fallback
            if (waypointData.lngLat) {
              coords = [waypointData.lngLat.lng, waypointData.lngLat.lat];
            } else {
              return; // No valid coordinates found
            }
          }

          name = waypointData.nearestRig.name;
        } else {
          console.error('Invalid waypoint data format:', waypointData);
          return;
        }
        
        // Extract name
        if (!name && waypointData.name) {
          name = waypointData.name;
        }
      } else {
        console.error('Invalid waypoint data:', waypointData);
        return;
      }

      // If we only have a name, try to look up coordinates (this could be enhanced)
      if (!coords && name) {
        console.log(`üåê We need to search for location with name: ${name}`);
        return; // For now, just return if we don't have coordinates
      }

      // Final validation of coords
      if (!coords || !Array.isArray(coords) || coords.length !== 2) {
        console.error('Invalid coordinates format:', coords);
        // Show error message to user
        if (window.LoadingIndicator) {
          window.LoadingIndicator.updateStatusIndicator(`Invalid coordinates. Please try again.`, 'error');
        }
        return;
      }

      // Check global waypoint mode flag
      if (window.isWaypointModeActive === true) {
        console.log('üåê Waypoint mode is active - forcing waypoint flag to true');
        isWaypoint = true;
      }
      
      console.log(`üåê FastPlannerApp: Adding ${isWaypoint ? 'waypoint' : 'stop'} at [${coords}] with name "${name || 'Unnamed'}"`);
      
      // Add the waypoint with the isWaypoint flag
      waypointManagerRef.current.addWaypoint(coords, name, { 
        isWaypoint: isWaypoint, // Pass the flag to identify waypoints vs stops
        type: isWaypoint ? 'WAYPOINT' : 'STOP' // Explicitly set type
      });

      // Get the updated waypoints list
      const updatedWaypoints = waypointManagerRef.current.getWaypoints();
      console.log(`üåê Updated waypoints (${updatedWaypoints.length}):`, updatedWaypoints);

      // Update the state - wait for it to complete
      await new Promise(resolve => {
        setWaypoints([...updatedWaypoints]); // Updating waypoints state will trigger the centralized useEffect
        // Use setTimeout to ensure the state update has time to complete
        setTimeout(resolve, 0);
      });

      // The centralized useEffect will handle recalculation
      console.log('üåê Waypoints updated. Centralized useEffect will recalculate fuel.');
    }
  };

  const removeWaypoint = (waypointIdOrIndex) => {
    if (waypointManagerRef.current) {
      const waypoints = waypointManagerRef.current.getWaypoints();
      let id, index;

      // Check if we received an ID or an index
      if (typeof waypointIdOrIndex === 'string') {
        // It's an ID
        id = waypointIdOrIndex;
        index = waypoints.findIndex(wp => wp.id === id);
      } else if (typeof waypointIdOrIndex === 'number') {
        // It's an index
        index = waypointIdOrIndex;
        id = waypoints[index]?.id;
      } else {
        console.error('Invalid waypoint identifier:', waypointIdOrIndex);
        return;
      }

      console.log(`FastPlannerApp: Removing waypoint with ID ${id} at index ${index}`);

      // Only proceed if we have a valid ID and index
      if (id && index !== -1) {
        waypointManagerRef.current.removeWaypoint(id, index);

        // Get updated waypoints
        const updatedWaypoints = waypointManagerRef.current.getWaypoints();

        // Update the state
        setWaypoints([...updatedWaypoints]); // Updating waypoints state will trigger the centralized useEffect

        // The centralized useEffect will handle recalculation
        console.log('FastPlannerApp: Waypoints updated. Centralized useEffect will recalculate fuel.');
      } else {
        // Clear route stats if we don't have enough waypoints
        setRouteStats(null);
      }
    }
  };

  const updateWaypointName = (index, name) => {
    if (waypointManagerRef.current) {
      waypointManagerRef.current.updateWaypointName(index, name);
      setWaypoints([...waypointManagerRef.current.getWaypoints()]); // Updating waypoints state will trigger the centralized useEffect
    }
  };

  const clearRoute = () => {
    if (waypointManagerRef.current) {
      waypointManagerRef.current.clearRoute();
      setWaypoints([]); // Updating waypoints state will trigger the centralized useEffect
      setRouteStats(null); // Also clear routeStats explicitly
    }
  };

  const handleAddFavoriteLocation = (location) => {
    if (favoriteLocationsManagerRef.current && currentRegion) {
      console.log(`Adding favorite location to region ${currentRegion.id}:`, location);

      // First add to the manager
      favoriteLocationsManagerRef.current.addFavoriteLocation(currentRegion.id, location);

      // Then immediately update the UI with the new favorites
      // This is needed because the callback might not be triggered properly
      const updatedFavorites = favoriteLocationsManagerRef.current.getFavoriteLocationsByRegion(currentRegion.id);
      console.log(`Manually updating UI with ${updatedFavorites.length} favorites after adding:`, updatedFavorites);
      setFavoriteLocations(updatedFavorites);
    } else {
      console.error('Cannot add favorite: No favorite locations manager or current region');
    }
  };

  /**
   * Reorder waypoints via drag and drop
   * @param {string} draggedId - ID of waypoint being dragged
   * @param {string} dropTargetId - ID of waypoint being dropped onto
   */
  const reorderWaypoints = (draggedId, dropTargetId) => {
    if (waypointManagerRef.current && draggedId && dropTargetId) {
      console.log(`FastPlannerApp: Reordering from ${draggedId} to ${dropTargetId}`);
      waypointManagerRef.current.reorderWaypoints(draggedId, dropTargetId);

      // Get updated waypoints
      setWaypoints([...waypointManagerRef.current.getWaypoints()]); // Updating waypoints state will trigger the centralized useEffect
    } else {
      console.error('Cannot reorder: Missing waypoint manager or invalid IDs');
    }
  };

  const handleRemoveFavoriteLocation = (locationId) => {
    if (favoriteLocationsManagerRef.current && currentRegion) {
      console.log(`Removing favorite location with ID ${locationId} from region ${currentRegion.id}`);
      favoriteLocationsManagerRef.current.removeFavoriteLocation(currentRegion.id, locationId);
      setFavoriteLocations(favoriteLocationsManagerRef.current.getFavoriteLocationsByRegion(currentRegion.id));
    } else {
      console.error('Cannot remove favorite: No favorite locations manager or current region');
    }
  };

  const togglePlatformsVisibility = () => {
    const newState = !platformsVisible;
    setPlatformsVisible(newState);

    if (platformManagerRef.current) {
      platformManagerRef.current.toggleVisibility(newState);
    }

    // Save to settings
    if (appSettingsManagerRef.current) {
      appSettingsManagerRef.current.updateUISettings({
        platformsVisible: newState
      });
    }
  };

  /**
   * Toggle waypoint insertion mode
   * @param {boolean} active - Whether to activate waypoint mode
   */
  const toggleWaypointMode = (active) => {
    console.log(`üîÑ Toggling waypoint insertion mode: ${active ? 'ON' : 'OFF'}`);
    
    // 1. Update UI state first
    setWaypointModeActive(active);
    
    // 2. Set the global flag for other components to check
    window.isWaypointModeActive = active;
    
    // 3. Toggle platform manager's waypoint mode which handles visibility and loading
    if (platformManagerRef.current) {
      // Pass client and current region name for OSDK waypoint loading
      const regionIdentifier = currentRegion ? currentRegion.osdkRegion || currentRegion.name : null;
      console.log(`üîÑ Calling platformManager.toggleWaypointMode with: active=${active}, client=available, region=${regionIdentifier}`);
      platformManagerRef.current.toggleWaypointMode(active, client, regionIdentifier);
    } else {
      console.warn('üîÑ Platform manager not available for waypoint mode toggle');
    }
    
    // 4. Use the dedicated waypoint handler if available
    if (waypointHandlerRef.current) {
      waypointHandlerRef.current.setEnabled(active);
      console.log(`üîÑ Waypoint handler state: ${waypointHandlerRef.current.isEnabled() ? 'ENABLED' : 'DISABLED'}`);
    }
    
    // 5. If window.toggleMapMode is available (set by ModeHandler), use it
    if (typeof window.toggleMapMode === 'function') {
      console.log('üîÑ Using window.toggleMapMode for extra compatibility');
      window.toggleMapMode(active ? 'waypoint' : 'normal');
    }
    
    // 6. Show status message to user
    if (window.LoadingIndicator) {
      window.LoadingIndicator.updateStatusIndicator(
        `${active ? 'Waypoint' : 'Normal'} mode activated. Click on the map to add ${active ? 'waypoints' : 'stops'}.`,
        active ? 'success' : 'info',
        5000 // Show for 5 seconds
      );
    }
    
    // 7. Log the state of all handlers for debugging
    console.log('üîÑ Waypoint mode state summary:', {
      uiState: active,
      globalFlag: window.isWaypointModeActive,
      waypointHandlerEnabled: waypointHandlerRef.current?.isEnabled(),
      platformManagerWaypointMode: platformManagerRef.current?.waypointModeActive
    });
  };

  const loadCustomChart = () => {
    // Not implemented yet
    console.log("loadCustomChart - Not implemented");
  };

  const reloadPlatformData = () => {
    if (platformManagerRef.current && currentRegion) {
      setRigsLoading(true);
      platformManagerRef.current.loadPlatformsFromFoundry(client, currentRegion.osdkRegion)
        .then(() => {
          setPlatformsLoaded(true);
          setRigsLoading(false);
          setPlatformsVisible(true);
        })
        .catch(error => {
          console.error(`Error loading platforms: ${error}`);
          setRigsError(error.message);
          setRigsLoading(false);
        });
    }
  };

  const changeRegion = (regionId) => {
    if (regionManagerRef.current) {
      console.log(`Changing region to ${regionId}`);
      setRegionLoading(true);

      // Clear aircraft selection when changing regions
      setAircraftType('');
      setAircraftRegistration('');
      setSelectedAircraft(null);

      // Set the new region
      regionManagerRef.current.setRegion(regionId);

      // Load favorite locations for the new region
      if (favoriteLocationsManagerRef.current) {
        console.log(`Loading favorite locations for region: ${regionId}`);
        const regionFavorites = favoriteLocationsManagerRef.current.getFavoriteLocationsByRegion(regionId);
        setFavoriteLocations(regionFavorites);
      }

      // Save to settings
      if (appSettingsManagerRef.current) {
        appSettingsManagerRef.current.setRegion(regionId);
      }
    }
  };

  const changeAircraftType = (type) => {
    setAircraftType(type);
    setAircraftRegistration('');  // Clear registration when type changes
    setSelectedAircraft(null);    // Clear selected aircraft

    // Save to settings
    if (appSettingsManagerRef.current) {
      appSettingsManagerRef.current.setAircraft(type, '');
    }

    if (aircraftManagerRef.current && currentRegion) {
      setAircraftLoading(true);
      aircraftManagerRef.current.filterAircraft(currentRegion.id, type);
    }
  };

  const changeAircraftRegistration = (registration) => {
    console.log(`‚ö° Changing aircraft registration to: ${registration}`);
    setAircraftRegistration(registration);

    // Find the selected aircraft in the aircraftsByType
    let aircraft = null;
    if (aircraftsByType[aircraftType]) {
      aircraft = aircraftsByType[aircraftType].find(a => a.registration === registration);
      setSelectedAircraft(aircraft); // Updating selectedAircraft state will trigger the centralized useEffect

      // CRITICAL: Make the selected aircraft globally available for API testing
      window.currentSelectedAircraft = aircraft;

      console.log(`‚ö° Selected aircraft:`, {
        registration: aircraft?.registration,
        type: aircraft?.modelType,
        cruiseSpeed: aircraft?.cruiseSpeed,
        fuelBurn: aircraft?.fuelBurn
      });

      // Save to settings
      if (appSettingsManagerRef.current) {
        appSettingsManagerRef.current.setAircraft(aircraftType, registration);
      }

      // Load aircraft-specific settings if they exist
      if (aircraft) {
        try {
          const storageKey = `aircraft_${aircraft.registration}`;
          const savedSettingsJson = localStorage.getItem(`fastPlanner_settings_${storageKey}`);

          if (savedSettingsJson) {
            const savedSettings = JSON.parse(savedSettingsJson);
            console.log(`Found saved settings for ${aircraft.registration}:`, savedSettings);

            // Update the flightSettings state with saved settings
            setFlightSettings(prev => ({
              ...prev,
              passengerWeight: savedSettings.passengerWeight ?? prev.passengerWeight,
              contingencyFuelPercent: savedSettings.contingencyFuelPercent ?? prev.contingencyFuelPercent,
              taxiFuel: savedSettings.taxiFuel ?? prev.taxiFuel,
              reserveFuel: savedSettings.reserveFuel ?? prev.reserveFuel,
              deckTimePerStop: savedSettings.deckTimePerStop ?? prev.deckTimePerStop,
              deckFuelFlow: savedSettings.deckFuelFlow ?? prev.deckFuelFlow,
              cargoWeight: savedSettings.cargoWeight ?? prev.cargoWeight,
            }));

            // Show a message that settings were loaded
            if (window.LoadingIndicator) {
              window.LoadingIndicator.updateStatusIndicator(`Loaded saved settings for ${aircraft.registration}`);
            }
          } else {
            // If no aircraft-specific settings, try to load type-specific settings
            const typeSettingsJson = localStorage.getItem(`fastPlanner_settings_${aircraftType}`);

            if (typeSettingsJson) {
              const typeSettings = JSON.parse(typeSettingsJson);
              console.log(`Found saved settings for aircraft type ${aircraftType}:`, typeSettings);

              // Update the flightSettings state with type settings
              setFlightSettings(prev => ({
                ...prev,
                passengerWeight: typeSettings.passengerWeight ?? prev.passengerWeight,
                contingencyFuelPercent: typeSettings.contingencyFuelPercent ?? prev.contingencyFuelPercent,
                taxiFuel: typeSettings.taxiFuel ?? prev.taxiFuel,
                reserveFuel: typeSettings.reserveFuel ?? prev.reserveFuel,
                deckTimePerStop: typeSettings.deckTimePerStop ?? prev.deckTimePerStop,
                deckFuelFlow: typeSettings.deckFuelFlow ?? prev.deckFuelFlow,
                cargoWeight: typeSettings.cargoWeight ?? prev.cargoWeight,
              }));

              // Show a message that type settings were loaded
              if (window.LoadingIndicator) {
                window.LoadingIndicator.updateStatusIndicator(`Loaded ${aircraftType} type settings`);
              }
            }
          }
        } catch (error) {
          console.error(`Error loading saved settings for ${registration}:`, error);
        }
      }

      // Handle the case when an aircraft is selected (non-empty registration)
      if (registration) {
        // After selecting an aircraft, reset dropdown values for next selection
        // but maintain the actual selected aircraft in state
        setTimeout(() => {
          // Reset type dropdown value but DO NOT change state
          setAircraftType('');
          // Reset registration dropdown value but DO NOT clear selected aircraft
          setAircraftRegistration('');

          // Force a UI update to refresh the dropdown components
          setForceUpdate(prev => prev + 1);

          console.log("Reset dropdowns after aircraft selection while keeping selectedAircraft");
        }, 100);
      }
    }
  };

  // Load aircraft data when region changes
  useEffect(() => {
    if (aircraftManagerRef.current && currentRegion && client) {
      console.log(`Loading aircraft for region ${currentRegion.name}`);
      setAircraftLoading(true);

      // Check if we already have loaded aircraft
      if (aircraftList.length > 0) {
        console.log('Aircraft already loaded, just filtering by region');
        aircraftManagerRef.current.filterAircraft(currentRegion.id, aircraftType);
        setAircraftLoading(false);
      } else {
        // Load all aircraft from OSDK
        try {
          aircraftManagerRef.current.loadAircraftFromOSDK(client)
            .then(() => {
              console.log('Aircraft loaded from OSDK, filtering by region');

              // Filter aircraft for the current region
              if (currentRegion) {
                aircraftManagerRef.current.filterAircraft(currentRegion.id, aircraftType);
              }

              setAircraftLoading(false);
            })
            .catch(error => {
              console.error(`Error loading aircraft: ${error}`);
              setAircraftLoading(false);
            });
        } catch (error) {
          console.error(`Error calling loadAircraftFromOSDK: ${error}`);
          setAircraftLoading(false);
        }
      }
    }
  }, [currentRegion, client, aircraftType, aircraftList.length]);

  // Load platform data and OSDK waypoints when region changes
  useEffect(() => {
    if (platformManagerRef.current && currentRegion && client) {
      console.log(`Loading platforms for region ${currentRegion.name}`);
      setRigsLoading(true);

      try {
        // Check if the method exists
        if (typeof platformManagerRef.current.loadPlatformsFromFoundry === 'function') {
          platformManagerRef.current.loadPlatformsFromFoundry(client, currentRegion.osdkRegion)
            .then(() => {
              setPlatformsLoaded(true);
              setRigsLoading(false);
              setPlatformsVisible(true);
            })
            .catch(error => {
              console.error(`Error loading platforms: ${error}`);
              setRigsError(error?.message || 'Unknown error loading platforms');
              setRigsLoading(false);
            });
        } else {
          // Method doesn't exist, show error
          console.error('PlatformManager.loadPlatformsFromFoundry is not a function');
          setRigsError('Platform loading method not available');
          setRigsLoading(false);
        }
      } catch (error) {
        console.error(`Error calling platform loading method: ${error}`);
        setRigsError(error?.message || 'Error loading platforms');
        setRigsLoading(false);
      }

      // Also load OSDK waypoints for the current region
      if (typeof platformManagerRef.current.loadOsdkWaypointsFromFoundry === 'function') {
        let regionQueryTerm = currentRegion.osdkRegion || currentRegion.name;
        // Specifically ensure "NORWAY" is uppercase if that's the region, as OSDK might be case-sensitive
        if (regionQueryTerm && regionQueryTerm.toLowerCase() === 'norway') {
          regionQueryTerm = 'NORWAY';
        }
        console.log(`Loading OSDK waypoints for region identifier: ${regionQueryTerm}`);
        platformManagerRef.current.loadOsdkWaypointsFromFoundry(client, regionQueryTerm)
          .then(() => {
            console.log(`OSDK waypoints loaded for ${regionQueryTerm}`);
          })
          .catch(error => {
            console.error(`Error loading OSDK waypoints for ${regionQueryTerm}:`, error);
          });
      } else {
        console.error('PlatformManager.loadOsdkWaypointsFromFoundry is not a function');
      }
    }
  }, [currentRegion, client]);

  return (
    <div className="fast-planner-container">
      {/* ModeHandler is kept but our dedicated WaypointHandler is used for waypoints */}
      <ModeHandler 
        mapManagerRef={mapManagerRef}
        waypointManagerRef={waypointManagerRef}
        platformManagerRef={platformManagerRef}
        initialMode="normal"
      />

      {/* Loading Overlay - Only used for critical operations, not for aircraft loading */}
      <div id="loading-overlay" className="loading-overlay" style={{ display: 'none' }}>
        <div className="loading-spinner"></div>
        <div className="loading-message">Loading...</div>
      </div>

      {/* Route Stats Card */}
      <RouteStatsCard
        routeStats={routeStats}
        selectedAircraft={selectedAircraft}
        waypoints={waypoints}
        // Pass individual flight settings from the flightSettings state object
        deckTimePerStop={flightSettings.deckTimePerStop}
        // deckFuelPerStop={deckFuelPerStop} // This individual state is removed
        deckFuelFlow={flightSettings.deckFuelFlow}
        passengerWeight={flightSettings.passengerWeight}
        cargoWeight={flightSettings.cargoWeight}
        taxiFuel={flightSettings.taxiFuel}
        contingencyFuelPercent={flightSettings.contingencyFuelPercent}
        reserveFuel={flightSettings.reserveFuel}
        weather={weather}
        stopCards={stopCards}
      />

      {/* Map Component */}
      <MapComponent
        mapManagerRef={mapManagerRef}
        onMapReady={handleMapReady}
        className="fast-planner-map"
      />

      {/* Left Panel (Route Editor) */}
      <LeftPanel
        visible={leftPanelVisible}
        onToggleVisibility={toggleLeftPanel}
        waypoints={waypoints}
        onRemoveWaypoint={removeWaypoint}
        onWaypointNameChange={updateWaypointName}
        onAddWaypoint={addWaypoint}
        onReorderWaypoints={reorderWaypoints}
        routeInput={routeInput}
        onRouteInputChange={handleRouteInputChange}
        favoriteLocations={favoriteLocations}
        onAddFavoriteLocation={handleAddFavoriteLocation}
        onRemoveFavoriteLocation={handleRemoveFavoriteLocation}
        onClearRoute={clearRoute}
        onToggleChart={togglePlatformsVisibility}
        chartsVisible={platformsVisible}
        onToggleWaypointMode={toggleWaypointMode}
        waypointModeActive={waypointModeActive}
      />

      {/* Right Panel (Controls & Stats) */}
      <RightPanel
        visible={rightPanelVisible}
        onToggleVisibility={toggleRightPanel}
        onClearRoute={clearRoute}
        onLoadRigData={reloadPlatformData}
        onToggleChart={togglePlatformsVisibility}
        onLoadCustomChart={loadCustomChart}
        chartsVisible={platformsVisible}
        aircraftType={aircraftType}
        onAircraftTypeChange={changeAircraftType}
        aircraftRegistration={aircraftRegistration}
        onAircraftRegistrationChange={changeAircraftRegistration}
        selectedAircraft={selectedAircraft}
        aircraftsByType={aircraftsByType}
        aircraftLoading={aircraftLoading}
        routeStats={routeStats}
        waypoints={waypoints}
        onRemoveWaypoint={removeWaypoint}
        isAuthenticated={isAuthenticated}
        authUserName={userName}
        rigsLoading={rigsLoading}
        onLogin={login}
        regions={regions}
        currentRegion={currentRegion}
        onRegionChange={changeRegion}
        regionLoading={regionLoading}
        // Flight settings props - Pass values from flightSettings state
        deckTimePerStop={flightSettings.deckTimePerStop}
        // deckFuelPerStop={deckFuelPerStop} // This individual state is removed
        deckFuelFlow={flightSettings.deckFuelFlow}
        passengerWeight={flightSettings.passengerWeight}
        cargoWeight={flightSettings.cargoWeight}
        taxiFuel={flightSettings.taxiFuel}
        contingencyFuelPercent={flightSettings.contingencyFuelPercent}
        reserveFuel={flightSettings.reserveFuel}
        reserveMethod={reserveMethod} // Keep reserveMethod if used for UI only
        onDeckTimeChange={(value) => updateFlightSetting('deckTimePerStop', value)}
        // onDeckFuelChange={(value) => updateFlightSetting('deckFuelPerStop', value)} // Keep handler for now, review if needed
        onDeckFuelFlowChange={(value) => updateFlightSetting('deckFuelFlow', value)}
        onPassengerWeightChange={(value) => updateFlightSetting('passengerWeight', value)}
        onCargoWeightChange={(value) => updateFlightSetting('cargoWeight', value)}
        onTaxiFuelChange={(value) => updateFlightSetting('taxiFuel', value)}
        onContingencyFuelPercentChange={(value) => updateFlightSetting('contingencyFuelPercent', value)}
        onReserveMethodChange={(value) => updateFlightSetting('reserveMethod', value)} // Keep handler if used for UI only
        onReserveFuelChange={(value) => updateFlightSetting('reserveFuel', value)} // Add handler for reserveFuel
        forceUpdate={forceUpdate} // Keep forceUpdate if used for UI refresh
        // Additional props - Remove individual payloadWeight and reserveFuel props
        // payloadWeight={payloadWeight}
        // onPayloadWeightChange={setPayloadWeight}
        // reserveFuel={reserveFuel}
        // onReserveFuelChange={setReserveFuel}
        // Weather props
        weather={weather}
        onWeatherUpdate={updateWeatherSettings}
      />
    </div>
  );
};

export default FastPlannerApp;
