class N{constructor(o){this.map=o,this.sourceId="weather-circles-source",this.layerId="weather-circles-layer",this.isVisible=!1,this.currentWeatherSegments=[]}addWeatherCircles(o){var E;if(!o||!this.map){console.warn("WeatherCirclesLayer: Missing weatherSegments or map");return}const n=Date.now();if(window.weatherCirclesCreationInProgress){const e=Date.now()-(window.weatherCirclesLockTime||0);if(console.log(`ðŸ”„ WeatherCirclesLayer: Creation lock active for ${e}ms`),e>1e4)console.log("ðŸ”“ WeatherCirclesLayer: Clearing stale lock (older than 10s)"),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null;else{console.log("ðŸ”„ WeatherCirclesLayer: Recent lock detected, skipping duplicate request");return}}window.weatherCirclesCreationInProgress=!0,window.weatherCirclesLockTime=n,console.log(`ðŸ”’ WeatherCirclesLayer: Setting creation lock at ${n}`);const r=()=>{window.weatherCirclesCreationInProgress&&window.weatherCirclesLockTime===n&&(window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null,console.log(`ðŸ”“ WeatherCirclesLayer: Clearing creation lock (held for ${Date.now()-n}ms)`))};setTimeout(r,5e3),console.log("ðŸŸ¡ WeatherCirclesLayer: Adding",o.length,"weather circles to map"),this.currentWeatherSegments=o,this.removeWeatherCircles();const l=[],i=[],c=new Set,s=new Set;o.forEach(e=>{e.alternateGeoShape&&(e.airportIcao||e.locationName)&&c.add(e.airportIcao||e.locationName)}),console.log("ðŸ”„ DEDUP: Found alternates for locations:",Array.from(c)),o.forEach((e,L)=>{var F,v,M,m;if(console.log(`ðŸ” Segment ${L}:`,{airportIcao:e.airportIcao,locationName:e.locationName,isRig:e.isRig,alternateGeoShape:e.alternateGeoShape,ranking2:e.ranking2,hasAlternateCoords:((v=(F=e.alternateGeoShape)==null?void 0:F.coordinates)==null?void 0:v.length)>=2,hasGeoPoint:!!e.geoPoint,geoPoint:e.geoPoint}),!(e.ranking2!==void 0&&e.ranking2!==null)){console.log(`âŒ Invalid segment ${L}: no valid ranking`);return}const A=e.airportIcao||e.locationName;if(A){if(!e.isRig&&!e.alternateGeoShape&&c.has(A)){console.log(`ðŸ”„ DEDUP: Skipping destination ${A} - alternate exists for same location`);return}if(s.has(A)){console.log(`ðŸ”„ DEDUP: Skipping duplicate ${A} - already processed`);return}s.add(A)}if(e.alternateGeoShape&&e.alternateGeoShape.coordinates&&Array.isArray(e.alternateGeoShape.coordinates)&&e.alternateGeoShape.coordinates.length>=2){const d=e.ranking2,w={...e,ranking2:d,extractedCoordinates:e.alternateGeoShape.coordinates[1],circleType:"alternate"};i.push(w),console.log(`âœ… Alternate ${L}: ${e.airportIcao} at ${JSON.stringify(e.alternateGeoShape.coordinates[1])} with ranking ${d}`),console.log(`ðŸš¨ COORDINATE DEBUG: Full alternateGeoShape.coordinates for ${e.airportIcao}:`,JSON.stringify(e.alternateGeoShape.coordinates,null,2)),console.log(`ðŸŒ¬ï¸ COLLECTING: Alternate arrow data for ${e.airportIcao}`);let t=null,p=null,u=null,f="Unknown",a=null;if(e.rawMetar&&window.weatherVisualizationManager){const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),S=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);a=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),I!==null&&S!==null&&(t=I,p=S,u=C,f="METAR")}t===null&&e.windSpeed&&(t=e.windSpeed,p=e.windDirection,u=e.windGust,f="Segment"),t!==null?(l.push({rigName:e.airportIcao,latitude:e.alternateGeoShape.coordinates[1][1],longitude:e.alternateGeoShape.coordinates[1][0],isAirport:!e.isRig,windSpeed:t,windDirection:p,windGust:u,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(a==null?void 0:a.visibility)||e.visibility||10,temperature:(a==null?void 0:a.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao,locationType:"alternate",comprehensiveMetar:a,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(a==null?void 0:a.clouds)||[],weatherConditions:(a==null?void 0:a.conditions)||[],altimeter:a==null?void 0:a.altimeter,dewpoint:a==null?void 0:a.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Alternate ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for alternate ${e.airportIcao}`),console.log(`ðŸŽ¯ SKIP: Not creating separate split point arrow for ${e.airportIcao} - prevents duplicates`)}else if(e.isRig){console.log(`ðŸ›¢ï¸ Processing rig weather: ${e.airportIcao}`);let d=null;if(window.currentWaypoints&&Array.isArray(window.currentWaypoints)){const w=window.currentWaypoints.find(t=>{var p,u;return t.name===e.airportIcao||((p=t.name)==null?void 0:p.toUpperCase())===((u=e.airportIcao)==null?void 0:u.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from currentWaypoints:`,d))}if(!d&&((M=window.waypointManager)!=null&&M.getWaypoints)){const t=window.waypointManager.getWaypoints().find(p=>{var u,f;return p.name===e.airportIcao||((u=p.name)==null?void 0:u.toUpperCase())===((f=e.airportIcao)==null?void 0:f.toUpperCase())});t&&t.lng&&t.lat&&(d=[t.lng,t.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from waypointManager:`,d))}if(!d&&window.globalWaypoints&&Array.isArray(window.globalWaypoints)){const w=window.globalWaypoints.find(t=>{var p,u;return t.name===e.airportIcao||((p=t.name)==null?void 0:p.toUpperCase())===((u=e.airportIcao)==null?void 0:u.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from globalWaypoints:`,d))}if(!d&&window.debugStopCards&&Array.isArray(window.debugStopCards)){const w=window.debugStopCards.find(t=>{var p,u,f,a;return t.name===e.airportIcao||((p=t.name)==null?void 0:p.toUpperCase())===((u=e.airportIcao)==null?void 0:u.toUpperCase())||t.stop===e.airportIcao||((f=t.stop)==null?void 0:f.toUpperCase())===((a=e.airportIcao)==null?void 0:a.toUpperCase())});w&&w.coordinates&&(d=w.coordinates,console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from stopCards:`,d))}if(d){const w={...e,ranking2:e.ranking2,extractedCoordinates:d,circleType:"rig"};i.push(w),console.log(`âœ… Rig ${e.airportIcao}: Found coordinates ${JSON.stringify(d)} with ranking ${e.ranking2}`),console.log(`ðŸŒ¬ï¸ COLLECTING: Rig arrow data for ${e.airportIcao}`);let t=null,p=null,u=null,f="Unknown";console.log(`ðŸŒ¬ï¸ RIG DEBUG: Available wind fields for ${e.airportIcao}:`,{rawMetar:e.rawMetar,rawTaf:e.rawTaf,windSpeed:e.windSpeed,windDirection:e.windDirection,windGust:e.windGust,wind:e.wind,allKeys:Object.keys(e).filter(I=>I.toLowerCase().includes("wind"))});let a=null;if(e.rawMetar&&window.weatherVisualizationManager){console.log(`ðŸŒ¬ï¸ RIG METAR: Parsing METAR for ${e.airportIcao}: "${e.rawMetar}"`);const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),S=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);a=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),console.log(`ðŸŒ¬ï¸ RIG METAR: Parsed values - Speed: ${I}, Dir: ${S}, Gust: ${C}`),console.log("ðŸŒ¬ï¸ RIG METAR: Comprehensive data:",a),I!==null&&S!==null?(t=I,p=S,u=C,f="METAR",console.log(`ðŸŒ¬ï¸ RIG METAR: âœ… Successfully extracted wind from METAR for ${e.airportIcao}`)):console.log(`ðŸŒ¬ï¸ RIG METAR: âŒ METAR parsing failed for ${e.airportIcao}`)}if(t===null&&e.rawTaf&&window.weatherVisualizationManager){console.log(`ðŸŒ¬ï¸ RIG TAF: Parsing TAF for ${e.airportIcao}: "${e.rawTaf}"`);const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawTaf),S=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawTaf),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawTaf);console.log(`ðŸŒ¬ï¸ RIG TAF: Parsed values - Speed: ${I}, Dir: ${S}, Gust: ${C}`),I!==null&&S!==null&&(t=I,p=S,u=C,f="Pseudo TAF",console.log(`ðŸŒ¬ï¸ RIG TAF: âœ… Successfully extracted wind from TAF for ${e.airportIcao}`))}if(t===null&&e.windSpeed!==void 0&&e.windSpeed!==null&&(t=e.windSpeed,p=e.windDirection,u=e.windGust,f="Rig Model Data"),t===null&&e.wind&&typeof e.wind=="object"&&(t=e.wind.speed||e.wind.windSpeed,p=e.wind.direction||e.wind.windDirection,u=e.wind.gust||e.wind.windGust,f="Rig Wind Object"),t===null){const I=["windSpeedKts","windSpeedMps","speed","wspd"],S=["windDirectionDeg","direction","wdir"];for(const C of I)if(e[C]!==void 0&&e[C]!==null){t=e[C],f=`Rig Field: ${C}`;break}for(const C of S)if(e[C]!==void 0&&e[C]!==null){p=e[C];break}}t!==null?(l.push({rigName:e.airportIcao,latitude:d[1],longitude:d[0],isAirport:!1,windSpeed:t,windDirection:p,windGust:u,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(a==null?void 0:a.visibility)||e.visibility||10,temperature:(a==null?void 0:a.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao,locationType:"rig",comprehensiveMetar:a,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(a==null?void 0:a.clouds)||[],weatherConditions:(a==null?void 0:a.conditions)||[],altimeter:a==null?void 0:a.altimeter,dewpoint:a==null?void 0:a.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Rig ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for rig ${e.airportIcao}`)}else console.log(`âŒ Rig ${e.airportIcao}: Could not find coordinates in any source`)}else if(e.isRig)console.log(`âŒ Segment ${L} (${e.airportIcao||e.locationName}) has no coordinates and is not a rig or destination`);else{console.log(`âœˆï¸ Processing destination weather: ${e.airportIcao||e.locationName}`);let d=null;if(e.geoPoint&&(d=this.parseGeoPoint(e.geoPoint),d&&console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from geoPoint:`,d)),!d&&window.currentWaypoints&&Array.isArray(window.currentWaypoints)){const w=window.currentWaypoints.find(t=>{var p,u;return t.name===e.airportIcao||((p=t.name)==null?void 0:p.toUpperCase())===((u=e.airportIcao)==null?void 0:u.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from currentWaypoints:`,d))}if(!d&&((m=window.waypointManager)!=null&&m.getWaypoints)){const t=window.waypointManager.getWaypoints().find(p=>{var u,f;return p.name===e.airportIcao||((u=p.name)==null?void 0:u.toUpperCase())===((f=e.airportIcao)==null?void 0:f.toUpperCase())});t&&t.lng&&t.lat&&(d=[t.lng,t.lat],console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from waypointManager:`,d))}if(!d&&window.debugStopCards&&Array.isArray(window.debugStopCards)){const w=window.debugStopCards.find(t=>{var p,u,f,a;return t.name===e.airportIcao||((p=t.name)==null?void 0:p.toUpperCase())===((u=e.airportIcao)==null?void 0:u.toUpperCase())||t.stop===e.airportIcao||((f=t.stop)==null?void 0:f.toUpperCase())===((a=e.airportIcao)==null?void 0:a.toUpperCase())});w&&w.coordinates&&(d=w.coordinates,console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from stopCards:`,d))}if(d){const w={...e,ranking2:e.ranking2,extractedCoordinates:d,circleType:"destination"};i.push(w),console.log(`âœ… Destination ${e.airportIcao||e.locationName}: Found coordinates ${JSON.stringify(d)} with ranking ${e.ranking2}`),console.log(`ðŸŒ¬ï¸ COLLECTING: Destination arrow data for ${e.airportIcao}`);let t=null,p=null,u=null,f="Unknown",a=null;if(e.rawMetar&&window.weatherVisualizationManager){const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),S=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);a=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),I!==null&&S!==null&&(t=I,p=S,u=C,f="METAR")}t===null&&e.windSpeed&&(t=e.windSpeed,p=e.windDirection,u=e.windGust,f="Segment"),t!==null?(l.push({rigName:e.airportIcao||e.locationName,latitude:d[1],longitude:d[0],isAirport:!0,windSpeed:t,windDirection:p,windGust:u,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(a==null?void 0:a.visibility)||e.visibility||10,temperature:(a==null?void 0:a.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao||e.locationName,locationType:"destination",comprehensiveMetar:a,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(a==null?void 0:a.clouds)||[],weatherConditions:(a==null?void 0:a.conditions)||[],altimeter:a==null?void 0:a.altimeter,dewpoint:a==null?void 0:a.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Destination ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for destination ${e.airportIcao}`)}else console.log(`âŒ Destination ${e.airportIcao||e.locationName}: Could not find coordinates from any source (geoPoint: ${e.geoPoint})`)}});const h=this.deduplicateCirclesByLocation(i);if(console.log(`ðŸŸ¡ Found ${i.length} total segments, deduplicated to ${h.length} unique locations`),h.length===0){console.log("ðŸ”´ No valid segments found, adding test circles instead"),r(),this.addTestCircles();return}console.log("ðŸŸ¢ WeatherCirclesLayer: Processing",h.length,"deduplicated segments");const y=h.map(e=>this.createRingFeature(e,"outermost")).filter(e=>e!==null),g=h.map(e=>this.createRingFeature(e,"outer")).filter(e=>e!==null),W=h.map(e=>this.createRingFeature(e,"middle")).filter(e=>e!==null),k=h.map(e=>this.createRingFeature(e,"inner")).filter(e=>e!==null),P=h.map(e=>this.createRingFeature(e,"innermost")).filter(e=>e!==null);if(g.length===0){console.log("ðŸ”´ No valid ring features created"),r();return}console.log(`ðŸŸ¢ Created ${g.length} concentric ring sets`),this.addAlternateLines(o),this.map.addSource(this.sourceId+"-outermost",{type:"geojson",data:{type:"FeatureCollection",features:y}}),this.map.addSource(this.sourceId,{type:"geojson",data:{type:"FeatureCollection",features:g}}),this.map.addSource(this.sourceId+"-middle",{type:"geojson",data:{type:"FeatureCollection",features:W}}),this.map.addSource(this.sourceId+"-inner",{type:"geojson",data:{type:"FeatureCollection",features:k}}),this.map.addSource(this.sourceId+"-innermost",{type:"geojson",data:{type:"FeatureCollection",features:P}});const b=g.some(e=>e.geometry.type==="Polygon"),G=g.some(e=>e.geometry.type==="Point");console.log("WeatherCirclesLayer: Geometry types found:",{hasCircleGeometry:b,hasPointGeometry:G});let $=this.findFirstRouteLayer();if(b&&(this.map.addLayer({id:this.layerId+"-outermost",type:"line",source:this.sourceId+"-outermost",filter:["==","$type","Polygon"],paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.15},layout:{visibility:"visible"}},$),this.map.addLayer({id:this.layerId+"-outer",type:"line",source:this.sourceId,filter:["==","$type","Polygon"],paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.25},layout:{visibility:"visible"}},$),this.map.addLayer({id:this.layerId+"-middle",type:"line",source:this.sourceId+"-middle",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.5},layout:{visibility:"visible"}},$),this.map.addLayer({id:this.layerId+"-inner",type:"line",source:this.sourceId+"-inner",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.75},layout:{visibility:"visible"}},$),this.map.addLayer({id:this.layerId+"-innermost",type:"line",source:this.sourceId+"-innermost",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.95},layout:{visibility:"visible"}},$),console.log("WeatherCirclesLayer: Added 5 concentric ring layers"),console.log("ðŸ”— POPUP: WeatherCirclesLayer popup disabled - RigWeatherGraphics has more detailed weather data")),G){const e=this.layerId+"-points";this.map.addLayer({id:e+"-outer",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],80],60],"circle-stroke-color":["get","color"],"circle-stroke-width":3,"circle-stroke-opacity":.3},layout:{visibility:"visible"}},$),this.map.addLayer({id:e+"-middle",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],120],40],"circle-stroke-color":["get","color"],"circle-stroke-width":2,"circle-stroke-opacity":.5},layout:{visibility:"visible"}},$),this.map.addLayer({id:e+"-inner",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],160],25],"circle-stroke-color":["get","color"],"circle-stroke-width":2,"circle-stroke-opacity":.95},layout:{visibility:"visible"}},$),console.log("WeatherCirclesLayer: Added concentric ring layers for points"),console.log("ðŸ”— POPUP: WeatherCirclesLayer popup disabled - RigWeatherGraphics has more detailed weather data")}if(this.isVisible=!0,console.log("WeatherCirclesLayer: Added",g.length,"weather circles"),l.length>0&&window.rigWeatherIntegration&&window.rigWeatherIntegration.updateRigWeather){console.log(`ðŸŒ¬ï¸ CREATING ARROWS: ${l.length} wind arrows for all locations:`,l.map(e=>`${e.rigName}(${e.locationType})`));try{window.rigWeatherIntegration.updateRigWeather(l),console.log(`ðŸŒ¬ï¸ ARROWS: âœ… Successfully created ${l.length} wind arrows`);const e=l.reduce((L,R)=>(L[R.locationType]=(L[R.locationType]||0)+1,L),{});console.log("ðŸŒ¬ï¸ ARROWS: Arrow breakdown:",e)}catch(e){console.error("ðŸŒ¬ï¸ ARROWS: Error creating wind arrows:",e)}}else console.log("ðŸŒ¬ï¸ ARROWS: Cannot create arrows - rigWeatherIntegration not available or missing updateRigWeather method"),console.log(`ðŸŒ¬ï¸ DEBUG: rigWeatherIntegration exists: ${!!window.rigWeatherIntegration}`),console.log(`ðŸŒ¬ï¸ DEBUG: updateRigWeather method exists: ${!!((E=window.rigWeatherIntegration)!=null&&E.updateRigWeather)}`);r(),setTimeout(()=>{const e=[this.layerId+"-outermost",this.layerId+"-outer",this.layerId+"-middle",this.layerId+"-inner",this.layerId+"-innermost",this.layerId+"-points-outer",this.layerId+"-points-middle",this.layerId+"-points-inner",this.layerId+"-lines"],L=e.filter(R=>this.map.getLayer(R));L.length>0?console.log(`âœ… WeatherCirclesLayer: ${L.length} layers successfully added to map:`,L):(console.warn("âš ï¸ WeatherCirclesLayer: No weather circle layers found in map after adding - this may be normal if no features were created"),console.log("ðŸ” WeatherCirclesLayer: Available layers:",e.map(R=>({id:R,exists:!!this.map.getLayer(R)}))))},200)}createRingFeature(o,n){const r=o.extractedCoordinates;if(!r||!Array.isArray(r)||r.length!==2)return console.warn("WeatherCirclesLayer: Invalid extractedCoordinates:",r),null;const l=o.ranking2,i=this.getAviationRankingColor(l);console.log(`ðŸŽ¨ RING CREATION: ${n} ring for ${o.airportIcao} (${o.circleType}) at ${r} with ranking ${o.ranking2} = COLOR ${i}`);const c=this.getCircleRadius(l);let s;switch(n){case"outermost":s=c*1.8;break;case"outer":s=c*1.4;break;case"middle":s=c*1;break;case"inner":s=c*.7;break;case"innermost":s=c*.4;break;default:s=c}if(!window.turf)return console.warn("WeatherCirclesLayer: Turf.js not available, creating simple point feature"),{type:"Feature",geometry:{type:"Point",coordinates:r},properties:{airportIcao:o.airportIcao||"Unknown",ranking:l,color:i,isRig:o.isRig||!1,radius:s*1e3,ringType:n}};const h=window.turf.point(r);return{type:"Feature",geometry:window.turf.buffer(h,s,{units:"kilometers"}).geometry,properties:{airportIcao:o.airportIcao||"Unknown",ranking:l,color:i,isRig:o.isRig||!1,ringType:n}}}parseGeoPoint(o){if(!o)return null;console.log("WeatherCirclesLayer: Parsing geoPoint:",o);try{const n=o.split(",");if(n.length===2){const r=parseFloat(n[0].trim()),l=parseFloat(n[1].trim());if(console.log("WeatherCirclesLayer: Parsed coordinates:",{lat:r,lon:l,isValidLat:!isNaN(r),isValidLon:!isNaN(l)}),!isNaN(r)&&!isNaN(l)){const i=[l,r];return console.log("WeatherCirclesLayer: Final coordinates (GeoJSON format):",i),r>=-90&&r<=90&&l>=-180&&l<=180?i:(console.warn("WeatherCirclesLayer: Coordinates out of valid range:",{lat:r,lon:l}),null)}}}catch(n){console.error("WeatherCirclesLayer: Error parsing geoPoint:",o,n)}return null}getCircleRadius(o){switch(o){case 5:return 8*1.2;case 8:return 8*1.1;case 10:return 8;case 15:return 8*.9;case 20:return 8*.8;default:return 8}}getAviationRankingColor(o){switch(o){case 5:return"#D32F2F";case 8:return"#8E24AA";case 10:return"#F57C00";case 15:return"#66BB6A";case 20:return"#616161";default:return"#1976D2"}}removeWeatherCircles(){if(window.weatherCirclesCreationInProgress&&(console.log("ðŸ”“ WeatherCirclesLayer: Clearing creation lock during removal"),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null),!this.map){console.warn("ðŸ§¹ WeatherCirclesLayer: Cannot remove weather circles - map reference is null/undefined");return}try{const o=this.layerId+"-hover-areas";this.map.getLayer&&this.map.getLayer(o)&&(this.map.off("mouseenter",o),this.map.off("mouseleave",o),console.log("ðŸ§¹ Removed weather hover event listeners")),this.popup&&(this.popup.remove(),this.popup=null,console.log("ðŸ§¹ Removed weather popup instance")),["-outermost","-outer","-middle","-inner","-innermost"].forEach(i=>{this.map.getLayer(this.layerId+i)&&this.map.removeLayer(this.layerId+i)}),["-points-outer","-points-middle","-points-inner"].forEach(i=>{this.map.getLayer(this.layerId+i)&&this.map.removeLayer(this.layerId+i)}),this.map.getLayer(this.layerId)&&this.map.removeLayer(this.layerId),this.map.getLayer(this.layerId+"-points")&&this.map.removeLayer(this.layerId+"-points"),this.map.getLayer(this.layerId+"-lines")&&this.map.removeLayer(this.layerId+"-lines"),this.map.getLayer(this.layerId+"-lines-shadow")&&this.map.removeLayer(this.layerId+"-lines-shadow"),this.map.getSource(this.sourceId+"-lines")&&this.map.removeSource(this.sourceId+"-lines"),this.map.getSource(this.sourceId+"-lines-shadow")&&this.map.removeSource(this.sourceId+"-lines-shadow"),this.map.getLayer(this.layerId+"-hover-areas")&&this.map.removeLayer(this.layerId+"-hover-areas"),this.map.getSource(this.sourceId+"-hover-areas")&&this.map.removeSource(this.sourceId+"-hover-areas"),["-outermost","","-middle","-inner","-innermost"].forEach(i=>{this.map.getSource(this.sourceId+i)&&this.map.removeSource(this.sourceId+i)})}catch(o){console.error("WeatherCirclesLayer: Error removing weather circles:",o)}}toggle(){this.isVisible=!this.isVisible;const o=this.isVisible?"visible":"none";this.map.getLayer(this.layerId)&&this.map.setLayoutProperty(this.layerId,"visibility",o)}addTestCircles(){console.log("WeatherCirclesLayer: Adding test circles for debugging"),console.log("WeatherCirclesLayer: Map state:",{hasMap:!!this.map,mapLoaded:this.map?this.map.loaded?this.map.loaded():"checking...":!1,mapStyle:this.map?this.map.getStyle():null});const o=[{geoPoint:"27.5, -90.5",airportIcao:"TEST1",ranking2:5,isRig:!1},{geoPoint:"28.0, -89.5",airportIcao:"TEST2",ranking2:8,isRig:!0},{geoPoint:"26.8, -91.2",airportIcao:"TEST3",ranking2:15,isRig:!1},{geoPoint:"27.8, -88.5",airportIcao:"TEST4",ranking2:10,isRig:!1}];console.log("WeatherCirclesLayer: Created test segments:",o),this.addWeatherCircles(o)}addAlternateLines(o){if(console.log("ðŸ”— Adding curved dotted lines for weather alternate routes"),!this.map){console.warn("ðŸ”— WeatherCirclesLayer: Cannot add alternate lines - map reference is null/undefined");return}const n=window.flightAlternateData;let r=null;if(n&&n.splitPoint)if(typeof n.splitPoint=="string"){const i=n.splitPoint.split(",");if(i.length===2){const c=parseFloat(i[0].trim());r=[parseFloat(i[1].trim()),c],console.log("ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point:",r)}}else Array.isArray(n.splitPoint)&&(r=n.splitPoint,console.log("ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point array:",r));r||(console.warn("ðŸŽ¯ WARNING: No correct split point available from flight data - alternate lines may be incorrect"),console.warn("ðŸŽ¯ Available flight alternate data:",n));const l=[];if(o.forEach(i=>{if(i.alternateGeoShape&&i.alternateGeoShape.coordinates&&i.alternateGeoShape.coordinates.length>=2){const c=r||i.alternateGeoShape.coordinates[0],s=i.alternateGeoShape.coordinates[1];console.log(`ðŸ”— Creating curved line from split ${JSON.stringify(c)} to ${i.airportIcao} ${JSON.stringify(s)}`),console.log(`ðŸŽ¯ SPLIT POINT SOURCE: ${r?"Flight Data (CORRECT)":"Weather Segment (FALLBACK)"}`),console.log(`ðŸš¨ LINE DEBUG: Full coordinates array for ${i.airportIcao}:`,JSON.stringify(i.alternateGeoShape.coordinates,null,2));const y={type:"Feature",geometry:{type:"LineString",coordinates:[c,s]},properties:{type:"weather-alternate-line",airportIcao:i.airportIcao,ranking:i.ranking2,isRig:i.isRig||!1}};l.push(y)}}),l.length>0){const i=this.sourceId+"-lines",c=this.layerId+"-lines";try{this.map.getLayer&&this.map.getLayer(c)&&this.map.removeLayer(c),this.map.getSource&&this.map.getSource(i)&&this.map.removeSource(i),this.map.addSource(i,{type:"geojson",data:{type:"FeatureCollection",features:l}}),this.map.addSource(i+"-shadow",{type:"geojson",data:{type:"FeatureCollection",features:this.createStraightShadowLines(o)}}),this.map.addLayer({id:c+"-shadow",type:"line",source:i+"-shadow",paint:{"line-color":"rgba(0, 0, 0, 0.2)","line-width":2,"line-blur":1},layout:{visibility:"visible"}}),this.map.addLayer({id:c,type:"line",source:i,paint:{"line-color":"#999999","line-width":1,"line-dasharray":[3,3]},layout:{visibility:"visible"}}),console.log("ðŸ”— Added",l.length,"curved dotted weather alternate lines")}catch(s){console.error("ðŸ”— Error adding alternate lines:",s)}}else console.log("ðŸ”— No valid segments found for alternate lines")}deduplicateCirclesByLocation(o){const n=new Map;return o.forEach(r=>{if(!r.extractedCoordinates)return;const[l,i]=r.extractedCoordinates,c=`${Math.round(l*1e4)},${Math.round(i*1e4)}`,s=n.get(c);if(!s||this.getCirclePriority(r)>this.getCirclePriority(s)){const h=this.getAviationRankingColor(r.ranking2);n.set(c,r),console.log(`ðŸŽ¯ Deduplicate: Keeping ${r.airportIcao} (${r.circleType}) at ${c} with ranking ${r.ranking2} = COLOR ${h}`)}else{const h=this.getAviationRankingColor(s.ranking2),y=this.getAviationRankingColor(r.ranking2);console.log(`ðŸŽ¯ Deduplicate: Skipping ${r.airportIcao} (${r.circleType}) ranking=${r.ranking2} color=${y} - already have ${s.airportIcao} (${s.circleType}) ranking=${s.ranking2} color=${h}`)}}),Array.from(n.values())}getCirclePriority(o){let n=0;switch(o.circleType){case"alternate":n=200;break;case"split":n=100;break;default:n=150}const r=o.ranking2?25-o.ranking2:0;return n+r}findFirstRouteLayer(){var r;if(!this.map)return;const o=["route-shadow","route-glow","route-line","route","alternate-shadow","alternate-glow","alternate-line","alternate","waypoint","platform","airfield"],n=((r=this.map.getStyle())==null?void 0:r.layers)||[];for(const l of o){const i=n.find(c=>c.id.toLowerCase().includes(l.toLowerCase()));if(i)return console.log(`ðŸŽ¯ Weather rings will be placed before route layer: ${i.id}`),i.id}console.log("ðŸŽ¯ No route layers found, weather rings will be on top")}getRigCoordinatesFromWaypoints(o){var n,r,l,i,c;if(console.log(`ðŸ”§ DEBUG: Looking for rig coordinates for ${o}...`),console.log("ðŸ”§ DEBUG: Available window objects:",Object.keys(window).filter(s=>s.includes("waypoint")||s.includes("route"))),window.waypointManager)try{const s=window.waypointManager.waypoints||((r=(n=window.waypointManager).getWaypoints)==null?void 0:r.call(n))||window.waypointManager.currentWaypoints;if(console.log("ðŸ”§ DEBUG: WaypointManager waypoints:",s),s&&Array.isArray(s)){const y=s.find(g=>g.name===o||g.id===o||g.airportIcao===o);if(y&&y.lat&&y.lng)return console.log(`âœ… Found coordinates for rig ${o} in waypointManager:`,[y.lng,y.lat]),[y.lng,y.lat]}const h=Object.keys(window.waypointManager);console.log("ðŸ” WaypointManager available methods/properties:",h);for(const y of h){const g=window.waypointManager[y];if(Array.isArray(g)&&g.length>0){console.log(`ðŸ” Checking waypointManager.${y}:`,g);const W=g.find(k=>(k.name===o||k.id===o||k.airportIcao===o)&&k.lat&&k.lng);if(W)return console.log(`âœ… Found coordinates for rig ${o} in waypointManager.${y}:`,[W.lng,W.lat]),[W.lng,W.lat]}}}catch(s){console.warn("Error accessing waypointManager:",s)}if(window.routeCalculator)try{const s=window.routeCalculator.waypoints||((i=(l=window.routeCalculator).getWaypoints)==null?void 0:i.call(l))||((c=window.routeCalculator.currentRoute)==null?void 0:c.waypoints);if(s&&Array.isArray(s)){const h=s.find(y=>(y.name===o||y.id===o||y.airportIcao===o)&&y.lat&&y.lng);if(h)return console.log(`âœ… Found coordinates for rig ${o} in routeCalculator:`,[h.lng,h.lat]),[h.lng,h.lat]}}catch(s){console.warn("Error accessing routeCalculator:",s)}return console.warn(`âŒ Could not find coordinates for rig ${o} in any waypoint source`),null}createStraightShadowLines(o){const n=[],r=window.flightAlternateData;let l=null;if(r&&r.splitPoint)if(typeof r.splitPoint=="string"){const i=r.splitPoint.split(",");if(i.length===2){const c=parseFloat(i[0].trim());l=[parseFloat(i[1].trim()),c]}}else Array.isArray(r.splitPoint)&&(l=r.splitPoint);return o.forEach(i=>{if(i.alternateGeoShape&&i.alternateGeoShape.coordinates&&i.alternateGeoShape.coordinates.length>=2){const c=l||i.alternateGeoShape.coordinates[0],s=i.alternateGeoShape.coordinates[1],h={type:"Feature",geometry:{type:"LineString",coordinates:[c,s]},properties:{type:"weather-alternate-shadow",airportIcao:i.airportIcao}};n.push(h)}}),n}createCurvedLine(o,n){const[r,l]=o,[i,c]=n,s=(r+i)/2,h=(l+c)/2,y=i-r,g=c-l,W=Math.sqrt(y*y+g*g),k=W*.035;let P=-g/W*k,b=y/W*k;b<0&&(P=-P,b=-b);const G=s+P,$=h+b,E=25,e=[];for(let L=0;L<=E;L++){const R=L/E,A=R*R,F=1-R,v=F*F,M=v*r+2*F*R*G+A*i,m=v*l+2*F*R*$+A*c;e.push([M,m])}return e}updateWeatherCircles(o){this.addWeatherCircles(o)}static autoCreateOnWeatherLoad(o,n){if(!(!o||!n||n.length===0))if(console.log("ðŸ”„ AUTO-CREATE: Weather segments loaded, creating weather circles automatically"),window.currentWeatherCirclesLayer)window.currentWeatherCirclesLayer.addWeatherCircles(n),console.log("ðŸ”„ AUTO-CREATE: Weather circles updated automatically");else{const r=new N(o);r.addWeatherCircles(n),window.currentWeatherCirclesLayer=r,console.log("ðŸ”„ AUTO-CREATE: Weather circles created automatically for new flight")}}static refreshFromAvailableData(o){var n;try{console.log("ðŸ”„ REFRESH: Attempting to refresh weather circles from available data");let r=null,l="none";if(((n=window.loadedWeatherSegments)==null?void 0:n.length)>0&&(r=window.loadedWeatherSegments,l="window.loadedWeatherSegments"),console.log(`ðŸ”„ REFRESH: Found data from ${l}, segments:`,(r==null?void 0:r.length)||0),r&&r.length>0&&o){if(window.currentWeatherCirclesLayer)try{window.currentWeatherCirclesLayer.removeWeatherCircles()}catch(c){console.warn("ðŸ”„ REFRESH: Error during cleanup:",c)}const i=new N(o);return i.addWeatherCircles(r),window.currentWeatherCirclesLayer=i,console.log("ðŸ”„ REFRESH: Weather circles refreshed successfully"),!0}else return console.log("ðŸ”„ REFRESH: No weather data available to refresh from"),!1}catch(r){return console.error("ðŸ”„ REFRESH: Error refreshing weather circles:",r),!1}}}window.refreshWeatherCircles=()=>{var T;return(T=window.mapManager)!=null&&T.map?N.refreshFromAvailableData(window.mapManager.map):(console.error("ðŸ”„ REFRESH: Map not available for refresh"),!1)};window.clearWeatherCirclesLock=()=>{if(window.weatherCirclesCreationInProgress){const T=Date.now()-(window.weatherCirclesLockTime||0);return console.log(`ðŸ”“ MANUAL: Clearing weather circles lock (was active for ${T}ms)`),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null,!0}else return console.log("ðŸ”“ MANUAL: No active lock to clear"),!1};window.checkWeatherCirclesLock=()=>{if(window.weatherCirclesCreationInProgress){const T=Date.now()-(window.weatherCirclesLockTime||0);return console.log(`ðŸ”’ LOCK STATUS: Active for ${T}ms (set at ${new Date(window.weatherCirclesLockTime).toLocaleTimeString()})`),{active:!0,ageMs:T,setAt:window.weatherCirclesLockTime}}else return console.log("ðŸ”“ LOCK STATUS: No active lock"),{active:!1}};export{N as default};
