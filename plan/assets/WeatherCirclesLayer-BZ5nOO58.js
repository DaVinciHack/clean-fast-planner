class G{constructor(o){this.map=o,this.sourceId="weather-circles-source",this.layerId="weather-circles-layer",this.isVisible=!1,this.currentWeatherSegments=[]}addWeatherCircles(o){if(!o||!this.map){console.warn("WeatherCirclesLayer: Missing weatherSegments or map");return}const a=Date.now();if(window.weatherCirclesCreationInProgress){const e=Date.now()-(window.weatherCirclesLockTime||0);if(console.log(`ðŸ”„ WeatherCirclesLayer: Creation lock active for ${e}ms`),e>1e4)console.log("ðŸ”“ WeatherCirclesLayer: Clearing stale lock (older than 10s)"),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null;else{console.log("ðŸ”„ WeatherCirclesLayer: Recent lock detected, skipping duplicate request");return}}window.weatherCirclesCreationInProgress=!0,window.weatherCirclesLockTime=a,console.log(`ðŸ”’ WeatherCirclesLayer: Setting creation lock at ${a}`);const r=()=>{window.weatherCirclesCreationInProgress&&window.weatherCirclesLockTime===a&&(window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null,console.log(`ðŸ”“ WeatherCirclesLayer: Clearing creation lock (held for ${Date.now()-a}ms)`))};setTimeout(r,5e3),console.log("ðŸŸ¡ WeatherCirclesLayer: Adding",o.length,"weather circles to map"),this.currentWeatherSegments=o,this.removeWeatherCircles();const l=[],i=[],c=new Set,n=new Set;o.forEach(e=>{e.alternateGeoShape&&(e.airportIcao||e.locationName)&&c.add(e.airportIcao||e.locationName)}),console.log("ðŸ”„ DEDUP: Found alternates for locations:",Array.from(c)),o.forEach((e,S)=>{var m,b,E,M;if(console.log(`ðŸ” Segment ${S}:`,{airportIcao:e.airportIcao,locationName:e.locationName,isRig:e.isRig,alternateGeoShape:e.alternateGeoShape,ranking2:e.ranking2,hasAlternateCoords:((b=(m=e.alternateGeoShape)==null?void 0:m.coordinates)==null?void 0:b.length)>=2,hasGeoPoint:!!e.geoPoint,geoPoint:e.geoPoint}),!(e.ranking2!==void 0&&e.ranking2!==null)){console.log(`âŒ Invalid segment ${S}: no valid ranking`);return}const k=e.airportIcao||e.locationName;if(k){if(!e.isRig&&!e.alternateGeoShape&&c.has(k)){console.log(`ðŸ”„ DEDUP: Skipping destination ${k} - alternate exists for same location`);return}if(n.has(k)){console.log(`ðŸ”„ DEDUP: Skipping duplicate ${k} - already processed`);return}n.add(k)}if(e.alternateGeoShape&&e.alternateGeoShape.coordinates&&Array.isArray(e.alternateGeoShape.coordinates)&&e.alternateGeoShape.coordinates.length>=2){const d=e.ranking2,w={...e,ranking2:d,extractedCoordinates:e.alternateGeoShape.coordinates[1],circleType:"alternate"};i.push(w),console.log(`âœ… Alternate ${S}: ${e.airportIcao} at ${JSON.stringify(e.alternateGeoShape.coordinates[1])} with ranking ${d}`),console.log(`ðŸš¨ COORDINATE DEBUG: Full alternateGeoShape.coordinates for ${e.airportIcao}:`,JSON.stringify(e.alternateGeoShape.coordinates,null,2)),console.log(`ðŸŒ¬ï¸ COLLECTING: Alternate arrow data for ${e.airportIcao}`);let s=null,p=null,h=null,f="Unknown",t=null;if(e.rawMetar&&window.weatherVisualizationManager){const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),L=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);t=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),I!==null&&L!==null&&(s=I,p=L,h=C,f="METAR")}s===null&&e.windSpeed&&(s=e.windSpeed,p=e.windDirection,h=e.windGust,f="Segment"),s!==null?(l.push({rigName:e.airportIcao,latitude:e.alternateGeoShape.coordinates[1][1],longitude:e.alternateGeoShape.coordinates[1][0],isAirport:!e.isRig,windSpeed:s,windDirection:p,windGust:h,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(t==null?void 0:t.visibility)||e.visibility||10,temperature:(t==null?void 0:t.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao,locationType:"alternate",comprehensiveMetar:t,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(t==null?void 0:t.clouds)||[],weatherConditions:(t==null?void 0:t.conditions)||[],altimeter:t==null?void 0:t.altimeter,dewpoint:t==null?void 0:t.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Alternate ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for alternate ${e.airportIcao}`),console.log(`â­ï¸ Skipping split point for ${e.airportIcao} - only showing alternate destination`)}else if(e.isRig){console.log(`ðŸ›¢ï¸ Processing rig weather: ${e.airportIcao}`);let d=null;if(window.currentWaypoints&&Array.isArray(window.currentWaypoints)){const w=window.currentWaypoints.find(s=>{var p,h;return s.name===e.airportIcao||((p=s.name)==null?void 0:p.toUpperCase())===((h=e.airportIcao)==null?void 0:h.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from currentWaypoints:`,d))}if(!d&&((E=window.waypointManager)!=null&&E.getWaypoints)){const s=window.waypointManager.getWaypoints().find(p=>{var h,f;return p.name===e.airportIcao||((h=p.name)==null?void 0:h.toUpperCase())===((f=e.airportIcao)==null?void 0:f.toUpperCase())});s&&s.lng&&s.lat&&(d=[s.lng,s.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from waypointManager:`,d))}if(!d&&window.globalWaypoints&&Array.isArray(window.globalWaypoints)){const w=window.globalWaypoints.find(s=>{var p,h;return s.name===e.airportIcao||((p=s.name)==null?void 0:p.toUpperCase())===((h=e.airportIcao)==null?void 0:h.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from globalWaypoints:`,d))}if(!d&&window.debugStopCards&&Array.isArray(window.debugStopCards)){const w=window.debugStopCards.find(s=>{var p,h,f,t;return s.name===e.airportIcao||((p=s.name)==null?void 0:p.toUpperCase())===((h=e.airportIcao)==null?void 0:h.toUpperCase())||s.stop===e.airportIcao||((f=s.stop)==null?void 0:f.toUpperCase())===((t=e.airportIcao)==null?void 0:t.toUpperCase())});w&&w.coordinates&&(d=w.coordinates,console.log(`ðŸ›¢ï¸ Found rig ${e.airportIcao} coordinates from stopCards:`,d))}if(d){const w={...e,ranking2:e.ranking2,extractedCoordinates:d,circleType:"rig"};i.push(w),console.log(`âœ… Rig ${e.airportIcao}: Found coordinates ${JSON.stringify(d)} with ranking ${e.ranking2}`),console.log(`ðŸŒ¬ï¸ COLLECTING: Rig arrow data for ${e.airportIcao}`);let s=null,p=null,h=null,f="Unknown";console.log(`ðŸŒ¬ï¸ RIG DEBUG: Available wind fields for ${e.airportIcao}:`,{rawMetar:e.rawMetar,rawTaf:e.rawTaf,windSpeed:e.windSpeed,windDirection:e.windDirection,windGust:e.windGust,wind:e.wind,allKeys:Object.keys(e).filter(I=>I.toLowerCase().includes("wind"))});let t=null;if(e.rawMetar&&window.weatherVisualizationManager){console.log(`ðŸŒ¬ï¸ RIG METAR: Parsing METAR for ${e.airportIcao}: "${e.rawMetar}"`);const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),L=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);t=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),console.log(`ðŸŒ¬ï¸ RIG METAR: Parsed values - Speed: ${I}, Dir: ${L}, Gust: ${C}`),console.log("ðŸŒ¬ï¸ RIG METAR: Comprehensive data:",t),I!==null&&L!==null?(s=I,p=L,h=C,f="METAR",console.log(`ðŸŒ¬ï¸ RIG METAR: âœ… Successfully extracted wind from METAR for ${e.airportIcao}`)):console.log(`ðŸŒ¬ï¸ RIG METAR: âŒ METAR parsing failed for ${e.airportIcao}`)}if(s===null&&e.rawTaf&&window.weatherVisualizationManager){console.log(`ðŸŒ¬ï¸ RIG TAF: Parsing TAF for ${e.airportIcao}: "${e.rawTaf}"`);const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawTaf),L=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawTaf),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawTaf);console.log(`ðŸŒ¬ï¸ RIG TAF: Parsed values - Speed: ${I}, Dir: ${L}, Gust: ${C}`),I!==null&&L!==null&&(s=I,p=L,h=C,f="Pseudo TAF",console.log(`ðŸŒ¬ï¸ RIG TAF: âœ… Successfully extracted wind from TAF for ${e.airportIcao}`))}if(s===null&&e.windSpeed!==void 0&&e.windSpeed!==null&&(s=e.windSpeed,p=e.windDirection,h=e.windGust,f="Rig Model Data"),s===null&&e.wind&&typeof e.wind=="object"&&(s=e.wind.speed||e.wind.windSpeed,p=e.wind.direction||e.wind.windDirection,h=e.wind.gust||e.wind.windGust,f="Rig Wind Object"),s===null){const I=["windSpeedKts","windSpeedMps","speed","wspd"],L=["windDirectionDeg","direction","wdir"];for(const C of I)if(e[C]!==void 0&&e[C]!==null){s=e[C],f=`Rig Field: ${C}`;break}for(const C of L)if(e[C]!==void 0&&e[C]!==null){p=e[C];break}}s!==null?(l.push({rigName:e.airportIcao,latitude:d[1],longitude:d[0],isAirport:!1,windSpeed:s,windDirection:p,windGust:h,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(t==null?void 0:t.visibility)||e.visibility||10,temperature:(t==null?void 0:t.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao,locationType:"rig",comprehensiveMetar:t,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(t==null?void 0:t.clouds)||[],weatherConditions:(t==null?void 0:t.conditions)||[],altimeter:t==null?void 0:t.altimeter,dewpoint:t==null?void 0:t.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Rig ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for rig ${e.airportIcao}`)}else console.log(`âŒ Rig ${e.airportIcao}: Could not find coordinates in any source`)}else if(e.isRig)console.log(`âŒ Segment ${S} (${e.airportIcao||e.locationName}) has no coordinates and is not a rig or destination`);else{console.log(`âœˆï¸ Processing destination weather: ${e.airportIcao||e.locationName}`);let d=null;if(e.geoPoint&&(d=this.parseGeoPoint(e.geoPoint),d&&console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from geoPoint:`,d)),!d&&window.currentWaypoints&&Array.isArray(window.currentWaypoints)){const w=window.currentWaypoints.find(s=>{var p,h;return s.name===e.airportIcao||((p=s.name)==null?void 0:p.toUpperCase())===((h=e.airportIcao)==null?void 0:h.toUpperCase())});w&&w.lng&&w.lat&&(d=[w.lng,w.lat],console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from currentWaypoints:`,d))}if(!d&&((M=window.waypointManager)!=null&&M.getWaypoints)){const s=window.waypointManager.getWaypoints().find(p=>{var h,f;return p.name===e.airportIcao||((h=p.name)==null?void 0:h.toUpperCase())===((f=e.airportIcao)==null?void 0:f.toUpperCase())});s&&s.lng&&s.lat&&(d=[s.lng,s.lat],console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from waypointManager:`,d))}if(!d&&window.debugStopCards&&Array.isArray(window.debugStopCards)){const w=window.debugStopCards.find(s=>{var p,h,f,t;return s.name===e.airportIcao||((p=s.name)==null?void 0:p.toUpperCase())===((h=e.airportIcao)==null?void 0:h.toUpperCase())||s.stop===e.airportIcao||((f=s.stop)==null?void 0:f.toUpperCase())===((t=e.airportIcao)==null?void 0:t.toUpperCase())});w&&w.coordinates&&(d=w.coordinates,console.log(`âœˆï¸ Found destination ${e.airportIcao} coordinates from stopCards:`,d))}if(d){const w={...e,ranking2:e.ranking2,extractedCoordinates:d,circleType:"destination"};i.push(w),console.log(`âœ… Destination ${e.airportIcao||e.locationName}: Found coordinates ${JSON.stringify(d)} with ranking ${e.ranking2}`),console.log(`ðŸŒ¬ï¸ COLLECTING: Destination arrow data for ${e.airportIcao}`);let s=null,p=null,h=null,f="Unknown",t=null;if(e.rawMetar&&window.weatherVisualizationManager){const I=window.weatherVisualizationManager.parseWindSpeedFromMetar(e.rawMetar),L=window.weatherVisualizationManager.parseWindDirectionFromMetar(e.rawMetar),C=window.weatherVisualizationManager.parseWindGustFromMetar(e.rawMetar);t=window.weatherVisualizationManager.parseComprehensiveMetar(e.rawMetar),I!==null&&L!==null&&(s=I,p=L,h=C,f="METAR")}s===null&&e.windSpeed&&(s=e.windSpeed,p=e.windDirection,h=e.windGust,f="Segment"),s!==null?(l.push({rigName:e.airportIcao||e.locationName,latitude:d[1],longitude:d[0],isAirport:!0,windSpeed:s,windDirection:p,windGust:h,windSource:f,flightCategory:e.flightCategory||"VFR",visibility:(t==null?void 0:t.visibility)||e.visibility||10,temperature:(t==null?void 0:t.temperature)||e.temperature,conditions:e.conditions||e.weather||"Clear",stationId:e.airportIcao||e.locationName,locationType:"destination",comprehensiveMetar:t,rawMetar:e.rawMetar,rawTaf:e.rawTaf,clouds:(t==null?void 0:t.clouds)||[],weatherConditions:(t==null?void 0:t.conditions)||[],altimeter:t==null?void 0:t.altimeter,dewpoint:t==null?void 0:t.dewpoint}),console.log(`ðŸŒ¬ï¸ COLLECTED: Destination ${e.airportIcao} arrow data`)):console.log(`ðŸŒ¬ï¸ SKIP: No wind data for destination ${e.airportIcao}`)}else console.log(`âŒ Destination ${e.airportIcao||e.locationName}: Could not find coordinates from any source (geoPoint: ${e.geoPoint})`)}});const u=this.deduplicateCirclesByLocation(i);if(console.log(`ðŸŸ¡ Found ${i.length} total segments, deduplicated to ${u.length} unique locations`),u.length===0){console.log("ðŸ”´ No valid segments found, adding test circles instead"),r(),this.addTestCircles();return}console.log("ðŸŸ¢ WeatherCirclesLayer: Processing",u.length,"deduplicated segments");const y=u.map(e=>this.createRingFeature(e,"outermost")).filter(e=>e!==null),g=u.map(e=>this.createRingFeature(e,"outer")).filter(e=>e!==null),v=u.map(e=>this.createRingFeature(e,"middle")).filter(e=>e!==null),T=u.map(e=>this.createRingFeature(e,"inner")).filter(e=>e!==null),F=u.map(e=>this.createRingFeature(e,"innermost")).filter(e=>e!==null);if(g.length===0){console.log("ðŸ”´ No valid ring features created"),r();return}console.log(`ðŸŸ¢ Created ${g.length} concentric ring sets`),this.addAlternateLines(o),this.map.addSource(this.sourceId+"-outermost",{type:"geojson",data:{type:"FeatureCollection",features:y}}),this.map.addSource(this.sourceId,{type:"geojson",data:{type:"FeatureCollection",features:g}}),this.map.addSource(this.sourceId+"-middle",{type:"geojson",data:{type:"FeatureCollection",features:v}}),this.map.addSource(this.sourceId+"-inner",{type:"geojson",data:{type:"FeatureCollection",features:T}}),this.map.addSource(this.sourceId+"-innermost",{type:"geojson",data:{type:"FeatureCollection",features:F}});const $=g.some(e=>e.geometry.type==="Polygon"),P=g.some(e=>e.geometry.type==="Point");console.log("WeatherCirclesLayer: Geometry types found:",{hasCircleGeometry:$,hasPointGeometry:P});let R=this.findFirstRouteLayer();if($&&(this.map.addLayer({id:this.layerId+"-outermost",type:"line",source:this.sourceId+"-outermost",filter:["==","$type","Polygon"],paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.15},layout:{visibility:"visible"}},R),this.map.addLayer({id:this.layerId+"-outer",type:"line",source:this.sourceId,filter:["==","$type","Polygon"],paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.25},layout:{visibility:"visible"}},R),this.map.addLayer({id:this.layerId+"-middle",type:"line",source:this.sourceId+"-middle",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.5},layout:{visibility:"visible"}},R),this.map.addLayer({id:this.layerId+"-inner",type:"line",source:this.sourceId+"-inner",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.75},layout:{visibility:"visible"}},R),this.map.addLayer({id:this.layerId+"-innermost",type:"line",source:this.sourceId+"-innermost",paint:{"line-color":["get","color"],"line-width":2,"line-opacity":.95},layout:{visibility:"visible"}},R),console.log("WeatherCirclesLayer: Added 5 concentric ring layers"),this.addWeatherHoverPopups(u)),P){const e=this.layerId+"-points";this.map.addLayer({id:e+"-outer",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],80],60],"circle-stroke-color":["get","color"],"circle-stroke-width":3,"circle-stroke-opacity":.3},layout:{visibility:"visible"}},R),this.map.addLayer({id:e+"-middle",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],120],40],"circle-stroke-color":["get","color"],"circle-stroke-width":2,"circle-stroke-opacity":.5},layout:{visibility:"visible"}},R),this.map.addLayer({id:e+"-inner",type:"circle",source:this.sourceId,filter:["==","$type","Point"],paint:{"circle-color":"transparent","circle-radius":["case",["has","radius"],["/",["get","radius"],160],25],"circle-stroke-color":["get","color"],"circle-stroke-width":2,"circle-stroke-opacity":.95},layout:{visibility:"visible"}},R),console.log("WeatherCirclesLayer: Added concentric ring layers for points"),this.addWeatherHoverPopups(u)}if(this.isVisible=!0,console.log("WeatherCirclesLayer: Added",g.length,"weather circles"),l.length>0&&window.rigWeatherIntegration){console.log(`ðŸŒ¬ï¸ CONSOLIDATED: Creating ${l.length} wind arrows for all locations:`,l.map(e=>`${e.rigName}(${e.locationType})`)),console.log("ðŸŒ¬ï¸ CONSOLIDATED DEBUG: Full arrow data:",l.map(e=>({name:e.rigName,type:e.locationType,windSpeed:e.windSpeed,windDirection:e.windDirection,isAirport:e.isAirport})));try{window.rigWeatherIntegration.updateRigWeather(l),console.log(`ðŸŒ¬ï¸ CONSOLIDATED: âœ… Successfully created ${l.length} wind arrows`);const e=l.reduce((S,A)=>(S[A.locationType]=(S[A.locationType]||0)+1,S),{});console.log("ðŸŒ¬ï¸ CONSOLIDATED: Arrow breakdown:",e)}catch(e){console.error("ðŸŒ¬ï¸ CONSOLIDATED: Error creating wind arrows:",e)}}else console.log(`ðŸŒ¬ï¸ CONSOLIDATED: No wind arrows to create (${l.length} arrow data, rigWeatherIntegration: ${!!window.rigWeatherIntegration})`);r(),setTimeout(()=>{const e=[this.layerId+"-outermost",this.layerId+"-outer",this.layerId+"-middle",this.layerId+"-inner",this.layerId+"-innermost",this.layerId+"-points-outer",this.layerId+"-points-middle",this.layerId+"-points-inner",this.layerId+"-lines"],S=e.filter(A=>this.map.getLayer(A));S.length>0?console.log(`âœ… WeatherCirclesLayer: ${S.length} layers successfully added to map:`,S):(console.warn("âš ï¸ WeatherCirclesLayer: No weather circle layers found in map after adding - this may be normal if no features were created"),console.log("ðŸ” WeatherCirclesLayer: Available layers:",e.map(A=>({id:A,exists:!!this.map.getLayer(A)}))))},200)}createRingFeature(o,a){const r=o.extractedCoordinates;if(!r||!Array.isArray(r)||r.length!==2)return console.warn("WeatherCirclesLayer: Invalid extractedCoordinates:",r),null;const l=o.ranking2,i=this.getAviationRankingColor(l);console.log(`ðŸŽ¨ RING CREATION: ${a} ring for ${o.airportIcao} (${o.circleType}) at ${r} with ranking ${o.ranking2} = COLOR ${i}`);const c=this.getCircleRadius(l);let n;switch(a){case"outermost":n=c*1.8;break;case"outer":n=c*1.4;break;case"middle":n=c*1;break;case"inner":n=c*.7;break;case"innermost":n=c*.4;break;default:n=c}if(!window.turf)return console.warn("WeatherCirclesLayer: Turf.js not available, creating simple point feature"),{type:"Feature",geometry:{type:"Point",coordinates:r},properties:{airportIcao:o.airportIcao||"Unknown",ranking:l,color:i,isRig:o.isRig||!1,radius:n*1e3,ringType:a}};const u=window.turf.point(r);return{type:"Feature",geometry:window.turf.buffer(u,n,{units:"kilometers"}).geometry,properties:{airportIcao:o.airportIcao||"Unknown",ranking:l,color:i,isRig:o.isRig||!1,ringType:a}}}parseGeoPoint(o){if(!o)return null;console.log("WeatherCirclesLayer: Parsing geoPoint:",o);try{const a=o.split(",");if(a.length===2){const r=parseFloat(a[0].trim()),l=parseFloat(a[1].trim());if(console.log("WeatherCirclesLayer: Parsed coordinates:",{lat:r,lon:l,isValidLat:!isNaN(r),isValidLon:!isNaN(l)}),!isNaN(r)&&!isNaN(l)){const i=[l,r];return console.log("WeatherCirclesLayer: Final coordinates (GeoJSON format):",i),r>=-90&&r<=90&&l>=-180&&l<=180?i:(console.warn("WeatherCirclesLayer: Coordinates out of valid range:",{lat:r,lon:l}),null)}}}catch(a){console.error("WeatherCirclesLayer: Error parsing geoPoint:",o,a)}return null}getCircleRadius(o){switch(o){case 5:return 8*1.2;case 8:return 8*1.1;case 10:return 8;case 15:return 8*.9;case 20:return 8*.8;default:return 8}}getAviationRankingColor(o){switch(o){case 5:return"#D32F2F";case 8:return"#8E24AA";case 10:return"#F57C00";case 15:return"#66BB6A";case 20:return"#616161";default:return"#1976D2"}}removeWeatherCircles(){window.weatherCirclesCreationInProgress&&(console.log("ðŸ”“ WeatherCirclesLayer: Clearing creation lock during removal"),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null);try{const o=this.layerId+"-hover-areas";this.map.getLayer(o)&&(this.map.off("mouseenter",o),this.map.off("mouseleave",o),console.log("ðŸ§¹ Removed weather hover event listeners")),this.popup&&(this.popup.remove(),this.popup=null,console.log("ðŸ§¹ Removed weather popup instance")),["-outermost","-outer","-middle","-inner","-innermost"].forEach(i=>{this.map.getLayer(this.layerId+i)&&this.map.removeLayer(this.layerId+i)}),["-points-outer","-points-middle","-points-inner"].forEach(i=>{this.map.getLayer(this.layerId+i)&&this.map.removeLayer(this.layerId+i)}),this.map.getLayer(this.layerId)&&this.map.removeLayer(this.layerId),this.map.getLayer(this.layerId+"-points")&&this.map.removeLayer(this.layerId+"-points"),this.map.getLayer(this.layerId+"-lines")&&this.map.removeLayer(this.layerId+"-lines"),this.map.getLayer(this.layerId+"-lines-shadow")&&this.map.removeLayer(this.layerId+"-lines-shadow"),this.map.getSource(this.sourceId+"-lines")&&this.map.removeSource(this.sourceId+"-lines"),this.map.getSource(this.sourceId+"-lines-shadow")&&this.map.removeSource(this.sourceId+"-lines-shadow"),this.map.getLayer(this.layerId+"-hover-areas")&&this.map.removeLayer(this.layerId+"-hover-areas"),this.map.getSource(this.sourceId+"-hover-areas")&&this.map.removeSource(this.sourceId+"-hover-areas"),["-outermost","","-middle","-inner","-innermost"].forEach(i=>{this.map.getSource(this.sourceId+i)&&this.map.removeSource(this.sourceId+i)})}catch(o){console.error("WeatherCirclesLayer: Error removing weather circles:",o)}}toggle(){this.isVisible=!this.isVisible;const o=this.isVisible?"visible":"none";this.map.getLayer(this.layerId)&&this.map.setLayoutProperty(this.layerId,"visibility",o)}addTestCircles(){console.log("WeatherCirclesLayer: Adding test circles for debugging"),console.log("WeatherCirclesLayer: Map state:",{hasMap:!!this.map,mapLoaded:this.map?this.map.loaded?this.map.loaded():"checking...":!1,mapStyle:this.map?this.map.getStyle():null});const o=[{geoPoint:"27.5, -90.5",airportIcao:"TEST1",ranking2:5,isRig:!1},{geoPoint:"28.0, -89.5",airportIcao:"TEST2",ranking2:8,isRig:!0},{geoPoint:"26.8, -91.2",airportIcao:"TEST3",ranking2:15,isRig:!1},{geoPoint:"27.8, -88.5",airportIcao:"TEST4",ranking2:10,isRig:!1}];console.log("WeatherCirclesLayer: Created test segments:",o),this.addWeatherCircles(o)}addAlternateLines(o){console.log("ðŸ”— Adding curved dotted lines for weather alternate routes");const a=window.flightAlternateData;let r=null;if(a&&a.splitPoint)if(typeof a.splitPoint=="string"){const i=a.splitPoint.split(",");if(i.length===2){const c=parseFloat(i[0].trim());r=[parseFloat(i[1].trim()),c],console.log("ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point:",r)}}else Array.isArray(a.splitPoint)&&(r=a.splitPoint,console.log("ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point array:",r));r||(console.warn("ðŸŽ¯ WARNING: No correct split point available from flight data - alternate lines may be incorrect"),console.warn("ðŸŽ¯ Available flight alternate data:",a));const l=[];if(o.forEach(i=>{if(i.alternateGeoShape&&i.alternateGeoShape.coordinates&&i.alternateGeoShape.coordinates.length>=2){const c=r||i.alternateGeoShape.coordinates[0],n=i.alternateGeoShape.coordinates[1];console.log(`ðŸ”— Creating curved line from split ${JSON.stringify(c)} to ${i.airportIcao} ${JSON.stringify(n)}`),console.log(`ðŸŽ¯ SPLIT POINT SOURCE: ${r?"Flight Data (CORRECT)":"Weather Segment (FALLBACK)"}`),console.log(`ðŸš¨ LINE DEBUG: Full coordinates array for ${i.airportIcao}:`,JSON.stringify(i.alternateGeoShape.coordinates,null,2));const y={type:"Feature",geometry:{type:"LineString",coordinates:[c,n]},properties:{type:"weather-alternate-line",airportIcao:i.airportIcao,ranking:i.ranking2,isRig:i.isRig||!1}};l.push(y)}}),l.length>0){const i=this.sourceId+"-lines",c=this.layerId+"-lines";try{this.map.getLayer(c)&&this.map.removeLayer(c),this.map.getSource(i)&&this.map.removeSource(i),this.map.addSource(i,{type:"geojson",data:{type:"FeatureCollection",features:l}}),this.map.addSource(i+"-shadow",{type:"geojson",data:{type:"FeatureCollection",features:this.createStraightShadowLines(o)}}),this.map.addLayer({id:c+"-shadow",type:"line",source:i+"-shadow",paint:{"line-color":"rgba(0, 0, 0, 0.2)","line-width":2,"line-blur":1},layout:{visibility:"visible"}}),this.map.addLayer({id:c,type:"line",source:i,paint:{"line-color":"#999999","line-width":1,"line-dasharray":[3,3]},layout:{visibility:"visible"}}),console.log("ðŸ”— Added",l.length,"curved dotted weather alternate lines")}catch(n){console.error("ðŸ”— Error adding alternate lines:",n)}}else console.log("ðŸ”— No valid segments found for alternate lines")}addWeatherHoverPopups(o){console.log("ðŸŽ¯ WEATHER POPUPS: Re-enabling weather circle hover popups"),this.popup&&(this.popup.remove(),this.popup=null);const a=this.layerId+"-hover-areas";this.map.getLayer(a)&&(this.map.off("mouseenter",a),this.map.off("mouseleave",a)),this.addInvisibleHoverAreas(o),this.map.on("mouseenter",a,r=>{if(r.features.length>0){const l=r.features[0],i=l.properties.airportIcao,c=l.properties.ranking,n=this.findWeatherSegmentByIcao(i),u=this.createDetailedWeatherPopup(i,c,n,l.properties.ringType);this.popup=new window.mapboxgl.Popup({closeButton:!1,closeOnClick:!1,className:"weather-circle-popup"}).setLngLat(r.lngLat).setHTML(u).addTo(this.map),this.map.getCanvas().style.cursor="pointer"}}),this.map.on("mouseleave",a,()=>{this.popup&&(this.popup.remove(),this.popup=null),this.map.getCanvas().style.cursor=""}),console.log("ðŸŽ¯ WEATHER POPUPS: Weather circle hover popups enabled")}addInvisibleHoverAreas(o){if(!o||o.length===0){console.warn("No weather segments provided for hover areas");return}const a=o.filter(r=>r.extractedCoordinates).map(r=>this.createHoverAreaFeature(r)).filter(r=>r!==null);if(console.log(`ðŸŽ¯ Creating ${a.length} hover areas from ${o.length} segments`),a.length===0){console.log("No hover area features to create");return}this.map.addSource(this.sourceId+"-hover-areas",{type:"geojson",data:{type:"FeatureCollection",features:a}}),this.map.addLayer({id:this.layerId+"-hover-areas",type:"fill",source:this.sourceId+"-hover-areas",paint:{"fill-color":"transparent","fill-opacity":0},layout:{visibility:"visible"}}),console.log("ðŸŽ¯ Added invisible hover areas for easy targeting")}createHoverAreaFeature(o){const a=o.extractedCoordinates;if(!a||!Array.isArray(a)||a.length!==2)return null;const r=o.ranking2,i=this.getCircleRadius(r)*.4;if(!window.turf)return console.warn("WeatherCirclesLayer: Turf.js not available for hover areas"),null;const c=window.turf.point(a);return{type:"Feature",geometry:window.turf.buffer(c,i,{units:"kilometers"}).geometry,properties:{airportIcao:o.airportIcao||"Unknown",ranking:o.ranking2,isRig:o.isRig||!1,ringType:o.circleType||"weather"}}}findWeatherSegmentByIcao(o){return this.currentWeatherSegments?this.currentWeatherSegments.find(a=>a.airportIcao===o||a.airportIcao===o.replace("-SPLIT","")):null}createDetailedWeatherPopup(o,a,r,l){const i=this.getFuelStatus(a),c=this.getAviationRankingColor(a);let n=`
      <div class="weather-popup-content" style="font-size: 13px; line-height: 1.4;">
        <h4 style="margin: 0 0 8px 0; color: ${c}; font-size: 16px;">
          ${o}
        </h4>
    `;if(r){if(r.arrivalTime){const u=new Date(r.arrivalTime).toLocaleTimeString();n+=`
          <div style="margin-bottom: 6px; font-size: 13px;">
            <strong>Arrival:</strong> ${u}
          </div>
        `}n+=`
        <div style="margin-bottom: 8px; font-size: 13px; color: ${c};">
          <strong>${i}</strong>
        </div>
      `,r.rawMetar&&(n+=`
          <div style="margin-bottom: 8px;">
            <strong>METAR:</strong><br>
            <span style="font-family: monospace; font-size: 11px; word-break: break-all;">${r.rawMetar}</span>
          </div>
        `),r.rawTaf&&(n+=`
          <div style="margin-bottom: 6px;">
            <strong>TAF:</strong><br>
            <span style="font-family: monospace; font-size: 11px; word-break: break-all;">${r.rawTaf}</span>
          </div>
        `)}return n+=`
      </div>
    `,n}getFuelStatus(o){switch(o){case 5:return"Below Minimums";case 8:return"ARA Fuel Needed";case 10:return"Approach Fuel Needed";case 15:return"Good Conditions";case 20:return"Good Conditions";default:return"Weather Conditions"}}getWeatherDescription(o){switch(o){case 5:return"Below Minimums - Cannot Land";case 8:return"ARA Fuel Required - Poor Conditions";case 10:return"Warning Conditions - Approach Fuel Needed";case 15:return"Good Conditions - Safe to Land";case 20:return"Not Applicable - No Landing Restrictions";default:return`Ranking ${o} - Custom Conditions`}}deduplicateCirclesByLocation(o){const a=new Map;return o.forEach(r=>{if(!r.extractedCoordinates)return;const[l,i]=r.extractedCoordinates,c=`${Math.round(l*1e4)},${Math.round(i*1e4)}`,n=a.get(c);if(!n||this.getCirclePriority(r)>this.getCirclePriority(n)){const u=this.getAviationRankingColor(r.ranking2);a.set(c,r),console.log(`ðŸŽ¯ Deduplicate: Keeping ${r.airportIcao} (${r.circleType}) at ${c} with ranking ${r.ranking2} = COLOR ${u}`)}else{const u=this.getAviationRankingColor(n.ranking2),y=this.getAviationRankingColor(r.ranking2);console.log(`ðŸŽ¯ Deduplicate: Skipping ${r.airportIcao} (${r.circleType}) ranking=${r.ranking2} color=${y} - already have ${n.airportIcao} (${n.circleType}) ranking=${n.ranking2} color=${u}`)}}),Array.from(a.values())}getCirclePriority(o){let a=0;switch(o.circleType){case"alternate":a=200;break;case"split":a=100;break;default:a=150}const r=o.ranking2?25-o.ranking2:0;return a+r}findFirstRouteLayer(){var r;if(!this.map)return;const o=["route-shadow","route-glow","route-line","route","alternate-shadow","alternate-glow","alternate-line","alternate","waypoint","platform","airfield"],a=((r=this.map.getStyle())==null?void 0:r.layers)||[];for(const l of o){const i=a.find(c=>c.id.toLowerCase().includes(l.toLowerCase()));if(i)return console.log(`ðŸŽ¯ Weather rings will be placed before route layer: ${i.id}`),i.id}console.log("ðŸŽ¯ No route layers found, weather rings will be on top")}getRigCoordinatesFromWaypoints(o){var a,r,l,i,c;if(console.log(`ðŸ”§ DEBUG: Looking for rig coordinates for ${o}...`),console.log("ðŸ”§ DEBUG: Available window objects:",Object.keys(window).filter(n=>n.includes("waypoint")||n.includes("route"))),window.waypointManager)try{const n=window.waypointManager.waypoints||((r=(a=window.waypointManager).getWaypoints)==null?void 0:r.call(a))||window.waypointManager.currentWaypoints;if(console.log("ðŸ”§ DEBUG: WaypointManager waypoints:",n),n&&Array.isArray(n)){const y=n.find(g=>g.name===o||g.id===o||g.airportIcao===o);if(y&&y.lat&&y.lng)return console.log(`âœ… Found coordinates for rig ${o} in waypointManager:`,[y.lng,y.lat]),[y.lng,y.lat]}const u=Object.keys(window.waypointManager);console.log("ðŸ” WaypointManager available methods/properties:",u);for(const y of u){const g=window.waypointManager[y];if(Array.isArray(g)&&g.length>0){console.log(`ðŸ” Checking waypointManager.${y}:`,g);const v=g.find(T=>(T.name===o||T.id===o||T.airportIcao===o)&&T.lat&&T.lng);if(v)return console.log(`âœ… Found coordinates for rig ${o} in waypointManager.${y}:`,[v.lng,v.lat]),[v.lng,v.lat]}}}catch(n){console.warn("Error accessing waypointManager:",n)}if(window.routeCalculator)try{const n=window.routeCalculator.waypoints||((i=(l=window.routeCalculator).getWaypoints)==null?void 0:i.call(l))||((c=window.routeCalculator.currentRoute)==null?void 0:c.waypoints);if(n&&Array.isArray(n)){const u=n.find(y=>(y.name===o||y.id===o||y.airportIcao===o)&&y.lat&&y.lng);if(u)return console.log(`âœ… Found coordinates for rig ${o} in routeCalculator:`,[u.lng,u.lat]),[u.lng,u.lat]}}catch(n){console.warn("Error accessing routeCalculator:",n)}return console.warn(`âŒ Could not find coordinates for rig ${o} in any waypoint source`),null}createStraightShadowLines(o){const a=[],r=window.flightAlternateData;let l=null;if(r&&r.splitPoint)if(typeof r.splitPoint=="string"){const i=r.splitPoint.split(",");if(i.length===2){const c=parseFloat(i[0].trim());l=[parseFloat(i[1].trim()),c]}}else Array.isArray(r.splitPoint)&&(l=r.splitPoint);return o.forEach(i=>{if(i.alternateGeoShape&&i.alternateGeoShape.coordinates&&i.alternateGeoShape.coordinates.length>=2){const c=l||i.alternateGeoShape.coordinates[0],n=i.alternateGeoShape.coordinates[1],u={type:"Feature",geometry:{type:"LineString",coordinates:[c,n]},properties:{type:"weather-alternate-shadow",airportIcao:i.airportIcao}};a.push(u)}}),a}createCurvedLine(o,a){const[r,l]=o,[i,c]=a,n=(r+i)/2,u=(l+c)/2,y=i-r,g=c-l,v=Math.sqrt(y*y+g*g),T=v*.035;let F=-g/v*T,$=y/v*T;$<0&&(F=-F,$=-$);const P=n+F,R=u+$,e=25,S=[];for(let A=0;A<=e;A++){const k=A/e,m=k*k,b=1-k,E=b*b,M=E*r+2*b*k*P+m*i,d=E*l+2*b*k*R+m*c;S.push([M,d])}return S}updateWeatherCircles(o){this.addWeatherCircles(o)}static autoCreateOnWeatherLoad(o,a){if(!(!o||!a||a.length===0))if(console.log("ðŸ”„ AUTO-CREATE: Weather segments loaded, creating weather circles automatically"),window.currentWeatherCirclesLayer)window.currentWeatherCirclesLayer.addWeatherCircles(a),console.log("ðŸ”„ AUTO-CREATE: Weather circles updated automatically");else{const r=new G(o);r.addWeatherCircles(a),window.currentWeatherCirclesLayer=r,console.log("ðŸ”„ AUTO-CREATE: Weather circles created automatically for new flight")}}static refreshFromAvailableData(o){var a;try{console.log("ðŸ”„ REFRESH: Attempting to refresh weather circles from available data");let r=null,l="none";if(((a=window.loadedWeatherSegments)==null?void 0:a.length)>0&&(r=window.loadedWeatherSegments,l="window.loadedWeatherSegments"),console.log(`ðŸ”„ REFRESH: Found data from ${l}, segments:`,(r==null?void 0:r.length)||0),r&&r.length>0&&o){if(window.currentWeatherCirclesLayer)try{window.currentWeatherCirclesLayer.removeWeatherCircles()}catch(c){console.warn("ðŸ”„ REFRESH: Error during cleanup:",c)}const i=new G(o);return i.addWeatherCircles(r),window.currentWeatherCirclesLayer=i,console.log("ðŸ”„ REFRESH: Weather circles refreshed successfully"),!0}else return console.log("ðŸ”„ REFRESH: No weather data available to refresh from"),!1}catch(r){return console.error("ðŸ”„ REFRESH: Error refreshing weather circles:",r),!1}}}window.refreshWeatherCircles=()=>{var W;return(W=window.mapManager)!=null&&W.map?G.refreshFromAvailableData(window.mapManager.map):(console.error("ðŸ”„ REFRESH: Map not available for refresh"),!1)};window.clearWeatherCirclesLock=()=>{if(window.weatherCirclesCreationInProgress){const W=Date.now()-(window.weatherCirclesLockTime||0);return console.log(`ðŸ”“ MANUAL: Clearing weather circles lock (was active for ${W}ms)`),window.weatherCirclesCreationInProgress=!1,window.weatherCirclesLockTime=null,!0}else return console.log("ðŸ”“ MANUAL: No active lock to clear"),!1};window.checkWeatherCirclesLock=()=>{if(window.weatherCirclesCreationInProgress){const W=Date.now()-(window.weatherCirclesLockTime||0);return console.log(`ðŸ”’ LOCK STATUS: Active for ${W}ms (set at ${new Date(window.weatherCirclesLockTime).toLocaleTimeString()})`),{active:!0,ageMs:W,setAt:window.weatherCirclesLockTime}}else return console.log("ðŸ”“ LOCK STATUS: No active lock"),{active:!1}};export{G as default};
//# sourceMappingURL=WeatherCirclesLayer-BZ5nOO58.js.map
