{"version":3,"file":"WeatherCirclesLayer-C16jtu-Q.js","sources":["../../src/components/fast-planner/modules/layers/WeatherCirclesLayer.js"],"sourcesContent":["/**\n * WeatherCirclesLayer.js\n * \n * 3D weather circles lying flat on the ground under all other elements\n * Color-coded by weather ranking using aviation-specific colors\n */\n\nclass WeatherCirclesLayer {\n  constructor(map) {\n    this.map = map;\n    this.sourceId = 'weather-circles-source';\n    this.layerId = 'weather-circles-layer';\n    this.isVisible = false;\n    this.currentWeatherSegments = [];\n  }\n\n  /**\n   * Add weather circles to the map\n   * @param {Array} weatherSegments - Array of weather segments with coordinates and rankings\n   */\n  addWeatherCircles(weatherSegments) {\n    if (!weatherSegments || !this.map) {\n      console.warn('WeatherCirclesLayer: Missing weatherSegments or map');\n      return;\n    }\n    \n    // ENHANCED RACE CONDITION PROTECTION: Check if another process is already creating weather circles\n    const lockStartTime = Date.now();\n    if (window.weatherCirclesCreationInProgress) {\n      const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n      console.log(`ðŸ”„ WeatherCirclesLayer: Creation lock active for ${lockAge}ms`);\n      \n      // If lock is older than 10 seconds OR this is a legitimate retry, clear it\n      if (lockAge > 10000) {\n        console.log('ðŸ”“ WeatherCirclesLayer: Clearing stale lock (older than 10s)');\n        window.weatherCirclesCreationInProgress = false;\n        window.weatherCirclesLockTime = null;\n      } else {\n        console.log('ðŸ”„ WeatherCirclesLayer: Recent lock detected, skipping duplicate request');\n        return;\n      }\n    }\n    \n    // Set the lock with timestamp\n    window.weatherCirclesCreationInProgress = true;\n    window.weatherCirclesLockTime = lockStartTime;\n    console.log(`ðŸ”’ WeatherCirclesLayer: Setting creation lock at ${lockStartTime}`);\n    \n    // Clear the lock after completion (with failsafe timeout)\n    const clearLock = () => {\n      if (window.weatherCirclesCreationInProgress && window.weatherCirclesLockTime === lockStartTime) {\n        window.weatherCirclesCreationInProgress = false;\n        window.weatherCirclesLockTime = null;\n        console.log(`ðŸ”“ WeatherCirclesLayer: Clearing creation lock (held for ${Date.now() - lockStartTime}ms)`);\n      }\n    };\n    \n    // Failsafe: Clear lock after 5 seconds if something goes wrong\n    setTimeout(clearLock, 5000);\n    \n    console.log('ðŸŸ¡ WeatherCirclesLayer: Adding', weatherSegments.length, 'weather circles to map');\n    \n    this.currentWeatherSegments = weatherSegments;\n    this.removeWeatherCircles();\n    \n    // CONSOLIDATED ARROW SYSTEM: Collect all arrow data first, then create all arrows at once\n    const allArrowData = [];\n    \n    // Rest of the method continues unchanged...\n    // ENHANCED APPROACH: Handle alternates, rigs, and split points\n    const validSegments = [];\n    \n    // DEDUPLICATION: First pass - identify all alternates to prioritize them\n    const alternateLocations = new Set();\n    const processedLocations = new Set();\n    \n    // First pass: collect all alternate locations\n    weatherSegments.forEach(segment => {\n      if (segment.alternateGeoShape && (segment.airportIcao || segment.locationName)) {\n        alternateLocations.add(segment.airportIcao || segment.locationName);\n      }\n    });\n    \n    console.log('ðŸ”„ DEDUP: Found alternates for locations:', Array.from(alternateLocations));\n    \n    weatherSegments.forEach((segment, index) => {\n      console.log(`ðŸ” Segment ${index}:`, {\n        airportIcao: segment.airportIcao,\n        locationName: segment.locationName,\n        isRig: segment.isRig,\n        alternateGeoShape: segment.alternateGeoShape,\n        ranking2: segment.ranking2,\n        hasAlternateCoords: !!(segment.alternateGeoShape?.coordinates?.length >= 2),\n        hasGeoPoint: !!segment.geoPoint,\n        geoPoint: segment.geoPoint\n      });\n      \n      const hasValidRanking = (segment.ranking2 !== undefined && segment.ranking2 !== null);\n      \n      if (!hasValidRanking) {\n        console.log(`âŒ Invalid segment ${index}: no valid ranking`);\n        return;\n      }\n      \n      // DUPLICATE CHECK: Skip destinations if there's an alternate for the same location\n      const locationKey = segment.airportIcao || segment.locationName;\n      if (locationKey) {\n        // If this is a destination (no alternateGeoShape) and there's an alternate for this location, skip it\n        if (!segment.isRig && !segment.alternateGeoShape && alternateLocations.has(locationKey)) {\n          console.log(`ðŸ”„ DEDUP: Skipping destination ${locationKey} - alternate exists for same location`);\n          return;\n        }\n        \n        // If we already processed this exact location, skip it\n        if (processedLocations.has(locationKey)) {\n          console.log(`ðŸ”„ DEDUP: Skipping duplicate ${locationKey} - already processed`);\n          return;\n        }\n        \n        // Mark this location as processed\n        processedLocations.add(locationKey);\n      }\n      \n      // Handle ALTERNATE destinations (have alternateGeoShape)\n      if (segment.alternateGeoShape && \n          segment.alternateGeoShape.coordinates && \n          Array.isArray(segment.alternateGeoShape.coordinates) &&\n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        const ranking = segment.ranking2;\n        \n        // Add alternate destination circle (coordinates[1])\n        const alternateSegment = {\n          ...segment,\n          ranking2: ranking,\n          extractedCoordinates: segment.alternateGeoShape.coordinates[1],\n          circleType: 'alternate'\n        };\n        validSegments.push(alternateSegment);\n        console.log(`âœ… Alternate ${index}: ${segment.airportIcao} at ${JSON.stringify(segment.alternateGeoShape.coordinates[1])} with ranking ${ranking}`);\n        console.log(`ðŸš¨ COORDINATE DEBUG: Full alternateGeoShape.coordinates for ${segment.airportIcao}:`, JSON.stringify(segment.alternateGeoShape.coordinates, null, 2));\n        \n        // COLLECT ALTERNATE ARROW DATA: Store for batch creation later\n        console.log(`ðŸŒ¬ï¸ COLLECTING: Alternate arrow data for ${segment.airportIcao}`);\n        \n        // Extract wind data for this alternate\n        let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n        \n        // Try METAR first (for airports)\n        let comprehensiveMetarData = null;\n        if (segment.rawMetar && window.weatherVisualizationManager) {\n          const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n          const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n          const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n          \n          // Parse comprehensive METAR data for alternates\n          comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n          \n          if (metarSpeed !== null && metarDir !== null) {\n            windSpeed = metarSpeed;\n            windDirection = metarDir;\n            windGust = metarGust;\n            windSource = 'METAR';\n          }\n        }\n        \n        // Use segment wind data if no METAR\n        if (windSpeed === null && segment.windSpeed) {\n          windSpeed = segment.windSpeed;\n          windDirection = segment.windDirection;\n          windGust = segment.windGust;\n          windSource = 'Segment';\n        }\n        \n        if (windSpeed !== null) {\n          allArrowData.push({\n            rigName: segment.airportIcao,\n            latitude: segment.alternateGeoShape.coordinates[1][1],\n            longitude: segment.alternateGeoShape.coordinates[1][0],\n            isAirport: !segment.isRig,\n            windSpeed: windSpeed,\n            windDirection: windDirection,\n            windGust: windGust,\n            windSource: windSource,\n            flightCategory: segment.flightCategory || 'VFR',\n            visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n            temperature: comprehensiveMetarData?.temperature || segment.temperature,\n            conditions: segment.conditions || segment.weather || 'Clear',\n            stationId: segment.airportIcao,\n            locationType: 'alternate',\n            // Enhanced METAR data for better popups\n            comprehensiveMetar: comprehensiveMetarData,\n            rawMetar: segment.rawMetar,\n            rawTaf: segment.rawTaf,\n            clouds: comprehensiveMetarData?.clouds || [],\n            weatherConditions: comprehensiveMetarData?.conditions || [],\n            altimeter: comprehensiveMetarData?.altimeter,\n            dewpoint: comprehensiveMetarData?.dewpoint\n          });\n          console.log(`ðŸŒ¬ï¸ COLLECTED: Alternate ${segment.airportIcao} arrow data`);\n        } else {\n          console.log(`ðŸŒ¬ï¸ SKIP: No wind data for alternate ${segment.airportIcao}`);\n        }\n        \n        // SKIP split point circles - they were creating unwanted rig weather\n        console.log(`â­ï¸ Skipping split point for ${segment.airportIcao} - only showing alternate destination`);\n      }\n      \n      // Handle RIGS - find coordinates from current waypoints/route\n      else if (segment.isRig) {\n        console.log(`ðŸ›¢ï¸ Processing rig weather: ${segment.airportIcao}`);\n        \n        // Try to get rig coordinates from multiple sources\n        let rigCoordinates = null;\n        \n        // Method 1: Check current waypoints (most reliable)\n        if (window.currentWaypoints && Array.isArray(window.currentWaypoints)) {\n          const matchingWaypoint = window.currentWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from currentWaypoints:`, rigCoordinates);\n          }\n        }\n        \n        // Method 2: Check waypoint manager\n        if (!rigCoordinates && window.waypointManager?.getWaypoints) {\n          const waypoints = window.waypointManager.getWaypoints();\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from waypointManager:`, rigCoordinates);\n          }\n        }\n        \n        // Method 3: Check global waypoints state (from React)\n        if (!rigCoordinates && window.globalWaypoints && Array.isArray(window.globalWaypoints)) {\n          const matchingWaypoint = window.globalWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            rigCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from globalWaypoints:`, rigCoordinates);\n          }\n        }\n        \n        // Method 4: Check stop cards for coordinates (they have all the lat/lng data!)\n        if (!rigCoordinates && window.debugStopCards && Array.isArray(window.debugStopCards)) {\n          const matchingStopCard = window.debugStopCards.find(card => \n            card.name === segment.airportIcao || \n            card.name?.toUpperCase() === segment.airportIcao?.toUpperCase() ||\n            card.stop === segment.airportIcao ||\n            card.stop?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingStopCard && matchingStopCard.coordinates) {\n            rigCoordinates = matchingStopCard.coordinates;\n            console.log(`ðŸ›¢ï¸ Found rig ${segment.airportIcao} coordinates from stopCards:`, rigCoordinates);\n          }\n        }\n        \n        if (rigCoordinates) {\n          const rigSegment = {\n            ...segment,\n            ranking2: segment.ranking2,\n            extractedCoordinates: rigCoordinates,\n            circleType: 'rig'\n          };\n          validSegments.push(rigSegment);\n          console.log(`âœ… Rig ${segment.airportIcao}: Found coordinates ${JSON.stringify(rigCoordinates)} with ranking ${segment.ranking2}`);\n          \n          // COLLECT RIG ARROW DATA: Store for batch creation later\n          console.log(`ðŸŒ¬ï¸ COLLECTING: Rig arrow data for ${segment.airportIcao}`);\n          \n          // Extract wind data for this rig\n          let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n          \n          // DEBUG: Log all available wind fields for rigs\n          console.log(`ðŸŒ¬ï¸ RIG DEBUG: Available wind fields for ${segment.airportIcao}:`, {\n            rawMetar: segment.rawMetar,\n            rawTaf: segment.rawTaf,\n            windSpeed: segment.windSpeed,\n            windDirection: segment.windDirection,\n            windGust: segment.windGust,\n            wind: segment.wind,\n            allKeys: Object.keys(segment).filter(key => key.toLowerCase().includes('wind'))\n          });\n          \n          // Try METAR first (for airports AND rigs - they both have METAR data!)\n          let comprehensiveMetarData = null;\n          if (segment.rawMetar && window.weatherVisualizationManager) {\n            console.log(`ðŸŒ¬ï¸ RIG METAR: Parsing METAR for ${segment.airportIcao}: \"${segment.rawMetar}\"`);\n            \n            // Parse wind data\n            const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n            const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n            const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n            \n            // Parse comprehensive METAR data  \n            comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n            \n            console.log(`ðŸŒ¬ï¸ RIG METAR: Parsed values - Speed: ${metarSpeed}, Dir: ${metarDir}, Gust: ${metarGust}`);\n            console.log(`ðŸŒ¬ï¸ RIG METAR: Comprehensive data:`, comprehensiveMetarData);\n            \n            if (metarSpeed !== null && metarDir !== null) {\n              windSpeed = metarSpeed;\n              windDirection = metarDir;\n              windGust = metarGust;\n              windSource = 'METAR';\n              console.log(`ðŸŒ¬ï¸ RIG METAR: âœ… Successfully extracted wind from METAR for ${segment.airportIcao}`);\n            } else {\n              console.log(`ðŸŒ¬ï¸ RIG METAR: âŒ METAR parsing failed for ${segment.airportIcao}`);\n            }\n          }\n          \n          // Try TAF data for rigs (pseudo TAF)\n          if (windSpeed === null && segment.rawTaf && window.weatherVisualizationManager) {\n            console.log(`ðŸŒ¬ï¸ RIG TAF: Parsing TAF for ${segment.airportIcao}: \"${segment.rawTaf}\"`);\n            \n            // TAF uses same wind format as METAR\n            const tafSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawTaf);\n            const tafDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawTaf);\n            const tafGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawTaf);\n            \n            console.log(`ðŸŒ¬ï¸ RIG TAF: Parsed values - Speed: ${tafSpeed}, Dir: ${tafDir}, Gust: ${tafGust}`);\n            \n            if (tafSpeed !== null && tafDir !== null) {\n              windSpeed = tafSpeed;\n              windDirection = tafDir;\n              windGust = tafGust;\n              windSource = 'Pseudo TAF';\n              console.log(`ðŸŒ¬ï¸ RIG TAF: âœ… Successfully extracted wind from TAF for ${segment.airportIcao}`);\n            }\n          }\n          \n          // Use direct segment wind data (for rigs)\n          if (windSpeed === null && segment.windSpeed !== undefined && segment.windSpeed !== null) {\n            windSpeed = segment.windSpeed;\n            windDirection = segment.windDirection;\n            windGust = segment.windGust;\n            windSource = 'Rig Model Data';\n          }\n          \n          // Try alternative wind field names for rigs\n          if (windSpeed === null && segment.wind) {\n            if (typeof segment.wind === 'object') {\n              windSpeed = segment.wind.speed || segment.wind.windSpeed;\n              windDirection = segment.wind.direction || segment.wind.windDirection;\n              windGust = segment.wind.gust || segment.wind.windGust;\n              windSource = 'Rig Wind Object';\n            }\n          }\n          \n          // Try other possible wind field names\n          if (windSpeed === null) {\n            const possibleSpeedFields = ['windSpeedKts', 'windSpeedMps', 'speed', 'wspd'];\n            const possibleDirFields = ['windDirectionDeg', 'direction', 'wdir'];\n            \n            for (const field of possibleSpeedFields) {\n              if (segment[field] !== undefined && segment[field] !== null) {\n                windSpeed = segment[field];\n                windSource = `Rig Field: ${field}`;\n                break;\n              }\n            }\n            \n            for (const field of possibleDirFields) {\n              if (segment[field] !== undefined && segment[field] !== null) {\n                windDirection = segment[field];\n                break;\n              }\n            }\n          }\n          \n          if (windSpeed !== null) {\n            allArrowData.push({\n              rigName: segment.airportIcao,\n              latitude: rigCoordinates[1],\n              longitude: rigCoordinates[0],\n              isAirport: false,\n              windSpeed: windSpeed,\n              windDirection: windDirection,\n              windGust: windGust,\n              windSource: windSource,\n              flightCategory: segment.flightCategory || 'VFR',\n              visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n              temperature: comprehensiveMetarData?.temperature || segment.temperature,\n              conditions: segment.conditions || segment.weather || 'Clear',\n              stationId: segment.airportIcao,\n              locationType: 'rig',\n              // Enhanced METAR data for better popups\n              comprehensiveMetar: comprehensiveMetarData,\n              rawMetar: segment.rawMetar,\n              rawTaf: segment.rawTaf,\n              clouds: comprehensiveMetarData?.clouds || [],\n              weatherConditions: comprehensiveMetarData?.conditions || [],\n              altimeter: comprehensiveMetarData?.altimeter,\n              dewpoint: comprehensiveMetarData?.dewpoint\n            });\n            console.log(`ðŸŒ¬ï¸ COLLECTED: Rig ${segment.airportIcao} arrow data`);\n          } else {\n            console.log(`ðŸŒ¬ï¸ SKIP: No wind data for rig ${segment.airportIcao}`);\n          }\n        } else {\n          console.log(`âŒ Rig ${segment.airportIcao}: Could not find coordinates in any source`);\n        }\n      \n      // Handle DESTINATIONS (airports that are not rigs)\n      } else if (!segment.isRig) {\n        console.log(`âœˆï¸ Processing destination weather: ${segment.airportIcao || segment.locationName}`);\n        \n        // Try to get destination coordinates from multiple sources\n        let destinationCoordinates = null;\n        \n        // Method 1: Try geoPoint first if available\n        if (segment.geoPoint) {\n          destinationCoordinates = this.parseGeoPoint(segment.geoPoint);\n          if (destinationCoordinates) {\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from geoPoint:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 2: Check current waypoints if geoPoint failed\n        if (!destinationCoordinates && window.currentWaypoints && Array.isArray(window.currentWaypoints)) {\n          const matchingWaypoint = window.currentWaypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            destinationCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from currentWaypoints:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 3: Check waypoint manager\n        if (!destinationCoordinates && window.waypointManager?.getWaypoints) {\n          const waypoints = window.waypointManager.getWaypoints();\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === segment.airportIcao || \n            wp.name?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingWaypoint && matchingWaypoint.lng && matchingWaypoint.lat) {\n            destinationCoordinates = [matchingWaypoint.lng, matchingWaypoint.lat];\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from waypointManager:`, destinationCoordinates);\n          }\n        }\n        \n        // Method 4: Check stop cards for coordinates\n        if (!destinationCoordinates && window.debugStopCards && Array.isArray(window.debugStopCards)) {\n          const matchingStopCard = window.debugStopCards.find(card => \n            card.name === segment.airportIcao || \n            card.name?.toUpperCase() === segment.airportIcao?.toUpperCase() ||\n            card.stop === segment.airportIcao ||\n            card.stop?.toUpperCase() === segment.airportIcao?.toUpperCase()\n          );\n          if (matchingStopCard && matchingStopCard.coordinates) {\n            destinationCoordinates = matchingStopCard.coordinates;\n            console.log(`âœˆï¸ Found destination ${segment.airportIcao} coordinates from stopCards:`, destinationCoordinates);\n          }\n        }\n        \n        if (destinationCoordinates) {\n          const destinationSegment = {\n            ...segment,\n            ranking2: segment.ranking2,\n            extractedCoordinates: destinationCoordinates,\n            circleType: 'destination'\n          };\n          validSegments.push(destinationSegment);\n          console.log(`âœ… Destination ${segment.airportIcao || segment.locationName}: Found coordinates ${JSON.stringify(destinationCoordinates)} with ranking ${segment.ranking2}`);\n          \n          // COLLECT DESTINATION ARROW DATA: Store for batch creation later\n          console.log(`ðŸŒ¬ï¸ COLLECTING: Destination arrow data for ${segment.airportIcao}`);\n          \n          // Extract wind data for this destination\n          let windSpeed = null, windDirection = null, windGust = null, windSource = 'Unknown';\n          \n          // Try METAR first (airports should have METAR)\n          let comprehensiveMetarData = null;\n          if (segment.rawMetar && window.weatherVisualizationManager) {\n            const metarSpeed = window.weatherVisualizationManager.parseWindSpeedFromMetar(segment.rawMetar);\n            const metarDir = window.weatherVisualizationManager.parseWindDirectionFromMetar(segment.rawMetar);\n            const metarGust = window.weatherVisualizationManager.parseWindGustFromMetar(segment.rawMetar);\n            \n            // Parse comprehensive METAR data for destinations\n            comprehensiveMetarData = window.weatherVisualizationManager.parseComprehensiveMetar(segment.rawMetar);\n            \n            if (metarSpeed !== null && metarDir !== null) {\n              windSpeed = metarSpeed;\n              windDirection = metarDir;\n              windGust = metarGust;\n              windSource = 'METAR';\n            }\n          }\n          \n          // Use segment wind data if no METAR\n          if (windSpeed === null && segment.windSpeed) {\n            windSpeed = segment.windSpeed;\n            windDirection = segment.windDirection;\n            windGust = segment.windGust;\n            windSource = 'Segment';\n          }\n          \n          if (windSpeed !== null) {\n            allArrowData.push({\n              rigName: segment.airportIcao || segment.locationName,\n              latitude: destinationCoordinates[1],\n              longitude: destinationCoordinates[0],\n              isAirport: true,\n              windSpeed: windSpeed,\n              windDirection: windDirection,\n              windGust: windGust,\n              windSource: windSource,\n              flightCategory: segment.flightCategory || 'VFR',\n              visibility: comprehensiveMetarData?.visibility || segment.visibility || 10,\n              temperature: comprehensiveMetarData?.temperature || segment.temperature,\n              conditions: segment.conditions || segment.weather || 'Clear',\n              stationId: segment.airportIcao || segment.locationName,\n              locationType: 'destination',\n              // Enhanced METAR data for better popups\n              comprehensiveMetar: comprehensiveMetarData,\n              rawMetar: segment.rawMetar,\n              rawTaf: segment.rawTaf,\n              clouds: comprehensiveMetarData?.clouds || [],\n              weatherConditions: comprehensiveMetarData?.conditions || [],\n              altimeter: comprehensiveMetarData?.altimeter,\n              dewpoint: comprehensiveMetarData?.dewpoint\n            });\n            console.log(`ðŸŒ¬ï¸ COLLECTED: Destination ${segment.airportIcao} arrow data`);\n          } else {\n            console.log(`ðŸŒ¬ï¸ SKIP: No wind data for destination ${segment.airportIcao}`);\n          }\n        } else {\n          console.log(`âŒ Destination ${segment.airportIcao || segment.locationName}: Could not find coordinates from any source (geoPoint: ${segment.geoPoint})`);\n        }\n      \n      } else {\n        console.log(`âŒ Segment ${index} (${segment.airportIcao || segment.locationName}) has no coordinates and is not a rig or destination`);\n      }\n    });\n    \n    // DEDUPLICATE circles at same locations (only keep one circle per location)\n    const deduplicatedSegments = this.deduplicateCirclesByLocation(validSegments);\n    \n    console.log(`ðŸŸ¡ Found ${validSegments.length} total segments, deduplicated to ${deduplicatedSegments.length} unique locations`);\n    \n    if (deduplicatedSegments.length === 0) {\n      console.log('ðŸ”´ No valid segments found, adding test circles instead');\n      clearLock(); // Clear lock before test circles\n      this.addTestCircles();\n      return;\n    }\n    \n    console.log('ðŸŸ¢ WeatherCirclesLayer: Processing', deduplicatedSegments.length, 'deduplicated segments');\n    \n    // Create concentric ring features for each deduplicated weather segment (MORE RINGS!)\n    const outerMostFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'outermost')).filter(f => f !== null);\n    const outerFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'outer')).filter(f => f !== null);\n    const middleFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'middle')).filter(f => f !== null);\n    const innerFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'inner')).filter(f => f !== null);\n    const innerMostFeatures = deduplicatedSegments.map(segment => this.createRingFeature(segment, 'innermost')).filter(f => f !== null);\n    \n    if (outerFeatures.length === 0) {\n      console.log('ðŸ”´ No valid ring features created');\n      clearLock(); // Clear lock on error\n      return;\n    }\n    \n    console.log(`ðŸŸ¢ Created ${outerFeatures.length} concentric ring sets`);\n    \n    // Also add dotted lines to alternate destinations if available (use ORIGINAL segments for lines)\n    this.addAlternateLines(weatherSegments);\n    \n    // Add sources for each ring layer (MORE RINGS!)\n    this.map.addSource(this.sourceId + '-outermost', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: outerMostFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId, {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: outerFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-middle', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: middleFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-inner', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: innerFeatures\n      }\n    });\n    \n    this.map.addSource(this.sourceId + '-innermost', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: innerMostFeatures\n      }\n    });\n    \n    // Determine layer type based on geometry type\n    const hasCircleGeometry = outerFeatures.some(f => f.geometry.type === 'Polygon');\n    const hasPointGeometry = outerFeatures.some(f => f.geometry.type === 'Point');\n    \n    console.log('WeatherCirclesLayer: Geometry types found:', { hasCircleGeometry, hasPointGeometry });\n    \n    // Add concentric ring layers for weather area effect (BELOW route layers)\n    // Find the first route layer to insert weather rings before it\n    let beforeLayer = this.findFirstRouteLayer();\n    \n    if (hasCircleGeometry) {\n      // Add multiple ring layers for fading effect (MORE RINGS!)\n      \n      // Outermost ring (biggest, most transparent)\n      this.map.addLayer({\n        id: this.layerId + '-outermost',\n        type: 'line',\n        source: this.sourceId + '-outermost',\n        filter: ['==', '$type', 'Polygon'],\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.15 // Very faint\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Outer ring (large, transparent)\n      this.map.addLayer({\n        id: this.layerId + '-outer',\n        type: 'line',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Polygon'],\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.25 // Faint\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Middle ring (medium opacity)\n      this.map.addLayer({\n        id: this.layerId + '-middle',\n        type: 'line',\n        source: this.sourceId + '-middle',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.5\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Inner ring (bright)\n      this.map.addLayer({\n        id: this.layerId + '-inner',\n        type: 'line',\n        source: this.sourceId + '-inner',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.75\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Innermost ring (brightest, most visible)\n      this.map.addLayer({\n        id: this.layerId + '-innermost',\n        type: 'line',\n        source: this.sourceId + '-innermost',\n        paint: {\n          'line-color': ['get', 'color'],\n          'line-width': 2,\n          'line-opacity': 0.95 // Brightest\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      console.log('WeatherCirclesLayer: Added 5 concentric ring layers');\n      \n      // Add hover popups for weather info\n      this.addWeatherHoverPopups(deduplicatedSegments);\n    }\n    \n    if (hasPointGeometry) {\n      // Add concentric ring layers for point features\n      const pointLayerId = this.layerId + '-points';\n      \n      // Outer ring\n      this.map.addLayer({\n        id: pointLayerId + '-outer',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 80], 60],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 3,\n          'circle-stroke-opacity': 0.3\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Middle ring\n      this.map.addLayer({\n        id: pointLayerId + '-middle',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 120], 40],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 2,\n          'circle-stroke-opacity': 0.5\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      // Inner ring (BRIGHTENED)\n      this.map.addLayer({\n        id: pointLayerId + '-inner',\n        type: 'circle',\n        source: this.sourceId,\n        filter: ['==', '$type', 'Point'],\n        paint: {\n          'circle-color': 'transparent',\n          'circle-radius': ['case', ['has', 'radius'], ['/', ['get', 'radius'], 160], 25],\n          'circle-stroke-color': ['get', 'color'],\n          'circle-stroke-width': 2,\n          'circle-stroke-opacity': 0.95 // Brightened from 0.8 to 0.95\n        },\n        layout: {\n          'visibility': 'visible'\n        }\n      }, beforeLayer);\n      \n      console.log('WeatherCirclesLayer: Added concentric ring layers for points');\n      \n      // Add hover popups for weather info (pass deduplicated segments)\n      this.addWeatherHoverPopups(deduplicatedSegments);\n    }\n    \n    this.isVisible = true;\n    console.log('WeatherCirclesLayer: Added', outerFeatures.length, 'weather circles');\n    \n    // CONSOLIDATED ARROW SYSTEM: Create ALL arrows at once to prevent overwrites\n    if (allArrowData.length > 0 && window.rigWeatherIntegration) {\n      console.log(`ðŸŒ¬ï¸ CONSOLIDATED: Creating ${allArrowData.length} wind arrows for all locations:`, \n        allArrowData.map(a => `${a.rigName}(${a.locationType})`));\n      \n      // DEBUG: Show detailed breakdown of all arrow data\n      console.log(`ðŸŒ¬ï¸ CONSOLIDATED DEBUG: Full arrow data:`, allArrowData.map(a => ({\n        name: a.rigName,\n        type: a.locationType,\n        windSpeed: a.windSpeed,\n        windDirection: a.windDirection,\n        isAirport: a.isAirport\n      })));\n      \n      try {\n        // Create ALL arrows in one batch operation\n        window.rigWeatherIntegration.updateRigWeather(allArrowData);\n        console.log(`ðŸŒ¬ï¸ CONSOLIDATED: âœ… Successfully created ${allArrowData.length} wind arrows`);\n        \n        // Debug: Log what types of arrows were created\n        const arrowTypes = allArrowData.reduce((acc, arrow) => {\n          acc[arrow.locationType] = (acc[arrow.locationType] || 0) + 1;\n          return acc;\n        }, {});\n        console.log(`ðŸŒ¬ï¸ CONSOLIDATED: Arrow breakdown:`, arrowTypes);\n        \n      } catch (error) {\n        console.error(`ðŸŒ¬ï¸ CONSOLIDATED: Error creating wind arrows:`, error);\n      }\n    } else {\n      console.log(`ðŸŒ¬ï¸ CONSOLIDATED: No wind arrows to create (${allArrowData.length} arrow data, rigWeatherIntegration: ${!!window.rigWeatherIntegration})`);\n    }\n    \n    // Clear the creation lock on successful completion\n    clearLock();\n    \n    // Debug: Check if layers were actually added\n    setTimeout(() => {\n      // Check for any of the weather circle layers that should exist\n      const layersToCheck = [\n        this.layerId + '-outermost',\n        this.layerId + '-outer', \n        this.layerId + '-middle',\n        this.layerId + '-inner',\n        this.layerId + '-innermost',\n        this.layerId + '-points-outer',\n        this.layerId + '-points-middle',\n        this.layerId + '-points-inner',\n        this.layerId + '-lines'\n      ];\n      \n      const foundLayers = layersToCheck.filter(layerId => this.map.getLayer(layerId));\n      \n      if (foundLayers.length > 0) {\n        console.log(`âœ… WeatherCirclesLayer: ${foundLayers.length} layers successfully added to map:`, foundLayers);\n      } else {\n        console.warn('âš ï¸ WeatherCirclesLayer: No weather circle layers found in map after adding - this may be normal if no features were created');\n        console.log('ðŸ” WeatherCirclesLayer: Available layers:', layersToCheck.map(id => ({ id, exists: !!this.map.getLayer(id) })));\n      }\n    }, 200); // Slightly longer delay to ensure layers are fully processed\n  }\n  \n  /**\n   * Create a ring feature for a weather segment with specific size\n   * @param {Object} segment - Weather segment with extractedCoordinates and ranking\n   * @param {string} ringType - 'outer', 'middle', or 'inner'\n   * @returns {Object} GeoJSON feature\n   */\n  createRingFeature(segment, ringType) {\n    // FIXED: Use extractedCoordinates from alternateGeoShape instead of parsing geoPoint\n    const coords = segment.extractedCoordinates;\n    \n    if (!coords || !Array.isArray(coords) || coords.length !== 2) {\n      console.warn('WeatherCirclesLayer: Invalid extractedCoordinates:', coords);\n      return null;\n    }\n    \n    // Use ranking2 for color\n    const ranking = segment.ranking2;\n    const color = this.getAviationRankingColor(ranking);\n    \n    console.log(`ðŸŽ¨ RING CREATION: ${ringType} ring for ${segment.airportIcao} (${segment.circleType}) at ${coords} with ranking ${segment.ranking2} = COLOR ${color}`);\n    \n    // Get radius based on ring type (MORE RINGS!)\n    const baseRadius = this.getCircleRadius(ranking);\n    let radius;\n    switch (ringType) {\n      case 'outermost':\n        radius = baseRadius * 1.8; // Biggest ring (new)\n        break;\n      case 'outer':\n        radius = baseRadius * 1.4; // Large ring\n        break;\n      case 'middle':\n        radius = baseRadius * 1.0; // Medium ring\n        break;\n      case 'inner':\n        radius = baseRadius * 0.7; // Small ring\n        break;\n      case 'innermost':\n        radius = baseRadius * 0.4; // Smallest ring (new)\n        break;\n      default:\n        radius = baseRadius;\n    }\n    \n    // Check if Turf.js is available for circles\n    if (!window.turf) {\n      console.warn('WeatherCirclesLayer: Turf.js not available, creating simple point feature');\n      return {\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: coords\n        },\n        properties: {\n          airportIcao: segment.airportIcao || 'Unknown',\n          ranking: ranking,\n          color: color,\n          isRig: segment.isRig || false,\n          radius: radius * 1000, // Convert km to meters for point display\n          ringType: ringType\n        }\n      };\n    }\n    \n    // Create a circle polygon using Turf.js buffer\n    const center = window.turf.point(coords);\n    const circle = window.turf.buffer(center, radius, { units: 'kilometers' });\n    \n    return {\n      type: 'Feature',\n      geometry: circle.geometry,\n      properties: {\n        airportIcao: segment.airportIcao || 'Unknown',\n        ranking: ranking,\n        color: color,\n        isRig: segment.isRig || false,\n        ringType: ringType\n      }\n    };\n  }\n  \n  /**\n   * Parse geoPoint string to coordinates\n   * @param {string} geoPoint - Comma-separated lat,lng string\n   * @returns {Array} [longitude, latitude] coordinates or null\n   */\n  parseGeoPoint(geoPoint) {\n    if (!geoPoint) return null;\n    \n    console.log('WeatherCirclesLayer: Parsing geoPoint:', geoPoint);\n    \n    try {\n      const parts = geoPoint.split(',');\n      if (parts.length === 2) {\n        const lat = parseFloat(parts[0].trim());\n        const lon = parseFloat(parts[1].trim());\n        \n        console.log('WeatherCirclesLayer: Parsed coordinates:', { lat, lon, isValidLat: !isNaN(lat), isValidLon: !isNaN(lon) });\n        \n        if (!isNaN(lat) && !isNaN(lon)) {\n          // GeoJSON format: [longitude, latitude]\n          const coords = [lon, lat];\n          console.log('WeatherCirclesLayer: Final coordinates (GeoJSON format):', coords);\n          \n          // Validate coordinates are in reasonable ranges\n          if (lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180) {\n            return coords;\n          } else {\n            console.warn('WeatherCirclesLayer: Coordinates out of valid range:', { lat, lon });\n            return null;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('WeatherCirclesLayer: Error parsing geoPoint:', geoPoint, error);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get circle radius based on weather ranking\n   * @param {number} ranking - Weather ranking (5, 8, 10, 15, 20)\n   * @returns {number} Radius in kilometers\n   */\n  getCircleRadius(ranking) {\n    // Base radius that makes circles visible but not overwhelming\n    const baseRadius = 8; // 8km base radius\n    \n    // Adjust size slightly based on ranking importance\n    switch (ranking) {\n      case 5:  // Below minimums - larger, more attention\n        return baseRadius * 1.2;\n      case 8:  // ARA needed - slightly larger\n        return baseRadius * 1.1;\n      case 10: // Warning - normal size\n        return baseRadius;\n      case 15: // Good - slightly smaller\n        return baseRadius * 0.9;\n      case 20: // N/A - smaller, less prominent\n        return baseRadius * 0.8;\n      default:\n        return baseRadius;\n    }\n  }\n  \n  /**\n   * Get aviation ranking color using the centralized color system from WeatherCard.jsx\n   * @param {number} ranking - Weather ranking\n   * @returns {string} Hex color code\n   */\n  getAviationRankingColor(ranking) {\n    switch (ranking) {\n      case 5:\n        return '#D32F2F'; // Red - Below alternate minimums\n      case 8:\n        return '#8E24AA'; // Brighter purple - ARA fuel needed at rig\n      case 10:\n        return '#F57C00'; // Orange - Warning conditions\n      case 15:\n        return '#66BB6A'; // Much brighter green - Good conditions\n      case 20:\n        return '#616161'; // Grey - Not applicable to landing time\n      default:\n        return '#1976D2'; // Blue - Default/unknown\n    }\n  }\n  \n  /**\n   * Remove weather circles from map\n   */\n  removeWeatherCircles() {\n    // Clear any creation lock when removing\n    if (window.weatherCirclesCreationInProgress) {\n      console.log('ðŸ”“ WeatherCirclesLayer: Clearing creation lock during removal');\n      window.weatherCirclesCreationInProgress = false;\n      window.weatherCirclesLockTime = null;\n    }\n    \n    try {\n      // Remove event listeners BEFORE removing layers\n      const hoverLayer = this.layerId + '-hover-areas';\n      if (this.map.getLayer(hoverLayer)) {\n        this.map.off('mouseenter', hoverLayer);\n        this.map.off('mouseleave', hoverLayer);\n        console.log('ðŸ§¹ Removed weather hover event listeners');\n      }\n      \n      // Clean up popup instance\n      if (this.popup) {\n        this.popup.remove();\n        this.popup = null;\n        console.log('ðŸ§¹ Removed weather popup instance');\n      }\n      \n      // Remove all ring layers (polygon-based) - MORE RINGS!\n      const ringLayers = ['-outermost', '-outer', '-middle', '-inner', '-innermost'];\n      ringLayers.forEach(suffix => {\n        if (this.map.getLayer(this.layerId + suffix)) {\n          this.map.removeLayer(this.layerId + suffix);\n        }\n      });\n      \n      // Remove all point ring layers\n      const pointRingLayers = ['-points-outer', '-points-middle', '-points-inner'];\n      pointRingLayers.forEach(suffix => {\n        if (this.map.getLayer(this.layerId + suffix)) {\n          this.map.removeLayer(this.layerId + suffix);\n        }\n      });\n      \n      // Remove legacy layers if they exist\n      if (this.map.getLayer(this.layerId)) {\n        this.map.removeLayer(this.layerId);\n      }\n      if (this.map.getLayer(this.layerId + '-points')) {\n        this.map.removeLayer(this.layerId + '-points');\n      }\n      \n      // Remove alternate lines and their shadows\n      if (this.map.getLayer(this.layerId + '-lines')) {\n        this.map.removeLayer(this.layerId + '-lines');\n      }\n      if (this.map.getLayer(this.layerId + '-lines-shadow')) {\n        this.map.removeLayer(this.layerId + '-lines-shadow');\n      }\n      if (this.map.getSource(this.sourceId + '-lines')) {\n        this.map.removeSource(this.sourceId + '-lines');\n      }\n      if (this.map.getSource(this.sourceId + '-lines-shadow')) {\n        this.map.removeSource(this.sourceId + '-lines-shadow');\n      }\n      \n      // Remove hover areas\n      if (this.map.getLayer(this.layerId + '-hover-areas')) {\n        this.map.removeLayer(this.layerId + '-hover-areas');\n      }\n      if (this.map.getSource(this.sourceId + '-hover-areas')) {\n        this.map.removeSource(this.sourceId + '-hover-areas');\n      }\n\n      // Remove all sources - MORE RINGS!\n      const sources = ['-outermost', '', '-middle', '-inner', '-innermost'];\n      sources.forEach(suffix => {\n        if (this.map.getSource(this.sourceId + suffix)) {\n          this.map.removeSource(this.sourceId + suffix);\n        }\n      });\n    } catch (error) {\n      console.error('WeatherCirclesLayer: Error removing weather circles:', error);\n    }\n  }\n  \n  /**\n   * Toggle layer visibility\n   */\n  toggle() {\n    this.isVisible = !this.isVisible;\n    const visibility = this.isVisible ? 'visible' : 'none';\n    \n    if (this.map.getLayer(this.layerId)) {\n      this.map.setLayoutProperty(this.layerId, 'visibility', visibility);\n    }\n  }\n  \n  /**\n   * Add test weather circles for debugging\n   */\n  addTestCircles() {\n    console.log('WeatherCirclesLayer: Adding test circles for debugging');\n    console.log('WeatherCirclesLayer: Map state:', {\n      hasMap: !!this.map,\n      mapLoaded: this.map ? (this.map.loaded ? this.map.loaded() : 'checking...') : false,\n      mapStyle: this.map ? this.map.getStyle() : null\n    });\n    \n    // Create test weather segments for Gulf of Mexico\n    // Format: \"lat, lon\" - these should appear in the Gulf of Mexico around Louisiana/Texas coast\n    const testSegments = [\n      {\n        geoPoint: \"27.5, -90.5\", // Should be in Gulf of Mexico southwest of New Orleans\n        airportIcao: \"TEST1\",\n        ranking2: 5, // Use ranking2 to match real data structure\n        isRig: false\n      },\n      {\n        geoPoint: \"28.0, -89.5\", // Should be in Gulf of Mexico south of New Orleans\n        airportIcao: \"TEST2\", \n        ranking2: 8, // Use ranking2 to match real data structure\n        isRig: true\n      },\n      {\n        geoPoint: \"26.8, -91.2\", // Should be in Gulf of Mexico southwest of Louisiana\n        airportIcao: \"TEST3\",\n        ranking2: 15, // Use ranking2 to match real data structure\n        isRig: false\n      },\n      {\n        geoPoint: \"27.8, -88.5\", // Should be in Gulf of Mexico southeast of New Orleans\n        airportIcao: \"TEST4\",\n        ranking2: 10, // Use ranking2 to match real data structure\n        isRig: false\n      }\n    ];\n    \n    console.log('WeatherCirclesLayer: Created test segments:', testSegments);\n    this.addWeatherCircles(testSegments);\n  }\n  \n  /**\n   * Add curved dotted lines from split points to alternate destinations\n   * @param {Array} validSegments - Weather segments with coordinates\n   */\n  addAlternateLines(validSegments) {\n    console.log('ðŸ”— Adding curved dotted lines for weather alternate routes');\n    \n    // CRITICAL FIX: Get correct split point from flight data, not weather segments\n    const flightAlternateData = window.flightAlternateData;\n    let correctSplitPoint = null;\n    \n    if (flightAlternateData && flightAlternateData.splitPoint) {\n      // Parse the split point from flight data\n      if (typeof flightAlternateData.splitPoint === 'string') {\n        const parts = flightAlternateData.splitPoint.split(',');\n        if (parts.length === 2) {\n          const lat = parseFloat(parts[0].trim());\n          const lng = parseFloat(parts[1].trim());\n          correctSplitPoint = [lng, lat]; // GeoJSON format: [lng, lat]\n          console.log('ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point:', correctSplitPoint);\n        }\n      } else if (Array.isArray(flightAlternateData.splitPoint)) {\n        correctSplitPoint = flightAlternateData.splitPoint;\n        console.log('ðŸŽ¯ CORRECT SPLIT POINT: Using flight data split point array:', correctSplitPoint);\n      }\n    }\n    \n    if (!correctSplitPoint) {\n      console.warn('ðŸŽ¯ WARNING: No correct split point available from flight data - alternate lines may be incorrect');\n      console.warn('ðŸŽ¯ Available flight alternate data:', flightAlternateData);\n    }\n    \n    // Create curved line features for each weather segment with coordinates\n    const lineFeatures = [];\n    \n    validSegments.forEach(segment => {\n      if (segment.alternateGeoShape && segment.alternateGeoShape.coordinates && \n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        // Use correct split point from flight data, fallback to segment data if unavailable\n        const splitPoint = correctSplitPoint || segment.alternateGeoShape.coordinates[0];\n        const destination = segment.alternateGeoShape.coordinates[1]; // End point\n        \n        console.log(`ðŸ”— Creating curved line from split ${JSON.stringify(splitPoint)} to ${segment.airportIcao} ${JSON.stringify(destination)}`);\n        console.log(`ðŸŽ¯ SPLIT POINT SOURCE: ${correctSplitPoint ? 'Flight Data (CORRECT)' : 'Weather Segment (FALLBACK)'}`);\n        console.log(`ðŸš¨ LINE DEBUG: Full coordinates array for ${segment.airportIcao}:`, JSON.stringify(segment.alternateGeoShape.coordinates, null, 2));\n        \n        // Create straight line for alternate routes (cleaner look)\n        const straightCoordinates = [splitPoint, destination];\n        \n        const lineFeature = {\n          type: 'Feature',\n          geometry: {\n            type: 'LineString',\n            coordinates: straightCoordinates\n          },\n          properties: {\n            type: 'weather-alternate-line',\n            airportIcao: segment.airportIcao,\n            ranking: segment.ranking2,\n            isRig: segment.isRig || false\n          }\n        };\n        \n        lineFeatures.push(lineFeature);\n      }\n    });\n    \n    if (lineFeatures.length > 0) {\n      // Add alternate lines source and layer\n      const linesSourceId = this.sourceId + '-lines';\n      const linesLayerId = this.layerId + '-lines';\n      \n      try {\n        // Remove existing lines\n        if (this.map.getLayer(linesLayerId)) {\n          this.map.removeLayer(linesLayerId);\n        }\n        if (this.map.getSource(linesSourceId)) {\n          this.map.removeSource(linesSourceId);\n        }\n        \n        // Add new lines with drop shadow\n        this.map.addSource(linesSourceId, {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection',\n            features: lineFeatures\n          }\n        });\n        \n        // Add STRAIGHT shadow layer first (3D effect) - FIXED FOR VISIBILITY\n        this.map.addSource(linesSourceId + '-shadow', {\n          type: 'geojson',\n          data: {\n            type: 'FeatureCollection',\n            features: this.createStraightShadowLines(validSegments)\n          }\n        });\n        \n        this.map.addLayer({\n          id: linesLayerId + '-shadow',\n          type: 'line',\n          source: linesSourceId + '-shadow',\n          paint: {\n            'line-color': 'rgba(0, 0, 0, 0.2)', // LIGHTER shadow (was 0.6, now 0.2)\n            'line-width': 2, // THINNER shadow (was 3, now 2)\n            'line-blur': 1 // BLURRIER shadow effect\n            // REMOVED line-dasharray - solid line for shadow\n          },\n          layout: {\n            'visibility': 'visible'\n          }\n        });\n        \n        // Add main line layer on top (BRIGHTENED)\n        this.map.addLayer({\n          id: linesLayerId,\n          type: 'line',\n          source: linesSourceId,\n          paint: {\n            'line-color': '#999999', // Brighter grey (was #666666)\n            'line-width': 1, // Single pixel width\n            'line-dasharray': [3, 3] // Dotted pattern\n          },\n          layout: {\n            'visibility': 'visible'\n          }\n        });\n        \n        console.log('ðŸ”— Added', lineFeatures.length, 'curved dotted weather alternate lines');\n      } catch (error) {\n        console.error('ðŸ”— Error adding alternate lines:', error);\n      }\n    } else {\n      console.log('ðŸ”— No valid segments found for alternate lines');\n    }\n  }\n  \n  /**\n   * Add hover popups to show weather information\n   */\n  addWeatherHoverPopups(deduplicatedSegments) {\n    // ðŸ”— UNIFIED POPUP: OLD POPUP SYSTEM DISABLED\n    // The old Palantir popup system has been disabled to prevent conflicts with the new unified popup system.\n    // TAF/METAR data is now displayed in the unified rig weather graphics popup system instead.\n    \n    console.log('ðŸ”— UNIFIED POPUP: Old weather circle popups disabled - using unified popup system for weather data');\n    \n    // Clean up any existing popup instances\n    if (this.popup) {\n      this.popup.remove();\n      this.popup = null;\n    }\n    \n    // Remove any existing event listeners\n    const hoverLayer = this.layerId + '-hover-areas';\n    if (this.map.getLayer(hoverLayer)) {\n      this.map.off('mouseenter', hoverLayer);\n      this.map.off('mouseleave', hoverLayer);\n    }\n    \n    // Still create invisible hover areas for potential future use, but without popups\n    // This maintains the layer structure but removes the competing popup system\n    this.addInvisibleHoverAreas(deduplicatedSegments);\n    \n    console.log('ðŸ”— UNIFIED POPUP: Weather circles maintained without competing popups');\n  }\n\n  /**\n   * Add invisible filled circles for easy hover targeting\n   */\n  addInvisibleHoverAreas(segments) {\n    // Use the passed segments (deduplicated)\n    if (!segments || segments.length === 0) {\n      console.warn('No weather segments provided for hover areas');\n      return;\n    }\n\n    // Create filled circle features for each weather segment (using innermost size)\n    const hoverFeatures = segments\n      .filter(segment => segment.extractedCoordinates)\n      .map(segment => this.createHoverAreaFeature(segment))\n      .filter(f => f !== null);\n\n    console.log(`ðŸŽ¯ Creating ${hoverFeatures.length} hover areas from ${segments.length} segments`);\n\n    if (hoverFeatures.length === 0) {\n      console.log('No hover area features to create');\n      return;\n    }\n\n    // Add source for hover areas\n    this.map.addSource(this.sourceId + '-hover-areas', {\n      type: 'geojson',\n      data: {\n        type: 'FeatureCollection',\n        features: hoverFeatures\n      }\n    });\n\n    // Add invisible filled layer for hover detection\n    this.map.addLayer({\n      id: this.layerId + '-hover-areas',\n      type: 'fill',\n      source: this.sourceId + '-hover-areas',\n      paint: {\n        'fill-color': 'transparent',\n        'fill-opacity': 0 // Completely invisible\n      },\n      layout: {\n        'visibility': 'visible'\n      }\n    });\n\n    console.log('ðŸŽ¯ Added invisible hover areas for easy targeting');\n  }\n\n  /**\n   * Create a filled circle feature for hover detection\n   * @param {Object} segment - Weather segment with coordinates\n   * @returns {Object} GeoJSON feature for hover\n   */\n  createHoverAreaFeature(segment) {\n    const coords = segment.extractedCoordinates;\n    \n    if (!coords || !Array.isArray(coords) || coords.length !== 2) {\n      return null;\n    }\n\n    // Use innermost ring size for hover area\n    const ranking = segment.ranking2;\n    const baseRadius = this.getCircleRadius(ranking);\n    const radius = baseRadius * 0.4; // Same as innermost ring\n\n    // Check if Turf.js is available\n    if (!window.turf) {\n      console.warn('WeatherCirclesLayer: Turf.js not available for hover areas');\n      return null;\n    }\n\n    // Create filled circle using Turf.js\n    const center = window.turf.point(coords);\n    const circle = window.turf.buffer(center, radius, { units: 'kilometers' });\n\n    return {\n      type: 'Feature',\n      geometry: circle.geometry,\n      properties: {\n        airportIcao: segment.airportIcao || 'Unknown',\n        ranking: segment.ranking2,\n        isRig: segment.isRig || false,\n        ringType: segment.circleType || 'weather'\n      }\n    };\n  }\n\n  /**\n   * Find weather segment by ICAO code\n   * @param {string} icao - Airport ICAO code\n   * @returns {Object|null} Weather segment data\n   */\n  findWeatherSegmentByIcao(icao) {\n    if (!this.currentWeatherSegments) return null;\n    \n    return this.currentWeatherSegments.find(segment => \n      segment.airportIcao === icao || segment.airportIcao === icao.replace('-SPLIT', '')\n    );\n  }\n\n  /**\n   * Create detailed weather popup content (same info as weather card)\n   * @param {string} icao - Airport ICAO  \n   * @param {number} ranking - Weather ranking\n   * @param {Object} segment - Weather segment data\n   * @param {string} circleType - Type of circle\n   * @returns {string} HTML content\n   */\n  createDetailedWeatherPopup(icao, ranking, segment, circleType) {\n    // Simple fuel status instead of technical ranking\n    const fuelStatus = this.getFuelStatus(ranking);\n    const color = this.getAviationRankingColor(ranking);\n    \n    let content = `\n      <div class=\"weather-popup-content\" style=\"font-size: 13px; line-height: 1.4;\">\n        <h4 style=\"margin: 0 0 8px 0; color: ${color}; font-size: 16px;\">\n          ${icao}\n        </h4>\n    `;\n\n    if (segment) {\n      // Add arrival time if available\n      if (segment.arrivalTime) {\n        const arrivalTime = new Date(segment.arrivalTime).toLocaleTimeString();\n        content += `\n          <div style=\"margin-bottom: 6px; font-size: 13px;\">\n            <strong>Arrival:</strong> ${arrivalTime}\n          </div>\n        `;\n      }\n\n      // Add simple fuel status\n      content += `\n        <div style=\"margin-bottom: 8px; font-size: 13px; color: ${color};\">\n          <strong>${fuelStatus}</strong>\n        </div>\n      `;\n\n      // Add full METAR if available\n      if (segment.rawMetar) {\n        content += `\n          <div style=\"margin-bottom: 8px;\">\n            <strong>METAR:</strong><br>\n            <span style=\"font-family: monospace; font-size: 11px; word-break: break-all;\">${segment.rawMetar}</span>\n          </div>\n        `;\n      }\n\n      // Add FULL TAF if available (no truncation)\n      if (segment.rawTaf) {\n        content += `\n          <div style=\"margin-bottom: 6px;\">\n            <strong>TAF:</strong><br>\n            <span style=\"font-family: monospace; font-size: 11px; word-break: break-all;\">${segment.rawTaf}</span>\n          </div>\n        `;\n      }\n    }\n\n    content += `\n      </div>\n    `;\n\n    return content;\n  }\n\n  /**\n   * Get simple fuel status for users\n   * @param {number} ranking - Weather ranking (5, 8, 10, 15, 20)\n   * @returns {string} Simple fuel status\n   */\n  getFuelStatus(ranking) {\n    switch (ranking) {\n      case 5:\n        return 'Below Minimums';\n      case 8:\n        return 'ARA Fuel Needed';\n      case 10:\n        return 'Approach Fuel Needed';\n      case 15:\n        return 'Good Conditions';\n      case 20:\n        return 'Good Conditions';\n      default:\n        return 'Weather Conditions';\n    }\n  }\n\n  /**\n   * Get weather description from ranking\n   * @param {number} ranking - Weather ranking (5, 8, 10, 15, 20)\n   * @returns {string} Human readable description\n   */\n  getWeatherDescription(ranking) {\n    switch (ranking) {\n      case 5:\n        return 'Below Minimums - Cannot Land';\n      case 8:\n        return 'ARA Fuel Required - Poor Conditions';\n      case 10:\n        return 'Warning Conditions - Approach Fuel Needed';\n      case 15:\n        return 'Good Conditions - Safe to Land';\n      case 20:\n        return 'Not Applicable - No Landing Restrictions';\n      default:\n        return `Ranking ${ranking} - Custom Conditions`;\n    }\n  }\n\n  /**\n   * Deduplicate circles by location (only keep one circle per unique location)\n   * @param {Array} segments - Array of weather segments with coordinates\n   * @returns {Array} Deduplicated segments\n   */\n  deduplicateCirclesByLocation(segments) {\n    const locationMap = new Map();\n    \n    segments.forEach(segment => {\n      if (!segment.extractedCoordinates) return;\n      \n      // Create a location key from coordinates (rounded to avoid floating point issues)\n      const [lng, lat] = segment.extractedCoordinates;\n      const locationKey = `${Math.round(lng * 10000)},${Math.round(lat * 10000)}`;\n      \n      // If we haven't seen this location before, or this segment has higher priority, keep it\n      const existing = locationMap.get(locationKey);\n      \n      if (!existing || this.getCirclePriority(segment) > this.getCirclePriority(existing)) {\n        const color = this.getAviationRankingColor(segment.ranking2);\n        locationMap.set(locationKey, segment);\n        console.log(`ðŸŽ¯ Deduplicate: Keeping ${segment.airportIcao} (${segment.circleType}) at ${locationKey} with ranking ${segment.ranking2} = COLOR ${color}`);\n      } else {\n        const existingColor = this.getAviationRankingColor(existing.ranking2);\n        const segmentColor = this.getAviationRankingColor(segment.ranking2);\n        console.log(`ðŸŽ¯ Deduplicate: Skipping ${segment.airportIcao} (${segment.circleType}) ranking=${segment.ranking2} color=${segmentColor} - already have ${existing.airportIcao} (${existing.circleType}) ranking=${existing.ranking2} color=${existingColor}`);\n      }\n    });\n    \n    return Array.from(locationMap.values());\n  }\n  \n  /**\n   * Get priority for circle deduplication (higher number = higher priority)\n   * @param {Object} segment - Weather segment\n   * @returns {number} Priority score\n   */\n  getCirclePriority(segment) {\n    // SIMPLIFIED: Since we're skipping rigs, only prioritize alternates vs splits\n    let basePriority = 0;\n    \n    switch (segment.circleType) {\n      case 'alternate':\n        basePriority = 200; // Higher priority for alternates\n        break;\n      case 'split':\n        basePriority = 100; // Lower priority for split points\n        break;\n      default:\n        basePriority = 150;\n    }\n    \n    // Add weather ranking priority (worse weather = higher priority)\n    // Rankings: 5=worst, 8=ara, 10=warning, 15=good, 20=n/a\n    const weatherPriority = segment.ranking2 ? (25 - segment.ranking2) : 0;\n    \n    return basePriority + weatherPriority;\n  }\n\n  /**\n   * Find the first route layer to ensure weather rings go underneath\n   * @returns {string|undefined} Layer ID to insert before, or undefined for top\n   */\n  findFirstRouteLayer() {\n    if (!this.map) return undefined;\n    \n    // Common route layer names to look for (in order of preference)\n    const routeLayerPatterns = [\n      'route-shadow',      // Route shadows (lowest route layer)\n      'route-glow',        // Route glow effects\n      'route-line',        // Main route lines\n      'route',             // Generic route layers\n      'alternate-shadow',  // Alternate route shadows\n      'alternate-glow',    // Alternate glow\n      'alternate-line',    // Alternate lines\n      'alternate',         // Generic alternate layers\n      'waypoint',          // Waypoint layers\n      'platform',          // Platform layers\n      'airfield'           // Airfield layers\n    ];\n    \n    // Get all layer IDs from the map\n    const allLayers = this.map.getStyle()?.layers || [];\n    \n    // Find the first matching route layer\n    for (const pattern of routeLayerPatterns) {\n      const matchingLayer = allLayers.find(layer => \n        layer.id.toLowerCase().includes(pattern.toLowerCase())\n      );\n      \n      if (matchingLayer) {\n        console.log(`ðŸŽ¯ Weather rings will be placed before route layer: ${matchingLayer.id}`);\n        return matchingLayer.id;\n      }\n    }\n    \n    console.log(`ðŸŽ¯ No route layers found, weather rings will be on top`);\n    return undefined; // Add on top if no route layers found\n  }\n\n  /**\n   * Get rig coordinates from waypoints data\n   * @param {string} rigIcao - Rig ICAO code to find\n   * @returns {Array|null} [lng, lat] coordinates or null\n   */\n  getRigCoordinatesFromWaypoints(rigIcao) {\n    // FIXED: Use waypointManager to get coordinates\n    console.log(`ðŸ”§ DEBUG: Looking for rig coordinates for ${rigIcao}...`);\n    console.log(`ðŸ”§ DEBUG: Available window objects:`, Object.keys(window).filter(k => k.includes('waypoint') || k.includes('route')));\n    \n    // Try waypointManager first\n    if (window.waypointManager) {\n      try {\n        // Check if waypointManager has a method to get waypoints\n        const waypoints = window.waypointManager.waypoints || \n                         window.waypointManager.getWaypoints?.() ||\n                         window.waypointManager.currentWaypoints;\n        \n        console.log(`ðŸ”§ DEBUG: WaypointManager waypoints:`, waypoints);\n        \n        if (waypoints && Array.isArray(waypoints)) {\n          const matchingWaypoint = waypoints.find(wp => \n            wp.name === rigIcao || \n            wp.id === rigIcao ||\n            wp.airportIcao === rigIcao\n          );\n          \n          if (matchingWaypoint && matchingWaypoint.lat && matchingWaypoint.lng) {\n            console.log(`âœ… Found coordinates for rig ${rigIcao} in waypointManager:`, [matchingWaypoint.lng, matchingWaypoint.lat]);\n            return [matchingWaypoint.lng, matchingWaypoint.lat]; // GeoJSON format\n          }\n        }\n        \n        // Try alternative waypoint manager properties\n        const waypointManagerKeys = Object.keys(window.waypointManager);\n        console.log(`ðŸ” WaypointManager available methods/properties:`, waypointManagerKeys);\n        \n        // Look for any property that might contain waypoints\n        for (const key of waypointManagerKeys) {\n          const value = window.waypointManager[key];\n          if (Array.isArray(value) && value.length > 0) {\n            console.log(`ðŸ” Checking waypointManager.${key}:`, value);\n            const match = value.find(wp => \n              (wp.name === rigIcao || wp.id === rigIcao || wp.airportIcao === rigIcao) &&\n              wp.lat && wp.lng\n            );\n            if (match) {\n              console.log(`âœ… Found coordinates for rig ${rigIcao} in waypointManager.${key}:`, [match.lng, match.lat]);\n              return [match.lng, match.lat];\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Error accessing waypointManager:`, error);\n      }\n    }\n    \n    // Try route calculator as fallback\n    if (window.routeCalculator) {\n      try {\n        const routeWaypoints = window.routeCalculator.waypoints || \n                              window.routeCalculator.getWaypoints?.() ||\n                              window.routeCalculator.currentRoute?.waypoints;\n        \n        if (routeWaypoints && Array.isArray(routeWaypoints)) {\n          const match = routeWaypoints.find(wp => \n            (wp.name === rigIcao || wp.id === rigIcao || wp.airportIcao === rigIcao) &&\n            wp.lat && wp.lng\n          );\n          if (match) {\n            console.log(`âœ… Found coordinates for rig ${rigIcao} in routeCalculator:`, [match.lng, match.lat]);\n            return [match.lng, match.lat];\n          }\n        }\n      } catch (error) {\n        console.warn(`Error accessing routeCalculator:`, error);\n      }\n    }\n    \n    console.warn(`âŒ Could not find coordinates for rig ${rigIcao} in any waypoint source`);\n    return null;\n  }\n\n  /**\n   * Create straight shadow lines for 3D effect\n   * @param {Array} validSegments - Weather segments with coordinates\n   * @returns {Array} Array of straight line features for shadows\n   */\n  createStraightShadowLines(validSegments) {\n    const shadowFeatures = [];\n    \n    // CRITICAL FIX: Get correct split point from flight data for shadows too\n    const flightAlternateData = window.flightAlternateData;\n    let correctSplitPoint = null;\n    \n    if (flightAlternateData && flightAlternateData.splitPoint) {\n      // Parse the split point from flight data\n      if (typeof flightAlternateData.splitPoint === 'string') {\n        const parts = flightAlternateData.splitPoint.split(',');\n        if (parts.length === 2) {\n          const lat = parseFloat(parts[0].trim());\n          const lng = parseFloat(parts[1].trim());\n          correctSplitPoint = [lng, lat]; // GeoJSON format: [lng, lat]\n        }\n      } else if (Array.isArray(flightAlternateData.splitPoint)) {\n        correctSplitPoint = flightAlternateData.splitPoint;\n      }\n    }\n    \n    validSegments.forEach(segment => {\n      if (segment.alternateGeoShape && segment.alternateGeoShape.coordinates && \n          segment.alternateGeoShape.coordinates.length >= 2) {\n        \n        // Use correct split point from flight data, fallback to segment data if unavailable\n        const splitPoint = correctSplitPoint || segment.alternateGeoShape.coordinates[0];\n        const destination = segment.alternateGeoShape.coordinates[1];\n        \n        // Create STRAIGHT line for shadow (3D effect)\n        const shadowFeature = {\n          type: 'Feature',\n          geometry: {\n            type: 'LineString',\n            coordinates: [splitPoint, destination] // Straight line for shadow\n          },\n          properties: {\n            type: 'weather-alternate-shadow',\n            airportIcao: segment.airportIcao\n          }\n        };\n        \n        shadowFeatures.push(shadowFeature);\n      }\n    });\n    \n    return shadowFeatures;\n  }\n\n  /**\n   * Create curved line coordinates between two points (same as route curves)\n   * @param {Array} start - [lng, lat] start coordinates\n   * @param {Array} end - [lng, lat] end coordinates\n   * @returns {Array} Array of curved coordinates\n   */\n  createCurvedLine(start, end) {\n    // Simple curved line implementation\n    // Uses a control point offset perpendicular to the line for the curve\n    \n    const [startLng, startLat] = start;\n    const [endLng, endLat] = end;\n    \n    // Calculate midpoint\n    const midLng = (startLng + endLng) / 2;\n    const midLat = (startLat + endLat) / 2;\n    \n    // Calculate perpendicular offset for curve (smaller for weather lines)\n    const deltaLng = endLng - startLng;\n    const deltaLat = endLat - startLat;\n    const distance = Math.sqrt(deltaLng * deltaLng + deltaLat * deltaLat);\n    \n    // Curve offset proportional to distance (MUCH LOWER curve for weather alternate lines)\n    const curveOffset = distance * 0.035; // Reduced from 0.075 to 0.035 (much flatter curves)\n    \n    // FIXED: Always curve upward/right - ensure positive direction\n    // Calculate perpendicular direction and force it upward\n    let perpLng = -deltaLat / distance * curveOffset;\n    let perpLat = deltaLng / distance * curveOffset;\n    \n    // Force curve to always go \"up\" (positive latitude direction) or \"right\" (positive longitude)\n    // This ensures consistent curve direction regardless of route direction\n    if (perpLat < 0) {\n      perpLng = -perpLng;\n      perpLat = -perpLat;\n    }\n    \n    // Control point offset from midpoint\n    const controlLng = midLng + perpLng;\n    const controlLat = midLat + perpLat;\n    \n    // Generate curved line with multiple points\n    const steps = 25; // Increased steps for smoother curve\n    const coordinates = [];\n    \n    for (let i = 0; i <= steps; i++) {\n      const t = i / steps;\n      const t2 = t * t;\n      const oneMinusT = 1 - t;\n      const oneMinusT2 = oneMinusT * oneMinusT;\n      \n      // Quadratic Bezier curve formula\n      const lng = oneMinusT2 * startLng + 2 * oneMinusT * t * controlLng + t2 * endLng;\n      const lat = oneMinusT2 * startLat + 2 * oneMinusT * t * controlLat + t2 * endLat;\n      \n      coordinates.push([lng, lat]);\n    }\n    \n    return coordinates;\n  }\n  \n  /**\n   * Update weather circles with new data\n   * @param {Array} weatherSegments - New weather segments data\n   */\n  updateWeatherCircles(weatherSegments) {\n    this.addWeatherCircles(weatherSegments);\n  }\n\n  /**\n   * Static method to auto-create weather circles when segments are loaded\n   * Call this when weather segments are first loaded for a new flight\n   */\n  static autoCreateOnWeatherLoad(map, weatherSegments) {\n    if (!map || !weatherSegments || weatherSegments.length === 0) {\n      return;\n    }\n\n    console.log('ðŸ”„ AUTO-CREATE: Weather segments loaded, creating weather circles automatically');\n    \n    // Create weather circles layer if it doesn't exist\n    if (!window.currentWeatherCirclesLayer) {\n      const weatherCirclesLayer = new WeatherCirclesLayer(map);\n      weatherCirclesLayer.addWeatherCircles(weatherSegments);\n      window.currentWeatherCirclesLayer = weatherCirclesLayer;\n      console.log('ðŸ”„ AUTO-CREATE: Weather circles created automatically for new flight');\n    } else {\n      // Update existing layer\n      window.currentWeatherCirclesLayer.addWeatherCircles(weatherSegments);\n      console.log('ðŸ”„ AUTO-CREATE: Weather circles updated automatically');\n    }\n  }\n  \n  /**\n   * Global helper function to refresh weather circles from any available data\n   * Useful for debugging and manual testing\n   */\n  static refreshFromAvailableData(map) {\n    try {\n      console.log('ðŸ”„ REFRESH: Attempting to refresh weather circles from available data');\n      \n      // Find any available weather data\n      let weatherData = null;\n      let dataSource = 'none';\n      \n      if (window.loadedWeatherSegments?.length > 0) {\n        weatherData = window.loadedWeatherSegments;\n        dataSource = 'window.loadedWeatherSegments';\n      }\n      \n      console.log(`ðŸ”„ REFRESH: Found data from ${dataSource}, segments:`, weatherData?.length || 0);\n      \n      if (weatherData && weatherData.length > 0 && map) {\n        // Clean up existing layer\n        if (window.currentWeatherCirclesLayer) {\n          try {\n            window.currentWeatherCirclesLayer.removeWeatherCircles();\n          } catch (cleanupError) {\n            console.warn('ðŸ”„ REFRESH: Error during cleanup:', cleanupError);\n          }\n        }\n        \n        // Create new layer\n        const weatherCirclesLayer = new WeatherCirclesLayer(map);\n        weatherCirclesLayer.addWeatherCircles(weatherData);\n        window.currentWeatherCirclesLayer = weatherCirclesLayer;\n        console.log('ðŸ”„ REFRESH: Weather circles refreshed successfully');\n        return true;\n      } else {\n        console.log('ðŸ”„ REFRESH: No weather data available to refresh from');\n        return false;\n      }\n    } catch (error) {\n      console.error('ðŸ”„ REFRESH: Error refreshing weather circles:', error);\n      return false;\n    }\n  }\n}\n\n// Make refresh function globally available for debugging\nwindow.refreshWeatherCircles = () => {\n  if (window.mapManager?.map) {\n    return WeatherCirclesLayer.refreshFromAvailableData(window.mapManager.map);\n  } else {\n    console.error('ðŸ”„ REFRESH: Map not available for refresh');\n    return false;\n  }\n};\n\n// Global function to clear stuck locks\nwindow.clearWeatherCirclesLock = () => {\n  if (window.weatherCirclesCreationInProgress) {\n    const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n    console.log(`ðŸ”“ MANUAL: Clearing weather circles lock (was active for ${lockAge}ms)`);\n    window.weatherCirclesCreationInProgress = false;\n    window.weatherCirclesLockTime = null;\n    return true;\n  } else {\n    console.log('ðŸ”“ MANUAL: No active lock to clear');\n    return false;\n  }\n};\n\n// Global function to check lock status\nwindow.checkWeatherCirclesLock = () => {\n  if (window.weatherCirclesCreationInProgress) {\n    const lockAge = Date.now() - (window.weatherCirclesLockTime || 0);\n    console.log(`ðŸ”’ LOCK STATUS: Active for ${lockAge}ms (set at ${new Date(window.weatherCirclesLockTime).toLocaleTimeString()})`);\n    return { active: true, ageMs: lockAge, setAt: window.weatherCirclesLockTime };\n  } else {\n    console.log('ðŸ”“ LOCK STATUS: No active lock');\n    return { active: false };\n  }\n};\n\nexport default WeatherCirclesLayer;"],"names":["WeatherCirclesLayer","map","weatherSegments","lockStartTime","lockAge","clearLock","allArrowData","validSegments","alternateLocations","processedLocations","segment","index","_a","_b","_c","_d","locationKey","ranking","alternateSegment","windSpeed","windDirection","windGust","windSource","comprehensiveMetarData","metarSpeed","metarDir","metarGust","rigCoordinates","matchingWaypoint","wp","matchingStopCard","card","rigSegment","key","tafSpeed","tafDir","tafGust","possibleSpeedFields","possibleDirFields","field","destinationCoordinates","destinationSegment","deduplicatedSegments","outerMostFeatures","f","outerFeatures","middleFeatures","innerFeatures","innerMostFeatures","hasCircleGeometry","hasPointGeometry","beforeLayer","pointLayerId","a","arrowTypes","acc","arrow","error","layersToCheck","foundLayers","layerId","id","ringType","coords","color","baseRadius","radius","center","geoPoint","parts","lat","lon","hoverLayer","suffix","visibility","testSegments","flightAlternateData","correctSplitPoint","lineFeatures","splitPoint","destination","lineFeature","linesSourceId","linesLayerId","segments","hoverFeatures","icao","circleType","fuelStatus","content","arrivalTime","locationMap","lng","existing","existingColor","segmentColor","basePriority","weatherPriority","routeLayerPatterns","allLayers","pattern","matchingLayer","layer","rigIcao","_e","k","waypoints","waypointManagerKeys","value","match","routeWaypoints","shadowFeatures","shadowFeature","start","end","startLng","startLat","endLng","endLat","midLng","midLat","deltaLng","deltaLat","distance","curveOffset","perpLng","perpLat","controlLng","controlLat","steps","coordinates","i","t","t2","oneMinusT","oneMinusT2","weatherCirclesLayer","weatherData","dataSource","cleanupError"],"mappings":"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"}