// node_modules/@osdk/shared.client/index.js
var symbolClientContext = Symbol("ClientContext");

// node_modules/@osdk/shared.client2/index.js
var symbolClientContext2 = "__osdkClientContext";

// node_modules/@osdk/shared.net.platformapi/node_modules/@osdk/shared.net.errors/build/browser/PalantirApiError.js
var PalantirApiError = class extends Error {
  constructor(message, errorName, errorCode, statusCode, errorInstanceId, parameters) {
    super(message);
    this.message = message;
    this.errorName = errorName;
    this.errorCode = errorCode;
    this.statusCode = statusCode;
    this.errorInstanceId = errorInstanceId;
    this.parameters = parameters;
  }
};

// node_modules/@osdk/shared.net.platformapi/node_modules/@osdk/shared.net.errors/build/browser/UnknownError.js
var UnknownError = class extends PalantirApiError {
  constructor(message, errorType, originalError) {
    super(message, errorType);
    this.originalError = originalError;
  }
};

// node_modules/@osdk/shared.net.platformapi/build/browser/foundryPlatformFetch.js
async function foundryPlatformFetch(client, [httpMethodNum, origPath, flags, contentType, responseContentType], ...args) {
  const path = origPath.replace(/\{([^}]+)\}/g, () => encodeURIComponent(args.shift()));
  const body = flags & 1 ? args.shift() : void 0;
  const queryArgs = flags & 2 ? args.shift() : void 0;
  const headerArgs = flags & 4 ? args.shift() : void 0;
  const method = ["GET", "POST", "PUT", "DELETE", "PATCH"][httpMethodNum];
  return await apiFetch(client[symbolClientContext2] ?? client[symbolClientContext] ?? client, method, path, body, queryArgs, headerArgs, contentType, responseContentType);
}
async function apiFetch(clientCtx, method, endpointPath, data, queryArguments, headers, requestMediaType, responseMediaType) {
  const url = parseUrl(clientCtx.baseUrl, endpointPath);
  for (const [key, value] of Object.entries(queryArguments || {})) {
    if (value == null) {
      continue;
    }
    if (Array.isArray(value)) {
      for (const item of value) {
        url.searchParams.append(key, item);
      }
    } else {
      url.searchParams.append(key, value);
    }
  }
  const headersInit = new Headers();
  headersInit.set("Content-Type", requestMediaType ?? "application/json");
  headersInit.set("Accept", responseMediaType ?? "application/json");
  Object.entries(headers || {}).forEach(([key, value]) => {
    if (value != null) {
      headersInit.append(key, value.toString());
    }
  });
  const body = data == null || data instanceof globalThis.Blob ? data : JSON.stringify(data);
  const response = await clientCtx.fetch(url.toString(), {
    body,
    method,
    headers: headersInit
  });
  if (!response.ok) {
    try {
      const convertedError = await response.json();
      return new PalantirApiError(convertedError.message, convertedError.errorName, convertedError.errorCode, response.status, convertedError.errorInstanceId, convertedError.parameters);
    } catch (e) {
      if (e instanceof Error) {
        return new UnknownError(e.message, "UNKNOWN");
      }
      return new UnknownError("Unable to parse error response", "UNKNOWN");
    }
  }
  if (response.status === 204) {
    return;
  }
  if (responseMediaType == null || responseMediaType === "application/json") {
    return await response.json();
  }
  return response;
}
function parseUrl(baseUrl, endpointPath) {
  baseUrl += baseUrl.endsWith("/") ? "" : "/";
  return new URL(`api${endpointPath}`, baseUrl);
}

export {
  symbolClientContext,
  foundryPlatformFetch
};
//# sourceMappingURL=chunk-3UWMVGII.js.map
