{
  "version": 3,
  "sources": ["../../fetch-retry/dist/fetch-retry.umd.js", "../../@osdk/api/build/browser/aggregate/WhereClause.ts", "../../@osdk/api/build/browser/mapping/DurationMapping.ts", "../../@osdk/api/build/browser/groupby/GroupByClause.ts", "../../@osdk/api/build/browser/object/Result.ts", "../../@osdk/api/build/browser/timeseries/timeseries.ts", "../../@osdk/shared.net.errors/build/browser/PalantirApiError.ts", "../../@osdk/shared.net.errors/build/browser/UnknownError.ts", "../../@osdk/client/build/browser/actions/ActionValidationError.ts", "../../@osdk/api/build/browser/experimental/createMediaReference.ts", "../../@osdk/api/build/browser/experimental/fetchOneByRid.ts", "../../@osdk/api/build/browser/experimental/fetchPageByRid.ts", "../../@osdk/api/build/browser/experimental/getBulkLinks.ts", "../../@osdk/foundry.ontologies/build/browser/public/Action.js", "../../@osdk/foundry.ontologies/build/browser/public/ActionTypeV2.js", "../../@osdk/foundry.ontologies/build/browser/public/Attachment.js", "../../@osdk/foundry.ontologies/build/browser/public/AttachmentPropertyV2.js", "../../@osdk/foundry.ontologies/build/browser/public/CipherTextProperty.js", "../../@osdk/foundry.ontologies/build/browser/public/LinkedObjectV2.js", "../../@osdk/foundry.ontologies/build/browser/public/MediaReferenceProperty.js", "../../@osdk/foundry.ontologies/build/browser/public/ObjectTypeV2.js", "../../@osdk/foundry.ontologies/build/browser/public/OntologyInterface.js", "../../@osdk/foundry.ontologies/build/browser/public/OntologyObjectSet.js", "../../@osdk/foundry.ontologies/build/browser/public/OntologyObjectV2.js", "../../@osdk/foundry.ontologies/build/browser/public/OntologyV2.js", "../../@osdk/foundry.ontologies/build/browser/public/Query.js", "../../@osdk/foundry.ontologies/build/browser/public/QueryType.js", "../../@osdk/foundry.ontologies/build/browser/public/TimeSeriesPropertyV2.js", "../../@osdk/foundry.ontologies/build/browser/public/TimeSeriesValueBankProperty.js", "../../@osdk/client.unstable/node_modules/conjure-lite/dist/index.mjs", "../../@osdk/client.unstable/src/generated/object-set-service/api/ObjectSetService/createTemporaryObjectSet.ts", "../../@osdk/client.unstable/src/generated/object-set-service/api/ObjectSetServiceV2/getBulkLinksPage.ts", "../../@osdk/client.unstable/src/generated/ontology-metadata/api/OntologyMetadataService/bulkLoadOntologyEntities.ts", "../../@osdk/client.unstable/src/generated/ontology-metadata/api/OntologyMetadataService/getLinkTypesForObjectTypes.ts", "../../@osdk/client.unstable/src/generated/ontology-metadata/api/OntologyMetadataService/loadAllOntologies.ts", "../../@osdk/client/build/browser/objectSet/conjureUnionType.ts", "../../@osdk/client/build/browser/ontology/makeConjureContext.ts", "../../@osdk/client/build/browser/pageRequestAsAsyncIter.ts", "../../@osdk/client/build/browser/object/SimpleCache.ts", "../../@osdk/client/build/browser/__unstable/ConjureSupport.ts", "../../@osdk/client/build/browser/__unstable/createBulkLinksAsyncIterFactory.ts", "../../@osdk/shared.net.fetch/build/browser/createFetchHeaderMutator.ts", "../../@osdk/shared.net.fetch/build/browser/createFetchOrThrow.ts", "../../@osdk/shared.net.fetch/build/browser/createRetryingFetch.ts", "../../@osdk/client/build/browser/util/addUserAgentAndRequestContextHeaders.ts", "../../@osdk/client/build/browser/util/augmentRequestContext.ts", "../../@osdk/client/build/browser/object/AttachmentUpload.ts", "../../@osdk/client/build/browser/object/mediaUpload.ts", "../../@osdk/client/build/browser/internal/conversions/modernToLegacyWhereClause.ts", "../../@osdk/client/build/browser/derivedProperties/derivedPropertyDefinitionFactory.ts", "../../@osdk/client/build/browser/derivedProperties/createWithPropertiesObjectSet.ts", "../../@osdk/client/build/browser/internal/conversions/legacyToModernSingleAggregationResult.ts", "../../@osdk/client/build/browser/internal/conversions/modernToLegacyAggregationClause.ts", "../../@osdk/client/build/browser/internal/conversions/modernToLegacyGroupByClause.ts", "../../@osdk/client/build/browser/util/objectSetUtils.ts", "../../@osdk/client/build/browser/object/aggregate.ts", "../../@osdk/client/build/browser/util/extractRdpDefinition.ts", "../../@osdk/client/build/browser/object/fetchPage.ts", "../../@osdk/client/build/browser/object/fetchSingle.ts", "../../@osdk/client/build/browser/util/WireObjectSet.ts", "../../isomorphic-ws/browser.js", "../../@osdk/client/build/browser/objectSet/ObjectSetListenerWebsocket.ts", "../../@osdk/client/build/browser/objectSet/createObjectSet.ts", "../../@osdk/client/build/browser/util/interfaceUtils.ts", "../../@osdk/client/build/browser/util/isObjectSpecifiersObject.ts", "../../@osdk/client/build/browser/util/isOntologyObjectV2.ts", "../../@osdk/client/build/browser/util/isPoint.ts", "../../@osdk/client/build/browser/util/toDataValue.ts", "../../@osdk/client/build/browser/actions/applyAction.ts", "../../@osdk/client/build/browser/Client.ts", "../../@osdk/shared.client.impl/build/browser/createSharedClientContext.ts", "../../@osdk/client/build/browser/util/streamutils.ts", "../../@osdk/client/build/browser/util/timeseriesUtils.ts", "../../@osdk/client/build/browser/createGeotimeSeriesProperty.ts", "../../@osdk/client/build/browser/createMediaReferenceProperty.ts", "../../@osdk/client/build/browser/createTimeseriesProperty.ts", "../../@osdk/client/build/browser/public-utils/hydrateAttachmentFromRid.ts", "../../@osdk/client/build/browser/util/objectSpecifierUtils.ts", "../../@osdk/client/build/browser/ontology/OntologyProvider.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects/InternalSymbols.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects/createOsdkInterface.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects/getDollarAs.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects/getDollarLink.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects/createOsdkObject.ts", "../../@osdk/client/build/browser/object/convertWireToOsdkObjects.ts", "../../@osdk/client/build/browser/object/Cache.ts", "../../@osdk/generator-converters/build/browser/wirePropertyV2ToSdkPropertyDefinition.ts", "../../@osdk/generator-converters/build/browser/__UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition.ts", "../../@osdk/generator-converters/build/browser/getEditedEntities.ts", "../../@osdk/generator-converters/build/browser/wirePropertyV2ToSdkPrimaryKeyTypeDefinition.ts", "../../@osdk/generator-converters/build/browser/wireObjectTypeFullMetadataToSdkObjectMetadata.ts", "../../@osdk/generator-converters/build/browser/wireActionTypeV2ToSdkActionMetadata.ts", "../../@osdk/generator-converters/build/browser/isNullableQueryDataType.ts", "../../@osdk/generator-converters/build/browser/wireQueryDataTypeToQueryDataTypeDefinition.ts", "../../@osdk/generator-converters/build/browser/wireQueryTypeV2ToSdkQueryMetadata.ts", "../../@osdk/client/build/browser/ontology/loadActionMetadata.ts", "../../@osdk/client/build/browser/ontology/loadFullObjectMetadata.ts", "../../@osdk/client/build/browser/ontology/loadInterfaceMetadata.ts", "../../@osdk/client/build/browser/ontology/loadQueryMetadata.ts", "../../@osdk/client/build/browser/ontology/StandardOntologyProvider.ts", "../../@osdk/client/build/browser/util/UserAgent.ts", "../../@osdk/client/build/browser/createMinimalClient.ts", "../../@osdk/client/build/browser/fetchMetadata.ts", "../../@osdk/client/build/browser/logger/BaseLogger.ts", "../../@osdk/client/build/browser/logger/MinimalLogger.ts", "../../@osdk/client/build/browser/util/toDataValueQueries.ts", "../../@osdk/client/build/browser/queries/applyQuery.ts", "../../@osdk/client/build/browser/createClient.ts", "../../@osdk/client/build/browser/createPlatformClient.ts", "../../@osdk/client/build/browser/util/datetimeConverters.ts"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.fetchRetry = factory());\n})(this, (function () { 'use strict';\n\n  var fetchRetry = function (fetch, defaults) {\n    defaults = defaults || {};\n    if (typeof fetch !== 'function') {\n      throw new ArgumentError('fetch must be a function');\n    }\n\n    if (typeof defaults !== 'object') {\n      throw new ArgumentError('defaults must be an object');\n    }\n\n    if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {\n      throw new ArgumentError('retries must be a positive integer');\n    }\n\n    if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {\n      throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n    }\n\n    if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {\n      throw new ArgumentError('retryOn property expects an array or function');\n    }\n\n    var baseDefaults = {\n      retries: 3,\n      retryDelay: 1000,\n      retryOn: [],\n    };\n\n    defaults = Object.assign(baseDefaults, defaults);\n\n    return function fetchRetry(input, init) {\n      var retries = defaults.retries;\n      var retryDelay = defaults.retryDelay;\n      var retryOn = defaults.retryOn;\n\n      if (init && init.retries !== undefined) {\n        if (isPositiveInteger(init.retries)) {\n          retries = init.retries;\n        } else {\n          throw new ArgumentError('retries must be a positive integer');\n        }\n      }\n\n      if (init && init.retryDelay !== undefined) {\n        if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {\n          retryDelay = init.retryDelay;\n        } else {\n          throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n        }\n      }\n\n      if (init && init.retryOn) {\n        if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {\n          retryOn = init.retryOn;\n        } else {\n          throw new ArgumentError('retryOn property expects an array or function');\n        }\n      }\n\n      // eslint-disable-next-line no-undef\n      return new Promise(function (resolve, reject) {\n        var wrappedFetch = function (attempt) {\n          // As of node 18, this is no longer needed since node comes with native support for fetch:\n          /* istanbul ignore next */\n          var _input =\n            typeof Request !== 'undefined' && input instanceof Request\n              ? input.clone()\n              : input;\n          fetch(_input, init)\n            .then(function (response) {\n              if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {\n                resolve(response);\n              } else if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  return Promise.resolve(retryOn(attempt, null, response))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, null, response);\n                      } else {\n                        resolve(response);\n                      }\n                    }).catch(reject);\n                } catch (error) {\n                  reject(error);\n                }\n              } else {\n                if (attempt < retries) {\n                  retry(attempt, null, response);\n                } else {\n                  resolve(response);\n                }\n              }\n            })\n            .catch(function (error) {\n              if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  Promise.resolve(retryOn(attempt, error, null))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, error, null);\n                      } else {\n                        reject(error);\n                      }\n                    })\n                    .catch(function(error) {\n                      reject(error);\n                    });\n                } catch(error) {\n                  reject(error);\n                }\n              } else if (attempt < retries) {\n                retry(attempt, error, null);\n              } else {\n                reject(error);\n              }\n            });\n        };\n\n        function retry(attempt, error, response) {\n          var delay = (typeof retryDelay === 'function') ?\n            retryDelay(attempt, error, response) : retryDelay;\n          setTimeout(function () {\n            wrappedFetch(++attempt);\n          }, delay);\n        }\n\n        wrappedFetch(0);\n      });\n    };\n  };\n\n  function isPositiveInteger(value) {\n    return Number.isInteger(value) && value >= 0;\n  }\n\n  function ArgumentError(message) {\n    this.name = 'ArgumentError';\n    this.message = message;\n  }\n\n  return fetchRetry;\n\n}));\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { BBox, Point, Polygon } from \"geojson\";\nimport type {\n  ObjectOrInterfaceDefinition,\n} from \"../ontology/ObjectOrInterface.js\";\nimport type {\n  CompileTimeMetadata,\n  ObjectMetadata,\n} from \"../ontology/ObjectTypeDefinition.js\";\nimport type { BaseWirePropertyTypes } from \"../ontology/WirePropertyTypes.js\";\nimport type { IsNever } from \"../OsdkObjectFrom.js\";\nimport type { ArrayFilter } from \"./ArrayFilter.js\";\nimport type { BaseFilter } from \"./BaseFilter.js\";\nimport type { BooleanFilter } from \"./BooleanFilter.js\";\nimport type { DatetimeFilter } from \"./DatetimeFilter.js\";\nimport type { GeoFilter } from \"./GeoFilter.js\";\nimport type { Just } from \"./Just.js\";\nimport type { NumberFilter } from \"./NumberFilter.js\";\nimport type { StringFilter } from \"./StringFilter.js\";\n\nexport type PossibleWhereClauseFilters =\n  | \"$gt\"\n  | \"$eq\"\n  | \"$ne\"\n  | \"$isNull\"\n  | \"$contains\"\n  | \"$gte\"\n  | \"$lt\"\n  | \"$lte\"\n  | \"$within\"\n  | \"$in\"\n  | \"$intersects\"\n  | \"$startsWith\"\n  | \"$containsAllTermsInOrder\"\n  | \"$containsAnyTerm\"\n  | \"$containsAllTerms\";\n\n// the value side of this needs to match DistanceUnit from @osdk/foundry but we don't\n// want the dependency\nexport const DistanceUnitMapping: {\n  centimeter: \"CENTIMETERS\";\n  centimeters: \"CENTIMETERS\";\n  cm: \"CENTIMETERS\";\n  meter: \"METERS\";\n  meters: \"METERS\";\n  m: \"METERS\";\n  kilometer: \"KILOMETERS\";\n  kilometers: \"KILOMETERS\";\n  km: \"KILOMETERS\";\n  inch: \"INCHES\";\n  inches: \"INCHES\";\n  foot: \"FEET\";\n  feet: \"FEET\";\n  yard: \"YARDS\";\n  yards: \"YARDS\";\n  mile: \"MILES\";\n  miles: \"MILES\";\n  nautical_mile: \"NAUTICAL_MILES\";\n  nauticalMile: \"NAUTICAL_MILES\";\n  \"nautical miles\": \"NAUTICAL_MILES\";\n} = {\n  \"centimeter\": \"CENTIMETERS\",\n  \"centimeters\": \"CENTIMETERS\",\n  \"cm\": \"CENTIMETERS\",\n  \"meter\": \"METERS\",\n  \"meters\": \"METERS\",\n  \"m\": \"METERS\",\n  \"kilometer\": \"KILOMETERS\",\n  \"kilometers\": \"KILOMETERS\",\n  \"km\": \"KILOMETERS\",\n  \"inch\": \"INCHES\",\n  \"inches\": \"INCHES\",\n  \"foot\": \"FEET\",\n  \"feet\": \"FEET\",\n  \"yard\": \"YARDS\",\n  \"yards\": \"YARDS\",\n  \"mile\": \"MILES\",\n  \"miles\": \"MILES\",\n  \"nautical_mile\": \"NAUTICAL_MILES\",\n  \"nauticalMile\": \"NAUTICAL_MILES\",\n  \"nautical miles\": \"NAUTICAL_MILES\",\n} satisfies Record<\n  string,\n  | \"CENTIMETERS\"\n  | \"METERS\"\n  | \"KILOMETERS\"\n  | \"INCHES\"\n  | \"FEET\"\n  | \"YARDS\"\n  | \"MILES\"\n  | \"NAUTICAL_MILES\"\n>;\n\nexport type GeoFilter_Within = {\n  \"$within\":\n    | {\n      $distance: [number, keyof typeof DistanceUnitMapping];\n      $of: [number, number] | Readonly<Point>;\n      $bbox?: never;\n      $polygon?: never;\n    }\n    | {\n      $bbox: BBox;\n      $distance?: never;\n      $of?: never;\n      $polygon?: never;\n    }\n    | BBox\n    | {\n      $polygon: Polygon[\"coordinates\"];\n      $bbox?: never;\n      $distance?: never;\n      $of?: never;\n    }\n    | Polygon;\n};\n\nexport type GeoFilter_Intersects = {\n  \"$intersects\":\n    | {\n      $bbox: BBox;\n      $polygon?: never;\n    }\n    | BBox\n    | {\n      $polygon: Polygon[\"coordinates\"];\n      $bbox?: never;\n    }\n    | Polygon;\n};\n\ntype FilterFor<PD extends ObjectMetadata.Property> = PD[\"multiplicity\"] extends\n  true\n  ? (PD[\"type\"] extends\n    \"string\" | \"geopoint\" | \"geoshape\" | \"datetime\" | \"timestamp\"\n    ? ArrayFilter<string>\n    : (PD[\"type\"] extends boolean ? ArrayFilter<boolean>\n      : ArrayFilter<number>))\n  : PD[\"type\"] extends Record<string, BaseWirePropertyTypes> ?\n      | StructFilter<PD[\"type\"]>\n      | BaseFilter.$isNull<string>\n  : (PD[\"type\"] extends \"string\" ? StringFilter\n    : PD[\"type\"] extends \"geopoint\" | \"geoshape\" ? GeoFilter\n    : PD[\"type\"] extends \"datetime\" | \"timestamp\" ? DatetimeFilter\n    : PD[\"type\"] extends \"boolean\" ? BooleanFilter\n    : PD[\"type\"] extends\n      \"double\" | \"integer\" | \"long\" | \"float\" | \"decimal\" | \"byte\"\n      ? NumberFilter\n    : BaseFilter<string>); // FIXME we need to represent all types\n\ntype StructFilterOpts<ST extends Record<string, BaseWirePropertyTypes>> = {\n  [K in keyof ST]?: FilterFor<{ \"type\": ST[K] }>;\n};\ntype StructFilter<ST extends Record<string, BaseWirePropertyTypes>> = {\n  [K in keyof ST]: Just<K, StructFilterOpts<ST>>;\n}[keyof ST];\n\nexport interface AndWhereClause<\n  T extends ObjectOrInterfaceDefinition,\n> {\n  $and: WhereClause<T>[];\n}\n\nexport interface OrWhereClause<\n  T extends ObjectOrInterfaceDefinition,\n> {\n  $or: WhereClause<T>[];\n}\n\nexport interface NotWhereClause<\n  T extends ObjectOrInterfaceDefinition,\n> {\n  $not: WhereClause<T>;\n}\n\nexport type PropertyWhereClause<T extends ObjectOrInterfaceDefinition> = {\n  [P in keyof CompileTimeMetadata<T>[\"properties\"]]?: FilterFor<\n    CompileTimeMetadata<T>[\"properties\"][P]\n  >;\n};\n\nexport type WhereClause<\n  T extends ObjectOrInterfaceDefinition,\n> =\n  | OrWhereClause<T>\n  | AndWhereClause<T>\n  | NotWhereClause<T>\n  | (IsNever<keyof CompileTimeMetadata<T>[\"properties\"]> extends true\n    ? Record<string, never>\n    : PropertyWhereClause<T>);\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const TimeDurationMapping: {\n  sec: \"SECONDS\";\n  seconds: \"SECONDS\";\n  min: \"MINUTES\";\n  minute: \"MINUTES\";\n  minutes: \"MINUTES\";\n  hr: \"HOURS\";\n  hrs: \"HOURS\";\n  hour: \"HOURS\";\n  hours: \"HOURS\";\n  day: \"DAYS\";\n  days: \"DAYS\";\n  wk: \"WEEKS\";\n  week: \"WEEKS\";\n  weeks: \"WEEKS\";\n  mos: \"MONTHS\";\n  month: \"MONTHS\";\n  months: \"MONTHS\";\n  yr: \"YEARS\";\n  year: \"YEARS\";\n  years: \"YEARS\";\n} = {\n  \"sec\": \"SECONDS\",\n  \"seconds\": \"SECONDS\",\n  \"min\": \"MINUTES\",\n  \"minute\": \"MINUTES\",\n  \"minutes\": \"MINUTES\",\n  \"hr\": \"HOURS\",\n  \"hrs\": \"HOURS\",\n  \"hour\": \"HOURS\",\n  \"hours\": \"HOURS\",\n  \"day\": \"DAYS\",\n  \"days\": \"DAYS\",\n  \"wk\": \"WEEKS\",\n  \"week\": \"WEEKS\",\n  \"weeks\": \"WEEKS\",\n  \"mos\": \"MONTHS\",\n  \"month\": \"MONTHS\",\n  \"months\": \"MONTHS\",\n  \"yr\": \"YEARS\",\n  \"year\": \"YEARS\",\n  \"years\": \"YEARS\",\n} satisfies Record<\n  string,\n  | \"YEARS\"\n  | \"MONTHS\"\n  | \"WEEKS\"\n  | \"DAYS\"\n  | \"HOURS\"\n  | \"MINUTES\"\n  | \"SECONDS\"\n>;\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AggregatableKeys } from \"../aggregate/AggregatableKeys.js\";\nimport { TimeDurationMapping } from \"../mapping/DurationMapping.js\";\nimport type { ObjectOrInterfaceDefinition } from \"../ontology/ObjectOrInterface.js\";\nimport type { CompileTimeMetadata } from \"../ontology/ObjectTypeDefinition.js\";\nimport type { GroupByMapper } from \"./GroupByMapper.js\";\n\nexport type GroupByClause<\n  Q extends ObjectOrInterfaceDefinition,\n> = {\n  [P in AggregatableKeys<Q>]?: GroupByEntry<Q, P>;\n};\n\ntype BaseGroupByValue =\n  | \"exact\"\n  | { $exactWithLimit: number }\n  | ExactGroupByWithOptions;\n\ntype ExactGroupByWithOptions = {\n  $exact: { $limit?: number; $defaultValue?: string };\n};\n\nexport type GroupByRange<T> = [T, T];\n\nexport type StringGroupByValue = BaseGroupByValue;\n\nexport type NumericGroupByValue = BaseGroupByValue | {\n  $fixedWidth: number;\n} | { $ranges: GroupByRange<number>[] };\n\nexport type TimestampGroupByValue =\n  | BaseGroupByValue\n  | { $ranges: GroupByRange<string>[] }\n  | { $duration: TimestampDurationGroupBy };\n\nexport type DateGroupByValue =\n  | BaseGroupByValue\n  | { $ranges: GroupByRange<string>[] }\n  | { $duration: DatetimeDurationGroupBy };\n\nexport type BooleanGroupByValue = BaseGroupByValue;\n\nexport type TimestampTimeUnits =\n  | DateTimeUnits\n  | \"SECONDS\"\n  | \"MINUTES\"\n  | \"HOURS\";\n\nexport type DateTimeUnits = \"DAYS\" | \"WEEKS\" | \"MONTHS\" | \"YEARS\" | \"QUARTERS\";\nexport const DurationMapping: {\n  quarter: \"QUARTERS\";\n  quarters: \"QUARTERS\";\n  sec: \"SECONDS\";\n  seconds: \"SECONDS\";\n  min: \"MINUTES\";\n  minute: \"MINUTES\";\n  minutes: \"MINUTES\";\n  hr: \"HOURS\";\n  hrs: \"HOURS\";\n  hour: \"HOURS\";\n  hours: \"HOURS\";\n  day: \"DAYS\";\n  days: \"DAYS\";\n  wk: \"WEEKS\";\n  week: \"WEEKS\";\n  weeks: \"WEEKS\";\n  mos: \"MONTHS\";\n  month: \"MONTHS\";\n  months: \"MONTHS\";\n  yr: \"YEARS\";\n  year: \"YEARS\";\n  years: \"YEARS\";\n} = {\n  ...TimeDurationMapping,\n  \"quarter\": \"QUARTERS\",\n  \"quarters\": \"QUARTERS\",\n} satisfies Record<string, DateTimeUnits | TimestampTimeUnits>;\n\ninterface TimeValueMapping {\n  SECONDS: number;\n  MINUTES: number;\n  HOURS: number;\n  DAYS: number;\n  WEEKS: 1;\n  MONTHS: 1;\n  YEARS: 1;\n  QUARTERS: 1;\n}\n\ntype DurationGroupBy<A> = {\n  [K in keyof typeof DurationMapping]: typeof DurationMapping[K] extends A\n    ? [TimeValueMapping[typeof DurationMapping[K]], K]\n    : never;\n}[keyof typeof DurationMapping];\n\ntype TimestampDurationGroupBy = DurationGroupBy<TimestampTimeUnits>;\ntype DatetimeDurationGroupBy = DurationGroupBy<DateTimeUnits>;\n\ntype GroupByEntry<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends AggregatableKeys<Q>,\n> = CompileTimeMetadata<Q>[\"properties\"][P][\"type\"] extends keyof GroupByMapper\n  ? GroupByMapper[CompileTimeMetadata<Q>[\"properties\"][P][\"type\"]]\n  : never;\n\nexport type AllGroupByValues = GroupByMapper[keyof GroupByMapper];\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type ErrorResult = { error: Error; value?: never };\nexport type OkResult<V> = { value: V; error?: never };\nexport type Result<V> = OkResult<V> | ErrorResult;\n\n/**\n * Check if a result was successfully received\n * @param a - result wrapped value\n * @returns whether a result has a value in it\n */\nexport function isOk<X>(a: Result<X>): a is OkResult<X> {\n  return (\"value\" in a);\n}\n\n/**\n * Check if a result contains an error value\n * @param a Result wrapped value\n * @returns whether a result has an error in it\n */\nexport function isError<X>(a: Result<X>): a is ErrorResult {\n  return (\"error\" in a);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TimeDurationMapping } from \"../mapping/DurationMapping.js\";\n\nexport type TimeSeriesQuery =\n  | {\n    $before: number;\n    $unit: keyof typeof TimeseriesDurationMapping;\n    $after?: never;\n    $startTime?: never;\n    $endTime?: never;\n  }\n  | {\n    $after: number;\n    $unit: keyof typeof TimeseriesDurationMapping;\n    $before?: never;\n    $startTime?: never;\n    $endTime?: never;\n  }\n  | {\n    $startTime: string;\n    $endTime?: string;\n    $before?: never;\n    $after?: never;\n    $unit?: never;\n  }\n  | {\n    $startTime?: string;\n    $endTime: string;\n    $before?: never;\n    $after?: never;\n    $unit?: never;\n  };\n\nexport type TimeseriesDurationUnits =\n  | \"YEARS\"\n  | \"MONTHS\"\n  | \"WEEKS\"\n  | \"DAYS\"\n  | \"HOURS\"\n  | \"MINUTES\"\n  | \"SECONDS\"\n  | \"MILLISECONDS\";\n\nexport const TimeseriesDurationMapping: {\n  sec: \"SECONDS\";\n  seconds: \"SECONDS\";\n  min: \"MINUTES\";\n  minute: \"MINUTES\";\n  minutes: \"MINUTES\";\n  hr: \"HOURS\";\n  hrs: \"HOURS\";\n  hour: \"HOURS\";\n  hours: \"HOURS\";\n  day: \"DAYS\";\n  days: \"DAYS\";\n  wk: \"WEEKS\";\n  week: \"WEEKS\";\n  weeks: \"WEEKS\";\n  mos: \"MONTHS\";\n  month: \"MONTHS\";\n  months: \"MONTHS\";\n  yr: \"YEARS\";\n  year: \"YEARS\";\n  years: \"YEARS\";\n  ms: \"MILLISECONDS\";\n  milliseconds: \"MILLISECONDS\";\n} = {\n  \"ms\": \"MILLISECONDS\",\n  \"milliseconds\": \"MILLISECONDS\",\n  ...TimeDurationMapping,\n} satisfies Record<string, TimeseriesDurationUnits>;\n\nexport interface TimeSeriesPoint<T extends string | number | GeoJSON.Point> {\n  time: string;\n  value: T;\n}\n\nexport interface TimeSeriesProperty<T extends number | string> {\n  /**\n   * Queries the first point of the Timeseries\n   */\n  readonly getFirstPoint: () => Promise<TimeSeriesPoint<T>>;\n  /**\n   * Queries the last point of the Timeseries\n   */\n  readonly getLastPoint: () => Promise<TimeSeriesPoint<T>>;\n  /**\n     * Loads all points, within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const points = await employee.employeeStatus?.getAllPoints({\n        $after: 1,\n        $unit: \"month\",\n      });\n     */\n  readonly getAllPoints: (\n    query?: TimeSeriesQuery,\n  ) => Promise<Array<TimeSeriesPoint<T>>>;\n  /**\n     * Returns an async iterator to load all points\n     * within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const iterator = employee.employeeStatus?.asyncIter({\n        $after: 1,\n        $unit: \"month\",\n      });\n      for await (const point of iterator) {\n          // Handle time series point\n      }\n     */\n  readonly asyncIterPoints: (\n    query?: TimeSeriesQuery,\n  ) => AsyncGenerator<TimeSeriesPoint<T>>;\n}\n\nexport interface GeotimeSeriesProperty<T extends GeoJSON.Point> {\n  /**\n   * Queries the last point of the Geotime series\n   */\n  readonly getLatestValue: () => Promise<TimeSeriesPoint<T> | undefined>;\n  /**\n     * Loads all points, within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const points = await employee.employeeStatus?.getAllPoints({\n        $after: 1,\n        $unit: \"month\",\n      });\n     */\n  readonly getAllValues: (\n    query?: TimeSeriesQuery,\n  ) => Promise<Array<TimeSeriesPoint<T>>>;\n  /**\n     * Returns an async iterator to load all points\n     * within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const iterator = employee.employeeStatus?.asyncIter({\n        $after: 1,\n        $unit: \"month\",\n      });\n      for await (const point of iterator) {\n          // Handle time series point\n      }\n     */\n  readonly asyncIterValues: (\n    query?: TimeSeriesQuery,\n  ) => AsyncGenerator<TimeSeriesPoint<T>>;\n\n  /**\n   * The most recently fetched value for the latest point in the GTSR.\n   * This will not be loaded automatically upon object load, but will be refreshed every time\n   * getLatestValue() is called\n   */\n  readonly lastFetchedValue: TimeSeriesPoint<T> | undefined;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class PalantirApiError extends Error implements PalantirApiError {\n  public message: string;\n  public errorName?: string;\n  public errorCode?: string;\n  public statusCode?: number;\n  public errorInstanceId?: string;\n  public parameters?: any;\n\n  constructor(\n    message: string,\n    errorName?: string,\n    errorCode?: string,\n    statusCode?: number,\n    errorInstanceId?: string,\n    parameters?: any,\n  ) {\n    super(message);\n    this.message = message;\n    this.errorName = errorName;\n    this.errorCode = errorCode;\n    this.statusCode = statusCode;\n    this.errorInstanceId = errorInstanceId;\n    this.parameters = parameters;\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PalantirApiError } from \"./PalantirApiError.js\";\n\nexport class UnknownError extends PalantirApiError {\n  originalError: Error | undefined;\n  constructor(\n    message: string,\n    errorName?: string,\n    originalError?: Error,\n    statusCode?: number,\n  ) {\n    super(message, errorName, undefined, statusCode);\n    this.originalError = originalError;\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ValidateActionResponseV2 as ActionValidationResponse } from \"@osdk/foundry.ontologies\";\n\nexport class ActionValidationError extends Error {\n  constructor(public validation: ActionValidationResponse) {\n    super(\"Validation Error: \" + JSON.stringify(validation, null, 2));\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { MediaReference } from \"../object/Media.js\";\nimport type {\n  ObjectOrInterfaceDefinition,\n  PropertyKeys,\n} from \"../ontology/ObjectOrInterface.js\";\nimport type { Experiment } from \"./Experiment.js\";\n\n/**\n * @experimental This feature is experimental and might change in the future.\n *\n * Uploads a media item to the media property of the specified object type.\n *\n * @param data - Data to upload as media item\n * @param fileName - Name that will be assigned as path to the uploaded media item.\n * @param objectType - Object type to which the media item will be uploaded.\n * @param propertyType - Media reference property of the corresponding object type to which the media item will be uploaded.\n *\n * @returns media reference of the uploaded media item.\n */\ntype createMediaReference = <\n  Q extends ObjectOrInterfaceDefinition,\n  const L extends PropertyKeys.Filtered<Q, \"mediaReference\">,\n>(\n  args: {\n    data: Blob;\n    fileName: string;\n    objectType: Q;\n    propertyType: L;\n  },\n) => Promise<MediaReference>;\n\nexport const __EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference:\n  Experiment<\n    \"2.1.0\",\n    \"__EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference\",\n    { createMediaReference: createMediaReference }\n  > = {\n    name: \"__EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference\",\n    type: \"experiment\",\n    version: \"2.1.0\",\n  };\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  NullabilityAdherence,\n  SelectArg,\n} from \"../object/FetchPageArgs.js\";\n\nimport type { PropertyKeys } from \"../ontology/ObjectOrInterface.js\";\nimport type { ObjectTypeDefinition } from \"../ontology/ObjectTypeDefinition.js\";\nimport type { ExtractOptions, Osdk } from \"../OsdkObjectFrom.js\";\nimport type { Experiment } from \"./Experiment.js\";\n\ntype fetchOneByRidFn = <\n  Q extends ObjectTypeDefinition,\n  const L extends PropertyKeys<Q>,\n  const R extends boolean,\n  const S extends false | \"throw\" = NullabilityAdherence.Default,\n>(\n  objectType: Q,\n  rid: string,\n  options?: SelectArg<Q, L, R, S>,\n) => Promise<Osdk.Instance<Q, ExtractOptions<R, S>, L>>;\n\nexport const __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid: Experiment<\n  \"2.1.0\",\n  \"__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid\",\n  { fetchOneByRid: fetchOneByRidFn }\n> = {\n  name: \"__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid\",\n  type: \"experiment\",\n  version: \"2.1.0\",\n};\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  FetchPageArgs,\n  NullabilityAdherence,\n} from \"../object/FetchPageArgs.js\";\nimport type { FetchPageResult } from \"../object/FetchPageResult.js\";\n\nimport type {\n  ObjectOrInterfaceDefinition,\n  PropertyKeys,\n} from \"../ontology/ObjectOrInterface.js\";\nimport type { Experiment } from \"./Experiment.js\";\n\ntype fetchPageByRidFn = <\n  Q extends ObjectOrInterfaceDefinition,\n  const L extends PropertyKeys<Q>,\n  const R extends boolean,\n  const S extends NullabilityAdherence,\n  const T extends boolean,\n>(\n  objectType: Q,\n  rids: string[],\n  options?: FetchPageArgs<Q, L, R, any, S, T>,\n) => Promise<FetchPageResult<Q, L, R, S, T>>;\n\nexport const __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid: Experiment<\n  \"2.2.0\",\n  \"__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid\",\n  { fetchPageByRid: fetchPageByRidFn }\n> = {\n  name: \"__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid\",\n  type: \"experiment\",\n  version: \"2.2.0\",\n};\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  EXPERIMENTAL_BulkLinkResult,\n} from \"../objectSet/BulkLinkResult.js\";\nimport type { ObjectOrInterfaceDefinition } from \"../ontology/ObjectOrInterface.js\";\nimport type { Osdk } from \"../OsdkObjectFrom.js\";\nimport type { Experiment } from \"./Experiment.js\";\n\ntype getBulkLinksFn = <T extends ObjectOrInterfaceDefinition>(\n  objs: Osdk.Instance<T>[],\n  links: string[],\n) => AsyncGenerator<EXPERIMENTAL_BulkLinkResult, void, undefined>;\n\nexport const __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks: Experiment<\n  \"2.0.8\",\n  \"__EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks\",\n  { getBulkLinks: getBulkLinksFn }\n> = {\n  name: \"__EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks\",\n  type: \"experiment\",\n  version: \"2.0.8\",\n};\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _apply = [1, \"/v2/ontologies/{0}/actions/{1}/apply\", 3];\n/**\n * Applies an action using the given parameters.\n *\n * Changes to objects or links stored in Object Storage V1 are eventually consistent and may take some time to be visible.\n * Edits to objects or links in Object Storage V2 will be visible immediately after the action completes.\n *\n * Note that [parameter default values](https://www.palantir.com/docs/foundry/action-types/parameters-default-value/) are not currently supported by\n * this endpoint.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/actions/{action}/apply\n */\nexport function apply($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _apply, ...args);\n}\nconst _applyAsync = [1, \"/v2/ontologies/{0}/actions/{1}/applyAsync\", 3];\n/**\n * Applies an action using the given parameters.\n *\n * Changes to objects or links stored in Object Storage V1 are eventually consistent and may take some time to be visible.\n * Edits to objects or links in Object Storage V2 will be visible immediately after the action completes.\n *\n * Note that [parameter default values](https://www.palantir.com/docs/foundry/action-types/parameters-default-value/) are not currently supported by\n * this endpoint.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/actions/{action}/applyAsync\n */\nexport function applyAsync($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _applyAsync, ...args);\n}\nconst _applyBatch = [1, \"/v2/ontologies/{0}/actions/{1}/applyBatch\", 3];\n/**\n * Applies multiple actions (of the same Action Type) using the given parameters.\n *\n * Changes to objects or links stored in Object Storage V1 are eventually consistent and may take some time to be visible.\n * Edits to objects or links in Object Storage V2 will be visible immediately after the action completes.\n *\n * Up to 20 actions may be applied in one call. Actions that only modify objects in Object Storage v2 and do not\n * call Functions may receive a higher limit.\n *\n * Note that [notifications](https://www.palantir.com/docs/foundry/action-types/notifications/) are not currently supported by this endpoint.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/actions/{action}/applyBatch\n */\nexport function applyBatch($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _applyBatch, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies/{0}/actionTypes\", 2];\n/**\n * Lists the action types for the given Ontology.\n *\n * Each page may be smaller than the requested page size. However, it is guaranteed that if there are more\n * results available, at least one result will be present in the response.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/actionTypes\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/actionTypes/{1}\", 2];\n/**\n * Gets a specific action type with the given API name.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/actionTypes/{actionType}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _getByRid = [0, \"/v2/ontologies/{0}/actionTypes/byRid/{1}\", 2];\n/**\n * Gets a specific action type with the given RID.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/actionTypes/byRid/{actionTypeRid}\n */\nexport function getByRid($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getByRid, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _upload = [1, \"/v2/ontologies/attachments/upload\", 7, \"*/*\"];\n/**\n * Upload an attachment to use in an action. Any attachment which has not been linked to an object via\n * an action within one hour after upload will be removed.\n * Previously mapped attachments which are not connected to any object anymore are also removed on\n * a biweekly basis.\n * The body of the request must contain the binary content of the file and the `Content-Type` header must be `application/octet-stream`.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-write`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-write]\n * URL: /v2/ontologies/attachments/upload\n */\nexport function upload($ctx, ...args) {\n    const headerParams = {\n        ...args[2],\n        \"Content-Type\": args[2]?.[\"Content-Type\"] ?? args[0].type,\n        \"Content-Length\": args[0].size.toString(),\n    };\n    return $foundryPlatformFetch($ctx, _upload, args[0], args[1], headerParams);\n}\nconst _read = [0, \"/v2/ontologies/attachments/{0}/content\", , , \"*/*\"];\n/**\n * Get the content of an attachment.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/attachments/{attachmentRid}/content\n */\nexport function read($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _read, ...args);\n}\nconst _get = [0, \"/v2/ontologies/attachments/{0}\"];\n/**\n * Get the metadata of an attachment.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/attachments/{attachmentRid}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _getAttachment = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}\", 2];\n/**\n * Get the metadata of attachments parented to the given object.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/attachments/{property}\n */\nexport function getAttachment($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getAttachment, ...args);\n}\nconst _getAttachmentByRid = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/{4}\", 2];\n/**\n * Get the metadata of a particular attachment in an attachment list.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/attachments/{property}/{attachmentRid}\n */\nexport function getAttachmentByRid($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getAttachmentByRid, ...args);\n}\nconst _readAttachment = [\n    0,\n    \"/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/content\",\n    2,\n    ,\n    \"*/*\",\n];\n/**\n * Get the content of an attachment.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/attachments/{property}/content\n */\nexport function readAttachment($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _readAttachment, ...args);\n}\nconst _readAttachmentByRid = [\n    0,\n    \"/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/{4}/content\",\n    2,\n    ,\n    \"*/*\",\n];\n/**\n * Get the content of an attachment by its RID.\n *\n * The RID must exist in the attachment array of the property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/attachments/{property}/{attachmentRid}/content\n */\nexport function readAttachmentByRid($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _readAttachmentByRid, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _decrypt = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/ciphertexts/{3}/decrypt\"];\n/**\n * Decrypt the value of a ciphertext property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read api:ontologies-decrypt-ciphertext`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-decrypt-ciphertext]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/ciphertexts/{property}/decrypt\n */\nexport function decrypt($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _decrypt, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _listLinkedObjects = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/links/{3}\", 2];\n/**\n * Lists the linked objects for a specific object and the given link type.\n *\n * Note that this endpoint does not guarantee consistency. Changes to the data could result in missing or\n * repeated objects in the response pages.\n *\n * For Object Storage V1 backed objects, this endpoint returns a maximum of 10,000 objects. After 10,000 objects have been returned and if more objects\n * are available, attempting to load another page will result in an `ObjectsExceededLimit` error being returned. There is no limit on Object Storage V2 backed objects.\n *\n * Each page may be smaller or larger than the requested page size. However, it\n * is guaranteed that if there are more results available, at least one result will be present\n * in the response.\n *\n * Note that null value properties will not be returned.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/links/{linkType}\n */\nexport function listLinkedObjects($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _listLinkedObjects, ...args);\n}\nconst _getLinkedObject = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/links/{3}/{4}\", 2];\n/**\n * Get a specific linked object that originates from another object.\n *\n * If there is no link between the two objects, `LinkedObjectNotFound` is thrown.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/links/{linkType}/{linkedObjectPrimaryKey}\n */\nexport function getLinkedObject($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getLinkedObject, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _getMediaContent = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/media/{3}/content\", 2, , \"*/*\"];\n/**\n * Gets the content of a media item referenced by this property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scopes: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/media/{property}/content\n */\nexport function getMediaContent($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getMediaContent, ...args);\n}\nconst _getMediaMetadata = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/media/{3}/metadata\", 2];\n/**\n * Gets metadata about the media item referenced by this property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scopes: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/media/{property}/metadata\n */\nexport function getMediaMetadata($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getMediaMetadata, ...args);\n}\nconst _upload = [1, \"/v2/ontologies/{0}/objectTypes/{1}/media/{2}/upload\", 3, \"*/*\"];\n/**\n * Uploads a media item to the media set which backs the specified property.  The property must be backed by a single media set and branch, otherwise an error will be thrown.\n * The body of the request must contain the binary content of the file and the `Content-Type` header must be `application/octet-stream`.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/objectTypes/{objectType}/media/{property}/upload\n */\nexport function upload($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _upload, ...args);\n}\nconst _uploadMedia = [1, \"/v2/ontologies/{0}/actions/{1}/media/upload\", 3, \"*/*\"];\n/**\n * Uploads a media item for use by the specified action. If the media item isn't persisted by the associated action within 1 hour, the item will be deleted.\n *\n * The body of the request must contain the binary content of the file and the `Content-Type` header must be `application/octet-stream`.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/actions/{actionType}/media/upload\n */\nexport function uploadMedia($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _uploadMedia, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies/{0}/objectTypes\", 2];\n/**\n * Lists the object types for the given Ontology.\n *\n * Each page may be smaller or larger than the requested page size. However, it is guaranteed that if there are\n * more results available, at least one result will be present in the\n * response.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectTypes\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/objectTypes/{1}\", 2];\n/**\n * Gets a specific object type with the given API name.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectTypes/{objectType}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _getFullMetadata = [0, \"/v2/ontologies/{0}/objectTypes/{1}/fullMetadata\", 2];\n/**\n * Gets the full metadata for a specific object type with the given API name.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectTypes/{objectType}/fullMetadata\n */\nexport function getFullMetadata($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getFullMetadata, ...args);\n}\nconst _listOutgoingLinkTypes = [0, \"/v2/ontologies/{0}/objectTypes/{1}/outgoingLinkTypes\", 2];\n/**\n * List the outgoing links for an object type.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectTypes/{objectType}/outgoingLinkTypes\n */\nexport function listOutgoingLinkTypes($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _listOutgoingLinkTypes, ...args);\n}\nconst _getOutgoingLinkType = [0, \"/v2/ontologies/{0}/objectTypes/{1}/outgoingLinkTypes/{2}\", 2];\n/**\n * Get an outgoing link for an object type.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectTypes/{objectType}/outgoingLinkTypes/{linkType}\n */\nexport function getOutgoingLinkType($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getOutgoingLinkType, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies/{0}/interfaceTypes\", 2];\n/**\n * :::callout{theme=warning title=Warning}\n * This endpoint is in preview and may be modified or removed at any time.\n * To use this endpoint, add `preview=true` to the request query parameters.\n * :::\n *\n * Lists the interface types for the given Ontology.\n *\n * Each page may be smaller than the requested page size. However, it is guaranteed that if there are more\n * results available, at least one result will be present in the response.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/interfaceTypes\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/interfaceTypes/{1}\", 2];\n/**\n * :::callout{theme=warning title=Warning}\n * This endpoint is in preview and may be modified or removed at any time.\n * To use this endpoint, add `preview=true` to the request query parameters.\n * :::\n *\n * Gets a specific interface type with the given API name.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/interfaceTypes/{interfaceType}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _search = [1, \"/v2/ontologies/{0}/interfaces/{1}/search\", 3];\n/**\n * :::callout{theme=warning title=Warning}\n * This endpoint will be removed once TS OSDK is updated to use `objectSets/loadObjects` with interface object\n * sets.\n * :::\n * :::callout{theme=warning title=Warning}\n * This endpoint is in preview and may be modified or removed at any time.\n * To use this endpoint, add `preview=true` to the request query parameters.\n * :::\n *\n * Search for objects in the specified ontology and interface type. Any properties specified in the \"where\" or\n * \"orderBy\" parameters must be shared property type API names defined on the interface. The following search\n * queries are supported:\n *\n * | Query type                              | Description                                                                                                       | Supported Types                 |\n * |-----------------------------------------|-------------------------------------------------------------------------------------------------------------------|---------------------------------|\n * | lt                                      | The provided property is less than the provided value.                                                            | number, string, date, timestamp |\n * | gt                                      | The provided property is greater than the provided value.                                                         | number, string, date, timestamp |\n * | lte                                     | The provided property is less than or equal to the provided value.                                                | number, string, date, timestamp |\n * | gte                                     | The provided property is greater than or equal to the provided value.                                             | number, string, date, timestamp |\n * | eq                                      | The provided property is exactly equal to the provided value.                                                     | number, string, date, timestamp |\n * | isNull                                  | The provided property is (or is not) null.                                                                        | all                             |\n * | contains                                | The provided property contains the provided value.                                                                | array                           |\n * | not                                     | The sub-query does not match.                                                                                     | N/A (applied on a query)        |\n * | and                                     | All the sub-queries match.                                                                                        | N/A (applied on queries)        |\n * | or                                      | At least one of the sub-queries match.                                                                            | N/A (applied on queries)        |\n * | startsWith                              | The provided property starts with the provided term.                                                              | string                          |\n * | containsAllTermsInOrderPrefixLastTerm   | The provided property contains all the terms provided in order. The last term can be a partial prefix match.      | string                          |\n * | containsAllTermsInOrder                 | The provided property contains the provided terms as a substring.                                                 | string                          |\n * | containsAnyTerm                         | The provided property contains at least one of the terms separated by whitespace.                                 | string                          |\n * | containsAllTerms                        | The provided property contains all the terms separated by whitespace.                                             | string                          |\n *\n * Queries can be at most three levels deep. By default, terms are separated by whitespace or punctuation (`?!,:;-[](){}'\"~`). Periods (`.`) on their own are ignored.\n * Partial terms are not matched by terms filters except where explicitly noted.\n *\n * Attempting to use an unsupported query will result in a validation error. Third-party applications using this\n * endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/interfaces/{interfaceType}/search\n */\nexport function search($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _search, ...args);\n}\nconst _aggregate = [1, \"/v2/ontologies/{0}/interfaces/{1}/aggregate\", 3];\n/**\n * :::callout{theme=warning title=Warning}\n * This endpoint will be removed once TS OSDK is updated to use `objectSets/aggregate` with interface object\n * sets.\n * :::\n * :::callout{theme=warning title=Warning}\n * This endpoint is in preview and may be modified or removed at any time.\n * To use this endpoint, add `preview=true` to the request query parameters.\n * :::\n *\n * Perform functions on object fields in the specified ontology and of the specified interface type. Any\n * properties specified in the query must be shared property type API names defined on the interface.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/interfaces/{interfaceType}/aggregate\n */\nexport function aggregate($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _aggregate, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _createTemporary = [1, \"/v2/ontologies/{0}/objectSets/createTemporary\", 1];\n/**\n * Creates a temporary `ObjectSet` from the given definition. This `ObjectSet` expires after one hour.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read api:ontologies-write`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read, api:ontologies-write]\n * URL: /v2/ontologies/{ontology}/objectSets/createTemporary\n */\nexport function createTemporary($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _createTemporary, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/objectSets/{1}\"];\n/**\n * Gets the definition of the `ObjectSet` with the given RID.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: []\n * URL: /v2/ontologies/{ontology}/objectSets/{objectSetRid}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _load = [1, \"/v2/ontologies/{0}/objectSets/loadObjects\", 3];\n/**\n * Load the ontology objects present in the `ObjectSet` from the provided object set definition.\n *\n * For Object Storage V1 backed objects, this endpoint returns a maximum of 10,000 objects. After 10,000 objects have been returned and if more objects\n * are available, attempting to load another page will result in an `ObjectsExceededLimit` error being returned. There is no limit on Object Storage V2 backed objects.\n *\n * Note that null value properties will not be returned.\n *\n * Vector properties will not be returned unless included in the `select` parameter.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectSets/loadObjects\n */\nexport function load($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _load, ...args);\n}\nconst _loadMultipleObjectTypes = [1, \"/v2/ontologies/{0}/objectSets/loadObjectsMultipleObjectTypes\", 3];\n/**\n * Load the ontology objects present in the `ObjectSet` from the provided object set definition. The resulting\n * objects may be scoped to an object type, in which all the selected properties on the object type are returned, or scoped\n * to an interface, in which only the object type properties that implement the properties of any interfaces in its\n * scope are returned. For objects that are scoped to an interface in the result, a mapping from interface to\n * object implementation is returned in order to interpret the objects as the interfaces that they implement.\n *\n * For Object Storage V1 backed objects, this endpoint returns a maximum of 10,000 objects. After 10,000 objects have been returned and if more objects\n * are available, attempting to load another page will result in an `ObjectsExceededLimit` error being returned. There is no limit on Object Storage V2 backed objects.\n *\n * Note that null value properties will not be returned. In addition, property metadata (rid, apiName, and primaryKey)\n * will be prefixed with '$' instead of '\\_\\_' as is the case in `loadObjects`.\n *\n * Vector properties will not be returned unless included in the `select` parameter.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectSets/loadObjectsMultipleObjectTypes\n */\nexport function loadMultipleObjectTypes($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _loadMultipleObjectTypes, ...args);\n}\nconst _loadObjectsOrInterfaces = [1, \"/v2/ontologies/{0}/objectSets/loadObjectsOrInterfaces\", 3];\n/**\n * Load the ontology objects present in the `ObjectSet` from the provided object set definition. If the requested\n * object set contains interfaces and the object can be viewed as an interface, it will contain the properties\n * defined by the interface. If not, it will contain the properties defined by its object type. This allows directly\n * loading all objects of an interface where all objects are viewed as the interface, for example.\n *\n * Note that the result object set cannot contain a mix of objects with \"interface\" properties and \"object type\"\n * properties. Attempting to load an object set like this will result in an error.\n *\n * For Object Storage V1 backed objects, this endpoint returns a maximum of 10,000 objects. After 10,000 objects have been returned and if more objects\n * are available, attempting to load another page will result in an `ObjectsExceededLimit` error being returned. There is no limit on Object Storage V2 backed objects.\n *\n * Note that null value properties will not be returned. In addition, property metadata (rid, apiName, and primaryKey)\n * will be prefixed with '$' instead of '\\_\\_' as is the case in `/loadObjects`.\n *\n * Vector properties will not be returned unless included in the `select` parameter.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectSets/loadObjectsOrInterfaces\n */\nexport function loadObjectsOrInterfaces($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _loadObjectsOrInterfaces, ...args);\n}\nconst _aggregate = [1, \"/v2/ontologies/{0}/objectSets/aggregate\", 3];\n/**\n * Aggregates the ontology objects present in the `ObjectSet` from the provided object set definition.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objectSets/aggregate\n */\nexport function aggregate($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _aggregate, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies/{0}/objects/{1}\", 2];\n/**\n * Lists the objects for the given Ontology and object type.\n *\n * Note that this endpoint does not guarantee consistency. Changes to the data could result in missing or\n * repeated objects in the response pages.\n *\n * For Object Storage V1 backed objects, this endpoint returns a maximum of 10,000 objects. After 10,000 objects have been returned and if more objects\n * are available, attempting to load another page will result in an `ObjectsExceededLimit` error being returned. There is no limit on Object Storage V2 backed objects.\n *\n * Each page may be smaller or larger than the requested page size. However, it\n * is guaranteed that if there are more results available, at least one result will be present\n * in the response.\n *\n * Note that null value properties will not be returned.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/objects/{1}/{2}\", 2];\n/**\n * Gets a specific object with the given primary key.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _count = [1, \"/v2/ontologies/{0}/objects/{1}/count\", 2];\n/**\n * Returns a count of the objects of the given object type.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/count\n */\nexport function count($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _count, ...args);\n}\nconst _search = [1, \"/v2/ontologies/{0}/objects/{1}/search\", 3];\n/**\n * Search for objects in the specified ontology and object type. The request body is used\n * to filter objects based on the specified query. The supported queries are:\n *\n * | Query type                              | Description                                                                                                       | Supported Types                 |\n * |-----------------------------------------|-------------------------------------------------------------------------------------------------------------------|---------------------------------|\n * | lt                                      | The provided property is less than the provided value.                                                            | number, string, date, timestamp |\n * | gt                                      | The provided property is greater than the provided value.                                                         | number, string, date, timestamp |\n * | lte                                     | The provided property is less than or equal to the provided value.                                                | number, string, date, timestamp |\n * | gte                                     | The provided property is greater than or equal to the provided value.                                             | number, string, date, timestamp |\n * | eq                                      | The provided property is exactly equal to the provided value.                                                     | number, string, date, timestamp |\n * | isNull                                  | The provided property is (or is not) null.                                                                        | all                             |\n * | contains                                | The provided property contains the provided value.                                                                | array                           |\n * | not                                     | The sub-query does not match.                                                                                     | N/A (applied on a query)        |\n * | and                                     | All the sub-queries match.                                                                                        | N/A (applied on queries)        |\n * | or                                      | At least one of the sub-queries match.                                                                            | N/A (applied on queries)        |\n * | containsAllTermsInOrderPrefixLastTerm   | The provided property contains all the terms provided in order. The last term can be a partial prefix match.      | string                          |\n * | containsAllTermsInOrder                 | The provided property contains the provided term as a substring.                                                  | string                          |\n * | containsAnyTerm                         | The provided property contains at least one of the terms separated by whitespace.                                 | string                          |\n * | containsAllTerms                        | The provided property contains all the terms separated by whitespace.                                             | string                          |\n * | startsWith                              | Deprecated alias for containsAllTermsInOrderPrefixLastTerm.                                                       | string                          |\n *\n * Queries can be at most three levels deep. By default, terms are separated by whitespace or punctuation (`?!,:;-[](){}'\"~`). Periods (`.`) on their own are ignored.\n * Partial terms are not matched by terms filters except where explicitly noted.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/search\n */\nexport function search($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _search, ...args);\n}\nconst _aggregate = [1, \"/v2/ontologies/{0}/objects/{1}/aggregate\", 3];\n/**\n * Perform functions on object fields in the specified ontology and object type.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/aggregate\n */\nexport function aggregate($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _aggregate, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies\"];\n/**\n * Lists the Ontologies visible to the current user.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}\"];\n/**\n * Gets a specific ontology with the given Ontology RID.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\nconst _getFullMetadata = [0, \"/v2/ontologies/{0}/fullMetadata\", 2];\n/**\n * Get the full Ontology metadata. This includes the objects, links, actions, queries, and interfaces.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/fullMetadata\n */\nexport function getFullMetadata($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getFullMetadata, ...args);\n}\nconst _loadMetadata = [1, \"/v2/ontologies/{0}/metadata\", 3];\n/**\n * Load Ontology metadata for the requested object, link, action, query, and interface types.\n *\n * @alpha\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/metadata\n */\nexport function loadMetadata($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _loadMetadata, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _execute = [1, \"/v2/ontologies/{0}/queries/{1}/execute\", 3];\n/**\n * Executes a Query using the given parameters.\n *\n * Optional parameters do not need to be supplied.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/queries/{queryApiName}/execute\n */\nexport function execute($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _execute, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _list = [0, \"/v2/ontologies/{0}/queryTypes\", 2];\n/**\n * Lists the query types for the given Ontology.\n *\n * Each page may be smaller than the requested page size. However, it is guaranteed that if there are more\n * results available, at least one result will be present in the response.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/queryTypes\n */\nexport function list($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _list, ...args);\n}\nconst _get = [0, \"/v2/ontologies/{0}/queryTypes/{1}\", 2];\n/**\n * Gets a specific query type with the given API name.\n *\n * Third-party applications using this endpoint via OAuth2 must request the following operation scope: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/queryTypes/{queryApiName}\n */\nexport function get($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _get, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _getFirstPoint = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/firstPoint\", 2];\n/**\n * Get the first point of a time series property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/timeseries/{property}/firstPoint\n */\nexport function getFirstPoint($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getFirstPoint, ...args);\n}\nconst _getLastPoint = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/lastPoint\", 2];\n/**\n * Get the last point of a time series property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/timeseries/{property}/lastPoint\n */\nexport function getLastPoint($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getLastPoint, ...args);\n}\nconst _streamPoints = [\n    1,\n    \"/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/streamPoints\",\n    3,\n    ,\n    \"*/*\",\n];\n/**\n * Stream all of the points of a time series property.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @public\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/timeseries/{property}/streamPoints\n */\nexport function streamPoints($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _streamPoints, ...args);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { foundryPlatformFetch as $foundryPlatformFetch } from \"@osdk/shared.net.platformapi\";\n//\nconst _getLatestValue = [0, \"/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/latestValue\", 2];\n/**\n * Get the latest value of a property backed by a timeseries. If a specific geotime series integration has both a history and a live integration, we will give precedence to the live integration.\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/timeseries/{propertyName}/latestValue\n */\nexport function getLatestValue($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _getLatestValue, ...args);\n}\nconst _streamValues = [\n    1,\n    \"/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/streamValues\",\n    3,\n    ,\n    \"*/*\",\n];\n/**\n * Stream all of the points of a time series property (this includes geotime series references).\n *\n * Third-party applications using this endpoint via OAuth2 must request the\n * following operation scopes: `api:ontologies-read`.\n *\n * @beta\n *\n * Required Scopes: [api:ontologies-read]\n * URL: /v2/ontologies/{ontology}/objects/{objectType}/{primaryKey}/timeseries/{property}/streamValues\n */\nexport function streamValues($ctx, ...args) {\n    return $foundryPlatformFetch($ctx, _streamValues, ...args);\n}\n", "async function conjureFetch(\n  { fetchFn, baseUrl, servicePath, tokenProvider },\n  url,\n  method,\n  body,\n  params,\n  contentType,\n  accept,\n) {\n  if (body) {\n    if (\n      body instanceof URLSearchParams || body instanceof Blob || body instanceof FormData\n      || typeof body === \"string\" || body instanceof ArrayBuffer\n    );\n    else {\n      body = JSON.stringify(body);\n    }\n  }\n  const queryParams = Object.entries(params ?? {}).flatMap(\n    ([key, value]) => {\n      if (value == null) {\n        return [];\n      }\n      if (Array.isArray(value)) {\n        return value.map((item) => [key, item]);\n      }\n      const stringValue = \"\" + value;\n      return stringValue.length === 0 ? [] : [[key, stringValue]];\n    },\n  );\n  const query = Object.keys(queryParams).length === 0\n    ? \"\"\n    : `?${new URLSearchParams(queryParams).toString()}`;\n  const response = await (fetchFn ?? fetch)(`${baseUrl}${servicePath}${url}${query}`, {\n    method,\n    credentials: \"same-origin\",\n    headers: {\n      \"Fetch-User-Agent\": \"conjure-lite\",\n      \"Content-Type\": contentType ?? \"application/json\",\n      accept: accept ?? \"application/json\",\n      ...tokenProvider ? { \"Authorization\": `Bearer ${await tokenProvider()}` } : {},\n    },\n    ...body ? { body } : {},\n  });\n  try {\n    if (response.status === 204) {\n      return void 0;\n    }\n    const body2 = await readBody(response);\n    if (!response.ok) {\n      throw new ConjureError(\"STATUS\", void 0, response.status, body2);\n    }\n    return body2;\n  } catch (error) {\n    if (error instanceof ConjureError) {\n      throw error;\n    } else if (error instanceof TypeError) {\n      throw new ConjureError(\"NETWORK\", error);\n    } else {\n      throw new ConjureError(\"OTHER\", error);\n    }\n  }\n}\nasync function readBody(response) {\n  const contentType = response.headers.get(\"Content-Type\") != null\n    ? response.headers.get(\"Content-Type\")\n    : \"\";\n  try {\n    if (contentType.includes(\"application/json\")) {\n      return await response.json();\n    } else if (contentType.includes(\"application/octet-stream\")) {\n      return await response.blob();\n    } else {\n      return await response.text();\n    }\n  } catch (error) {\n    throw new ConjureError(\"PARSE\", error, response.status);\n  }\n}\nclass ConjureError {\n  type;\n  originalError;\n  status;\n  body;\n  constructor(errorType, originalError, status, body) {\n    this.type = errorType;\n    this.originalError = originalError;\n    this.status = status;\n    this.body = body;\n  }\n  toString() {\n    return JSON.stringify(\n      {\n        body: this.body,\n        originalError: this.originalError && this.originalError.toString(),\n        status: this.status,\n        type: this.type,\n      },\n      null,\n      \"  \",\n    );\n  }\n}\n\nexport { conjureFetch };\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { conjureFetch } from \"conjure-lite\";\n/**\n * Creates a temporary object set that will live for at least as long as the provided TTL, and will get deleted\n * at some point after that.\n *\n * Temporary object sets created by unscoped user tokens can only be accessed by the user that created them; a\n * gatekeeper resource is registered for every such temporary object set. NOTE: The same gatekeeper resource may\n * be reused for the same userId across different createTemporaryObjectSet requests.\n *\n * If the temporary object set is created from a build that uses a 'security-rid' output then the temp object\n * set will be secured using the relevant OutputSecurityRid for the build.\n *\n * Whenever an object set (temporary, or otherwise) referencing a temporary object set gets saved or used in\n * versioned object sets, the reference gets replaced with a full definition of the previously saved temporary\n * object. This is to ensure that they do not inherit the TTL of temporary object sets they reference.\n *\n * Please consider using temporary object sets whenever there is a need to save an object set just to be able to\n * pass it to another service without a need to persist it indefinitely.\n */\nexport async function createTemporaryObjectSet(ctx, request) {\n  return conjureFetch(ctx, `/objectSets/temporary`, \"POST\", request);\n}", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { conjureFetch } from \"conjure-lite\";\n/**\n * Returns a page of all `FoundryLink`s for a given relation based on a list of object identifiers. Response will\n * contain entries for every requested object regardless of links found.\n *\n * The API supports fetching links for maximum 5_000 ObjectIdentifiers in a single request.\n * Results are always limited to the maximum of 100_000 links, without applying any particular order. Specifically,\n * this means that if total links count is above 100_000 then the whole result set should be considered partial,\n * i.e. there is no guarantee that for a given object all links have been retrieved.\n * Note that this endpoint does not check if objects referenced by the returned links actually exist. For instance,\n * when primary keys in the join table become stale, it will still return links based on the stale join table records.\n *\n * Note that this API does not support OSv1 links and will throw an exception if links provided are backed by OSv1.\n */\nexport async function getBulkLinksPage(ctx, request) {\n  return conjureFetch(ctx, `/bulk-links`, \"PUT\", request);\n}", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { conjureFetch } from \"conjure-lite\";\n/**\n * Endpoint to load Ontology entities in bulk. The returned OntologyBulkLoadEntitiesResponse will only\n * contain entities that actually exist and are visible to the user. If the user has requested entities at\n * invalid versions or entities that do not exist in the specified versions, those will not be present\n * in the response.\n *\n * There are limits on the number of entities that can be loaded in one request. Please refer to\n * documentation of OntologyBulkLoadEntitiesRequest for the values of these limits.\n */\nexport async function bulkLoadOntologyEntities(ctx, onBehalfOf, request) {\n  return conjureFetch(ctx, `/ontology/ontology/bulkLoadEntities`, \"POST\", request);\n}", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { conjureFetch } from \"conjure-lite\";\n/**\n * Endpoint to batch load links associated to given ObjectTypeRid(s). The GetLinkTypesForObjectTypesResponse\n * will only contain links that are visible to the user. If the user has requested to get link types at\n * invalid ontology versions or for ObjectTypeRid(s) that do not exist in the specified versions, those entries\n * will include an empty set of link types.\n *\n * The includeObjectTypesWithoutSearchableDatasources flag is respected if present in the request,\n * else we set it to a default (false) unless the user-agent is blocklisted.\n * The flag is set to true for blocklisted user agents. Currently the blocklist\n * includes functions-typescript-gradle-plugin only.\n */\nexport async function getLinkTypesForObjectTypes(ctx, request) {\n  return conjureFetch(ctx, `/ontology/linkTypesForObjectTypes`, \"POST\", request);\n}", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { conjureFetch } from \"conjure-lite\";\n/**\n * Endpoint to load metadata about the Ontologies a user has access to. The response will contain\n * only Ontologies on which the user has `ontology:view-ontology`. Note that the returned\n * LoadAllOntologiesResponse may be empty if there is no Ontology yet.\n */\nexport async function loadAllOntologies(ctx, request) {\n  return conjureFetch(ctx, `/ontology/ontology/ontologies/load/all`, \"POST\", request);\n}", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ntype DeepWriteable<T> = {\n  -readonly [P in keyof T]: DeepWriteable<T[P]>;\n};\n\n/**\n * Helper function that creates the shape of a conjure union in fewer bytes than manually declaring it (when compressed)\n *\n * e.g `{type:\"base\",base:{foo:5}}` becomes `a(\"base\",{foo:5})`\n */\nexport function conjureUnionType<T extends string, const V>(\n  type: T,\n  value: V,\n): { type: T } & Record<T, DeepWriteable<V>> {\n  return {\n    type,\n    [type]: value,\n  } as { type: T } & Record<T, V>;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedClientContext } from \"@osdk/shared.client2\";\nimport type { ConjureContext } from \"conjure-lite\";\n\nexport function makeConjureContext(\n  { baseUrl, fetch: fetchFn, tokenProvider }: SharedClientContext,\n  servicePath: string,\n): ConjureContext {\n  return {\n    baseUrl,\n    servicePath,\n    fetchFn,\n    tokenProvider,\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function getResults<T extends { results: any[] }>(x: T): T[\"results\"] {\n  return x.results;\n}\nexport function applyPageToken<\n  X,\n  T extends { pageToken: X | undefined },\n>(\n  payload: T,\n  { pageToken }: { pageToken: X | undefined },\n): typeof payload | undefined {\n  return pageToken\n    ? {\n      ...payload,\n      pageToken,\n    }\n    : undefined;\n}\nexport async function* pageRequestAsAsyncIter<P, Z, R>(\n  call: (payload: P) => Promise<R>,\n  values: (x: R) => Iterable<Z>,\n  nextArgs: (previousPayload: P, previousResult: R) => P | undefined,\n  initialPayload: P,\n): AsyncGenerator<Awaited<Z>, void, unknown> {\n  let payload: P | undefined = initialPayload;\n\n  while (payload) {\n    const r = await call(payload);\n    for (const q of values(r)) {\n      yield q;\n    }\n    payload = nextArgs(payload, r);\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A simple cache that can be used to store values for a given client.\n */\n\nexport interface SimpleCache<K, V> {\n  get: (key: K) => V;\n  set: <X extends V>(key: K, value: X) => X;\n  remove: (key: K) => boolean;\n}\n/**\n * Create a new cache with a factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n */\n\nexport function createSimpleCache<K, V>(\n  map: Map<K, V> | (K extends object ? WeakMap<K, V> : never),\n  fn: (k: K) => V,\n): SimpleCache<K, V>;\n/**\n * Create a new cache without a factory function.\n */\nexport function createSimpleCache<K, V>(\n  map?: Map<K, V> | (K extends object ? WeakMap<K, V> : never),\n): SimpleCache<\n  K,\n  V | undefined\n>;\nexport function createSimpleCache<K, V>(\n  map: Map<K, V> | (K extends object ? WeakMap<K, V> : never) =\n    new Map() as any,\n  fn?: undefined | ((k: K) => V),\n): typeof fn extends undefined ? SimpleCache<K, V | undefined>\n  : SimpleCache<K, V>\n{\n  function get(key: K) {\n    let r = (map as Map<K, V>).get(key as any);\n    if (r === undefined && fn !== undefined) {\n      return set(key, fn(key));\n    } else {\n      return r;\n    }\n  }\n\n  function set(key: K, value: V) {\n    map.set(key as any, value);\n    return value;\n  }\n\n  function remove(key: K) {\n    return map.delete(key as any);\n  }\n\n  return { get, set, remove } as SimpleCache<K, V>;\n}\n/**\n * A simple async cache that can be used to store values for a given client.\n */\n\nexport interface WeakAsyncCache<K, V> {\n  getOrUndefined: (key: K) => V | undefined;\n\n  get: (key: K) => Promise<V>;\n\n  /**\n   * @param client the client to key from\n   * @param key the sub-key to use\n   * @param value the value or a promise to the value\n   * @returns a new promise to the resolved value\n   */\n  set: (\n    key: K,\n    value: V | Promise<V>,\n  ) => Promise<V>;\n}\n/**\n * Create a new cache with an async factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n * @returns\n */\n\nexport function createSimpleAsyncCache<K, V>(\n  type: \"weak\" | \"strong\",\n  fn: (key: K) => Promise<V>,\n  createCacheLocal: typeof createSimpleCache = createSimpleCache,\n): WeakAsyncCache<K, V> {\n  const cache = createCacheLocal<K, V>(\n    (type === \"weak\" ? new WeakMap() : new Map()) as Map<K, V>,\n  );\n  const inProgress = createCacheLocal<K, Promise<V> | V>(\n    (type === \"weak\" ? new WeakMap() : new Map()) as Map<K, V>,\n  );\n\n  const ret = {\n    getOrUndefined: function getOrUndefined(key: K) {\n      return cache.get(key);\n    },\n\n    get: async function get(key: K) {\n      return cache.get(key) ?? inProgress.get(key)\n        ?? ret.set(key, fn(key));\n    },\n\n    set: async function set(k: K, v: V | Promise<V>) {\n      // the `.set` happens first to prevent races.\n      try {\n        const r = await inProgress.set(k, v); // returns v\n\n        cache.set(k, r);\n        inProgress.remove(k);\n        return r;\n      } catch (e) {\n        // we don't want to cache failures\n        inProgress.remove(k);\n        throw e;\n      }\n    },\n  };\n\n  return ret;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  DirectedLinkTypeRid,\n  LinkTypeMetadata,\n  LoadAllOntologiesResponse,\n  ObjectType,\n  Type,\n} from \"@osdk/client.unstable\";\nimport {\n  bulkLoadOntologyEntities,\n  getLinkTypesForObjectTypes,\n  loadAllOntologies,\n} from \"@osdk/client.unstable\";\nimport type { ConjureContext } from \"conjure-lite\";\nimport invariant from \"tiny-invariant\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport {\n  createSimpleAsyncCache,\n  createSimpleCache,\n} from \"../object/SimpleCache.js\";\nimport { makeConjureContext } from \"../ontology/makeConjureContext.js\";\n\nexport interface ObjectPropertyMapping {\n  apiName: string;\n  id: string;\n  propertyIdToApiNameMapping: Record<string, string>;\n  propertyApiNameToIdMapping: Record<string, string>;\n  pk: {\n    rid: string;\n    apiName: string;\n    type: Type;\n  };\n}\n\ntype ObjectLinkMapping = Record<string, {\n  apiName: string;\n  directedLinkTypeRid: DirectedLinkTypeRid;\n  otherObjectType: string; // rid\n}>;\n\nlet cachedAllOntologies: LoadAllOntologiesResponse | undefined;\nasync function getOntologyVersionForRid(\n  ctx: ConjureContext,\n  ontologyRid: string,\n) {\n  cachedAllOntologies ??= await loadAllOntologies(ctx, {});\n  invariant(\n    cachedAllOntologies.ontologies[ontologyRid],\n    \"ontology should be loaded\",\n  );\n\n  return cachedAllOntologies.ontologies[ontologyRid].currentOntologyVersion;\n}\n\nconst strongMemoSync = <K, V>(fn: (entry: K) => V) =>\n  createSimpleCache<K, V>(new Map(), fn).get;\n\nconst weakMemoSync = <K extends object, V>(fn: (entry: K) => V) =>\n  createSimpleCache<K, V>(new WeakMap() as any, fn).get; // FIXME\n\nconst strongMemoAsync = <K, V>(fn: (entry: K) => Promise<V>) =>\n  createSimpleAsyncCache<K, V>(\"strong\", fn).get;\n\nconst weakMemoAsync = <K, V>(fn: (entry: K) => Promise<V>) =>\n  createSimpleAsyncCache<K, V>(\"weak\", fn).get;\n\nexport class MetadataClient {\n  #client: MinimalClient;\n  #ctx: ConjureContext;\n  #logger: any;\n\n  constructor(client: MinimalClient) {\n    this.#client = client;\n    this.#ctx = makeConjureContext(client, \"ontology-metadata/api\");\n    this.#client.ontologyProvider.getObjectDefinition;\n\n    this.#logger = this.#client.logger?.child({\n      mcc: true,\n    });\n  }\n\n  forObjectByRid: (key: string) => Promise<{\n    getPropertyMapping: () => Promise<ObjectPropertyMapping>;\n    getLinkMapping: () => Promise<ObjectLinkMapping>;\n    getRid: () => string;\n    getApiName: () => Promise<string | null | undefined>;\n  }> = strongMemoAsync(async (rid: string) => {\n    return Promise.resolve({\n      getPropertyMapping: this.#objectPropertyMapping.bind(this, rid),\n      getLinkMapping: this.#objectLinkMapping.bind(this, rid),\n      getRid: () => rid,\n      getApiName: async () => (await this.#getConjureObjectType(rid)).apiName,\n    });\n  });\n\n  forObjectByApiName: (key: string) => Promise<{\n    getPropertyMapping: () => Promise<ObjectPropertyMapping>;\n    getLinkMapping: () => Promise<ObjectLinkMapping>;\n    getRid: () => string;\n    getApiName: () => Promise<string | null | undefined>;\n  }> = strongMemoAsync(\n    async (objectApiName: string) => {\n      const objectDef = await this.#client.ontologyProvider.getObjectDefinition(\n        objectApiName,\n      );\n      return this.forObjectByRid(objectDef.rid);\n    },\n  );\n\n  #objectPropertyMapping = strongMemoAsync(async (objectTypeRid: string) => {\n    const conjureObjectType = await this.#getConjureObjectType(objectTypeRid);\n    return createObjectPropertyMapping(conjureObjectType);\n  });\n\n  #objectLinkMapping = strongMemoAsync(async (objectTypeRid: string) => {\n    const linkTypes = await getLinkTypesForObjectTypes(this.#ctx, {\n      includeObjectTypesWithoutSearchableDatasources: true,\n      loadRedacted: false,\n      objectTypeBranches: {},\n      objectTypeVersions: {\n        [objectTypeRid]: await this.ontologyVersion(\"\"),\n      },\n    });\n    invariant(\n      linkTypes.linkTypes[objectTypeRid],\n      \"link type should be loaded\",\n    );\n\n    // apiName to content\n    const ret: ObjectLinkMapping = {};\n    for (const l of linkTypes.linkTypes[objectTypeRid]) {\n      const helper = (\n        { apiName }: LinkTypeMetadata,\n        linkSide: \"SOURCE\" | \"TARGET\",\n        otherObjectType: string,\n      ) => {\n        if (apiName) {\n          ret[apiName] = {\n            apiName,\n            directedLinkTypeRid: {\n              linkTypeRid: l.rid,\n              linkSide,\n            },\n            otherObjectType,\n          };\n        }\n      };\n      if (l.definition.type === \"oneToMany\") {\n        const {\n          oneToMany: {\n            objectTypeRidManySide,\n            manyToOneLinkMetadata,\n            objectTypeRidOneSide,\n            oneToManyLinkMetadata,\n          },\n        } = l.definition;\n        if (objectTypeRidManySide === objectTypeRid) {\n          helper(\n            manyToOneLinkMetadata,\n            \"TARGET\",\n            objectTypeRidOneSide,\n          );\n        }\n        if (objectTypeRidOneSide === objectTypeRid) {\n          helper(\n            oneToManyLinkMetadata,\n            \"SOURCE\",\n            objectTypeRidManySide,\n          );\n        }\n      } else if (l.definition.type === \"manyToMany\") {\n        const {\n          manyToMany: {\n            objectTypeRidA,\n            objectTypeAToBLinkMetadata,\n            objectTypeRidB,\n            objectTypeBToALinkMetadata,\n          },\n        } = l.definition;\n        if (objectTypeRidA === objectTypeRid) {\n          helper(\n            objectTypeAToBLinkMetadata,\n            \"SOURCE\",\n            objectTypeRidB,\n          );\n        }\n\n        if (objectTypeRidB === objectTypeRid) {\n          helper(\n            objectTypeBToALinkMetadata,\n            \"TARGET\",\n            objectTypeRidA,\n          );\n        }\n      }\n    }\n\n    return ret;\n  });\n\n  #getConjureObjectType = strongMemoAsync(async (objectTypeRid: string) => {\n    this.#logger?.debug(`getConjureObjectType(${objectTypeRid})`);\n    const body = {\n      datasourceTypes: [],\n      objectTypes: [{\n        identifier: {\n          type: \"objectTypeRid\" as const,\n          objectTypeRid: objectTypeRid,\n        },\n        versionReference: {\n          type: \"ontologyVersion\" as const,\n          ontologyVersion: await this.ontologyVersion(\"\"),\n        },\n      }],\n      linkTypes: [],\n      sharedPropertyTypes: [],\n      interfaceTypes: [],\n      typeGroups: [],\n      loadRedacted: false,\n      includeObjectTypeCount: undefined,\n      includeObjectTypesWithoutSearchableDatasources: true,\n      includeEntityMetadata: undefined,\n      actionTypes: [],\n      includeTypeGroupEntitiesCount: undefined,\n      entityMetadata: undefined,\n    };\n    const entities = await bulkLoadOntologyEntities(this.#ctx, undefined, body);\n    invariant(\n      entities.objectTypes[0]?.objectType,\n      \"object type should be loaded\",\n    );\n    return entities.objectTypes[0].objectType;\n  });\n\n  ontologyVersion: (key: string) => Promise<string> = strongMemoAsync(async (\n    _: string,\n  ) => getOntologyVersionForRid(this.#ctx, await this.#client.ontologyRid));\n}\n\nexport const metadataCacheClient: (\n  key: MinimalClient,\n) => Promise<MetadataClient> = weakMemoAsync(\n  (client: MinimalClient) => Promise.resolve(new MetadataClient(client)),\n);\n\nfunction createObjectPropertyMapping(\n  conjureOT: ObjectType,\n): ObjectPropertyMapping {\n  invariant(\n    conjureOT.primaryKeys.length === 1,\n    `only one primary key supported, got ${conjureOT.primaryKeys.length}`,\n  );\n  const pkRid = conjureOT.primaryKeys[0];\n\n  const pkProperty = Object.values(conjureOT.propertyTypes).find(a =>\n    a.rid === pkRid\n  );\n  if (!pkProperty) {\n    throw new Error(`Could not find PK property by rid: ${pkRid}`);\n  }\n\n  const propertyIdToApiNameMapping: Record<string, string> = Object\n    .fromEntries(\n      Object.values(conjureOT.propertyTypes).map(\n        property => {\n          return [property.id, property.apiName!];\n        },\n      ),\n    );\n\n  const propertyApiNameToIdMapping: Record<string, string> = Object\n    .fromEntries(\n      Object.values(conjureOT.propertyTypes).map(\n        property => {\n          return [property.apiName!, property.id];\n        },\n      ),\n    );\n\n  return {\n    apiName: conjureOT.apiName!,\n    id: conjureOT.id,\n    propertyIdToApiNameMapping,\n    propertyApiNameToIdMapping,\n    pk: {\n      rid: pkRid,\n      apiName: pkProperty.apiName!,\n      type: pkProperty.type,\n    },\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OsdkBase } from \"@osdk/api\";\nimport type { EXPERIMENTAL_BulkLinkResult as BulkLinkResult } from \"@osdk/api/unstable\";\nimport type {\n  DirectedLinkTypeRid,\n  FoundryObjectReference,\n  GetBulkLinksPageRequest,\n  ObjectIdentifier,\n} from \"@osdk/client.unstable\";\nimport { getBulkLinksPage } from \"@osdk/client.unstable\";\nimport invariant from \"tiny-invariant\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { conjureUnionType } from \"../objectSet/conjureUnionType.js\";\nimport { makeConjureContext } from \"../ontology/makeConjureContext.js\";\nimport {\n  applyPageToken,\n  getResults,\n  pageRequestAsAsyncIter,\n} from \"../pageRequestAsAsyncIter.js\";\nimport { metadataCacheClient } from \"./ConjureSupport.js\";\n\nexport function createBulkLinksAsyncIterFactory(ctx: MinimalClient) {\n  return async function*(\n    objs: Array<OsdkBase<any>>,\n    linkTypes: string[],\n  ): AsyncGenerator<BulkLinkResult, void, unknown> {\n    if (objs.length === 0) {\n      return;\n    }\n\n    ctx.logger?.debug(\"Preparing to fetch bulk links\");\n\n    // require all objects to be the same type for now\n    invariant(objs.every(a => a.$objectType === objs[0].$objectType));\n\n    const mcc = await metadataCacheClient(ctx);\n    const helper = await mcc.forObjectByApiName(objs[0].$objectType);\n\n    const [objectTypeRid, propertyMapping, fullLinkMapping] = await Promise.all(\n      [\n        helper.getRid(),\n        helper.getPropertyMapping(),\n        helper.getLinkMapping(),\n      ],\n    );\n\n    const linkMapping = Object.fromEntries(\n      Object.entries(fullLinkMapping)\n        .filter(([apiName]) => linkTypes.includes(apiName)),\n    );\n\n    // make sure the link being requested exists\n    for (const linkType of linkTypes) {\n      if (linkMapping[linkType] == null) {\n        throw \"Unable to find link type: \" + linkType;\n      }\n    }\n\n    const req: GetBulkLinksPageRequest = {\n      objectSetContext: {\n        forkRid: undefined,\n        objectSetFilterContext: { parameterOverrides: {} },\n        ontologyBranchRid: undefined,\n        owningRid: undefined,\n        reportUsage: undefined,\n        workstateRid: undefined,\n      },\n      responseOptions: {\n        includeObjectSetEntities: true,\n        includeUsageCost: false,\n      },\n      pageSize: 1000,\n      pageToken: undefined,\n      linksRequests: [{\n        directedLinkTypes: Object.values(linkMapping)\n          .map<DirectedLinkTypeRid>(({ directedLinkTypeRid }) =>\n            directedLinkTypeRid\n          ),\n        objects: conjureUnionType(\n          \"objects\",\n          objs.map<ObjectIdentifier>(o =>\n            conjureUnionType(\"objectLocatorV2\", {\n              objectTypeRid,\n              objectPrimaryKey: {\n                [propertyMapping.pk.rid]: conjureUnionType(\n                  propertyMapping.pk.type.type as \"string\",\n                  o.$primaryKey as string,\n                ),\n              },\n            })\n          ),\n        ),\n      }],\n    };\n\n    const bulkLinksIter = pageRequestAsAsyncIter(\n      getBulkLinksPage.bind(\n        undefined,\n        makeConjureContext(ctx, \"object-set-service/api\"),\n      ),\n      getResults,\n      (prevReq, prevResult) =>\n        applyPageToken({ ...prevReq, pageToken: prevResult.pageToken }, {\n          pageToken: prevResult.pageToken,\n        }),\n      req,\n    );\n\n    for await (const item of bulkLinksIter) {\n      const { objectIdentifier } = item;\n      const obj = findObject(objectIdentifier, objs);\n\n      for (const link of item.links) {\n        const ref = link.link[\n          link.linkSide === \"SOURCE\"\n            ? \"objectSideB\"\n            : \"objectSideA\"\n        ];\n        const pk = getPrimaryKeyOrThrow(ref);\n        const otherObjectApiName =\n          await (await mcc.forObjectByRid(pk.objectTypeRid))\n            .getApiName();\n\n        const mappedLink = Object.values(linkMapping).find(a =>\n          a.directedLinkTypeRid.linkTypeRid === link.link.linkTypeRid\n          && a.directedLinkTypeRid.linkSide === link.linkSide\n        );\n        if (!mappedLink) throw new Error(\"Could not find link type\"); // should not happens\n\n        yield {\n          object: obj,\n          linkApiName: mappedLink.apiName,\n          otherObjectApiName: otherObjectApiName,\n          otherObjectPk: pk.pkValue,\n        };\n      }\n    }\n  };\n}\n\nfunction findObject(\n  objectIdentifier: ObjectIdentifier,\n  objs: (OsdkBase<any>)[],\n) {\n  const { pkValue } = getPrimaryKeyOrThrow(objectIdentifier);\n\n  const obj = objs.find(o => o.$primaryKey === pkValue);\n  if (obj == null) {\n    throw new Error(\n      `Needed to find object with pk ${pkValue}} and could not`,\n    );\n  }\n  return obj;\n}\n\nfunction getPrimaryKeyOrThrow(\n  ref: FoundryObjectReference | ObjectIdentifier,\n) {\n  if (\"type\" in ref && ref.type !== \"objectLocatorV2\") {\n    throw new Error(\"We do not support looking up object by rid\");\n  }\n\n  const pks = Object.entries(ref.objectLocatorV2.objectPrimaryKey);\n  if (pks.length !== 1) {\n    throw new Error(\n      \"Unable to support this request due to multiple pks\",\n    );\n  }\n\n  return {\n    objectTypeRid: ref.objectLocatorV2.objectTypeRid,\n    pkValue: (pks[0][1] as any)[pks[0][1].type] as unknown,\n  };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function createFetchHeaderMutator(\n  fetchFn: typeof fetch | undefined = fetch,\n  mutator: (headers: Headers) => Promise<Headers> | Headers,\n): typeof fetch {\n  return async function headerMutatedFetch(\n    url: RequestInfo | URL,\n    requestInit?: RequestInit,\n  ) {\n    if (!requestInit) {\n      return fetchFn(url, { headers: await mutator(new Headers()) });\n    }\n\n    return fetchFn(url, {\n      ...requestInit,\n      headers: await mutator(new Headers(requestInit.headers)),\n    });\n  };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PalantirApiError, UnknownError } from \"@osdk/shared.net.errors\";\n\n/**\n * Wraps a fetch plugin so that all errors (including when statusCode is not in the 200s) are converted to either PalantirApiError or UnknownError.\n *\n * If the returned promise does not have an error state, you are free to immediately call `.json()` or equivalent.\n *\n * @param fetchFn\n * @returns\n */\nexport function createFetchOrThrow(fetchFn: typeof fetch = fetch) {\n  return async function fetchOrThrow(\n    url: RequestInfo | URL,\n    requestInit?: RequestInit,\n  ): Promise<Response> {\n    let response;\n\n    try {\n      response = await fetchFn(url, requestInit);\n    } catch (e) {\n      throw convertError(e, \"A network error occurred\");\n    }\n\n    if (!response.ok) {\n      const fallbackMessage =\n        `Failed to fetch ${response.status} ${response.statusText}`;\n\n      if (response.headers.get(\"Content-Type\") === \"text/plain\") {\n        throw unknownError(await response.text(), response.status);\n      }\n\n      if (response.headers.get(\"Content-Type\") === \"text/html\") {\n        throw unknownError(\n          fallbackMessage,\n          response.status,\n          new Error(\"Received HTML error page: \" + await response.text()),\n        );\n      }\n\n      let body;\n      try {\n        body = await response.json();\n      } catch (e) {\n        throw unknownError(\n          fallbackMessage,\n          response.status,\n          e instanceof Error ? e : undefined,\n        );\n      }\n\n      throw new PalantirApiError(\n        body?.message\n          ?? fallbackMessage,\n        body?.errorName,\n        body?.errorCode,\n        response.status,\n        body?.errorInstanceId,\n        body?.parameters,\n      );\n    }\n    return response;\n  };\n}\n\nfunction convertError(\n  e: any,\n  msgIfNotError: string = \"An unknown error occurred\",\n) {\n  if (e instanceof Error) {\n    return unknownError(e.message, undefined, e);\n  }\n  return unknownError(msgIfNotError, undefined);\n}\n\nfunction unknownError(\n  message: string,\n  statusCode?: number,\n  originalError?: Error,\n) {\n  return new UnknownError(message, undefined, originalError, statusCode);\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PalantirApiError } from \"@osdk/shared.net.errors\";\nimport type { RequestInitRetryParams } from \"fetch-retry\";\nimport fetchRetry from \"fetch-retry\";\n\nconst INITIAL_DELAY = 1_000;\nconst JITTER_FACTOR = 0.5;\nconst MAX_RETRIES = 3;\n\nexport function createRetryingFetch(\n  fetch: typeof globalThis.fetch,\n): (\n  input: RequestInfo | URL,\n  init?:\n    | (\n      & RequestInit\n      & RequestInitRetryParams<typeof globalThis.fetch>\n    )\n    | undefined,\n) => ReturnType<typeof globalThis.fetch> {\n  return fetchRetry(fetch, {\n    retryDelay(attempt) {\n      const delay = INITIAL_DELAY * 2 ** attempt;\n      const jitter = delay * JITTER_FACTOR * (Math.random() * 2 - 1);\n      return delay + jitter;\n    },\n    retryOn(attempt, error, response) {\n      const status = response?.status ?? 0;\n      return (\n        !(status >= 200 && status < 300)\n        && isRetryable(error)\n        && attempt < MAX_RETRIES\n      );\n    },\n  });\n}\n\nfunction isRetryable(e: any): boolean {\n  if (e instanceof PalantirApiError) {\n    if (\n      e.statusCode !== SERVICE_UNAVAILABLE\n      && e.statusCode !== TOO_MANY_REQUESTS\n    ) {\n      return false;\n    }\n  }\n  return true; // I think this logic is flawed?\n}\n\nconst SERVICE_UNAVAILABLE = 503;\nconst TOO_MANY_REQUESTS = 429;\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectOrInterfaceDefinition } from \"@osdk/api\";\nimport { createFetchHeaderMutator } from \"@osdk/shared.net.fetch\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport const addUserAgentAndRequestContextHeaders = (\n  client: MinimalClient,\n  withMetadata: Pick<ObjectOrInterfaceDefinition, \"osdkMetadata\">,\n): MinimalClient => ({\n  ...client,\n  fetch: createFetchHeaderMutator(\n    client.fetch,\n    (headers) => {\n      headers.set(\n        \"X-OSDK-Request-Context\",\n        JSON.stringify(client.requestContext),\n      );\n\n      if (withMetadata.osdkMetadata) {\n        headers.set(\n          \"Fetch-User-Agent\",\n          withMetadata.osdkMetadata.extraUserAgent,\n        );\n      }\n      return headers;\n    },\n  ),\n});\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { MinimalClient, RequestContext } from \"../MinimalClientContext.js\";\n\n/**\nReturns a client with its `requestContext` merged with the result of applying\n`augment` to its `requestContext`.\n\nThe second argument is an `Partial<RequestContext>`-returning `augment` function\ninstead of a `RequestContext` object to make referencing the current request\ncontext easier. For example, modifying the `fetchPage` function to add its name\nto the object set's called method chain could look like:\n```\naugmentRequestContext(\n  clientContext,\n  ctx => ({ methodChain: [...ctx.methodChain, \"fetchPage\"] })\n)\n```\nor\n```\naugmentRequestContext(\n  clientContext,\n  ({ methodChain }) => ({ methodChain: [...methodChain, \"fetchPage\"] })\n)\n```\ninstead of\n```\naugmentRequestContext(\n  clientContext,\n  { methodChain: [...clientContext.requestContext.methodChain, \"fetchPage\"] }\n)\n```\n*/\nexport const augmentRequestContext = (\n  client: MinimalClient,\n  augment: (ctx: RequestContext) => Partial<RequestContext>,\n): MinimalClient => ({\n  ...client,\n  requestContext: {\n    ...client.requestContext,\n    ...augment(client.requestContext),\n  },\n});\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AttachmentUpload } from \"@osdk/api\";\n\nexport function isAttachmentUpload(o: any): o is AttachmentUpload {\n  return typeof o === `object` && \"name\" in o && \"data\" in o\n    && o.data instanceof Blob;\n}\n\nexport function isAttachmentFile(\n  o: any,\n): o is Blob & { readonly name: string } {\n  return typeof o === \"object\" && o instanceof Blob && \"name\" in o;\n}\n\nexport function createAttachmentUpload(\n  data: Blob,\n  name: string,\n): AttachmentUpload {\n  return { data, name };\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { MediaReference, MediaUpload } from \"@osdk/api\";\n\nexport function isMediaReference(o: any): o is MediaReference {\n  return typeof o === `object`\n    && typeof o.mimeType === \"string\"\n    && \"reference\" in o\n    && typeof o.reference === \"object\"\n    && o.reference.type === \"mediaSetViewItem\"\n    && \"mediaSetViewItem\" in o.reference\n    && typeof o.reference.mediaSetViewItem === \"object\"\n    && typeof o.reference.mediaSetViewItem.mediaSetRid === \"string\"\n    && typeof o.reference.mediaSetViewItem.mediaSetViewRid === \"string\"\n    && typeof o.reference.mediaSetViewItem.mediaItemRid === \"string\";\n}\n\nexport function isMediaUpload(o: any): o is MediaUpload {\n  return typeof o === \"object\"\n    && \"path\" in o\n    && typeof o.path === \"string\"\n    && \"data\" in o\n    && typeof o.data === \"object\"\n    && o.data instanceof Blob;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  GeoFilterOptions,\n  ObjectOrInterfaceDefinition,\n  PossibleWhereClauseFilters,\n  WhereClause,\n} from \"@osdk/api\";\nimport { DistanceUnitMapping } from \"@osdk/api\";\n\nimport type {\n  PropertyIdentifier,\n  SearchJsonQueryV2,\n} from \"@osdk/foundry.ontologies\";\nimport type { BBox, Position } from \"geojson\";\nimport invariant from \"tiny-invariant\";\n\nexport function extractNamespace(\n  fqApiName: string,\n): [string | undefined, string] {\n  const last = fqApiName.lastIndexOf(\".\");\n  if (last === -1) return [undefined, fqApiName];\n  return [fqApiName.slice(0, last), fqApiName.slice(last + 1)];\n}\n\n/** @internal */\nexport function modernToLegacyWhereClause<\n  T extends ObjectOrInterfaceDefinition,\n>(\n  whereClause: WhereClause<T>,\n  objectOrInterface: T,\n): SearchJsonQueryV2 {\n  if (\"$and\" in whereClause) {\n    return {\n      type: \"and\",\n      value: (whereClause.$and as WhereClause<T>[]).map(\n        (clause) => modernToLegacyWhereClause(clause, objectOrInterface),\n      ),\n    };\n  } else if (\"$or\" in whereClause) {\n    return {\n      type: \"or\",\n      value: (whereClause.$or as WhereClause<T>[]).map(\n        (clause) => modernToLegacyWhereClause(clause, objectOrInterface),\n      ),\n    };\n  } else if (\"$not\" in whereClause) {\n    return {\n      type: \"not\",\n      value: modernToLegacyWhereClause(\n        whereClause.$not as WhereClause<T>,\n        objectOrInterface,\n      ),\n    };\n  }\n\n  const parts = Object.entries(whereClause);\n\n  if (parts.length === 1) {\n    return handleWherePair(parts[0], objectOrInterface);\n  }\n\n  return {\n    type: \"and\",\n    value: parts.map<SearchJsonQueryV2>(\n      v => handleWherePair(v, objectOrInterface),\n    ),\n  };\n}\n\nfunction makeGeoFilterBbox(\n  bbox: BBox,\n  filterType: \"$within\" | \"$intersects\",\n  propertyIdentifier?: PropertyIdentifier,\n  field?: string,\n): SearchJsonQueryV2 {\n  return {\n    type: filterType === \"$within\"\n      ? \"withinBoundingBox\"\n      : \"intersectsBoundingBox\",\n    /**\n     * This is a bit ugly, but did this so that propertyIdentifier only shows up in the return object if its defined,\n     * this makes it so we don't need to go update our entire test bed either to include a field which may change in near future.\n     * Once we solidify that this is the way forward, I can remove field and clean this up\n     */\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: {\n      topLeft: {\n        type: \"Point\",\n        coordinates: [bbox[0], bbox[3]],\n      },\n      bottomRight: {\n        type: \"Point\",\n        coordinates: [bbox[2], bbox[1]],\n      },\n    },\n  };\n}\n\nfunction makeGeoFilterPolygon(\n  coordinates: Position[][],\n  filterType: \"intersectsPolygon\" | \"withinPolygon\",\n  propertyIdentifier?: PropertyIdentifier,\n  field?: string,\n): SearchJsonQueryV2 {\n  return {\n    type: filterType,\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: {\n      type: \"Polygon\",\n      coordinates,\n    },\n  };\n}\n\nfunction handleWherePair(\n  [fieldName, filter]: [string, any],\n  objectOrInterface: ObjectOrInterfaceDefinition,\n  structFieldSelector?: { propertyApiName: string; structFieldApiName: string },\n): SearchJsonQueryV2 {\n  invariant(\n    filter != null,\n    \"Defined key values are only allowed when they are not undefined.\",\n  );\n\n  const propertyIdentifier: PropertyIdentifier | undefined =\n    structFieldSelector != null\n      ? {\n        type: \"structField\",\n        ...structFieldSelector,\n        propertyApiName: fullyQualifyPropName(\n          structFieldSelector.propertyApiName,\n          objectOrInterface,\n        ),\n      }\n      : undefined;\n  const field = structFieldSelector == null\n    ? fullyQualifyPropName(fieldName, objectOrInterface)\n    : undefined;\n\n  if (\n    typeof filter === \"string\" || typeof filter === \"number\"\n    || typeof filter === \"boolean\"\n  ) {\n    propertyIdentifier;\n    return {\n      type: \"eq\",\n      ...(propertyIdentifier != null\n        && { propertyIdentifier }),\n      field,\n      value: filter,\n    };\n  }\n\n  const keysOfFilter = Object.keys(filter);\n\n  // If any of the keys start with `$` then they must be the only one.\n  // e.g. `where({ name: { $eq: \"foo\", $ne: \"bar\" } })` is invalid currently\n  const hasDollarSign = keysOfFilter.some((key) => key.startsWith(\"$\"));\n  invariant(\n    !hasDollarSign\n      || keysOfFilter.length === 1,\n    \"A WhereClause Filter with multiple clauses/fields is not allowed. Instead, use an 'or'/'and' clause to combine multiple filters.\",\n  );\n\n  if (!hasDollarSign) {\n    const structFilter = Object.entries(filter);\n    invariant(\n      structFilter.length === 1,\n      \"Cannot filter on more than one struct field in the same clause, need to use an and clause\",\n    );\n    const structFieldApiName = keysOfFilter[0];\n    return handleWherePair(Object.entries(filter)[0], objectOrInterface, {\n      propertyApiName: fieldName,\n      structFieldApiName,\n    });\n  }\n\n  const firstKey = keysOfFilter[0] as PossibleWhereClauseFilters;\n  invariant(filter[firstKey] != null);\n\n  if (firstKey === \"$ne\") {\n    return {\n      type: \"not\",\n      value: {\n        type: \"eq\",\n        ...(propertyIdentifier != null && { propertyIdentifier }),\n        field,\n        value: filter[firstKey],\n      },\n    };\n  }\n\n  if (firstKey === \"$within\") {\n    const withinBody = filter[firstKey] as GeoFilterOptions[\"$within\"];\n\n    if (Array.isArray(withinBody)) {\n      return makeGeoFilterBbox(withinBody, firstKey, propertyIdentifier, field);\n    } else if (\"$bbox\" in withinBody && withinBody.$bbox != null) {\n      return makeGeoFilterBbox(\n        withinBody.$bbox,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else if (\n      (\"$distance\" in withinBody && \"$of\" in withinBody)\n      && withinBody.$distance != null\n      && withinBody.$of != null\n    ) {\n      return {\n        type: \"withinDistanceOf\",\n        ...(propertyIdentifier != null && { propertyIdentifier }),\n        field,\n        value: {\n          center: Array.isArray(withinBody.$of)\n            ? {\n              type: \"Point\",\n              coordinates: withinBody.$of,\n            }\n            : withinBody.$of,\n          distance: {\n            value: withinBody.$distance[0],\n            unit: DistanceUnitMapping[withinBody.$distance[1]],\n          },\n        },\n      };\n    } else {\n      const coordinates = (\"$polygon\" in withinBody)\n        ? withinBody.$polygon\n        : withinBody.coordinates;\n      return makeGeoFilterPolygon(\n        coordinates,\n        \"withinPolygon\",\n        propertyIdentifier,\n        fieldName,\n      );\n    }\n  }\n  if (firstKey === \"$intersects\") {\n    const intersectsBody = filter[firstKey] as GeoFilterOptions[\"$intersects\"];\n    if (Array.isArray(intersectsBody)) {\n      return makeGeoFilterBbox(\n        intersectsBody,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else if (\"$bbox\" in intersectsBody && intersectsBody.$bbox != null) {\n      return makeGeoFilterBbox(\n        intersectsBody.$bbox,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else {\n      const coordinates = (\"$polygon\" in intersectsBody)\n        ? intersectsBody.$polygon\n        : intersectsBody.coordinates;\n      return makeGeoFilterPolygon(\n        coordinates,\n        \"intersectsPolygon\",\n        propertyIdentifier,\n        field,\n      );\n    }\n  }\n\n  if (firstKey === \"$containsAllTerms\" || firstKey === \"$containsAnyTerm\") {\n    return {\n      type: firstKey.substring(1) as DropDollarSign<typeof firstKey>,\n      ...(propertyIdentifier != null && { propertyIdentifier }),\n      field,\n      value: typeof filter[firstKey] === \"string\"\n        ? filter[firstKey]\n        : filter[firstKey][\"term\"],\n      fuzzy: typeof filter[firstKey] === \"string\"\n        ? false\n        : filter[firstKey][\"fuzzySearch\"] ?? false,\n    };\n  }\n\n  return {\n    type: firstKey.substring(1) as DropDollarSign<typeof firstKey>,\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: filter[firstKey] as any,\n  };\n}\n\ntype DropDollarSign<T extends `$${string}`> = T extends `$${infer U}` ? U\n  : never;\n\nfunction fullyQualifyPropName(\n  fieldName: string,\n  objectOrInterface: ObjectOrInterfaceDefinition,\n) {\n  if (objectOrInterface.type === \"interface\") {\n    const [objApiNamespace] = extractNamespace(objectOrInterface.apiName);\n    const [fieldApiNamespace, fieldShortName] = extractNamespace(fieldName);\n    return (fieldApiNamespace == null && objApiNamespace != null)\n      ? `${objApiNamespace}.${fieldShortName}`\n      : fieldName;\n  }\n  return fieldName;\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { DerivedProperty } from \"@osdk/api\";\nimport type { DerivedPropertyDefinition } from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\n\n/** @internal */\nexport function derivedPropertyDefinitionFactory(\n  wireDefinition: DerivedPropertyDefinition,\n  definitionMap: Map<any, DerivedPropertyDefinition>,\n): DerivedProperty.NumericPropertyDefinition<any, any> & {\n  extractPart: DerivedProperty.DatetimePropertyDefinition<\n    any,\n    any\n  >[\"extractPart\"];\n} {\n  type RemoveSymbolKeys<T> = {\n    [K in keyof T as K extends symbol ? never : K]: T[K];\n  };\n\n  const definition:\n    & RemoveSymbolKeys<DerivedProperty.NumericPropertyDefinition<any, any>>\n    & {\n      extractPart: DerivedProperty.DatetimePropertyDefinition<\n        any,\n        any\n      >[\"extractPart\"];\n    } = {\n      abs() {\n        return derivedPropertyDefinitionFactory({\n          type: \"absoluteValue\",\n          property: wireDefinition,\n        }, definitionMap);\n      },\n      negate() {\n        return derivedPropertyDefinitionFactory({\n          type: \"negate\",\n          property: wireDefinition,\n        }, definitionMap);\n      },\n      max(value) {\n        return derivedPropertyDefinitionFactory({\n          type: \"greatest\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      min(value) {\n        return derivedPropertyDefinitionFactory({\n          type: \"least\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      add(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          type: \"add\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      subtract(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          \"type\": \"subtract\",\n          \"left\": wireDefinition,\n          \"right\": getDefinitionFromMap(value, definitionMap),\n        }, definitionMap);\n      },\n      multiply(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          type: \"multiply\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      divide(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          \"type\": \"subtract\",\n          \"left\": wireDefinition,\n          \"right\": getDefinitionFromMap(value, definitionMap),\n        }, definitionMap);\n      },\n      extractPart: (part) => {\n        return derivedPropertyDefinitionFactory({\n          type: \"extract\",\n          part,\n          property: wireDefinition,\n        }, definitionMap);\n      },\n    };\n\n  definitionMap.set(definition, wireDefinition);\n  return definition as any;\n}\n\nconst getDefinitionFromMap = (\n  arg: string | number | DerivedProperty.Definition<any, any>,\n  definitionMap: Map<any, DerivedPropertyDefinition>,\n): DerivedPropertyDefinition => {\n  if (typeof arg === \"object\") {\n    const definition = definitionMap.get(arg);\n    invariant(definition, \"Derived Property is not defined\");\n    return definition;\n  } else if (typeof arg === \"number\") {\n    invariant(false, \"Literals for derived properties are not yet supported\");\n  }\n  invariant(false, \"Invalid argument type for a derived property\");\n};\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { DerivedProperty, ObjectOrInterfaceDefinition } from \"@osdk/api\";\nimport type {\n  DerivedPropertyDefinition,\n  ObjectSet as WireObjectSet,\n  SelectedPropertyOperation,\n} from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport { modernToLegacyWhereClause } from \"../internal/conversions/modernToLegacyWhereClause.js\";\nimport { derivedPropertyDefinitionFactory } from \"./derivedPropertyDefinitionFactory.js\";\n\ntype WithConstSelect<Q extends ObjectOrInterfaceDefinition> =\n  & DerivedProperty.SelectPropertyBuilder<Q, false>\n  & {\n    constant: DerivedProperty.Builder<Q, true>[\"constant\"];\n  };\n\n/** @internal */\nexport function createWithPropertiesObjectSet<\n  Q extends ObjectOrInterfaceDefinition,\n>(\n  objectType: Q,\n  objectSet: WireObjectSet,\n  definitionMap: Map<any, DerivedPropertyDefinition>,\n  fromBaseObjectSet: boolean = false,\n): WithConstSelect<Q> {\n  return {\n    pivotTo: (link) => {\n      return createWithPropertiesObjectSet(objectType, {\n        type: \"searchAround\",\n        objectSet,\n        link,\n      }, definitionMap);\n    },\n    where: (clause) => {\n      return createWithPropertiesObjectSet(objectType, {\n        type: \"filter\",\n        objectSet: objectSet,\n        where: modernToLegacyWhereClause(clause, objectType),\n      }, definitionMap);\n    },\n    aggregate: (aggregation: string, opt: any) => {\n      const splitAggregation = aggregation.split(\":\");\n      invariant(\n        splitAggregation.length === 2 || splitAggregation[0] === \"$count\",\n        \"Invalid aggregation format\",\n      );\n      const [aggregationPropertyName, aggregationOperation] = splitAggregation;\n      let aggregationOperationDefinition: SelectedPropertyOperation;\n      switch (aggregationOperation) {\n        case \"sum\":\n        case \"avg\":\n        case \"min\":\n        case \"max\":\n        case \"exactDistinct\":\n        case \"approximateDistinct\":\n          aggregationOperationDefinition = {\n            type: aggregationOperation,\n            selectedPropertyApiName: aggregationPropertyName,\n          };\n          break;\n        case \"approximatePercentile\":\n          aggregationOperationDefinition = {\n            type: \"approximatePercentile\",\n            selectedPropertyApiName: aggregationPropertyName,\n            approximatePercentile: opt?.percentile ?? .5,\n          };\n          break;\n        case \"collectSet\":\n        case \"collectList\":\n          aggregationOperationDefinition = {\n            type: aggregationOperation,\n            selectedPropertyApiName: aggregationPropertyName,\n            limit: opt?.limit ?? 100,\n          };\n          break;\n        case undefined:\n          if (aggregationPropertyName === \"$count\") {\n            aggregationOperationDefinition = {\n              type: \"count\",\n            };\n            break;\n          }\n        default:\n          invariant(\n            false,\n            \"Invalid aggregation operation \" + aggregationOperation,\n          );\n      }\n      const wrappedObjectSet: DerivedPropertyDefinition = {\n        type: \"selection\",\n        objectSet: objectSet,\n        operation: aggregationOperationDefinition,\n      };\n      const selectorResult: DerivedProperty.Definition<any, any> =\n        derivedPropertyDefinitionFactory(wrappedObjectSet, definitionMap);\n      definitionMap.set(selectorResult, wrappedObjectSet);\n      return selectorResult as any;\n    },\n    selectProperty: (name) => {\n      if (fromBaseObjectSet) {\n        const wrappedObjectSet: DerivedPropertyDefinition = {\n          type: \"property\",\n          apiName: name,\n        };\n        const selectorResult: DerivedProperty.Definition<any, any> =\n          derivedPropertyDefinitionFactory(wrappedObjectSet, definitionMap);\n        definitionMap.set(selectorResult, wrappedObjectSet);\n        return selectorResult as any;\n      }\n      const wrappedObjectSet: DerivedPropertyDefinition = {\n        type: \"selection\",\n        objectSet: objectSet,\n        operation: {\n          type: \"get\",\n          selectedPropertyApiName: name,\n        },\n      };\n      const selectorResult: DerivedProperty.Definition<any, any> =\n        derivedPropertyDefinitionFactory(wrappedObjectSet, definitionMap);\n      definitionMap.set(selectorResult, wrappedObjectSet);\n      return selectorResult as any;\n    },\n    constant: {\n      double: (value) => {\n        invariant(false, \"Not supported\");\n      },\n      integer: (value) => {\n        invariant(false, \"Not supported\");\n      },\n      long: (value) => {\n        invariant(false, \"Not supported\");\n      },\n      datetime: (value) => {\n        invariant(false, \"Not supported\");\n      },\n      timestamp: (value) => {\n        invariant(false, \"Not supported\");\n      },\n    },\n  };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AggregationClause,\n  AggregationResultsWithoutGroups,\n  ObjectOrInterfaceDefinition,\n} from \"@osdk/api\";\nimport type { AggregateObjectsResponseV2 } from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport type { ArrayElement } from \"../../util/ArrayElement.js\";\n\n/** @internal */\nexport function legacyToModernSingleAggregationResult<\n  Q extends ObjectOrInterfaceDefinition,\n  AC extends AggregationClause<Q>,\n>(\n  entry: ArrayElement<AggregateObjectsResponseV2[\"data\"]>,\n): AggregationResultsWithoutGroups<Q, AC> {\n  return entry.metrics.reduce(\n    (accumulator: AggregationResultsWithoutGroups<Q, AC>, curValue) => {\n      const parts = curValue.name.split(\".\");\n      if (parts[0] === \"count\") {\n        return accumulator;\n      }\n      invariant(\n        parts.length === 2,\n        \"assumed we were getting a `${key}.${type}`\",\n      );\n      const property = parts[0] as keyof AggregationResultsWithoutGroups<Q, AC>;\n      const metricType = parts[1];\n      if (!(property in accumulator)) {\n        accumulator[property] = {} as any; // fixme?\n      }\n      (accumulator[property] as any)[metricType] = curValue.value; // fixme?\n\n      return accumulator;\n    },\n    {} as AggregationResultsWithoutGroups<Q, AC>,\n  );\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AggregationClause } from \"@osdk/api\";\nimport type { AggregationV2 } from \"@osdk/foundry.ontologies\";\n\nconst directionFieldMap = (dir?: \"asc\" | \"desc\" | \"unordered\") =>\n  dir === \"asc\" ? \"ASC\" : dir === \"desc\" ? \"DESC\" : undefined;\n\n/** @internal */\nexport function modernToLegacyAggregationClause<\n  AC extends AggregationClause<any>,\n>(select: AC) {\n  return Object.entries(select).flatMap<AggregationV2>(\n    ([propAndMetric, aggregationType]) => {\n      if (propAndMetric === \"$count\") {\n        return {\n          type: \"count\",\n          name: \"count\",\n          direction: directionFieldMap(aggregationType),\n        };\n      }\n\n      const colonPos = propAndMetric.lastIndexOf(\":\");\n      const property = propAndMetric.slice(0, colonPos);\n      const metric = propAndMetric.slice(colonPos + 1);\n\n      return [\n        {\n          type: metric as\n            | \"approximateDistinct\"\n            | \"exactDistinct\"\n            | \"min\"\n            | \"max\"\n            | \"sum\"\n            | \"avg\"\n            | \"approximateDistinct\"\n            | \"exactDistinct\",\n          name: `${property}.${metric}`,\n          direction: directionFieldMap(aggregationType),\n          field: property,\n        },\n      ];\n    },\n  );\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AllGroupByValues, GroupByClause, GroupByRange } from \"@osdk/api\";\nimport { DurationMapping } from \"@osdk/api\";\nimport type {\n  AggregationGroupByV2,\n  AggregationRangeV2,\n} from \"@osdk/foundry.ontologies\";\n\n/** @internal */\nexport function modernToLegacyGroupByClause(\n  groupByClause: GroupByClause<any> | undefined,\n) {\n  if (!groupByClause) return [];\n\n  return Object.entries(\n    groupByClause as Record<string, AllGroupByValues>,\n  ).flatMap<AggregationGroupByV2>(([field, type]) => {\n    if (type === \"exact\") {\n      return [{ type, field }];\n    } else if (\"$exactWithLimit\" in type) {\n      {\n        return [\n          {\n            type: \"exact\",\n            field,\n            maxGroupCount: type.$exactWithLimit,\n          },\n        ];\n      }\n    } else if (\"$exact\" in type) {\n      return [\n        {\n          type: \"exact\",\n          field,\n          maxGroupCount: type.$exact?.$limit ?? undefined,\n          defaultValue: type.$exact.$defaultValue ?? undefined,\n        },\n      ];\n    } else if (\"$fixedWidth\" in type) {\n      return [{\n        type: \"fixedWidth\",\n        field,\n        fixedWidth: type.$fixedWidth,\n      }];\n    } else if (\"$ranges\" in type) {\n      return [{\n        type: \"ranges\",\n        field,\n        ranges: type.$ranges.map(range => convertRange(range)),\n      }];\n    } else if (\"$duration\" in type) {\n      return [{\n        type: \"duration\",\n        field,\n        value: type.$duration[0],\n        unit: DurationMapping[type.$duration[1]],\n      }];\n    } else return [];\n  });\n}\n\nfunction convertRange(\n  range: GroupByRange<number | string>,\n): AggregationRangeV2 {\n  return { startValue: range[0], endValue: range[1] };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectOrInterfaceDefinition } from \"@osdk/api\";\nimport type { ObjectSet as WireObjectSet } from \"@osdk/foundry.ontologies\";\n\nexport function resolveBaseObjectSetType(\n  objectType: ObjectOrInterfaceDefinition,\n): WireObjectSet {\n  return objectType.type === \"interface\"\n    ? {\n      type: \"interfaceBase\",\n      interfaceType: objectType[\"apiName\"] as string,\n    }\n    : {\n      type: \"base\",\n      objectType: objectType[\"apiName\"] as string,\n    };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AggregateOpts,\n  AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy,\n  AggregationResultsWithGroups,\n  AggregationsResults,\n  ObjectOrInterfaceDefinition,\n} from \"@osdk/api\";\nimport type {\n  AggregateObjectsRequestV2,\n  AggregateObjectsResponseV2,\n  ObjectSet,\n} from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport { legacyToModernSingleAggregationResult } from \"../internal/conversions/legacyToModernSingleAggregationResult.js\";\nimport { modernToLegacyAggregationClause } from \"../internal/conversions/modernToLegacyAggregationClause.js\";\nimport { modernToLegacyGroupByClause } from \"../internal/conversions/modernToLegacyGroupByClause.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport type { ArrayElement } from \"../util/ArrayElement.js\";\nimport { resolveBaseObjectSetType } from \"../util/objectSetUtils.js\";\n\n/** @internal */\nexport async function aggregate<\n  Q extends ObjectOrInterfaceDefinition,\n  AO extends AggregateOpts<Q>,\n>(\n  clientCtx: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n  req: AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy<Q, AO>,\n): Promise<AggregationsResults<Q, AO>> {\n  const resolvedObjectSet = resolveBaseObjectSetType(objectType);\n  const body: AggregateObjectsRequestV2 = {\n    aggregation: modernToLegacyAggregationClause<AO[\"$select\"]>(\n      req.$select,\n    ),\n    groupBy: [],\n    where: undefined,\n  };\n\n  if (req.$groupBy) {\n    body.groupBy = modernToLegacyGroupByClause(req.$groupBy);\n  }\n\n  const result = await OntologiesV2.OntologyObjectSets.aggregate(\n    addUserAgentAndRequestContextHeaders(clientCtx, objectType),\n    await clientCtx.ontologyRid,\n    {\n      objectSet,\n      groupBy: body.groupBy,\n      aggregation: body.aggregation,\n    },\n  );\n\n  if (!req.$groupBy) {\n    invariant(\n      result.data.length === 1,\n      \"no group by clause should mean only one data result\",\n    );\n\n    return {\n      ...aggregationToCountResult(result.data[0]),\n      ...legacyToModernSingleAggregationResult(\n        result.data[0],\n      ),\n    } as any;\n  }\n\n  const ret: AggregationResultsWithGroups<Q, AO[\"$select\"], any> = result.data\n    .map((entry) => {\n      return {\n        $group: entry.group as any,\n        ...aggregationToCountResult(entry),\n        ...legacyToModernSingleAggregationResult(entry),\n      };\n    }) as any; // fixme\n\n  return ret as any; // FIXME\n}\n\nfunction aggregationToCountResult(\n  entry: ArrayElement<AggregateObjectsResponseV2[\"data\"]>,\n): { $count: number } | undefined {\n  for (const aggregateResult of entry.metrics) {\n    if (aggregateResult.name === \"count\") {\n      return { $count: aggregateResult.value };\n    }\n  }\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectSet } from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport type { DerivedPropertyRuntimeMetadata } from \"../derivedProperties/derivedPropertyRuntimeMetadata.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport async function extractRdpDefinition(\n  clientCtx: MinimalClient,\n  objectSet: ObjectSet,\n): Promise<\n  DerivedPropertyRuntimeMetadata\n> {\n  return (await extractRdpDefinitionInternal(\n    clientCtx,\n    objectSet,\n    undefined,\n  )).definitions;\n}\n\n/* @internal\n* Returns a tuple of the derived property definitions and the object type that the derived property is defined on.\n*/\nasync function extractRdpDefinitionInternal(\n  clientCtx: MinimalClient,\n  objectSet: ObjectSet,\n  methodInputObjectType: string | undefined,\n): Promise<\n  {\n    definitions: DerivedPropertyRuntimeMetadata;\n    childObjectType?: string;\n  }\n> {\n  switch (objectSet.type) {\n    case \"searchAround\": {\n      const { definitions, childObjectType } =\n        await extractRdpDefinitionInternal(\n          clientCtx,\n          objectSet.objectSet,\n          methodInputObjectType,\n        );\n\n      if (childObjectType === undefined || childObjectType === \"\") {\n        return { definitions: {} };\n      }\n      const objDef = await clientCtx.ontologyProvider.getObjectDefinition(\n        childObjectType,\n      );\n      const linkDef = objDef.links[objectSet.link];\n      invariant(linkDef, `Missing link definition for '${objectSet.link}'`);\n      return {\n        definitions,\n        childObjectType: objDef.links[objectSet.link].targetType,\n      };\n    }\n    case \"withProperties\": {\n      // These are the definitions and current object type for all object set operations prior to the definition (e.g. filter, pivotTo, etc.)\n      const { definitions, childObjectType } =\n        await extractRdpDefinitionInternal(\n          clientCtx,\n          objectSet.objectSet,\n          methodInputObjectType,\n        );\n      if (childObjectType === undefined || childObjectType === \"\") {\n        return { definitions: {} };\n      }\n\n      for (\n        const [name, definition] of Object.entries(objectSet.derivedProperties)\n      ) {\n        if (definition.type !== \"selection\") {\n          definitions[name] = {\n            selectedOrCollectedPropertyType: undefined,\n            definition,\n          };\n          continue;\n        }\n\n        switch (definition.operation.type) {\n          case \"collectList\":\n          case \"collectSet\":\n          case \"get\":\n            // This is the object set construction for the derived property definition construction. We pass in childObjectType so that when we reach MethodInputObjectSet, we know where to start looking.\n            const { childObjectType: operationLevelObjectType } =\n              await extractRdpDefinitionInternal(\n                clientCtx,\n                definition.objectSet,\n                childObjectType,\n              );\n            if (\n              operationLevelObjectType === undefined\n              || operationLevelObjectType === \"\"\n            ) {\n              return { definitions: {} };\n            }\n            const objDef = await clientCtx.ontologyProvider.getObjectDefinition(\n              operationLevelObjectType,\n            );\n\n            definitions[name] = {\n              selectedOrCollectedPropertyType:\n                objDef.properties[definition.operation.selectedPropertyApiName],\n              definition,\n            };\n            break;\n\n          default:\n            definitions[name] = {\n              selectedOrCollectedPropertyType: undefined,\n              definition,\n            };\n        }\n      }\n      return { definitions, childObjectType };\n    }\n    case \"methodInput\":\n      return { definitions: {}, childObjectType: methodInputObjectType };\n    case \"base\":\n      return { definitions: {}, childObjectType: objectSet.objectType };\n    case \"interfaceBase\":\n      return { definitions: {}, childObjectType: objectSet.interfaceType };\n    case \"filter\":\n    case \"asBaseObjectTypes\":\n    case \"asType\":\n    case \"nearestNeighbors\":\n      return extractRdpDefinitionInternal(\n        clientCtx,\n        objectSet.objectSet,\n        methodInputObjectType,\n      );\n    // These will throw in OSS so we should throw here so no request is made\n    case \"intersect\":\n    case \"subtract\":\n    case \"union\":\n      const objectSets = objectSet.objectSets;\n      const objectSetTypes = await Promise.all(\n        objectSets.map((os) =>\n          extractRdpDefinitionInternal(\n            clientCtx,\n            os,\n            methodInputObjectType,\n          )\n        ),\n      );\n\n      const definitions = objectSetTypes.reduce(\n        (acc, { definitions }) => ({ ...acc, ...definitions }),\n        {},\n      );\n      invariant(\n        Object.keys(definitions).length === 0,\n        \"Object sets combined using intersect, subtract, or union must not contain any derived property definitions\",\n      );\n\n      const firstValidChildObjectType = objectSetTypes.find(\n        ({ childObjectType }) => childObjectType != null,\n      )?.childObjectType;\n      invariant(\n        objectSetTypes.every(\n          ({ childObjectType }) =>\n            childObjectType === firstValidChildObjectType\n            || childObjectType == null,\n        ),\n        \"All object sets in an intersect, subtract, or union must have the same child object type\",\n      );\n\n      return {\n        definitions: {},\n        childObjectType: firstValidChildObjectType,\n      };\n    case \"static\":\n    case \"reference\":\n      // Static and reference object sets are always intersected with a base object set, so we can just return no child object type.\n      return { definitions: {} };\n    // We don't have to worry about new object sets being added and doing a runtime break and breaking people since the OSDK is always constructing these.\n    case \"interfaceLinkSearchAround\":\n      invariant(\n        false,\n        `Unsupported object set type for Runtime Derived Properties`,\n      );\n    default:\n      const _: never = objectSet;\n      invariant(\n        false,\n        `Unsupported object set type for Runtime Derived Properties`,\n      );\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  Augment,\n  Augments,\n  FetchPageArgs,\n  FetchPageResult,\n  InterfaceDefinition,\n  NullabilityAdherence,\n  ObjectOrInterfaceDefinition,\n  ObjectTypeDefinition,\n  PropertyKeys,\n  Result,\n} from \"@osdk/api\";\nimport type { PageSize, PageToken } from \"@osdk/foundry.core\";\nimport type {\n  LoadObjectSetRequestV2,\n  LoadObjectSetV2MultipleObjectTypesRequest,\n  ObjectSet,\n  OntologyObjectV2,\n  SearchJsonQueryV2,\n  SearchObjectsForInterfaceRequest,\n  SearchOrderByV2,\n} from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport { extractRdpDefinition } from \"../util/extractRdpDefinition.js\";\nimport { resolveBaseObjectSetType } from \"../util/objectSetUtils.js\";\n\nexport function augment<\n  Q extends ObjectOrInterfaceDefinition,\n  T extends PropertyKeys<Q>,\n>(\n  type: Q,\n  ...properties: T[]\n): Augment<Q, T> {\n  return { [type.apiName]: properties } as any;\n}\n\n/** @internal */\nexport function objectSetToSearchJsonV2(\n  objectSet: ObjectSet,\n  expectedApiName: string,\n  existingWhere: SearchJsonQueryV2 | undefined = undefined,\n): SearchJsonQueryV2 | undefined {\n  if (objectSet.type === \"base\" || objectSet.type === \"interfaceBase\") {\n    if (objectSet.type === \"base\" && objectSet.objectType !== expectedApiName) {\n      throw new Error(\n        `Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.objectType}`,\n      );\n    }\n    if (\n      objectSet.type === \"interfaceBase\"\n      && objectSet.interfaceType !== expectedApiName\n    ) {\n      throw new Error(\n        `Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.interfaceType}`,\n      );\n    }\n\n    return existingWhere;\n  }\n\n  if (objectSet.type === \"filter\") {\n    return objectSetToSearchJsonV2(\n      objectSet.objectSet,\n      expectedApiName,\n      existingWhere == null ? objectSet.where : {\n        type: \"and\",\n        value: [existingWhere, objectSet.where],\n      },\n    );\n  }\n\n  throw new Error(`Unsupported objectSet type: ${objectSet.type}`);\n}\n\n/** @internal */\nexport function resolveInterfaceObjectSet(\n  objectSet: ObjectSet,\n  interfaceTypeApiName: string,\n  args: FetchPageArgs<any, any, any, any, any, any>,\n): ObjectSet {\n  return args?.$includeAllBaseObjectProperties\n    ? {\n      type: \"intersect\",\n      objectSets: [objectSet, {\n        type: \"interfaceBase\",\n        interfaceType: interfaceTypeApiName,\n        includeAllBaseObjectProperties: true,\n      }],\n    }\n    : objectSet;\n}\n\nasync function fetchInterfacePage<\n  Q extends InterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  interfaceType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet,\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  if (args.$__UNSTABLE_useOldInterfaceApis) {\n    const result = await OntologiesV2.OntologyInterfaces\n      .search(\n        addUserAgentAndRequestContextHeaders(client, interfaceType),\n        await client.ontologyRid,\n        interfaceType.apiName,\n        applyFetchArgs<SearchObjectsForInterfaceRequest>(args, {\n          augmentedProperties: {},\n          augmentedSharedPropertyTypes: {},\n          otherInterfaceTypes: [],\n          selectedObjectTypes: [],\n          selectedSharedPropertyTypes: args.$select as undefined | string[]\n            ?? [],\n          where: objectSetToSearchJsonV2(objectSet, interfaceType.apiName),\n        }),\n        { preview: true },\n      );\n\n    result.data = await client.objectFactory(\n      client,\n      result.data as OntologyObjectV2[], // drop readonly\n      interfaceType.apiName,\n      !args.$includeRid,\n      await extractRdpDefinition(client, objectSet),\n    );\n    return result as any;\n  }\n  const result = await OntologiesV2.OntologyObjectSets.loadMultipleObjectTypes(\n    addUserAgentAndRequestContextHeaders(client, interfaceType),\n    await client.ontologyRid,\n    applyFetchArgs<LoadObjectSetV2MultipleObjectTypesRequest>(args, {\n      objectSet: resolveInterfaceObjectSet(\n        objectSet,\n        interfaceType.apiName,\n        args,\n      ),\n      select: ((args?.$select as string[] | undefined) ?? []),\n      excludeRid: !args?.$includeRid,\n    }),\n    { preview: true },\n  );\n  return Promise.resolve({\n    data: await client.objectFactory2(\n      client,\n      result.data,\n      interfaceType.apiName,\n      {},\n      !args.$includeRid,\n      args.$select,\n      false,\n      result.interfaceToObjectTypeMappings,\n    ),\n    nextPageToken: result.nextPageToken,\n    totalCount: result.totalCount,\n  }) as unknown as Promise<FetchPageResult<Q, L, R, S, T>>;\n}\n\n/** @internal */\nexport async function fetchPageInternal<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  A extends Augments,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet,\n  args: FetchPageArgs<Q, L, R, A, S, T> = {},\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  if (objectType.type === \"interface\") {\n    return await fetchInterfacePage(\n      client,\n      objectType,\n      args,\n      objectSet,\n    ) as any; // fixme\n  } else {\n    return await fetchObjectPage(\n      client,\n      objectType,\n      args,\n      objectSet,\n    ) as any; // fixme\n  }\n}\n\n/** @internal */\nexport async function fetchPageWithErrorsInternal<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  A extends Augments,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet,\n  args: FetchPageArgs<Q, L, R, A, S, T> = {},\n): Promise<Result<FetchPageResult<Q, L, R, S, T>>> {\n  try {\n    const result = await fetchPageInternal(client, objectType, objectSet, args);\n    return { value: result };\n  } catch (e) {\n    if (e instanceof Error) {\n      return { error: e };\n    }\n    return { error: e as Error };\n  }\n}\n\n/**\n * @param client\n * @param objectType\n * @param args\n * @param objectSet\n * @returns\n * @internal\n */\nexport async function fetchPage<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  return fetchPageInternal(client, objectType, objectSet, args);\n}\n\n/** @internal */\nexport async function fetchPageWithErrors<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n): Promise<Result<FetchPageResult<Q, L, R, S, T>>> {\n  return fetchPageWithErrorsInternal(client, objectType, objectSet, args);\n}\n\nfunction applyFetchArgs<\n  X extends {\n    orderBy?: SearchOrderByV2;\n    pageToken?: PageToken;\n    pageSize?: PageSize;\n  },\n>(\n  args: FetchPageArgs<any, any, any, any, any, any>,\n  body: X,\n): X {\n  if (args?.$nextPageToken) {\n    body.pageToken = args.$nextPageToken;\n  }\n\n  if (args?.$pageSize != null) {\n    body.pageSize = args.$pageSize;\n  }\n\n  if (args?.$orderBy != null) {\n    body.orderBy = {\n      fields: Object.entries(args.$orderBy).map(([field, direction]) => ({\n        field,\n        direction,\n      })),\n    };\n  }\n\n  return body;\n}\n\n/** @internal */\nexport async function fetchObjectPage<\n  Q extends ObjectTypeDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, Augments, S, T>,\n  objectSet: ObjectSet,\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  const r = await OntologiesV2.OntologyObjectSets.load(\n    addUserAgentAndRequestContextHeaders(client, objectType),\n    await client.ontologyRid,\n    applyFetchArgs<LoadObjectSetRequestV2>(args, {\n      objectSet,\n      // We have to do the following case because LoadObjectSetRequestV2 isn't readonly\n      select: ((args?.$select as string[] | undefined) ?? []), // FIXME?\n      excludeRid: !args?.$includeRid,\n    }),\n  );\n\n  return Promise.resolve({\n    data: await client.objectFactory(\n      client,\n      r.data as OntologyObjectV2[],\n      undefined,\n      undefined,\n      await extractRdpDefinition(client, objectSet),\n      args.$select,\n    ),\n    nextPageToken: r.nextPageToken,\n    totalCount: r.totalCount,\n  }) as unknown as Promise<FetchPageResult<Q, L, R, S, T>>;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  FetchPageArgs,\n  ObjectOrInterfaceDefinition,\n  Result,\n  SingleOsdkResult,\n} from \"@osdk/api\";\nimport type { ObjectSet } from \"@osdk/foundry.ontologies\";\nimport { PalantirApiError } from \"@osdk/shared.net.errors\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { fetchPage } from \"./fetchPage.js\";\n\n/** @internal */\nexport async function fetchSingle<\n  Q extends ObjectOrInterfaceDefinition,\n  const A extends FetchPageArgs<Q, any, any>,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: A,\n  objectSet: ObjectSet,\n): Promise<\n  A extends FetchPageArgs<Q, infer L, infer R, any, infer S>\n    ? SingleOsdkResult<Q, L, R, S>\n    : SingleOsdkResult<Q, any, any, any>\n> {\n  const result = await fetchPage(\n    client,\n    objectType,\n    { ...args, $pageSize: 1 },\n    objectSet,\n  );\n\n  if (result.data.length !== 1 || result.nextPageToken != null) {\n    throw new PalantirApiError(\n      `Expected a single result but got ${result.data.length} instead${\n        result.nextPageToken != null ? \" with nextPageToken set\" : \"\"\n      }`,\n    );\n  }\n\n  return result.data[0] as any;\n}\n\n/** @internal */\nexport async function fetchSingleWithErrors<\n  Q extends ObjectOrInterfaceDefinition,\n  const A extends FetchPageArgs<Q, any, any>,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: A,\n  objectSet: ObjectSet,\n): Promise<\n  Result<\n    A extends FetchPageArgs<Q, infer L, infer R, any, infer S>\n      ? SingleOsdkResult<Q, L, R, S>\n      : SingleOsdkResult<Q, any, any, any>\n  >\n> {\n  try {\n    const result = await fetchSingle(client, objectType, args, objectSet);\n    return { value: result as any };\n  } catch (e) {\n    if (e instanceof Error) {\n      return { error: e };\n    }\n    return { error: e as Error };\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectSet as WireObjectSet } from \"@osdk/foundry.ontologies\";\n\nconst WIRE_OBJECT_SET_TYPES = new Set([\n  \"base\",\n  \"filter\",\n  \"intersect\",\n  \"reference\",\n  \"searchAround\",\n  \"static\",\n  \"subtract\",\n  \"union\",\n]);\n\n/** @internal */\nexport function isWireObjectSet(o: any): o is WireObjectSet {\n  return o != null && typeof o === \"object\"\n    && WIRE_OBJECT_SET_TYPES.has(o.type);\n}\n", "// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nexport default ws\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  Logger,\n  ObjectOrInterfaceDefinition,\n  ObjectSetSubscription,\n  Osdk,\n  PropertyKeys,\n} from \"@osdk/api\";\nimport type {\n  ObjectSet,\n  ObjectSetStreamSubscribeRequest,\n  ObjectSetStreamSubscribeRequests,\n  ObjectSetSubscribeResponses,\n  ObjectSetUpdates,\n  ObjectState,\n  RefreshObjectSet,\n  StreamMessage,\n  SubscriptionClosed,\n} from \"@osdk/foundry.ontologies\";\nimport WebSocket from \"isomorphic-ws\";\nimport invariant from \"tiny-invariant\";\nimport type { ClientCacheKey, MinimalClient } from \"../MinimalClientContext.js\";\n\nconst MINIMUM_RECONNECT_DELAY_MS = 5 * 1000;\n\n/** Noop function to reduce conditional checks */\nfunction doNothing() {}\n\n/**\n * Converts an ObjectSetListener to one where all the functions are defined.\n */\nfunction fillOutListener<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n>(\n  {\n    onChange = doNothing,\n    onError = doNothing,\n    onOutOfDate = doNothing,\n    onSuccessfulSubscription = doNothing,\n  }: ObjectSetSubscription.Listener<Q, P>,\n): Required<ObjectSetSubscription.Listener<Q, P>> {\n  return { onChange, onError, onOutOfDate, onSuccessfulSubscription };\n}\n\ninterface Subscription<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n> {\n  listener: Required<ObjectSetSubscription.Listener<Q, P>>;\n  requestedProperties: Array<P>;\n  requestedReferenceProperties: Array<P>;\n  objectSet: ObjectSet;\n\n  subscriptionId: string;\n  isReady?: boolean;\n  status:\n    | \"preparing\"\n    | \"subscribed\"\n    | \"done\"\n    | \"expired\"\n    | \"error\"\n    | \"reconnecting\";\n\n  interfaceApiName?: string;\n  primaryKeyPropertyName?: string;\n}\n\nfunction isReady<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n>(\n  sub: Subscription<Q, P>,\n): sub is Subscription<Q, P> & { temporaryObjectSetId: string } {\n  return sub.isReady != null;\n}\n\nfunction subscriptionIsDone(sub: Subscription<any, any>) {\n  return sub.status === \"done\" || sub.status === \"error\";\n}\n\n/** @internal */\nexport class ObjectSetListenerWebsocket {\n  static #instances = new WeakMap<\n    ClientCacheKey,\n    ObjectSetListenerWebsocket\n  >();\n  readonly MINIMUM_RECONNECT_DELAY_MS: number;\n\n  // FIXME\n  static getInstance(client: MinimalClient): ObjectSetListenerWebsocket {\n    let instance = ObjectSetListenerWebsocket.#instances.get(\n      client.clientCacheKey,\n    );\n    if (instance == null) {\n      instance = new ObjectSetListenerWebsocket(client);\n      ObjectSetListenerWebsocket.#instances.set(\n        client.clientCacheKey,\n        instance,\n      );\n    }\n    return instance;\n  }\n\n  #ws: WebSocket | undefined;\n  #lastWsConnect = 0;\n  #client: MinimalClient;\n\n  #logger?: Logger;\n\n  /**\n   * map of requestId to all active subscriptions at the time of the request\n   */\n  #pendingSubscriptions = new Map<\n    string,\n    Subscription<any, any>[]\n  >();\n\n  /**\n   * Map of subscriptionId to Subscription. Note: the subscriptionId may be\n   * temporary and not the actual subscriptionId from the server.\n   */\n  #subscriptions = new Map<\n    string,\n    Subscription<any, any>\n  >();\n\n  #endedSubscriptions = new Set<\n    string\n  >();\n\n  #maybeDisconnectTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  // DO NOT CONSTRUCT DIRECTLY. ONLY EXPOSED AS A TESTING SEAM\n  constructor(\n    client: MinimalClient,\n    {\n      minimumReconnectDelayMs = MINIMUM_RECONNECT_DELAY_MS,\n    } = {},\n  ) {\n    this.MINIMUM_RECONNECT_DELAY_MS = minimumReconnectDelayMs;\n    this.#client = client;\n    this.#logger = client.logger?.child({}, {\n      msgPrefix: \"<OSW> \",\n    });\n    invariant(\n      client.baseUrl.startsWith(\"https://\")\n        || client.baseUrl.startsWith(\"http://\"),\n      \"Stack must be a URL\",\n    );\n  }\n\n  async subscribe<\n    Q extends ObjectOrInterfaceDefinition,\n    P extends PropertyKeys<Q>,\n  >(\n    objectType: ObjectOrInterfaceDefinition,\n    objectSet: ObjectSet,\n    listener: ObjectSetSubscription.Listener<Q, P>,\n    properties: Array<P> = [],\n  ): Promise<() => void> {\n    const objOrInterfaceDef = objectType.type === \"object\"\n      ? await this.#client.ontologyProvider.getObjectDefinition(\n        objectType.apiName,\n      )\n      : await this.#client.ontologyProvider.getInterfaceDefinition(\n        objectType.apiName,\n      );\n\n    let objectProperties: Array<P> = [];\n    let referenceProperties: Array<P> = [];\n\n    if (properties.length === 0) {\n      properties = Object.keys(objOrInterfaceDef.properties) as Array<P>;\n    }\n\n    objectProperties = properties.filter((p) =>\n      objOrInterfaceDef.properties[p].type !== \"geotimeSeriesReference\"\n    );\n\n    referenceProperties = properties.filter((p) =>\n      objOrInterfaceDef.properties[p].type === \"geotimeSeriesReference\"\n    );\n\n    const sub: Subscription<Q, P> = {\n      listener: fillOutListener<Q, P>(listener),\n      objectSet,\n      primaryKeyPropertyName: objOrInterfaceDef.type === \"interface\"\n        ? undefined\n        : objOrInterfaceDef.primaryKeyApiName,\n      requestedProperties: objectProperties,\n      requestedReferenceProperties: referenceProperties,\n      status: \"preparing\",\n      // Since we don't have a real subscription id yet but we need to keep\n      // track of this reference, we can just use a random uuid.\n      subscriptionId: `TMP-${nextUuid()}}`,\n      interfaceApiName: objOrInterfaceDef.type === \"object\"\n        ? undefined\n        : objOrInterfaceDef.apiName,\n    };\n\n    this.#subscriptions.set(sub.subscriptionId, sub);\n\n    // actually prepares the subscription, ensures the ws is ready, and sends\n    // a subscribe message. We don't want to block on this.\n    void this.#initiateSubscribe(sub);\n\n    return () => {\n      this.#unsubscribe(sub);\n    };\n  }\n\n  /**\n   * Called at least once for every subscription.\n   *\n   * - Resets pending expiry\n   * - Recreates temporary object set\n   * - Triggers a full subscribe message\n   *\n   * @returns\n   */\n  async #initiateSubscribe(sub: Subscription<any, any>) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\"#initiateSubscribe()\");\n    }\n\n    try {\n      await this.#ensureWebsocket();\n\n      // the consumer may have already unsubscribed before we are ready to request a subscription\n      // so we have to acquire the pendingSubscription after the await.\n      if (subscriptionIsDone(sub)) {\n        return;\n      }\n      sub.isReady = true;\n      // if we aren't open, then this happens after we #onConnect\n      if (this.#ws?.readyState === WebSocket.OPEN) {\n        this.#sendSubscribeMessage();\n      }\n    } catch (error) {\n      this.#logger?.error(error, \"Error in #initiateSubscribe\");\n      this.#tryCatchOnError(sub, true, error);\n    }\n  }\n\n  #sendSubscribeMessage() {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\"#sendSubscribeMessage()\");\n    }\n    // If two calls to `.subscribe()` happen at once (or if the connection is reset),\n    // we may have multiple subscriptions that don't have a subscriptionId yet,\n    // so we filter those out.\n    const readySubs = [...this.#subscriptions.values()].filter(isReady);\n\n    const id = nextUuid();\n    // responses come back as an array of subIds, so we need to know the sources\n    this.#pendingSubscriptions.set(id, readySubs);\n\n    // every subscribe message \"overwrites\" the previous ones that are not\n    // re-included, so we have to reconstitute the entire list of subscriptions\n    const subscribe: ObjectSetStreamSubscribeRequests = {\n      id,\n      requests: readySubs.map<ObjectSetStreamSubscribeRequest>((\n        {\n          objectSet,\n          requestedProperties,\n          requestedReferenceProperties,\n          interfaceApiName,\n        },\n      ) => {\n        return {\n          objectSet: objectSet,\n          propertySet: requestedProperties,\n          referenceSet: requestedReferenceProperties,\n        };\n      }),\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\n        { payload: subscribe },\n        \"sending subscribe message\",\n      );\n    }\n    this.#ws?.send(JSON.stringify(subscribe));\n  }\n\n  #unsubscribe<Q extends ObjectOrInterfaceDefinition>(\n    sub: Subscription<Q, any>,\n    newStatus: \"done\" | \"error\" = \"done\",\n  ) {\n    if (subscriptionIsDone(sub)) {\n      // if we are already done, we don't need to do anything\n      return;\n    }\n\n    sub.status = newStatus;\n\n    // make sure listeners do nothing now\n    sub.listener = fillOutListener<Q, any>({});\n\n    this.#subscriptions.delete(sub.subscriptionId);\n    this.#endedSubscriptions.add(sub.subscriptionId);\n    this.#sendSubscribeMessage();\n\n    // If we have no more subscriptions, we can disconnect the websocket\n    // however we should wait a bit to see if we get any more subscriptions.\n    // For example, when switching between react views, you may unsubscribe\n    // in the old view and subscribe in the new view. We don't need to re-establish\n    // the websocket connection in that case.\n    if (this.#maybeDisconnectTimeout) {\n      // We reset the timeout on every unsubscribe so its always at least 15s from\n      // the last time we are empty. E.g.:\n      //   - 0s: Subscribe(A)\n      //   - 10s: Unsubscribe(A)\n      //   - 11s: Subscribe(B)\n      //   - 20s: Unsubscribe(B)\n      // If we do not clear out the timeout we would disconnect at 25s but that would only be\n      // 5s after the last subscription was removed instead of at 35s for the desired 15s.\n      clearTimeout(this.#maybeDisconnectTimeout);\n    }\n    this.#maybeDisconnectTimeout = setTimeout(() => {\n      this.#maybeDisconnectTimeout = undefined;\n      if (this.#subscriptions.size === 0) {\n        this.#cycleWebsocket();\n      }\n    }, 15_000 /* ms */);\n  }\n\n  async #ensureWebsocket() {\n    if (this.#ws == null) {\n      const { baseUrl, tokenProvider } = this.#client;\n      const url = constructWebsocketUrl(\n        baseUrl,\n        await this.#client.ontologyRid,\n      );\n\n      const token = await tokenProvider();\n\n      // tokenProvider is async, there could potentially be a race to create the websocket.\n      // Only the first call to reach here will find a null this.#ws, the rest will bail out\n      if (this.#ws == null) {\n        // TODO this can probably be exponential backoff with jitter\n        // don't reconnect more quickly than MINIMUM_RECONNECT_DELAY\n        const nextConnectTime = (this.#lastWsConnect ?? 0)\n          + this.MINIMUM_RECONNECT_DELAY_MS;\n        if (nextConnectTime > Date.now()) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, nextConnectTime - Date.now());\n          });\n        }\n\n        this.#lastWsConnect = Date.now();\n\n        // we again may have lost the race after our minimum backoff time\n        if (this.#ws == null) {\n          if (process.env.NODE_ENV !== \"production\") {\n            this.#logger?.debug(\"Creating websocket\");\n          }\n          this.#ws = new WebSocket(url, [`Bearer-${token}`]);\n          this.#ws.addEventListener(\"close\", this.#onClose);\n          this.#ws.addEventListener(\"message\", this.#onMessage);\n          this.#ws.addEventListener(\"open\", this.#onOpen);\n        }\n      }\n      // Allow await-ing the websocket open event if it isn't open already.\n      // This needs to happen even for callers that didn't just create this.#ws\n      if (this.#ws.readyState === WebSocket.CONNECTING) {\n        const ws = this.#ws;\n        return new Promise<void>((resolve, reject) => {\n          function cleanup() {\n            ws.removeEventListener(\"open\", open);\n            ws.removeEventListener(\"error\", error);\n            ws.removeEventListener(\"close\", cleanup);\n          }\n          function open() {\n            cleanup();\n            resolve();\n          }\n          function error(evt: unknown) {\n            cleanup();\n            reject(evt);\n          }\n          ws.addEventListener(\"open\", open);\n          ws.addEventListener(\"error\", error);\n          ws.addEventListener(\"close\", cleanup);\n        });\n      }\n    }\n  }\n\n  #onOpen = () => {\n    // resubscribe all of the listeners\n    this.#sendSubscribeMessage();\n  };\n\n  #onMessage = async (message: WebSocket.MessageEvent): Promise<void> => {\n    const data = JSON.parse(message.data.toString()) as StreamMessage;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug({ payload: data }, \"received message from ws\");\n    }\n    switch (data.type) {\n      case \"objectSetChanged\":\n        await this.#handleMessage_objectSetChanged(data);\n        return;\n\n      case \"refreshObjectSet\":\n        this.#handleMessage_refreshObjectSet(data);\n        return;\n\n      case \"subscribeResponses\":\n        this.#handleMessage_subscribeResponses(data);\n        return;\n\n      case \"subscriptionClosed\": {\n        this.#handleMessage_subscriptionClosed(data);\n        return;\n      }\n\n      default:\n        const _: never = data;\n        invariant(false, \"Unexpected message type\");\n    }\n  };\n\n  #handleMessage_objectSetChanged = async (\n    payload: ObjectSetUpdates,\n  ) => {\n    const sub = this.#subscriptions.get(payload.id);\n    if (sub == null) return;\n\n    const objectUpdates = payload.updates.filter((update) =>\n      update.type === \"object\"\n    );\n    const referenceUpdates = payload.updates.filter((update) =>\n      update.type === \"reference\"\n    );\n    const osdkObjectsWithReferenceUpdates = await Promise.all(\n      referenceUpdates.map(async (o) => {\n        const osdkObjectArray = await this.#client.objectFactory2(\n          this.#client,\n          [{\n            __apiName: o.objectType,\n            __primaryKey: sub.primaryKeyPropertyName != null\n              ? o.primaryKey[sub.primaryKeyPropertyName]\n              : undefined,\n            ...o.primaryKey,\n            [o.property]: o.value,\n          }],\n          sub.interfaceApiName,\n          {},\n          false,\n          undefined,\n          false,\n          await this.#fetchInterfaceMapping(\n            o.objectType,\n            sub.interfaceApiName,\n          ),\n        );\n        const singleOsdkObject = osdkObjectArray[0] ?? undefined;\n        return singleOsdkObject != null\n          ? {\n            object: singleOsdkObject as Osdk.Instance<any, never, any>,\n            state: \"ADDED_OR_UPDATED\" as ObjectState,\n          }\n          : undefined;\n      }),\n    );\n\n    for (const update of osdkObjectsWithReferenceUpdates) {\n      if (update != null) {\n        try {\n          sub.listener.onChange?.(update);\n        } catch (error) {\n          this.#logger?.error(error, \"Error in onChange callback\");\n          this.#tryCatchOnError(sub, false, error);\n        }\n      }\n    }\n\n    const osdkObjects = await Promise.all(objectUpdates.map(async (o) => {\n      const keysToDelete = Object.keys(o.object).filter((key) =>\n        sub.requestedReferenceProperties.includes(key)\n      );\n      for (const key of keysToDelete) {\n        delete o.object[key];\n      }\n\n      const osdkObjectArray = await this.#client.objectFactory2(\n        this.#client,\n        [o.object],\n        sub.interfaceApiName,\n        {},\n        false,\n        undefined,\n        false,\n        await this.#fetchInterfaceMapping(\n          o.object.__apiName,\n          sub.interfaceApiName,\n        ),\n      ) as Array<Osdk.Instance<any, never, any>>;\n      const singleOsdkObject = osdkObjectArray[0] ?? undefined;\n      return singleOsdkObject != null\n        ? {\n          object: singleOsdkObject,\n          state: o.state,\n        }\n        : undefined;\n    }));\n\n    for (const osdkObject of osdkObjects) {\n      if (osdkObject != null) {\n        try {\n          sub.listener.onChange?.(osdkObject);\n        } catch (error) {\n          this.#logger?.error(error, \"Error in onChange callback\");\n          this.#tryCatchOnError(sub, false, error);\n        }\n      }\n    }\n  };\n\n  async #fetchInterfaceMapping(\n    objectTypeApiName: string,\n    interfaceApiName: string | undefined,\n  ): Promise<Record<string, Record<string, Record<string, string>>>> {\n    if (interfaceApiName == null) return {};\n    const interfaceMap = (await this.#client.ontologyProvider\n      .getObjectDefinition(objectTypeApiName)).interfaceMap;\n    return {\n      [interfaceApiName]: {\n        [objectTypeApiName]: interfaceMap[interfaceApiName],\n      },\n    };\n  }\n\n  #handleMessage_refreshObjectSet = (payload: RefreshObjectSet) => {\n    const sub = this.#subscriptions.get(payload.id);\n    invariant(sub, `Expected subscription id ${payload.id}`);\n    try {\n      sub.listener.onOutOfDate();\n    } catch (error) {\n      this.#logger?.error(error, \"Error in onOutOfDate callback\");\n      this.#tryCatchOnError(sub, false, error);\n    }\n  };\n\n  #handleMessage_subscribeResponses = (\n    payload: ObjectSetSubscribeResponses,\n  ) => {\n    const { id, responses } = payload;\n\n    const subs = this.#pendingSubscriptions.get(id);\n    invariant(subs, `should have a pending subscription for ${id}`);\n    this.#pendingSubscriptions.delete(id);\n\n    for (let i = 0; i < responses.length; i++) {\n      const sub = subs[i];\n      const response = responses[i];\n\n      switch (response.type) {\n        case \"error\":\n          this.#tryCatchOnError(sub, true, response.errors);\n          this.#unsubscribe(sub, \"error\");\n          break;\n\n        case \"qos\":\n          // the server has requested that we tear down our websocket and reconnect to help load balance\n          this.#cycleWebsocket();\n          break;\n\n        case \"success\":\n          // `\"preparing\"` should only be the status on an initial subscribe.\n          const shouldFireOutOfDate = sub.status === \"expired\"\n            || sub.status === \"reconnecting\";\n\n          if (process.env.NODE_ENV !== \"production\") {\n            this.#logger?.debug({ shouldFireOutOfDate }, \"success\");\n          }\n          sub.status = \"subscribed\";\n          if (sub.subscriptionId !== response.id) {\n            // might be the temporary one\n            this.#subscriptions.delete(sub.subscriptionId);\n            sub.subscriptionId = response.id;\n            this.#subscriptions.set(sub.subscriptionId, sub); // future messages come by this subId\n          }\n          try {\n            if (shouldFireOutOfDate) sub.listener.onOutOfDate();\n            else sub.listener.onSuccessfulSubscription();\n          } catch (error) {\n            this.#logger?.error(\n              error,\n              \"Error in onOutOfDate or onSuccessfulSubscription callback\",\n            );\n            this.#tryCatchOnError(sub, false, error);\n          }\n          break;\n        default:\n          this.#tryCatchOnError(sub, true, response);\n      }\n    }\n  };\n\n  #handleMessage_subscriptionClosed(payload: SubscriptionClosed) {\n    const sub = this.#subscriptions.get(payload.id);\n    if (sub == null && this.#endedSubscriptions.has(payload.id)) return;\n    invariant(sub, `Expected subscription id ${payload.id}`);\n    this.#tryCatchOnError(sub, true, payload.cause);\n    this.#unsubscribe(sub, \"error\");\n  }\n\n  #onClose = (event: WebSocket.CloseEvent) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug({ event }, \"Received close event from ws\", event);\n    }\n    // TODO we should probably throttle this so we don't abuse the backend\n    this.#cycleWebsocket();\n  };\n\n  #cycleWebsocket = () => {\n    if (this.#ws) {\n      this.#ws.removeEventListener(\"open\", this.#onOpen);\n      this.#ws.removeEventListener(\"message\", this.#onMessage);\n      this.#ws.removeEventListener(\"close\", this.#onClose);\n\n      if (\n        this.#ws.readyState !== WebSocket.CLOSING\n        && this.#ws.readyState !== WebSocket.CLOSED\n      ) {\n        this.#ws.close();\n      }\n      this.#ws = undefined;\n    }\n\n    // if we have any listeners that are still depending on us, go ahead and reopen the websocket\n    if (this.#subscriptions.size > 0) {\n      if (process.env.NODE_ENV !== \"production\") {\n        for (const s of this.#subscriptions.values()) {\n          invariant(\n            s.status !== \"done\" && s.status !== \"error\",\n            \"should not have done/error subscriptions still\",\n          );\n        }\n      }\n\n      for (const s of this.#subscriptions.values()) {\n        if (s.status === \"subscribed\") s.status = \"reconnecting\";\n      }\n\n      // we don't care about the result of this (we want cycleWebsocket to be fire and forget)\n      // just that it happens\n      void this.#ensureWebsocket();\n    }\n  };\n\n  #tryCatchOnError = (\n    sub: Subscription<any, any>,\n    subscriptionClosed: boolean,\n    error: any,\n  ) => {\n    try {\n      sub.listener.onError({ subscriptionClosed: subscriptionClosed, error });\n    } catch (onErrorError) {\n      // eslint-disable-next-line no-console\n      console.error(\n        `Error encountered in an onError callback for an OSDK subscription`,\n        onErrorError,\n      );\n      // eslint-disable-next-line no-console\n      console.error(\n        `This onError call was triggered by an error in another callback`,\n        error,\n      );\n      // eslint-disable-next-line no-console\n      console.error(\n        `The subscription has been closed.`,\n        error,\n      );\n\n      if (!subscriptionClosed) {\n        this.#logger?.error(error, \"Error in onError callback\");\n        this.#unsubscribe(sub, \"error\");\n        this.#tryCatchOnError(sub, true, onErrorError);\n      }\n    }\n  };\n}\n\n/** @internal */\nexport function constructWebsocketUrl(\n  baseUrl: string,\n  ontologyRid: string,\n) {\n  const base = new URL(baseUrl);\n  const url = new URL(\n    `api/v2/ontologySubscriptions/ontologies/${ontologyRid}/streamSubscriptions`,\n    base,\n  );\n  url.protocol = url.protocol.replace(\"https\", \"wss\");\n  return url;\n}\n\nlet uuidCounter = 0;\n\nfunction nextUuid() {\n  return `00000000-0000-0000-0000-${\n    (uuidCounter++).toString().padStart(12, \"0\")\n  }`;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AsyncIterArgs,\n  Augments,\n  FetchPageResult,\n  LinkedType,\n  LinkNames,\n  NullabilityAdherence,\n  ObjectOrInterfaceDefinition,\n  ObjectSet,\n  ObjectTypeDefinition,\n  Osdk,\n  PrimaryKeyType,\n  PropertyKeys,\n  Result,\n  SelectArg,\n  SingleOsdkResult,\n} from \"@osdk/api\";\nimport type { MinimalObjectSet } from \"@osdk/api/unstable\";\nimport type {\n  DerivedPropertyDefinition,\n  ObjectSet as WireObjectSet,\n} from \"@osdk/foundry.ontologies\";\nimport { createWithPropertiesObjectSet } from \"../derivedProperties/createWithPropertiesObjectSet.js\";\nimport { modernToLegacyWhereClause } from \"../internal/conversions/modernToLegacyWhereClause.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { aggregate } from \"../object/aggregate.js\";\nimport {\n  fetchPageInternal,\n  fetchPageWithErrorsInternal,\n} from \"../object/fetchPage.js\";\nimport { fetchSingle, fetchSingleWithErrors } from \"../object/fetchSingle.js\";\nimport { augmentRequestContext } from \"../util/augmentRequestContext.js\";\nimport { resolveBaseObjectSetType } from \"../util/objectSetUtils.js\";\nimport { isWireObjectSet } from \"../util/WireObjectSet.js\";\nimport { ObjectSetListenerWebsocket } from \"./ObjectSetListenerWebsocket.js\";\n\nfunction isObjectTypeDefinition(\n  def: ObjectOrInterfaceDefinition,\n): def is ObjectTypeDefinition {\n  return def.type === \"object\";\n}\n\n/* @internal */\nexport function isObjectSet(o: any): o is ObjectSet<any> {\n  return o != null && typeof o === \"object\"\n    && isWireObjectSet(objectSetDefinitions.get(o));\n}\n\n/** @internal */\nexport function getWireObjectSet(\n  objectSet: ObjectSet<any> | MinimalObjectSet<any>,\n): WireObjectSet {\n  return objectSetDefinitions.get(objectSet)!;\n}\n\nconst objectSetDefinitions = new WeakMap<\n  any,\n  WireObjectSet\n>();\n\n/** @internal */\nexport function createObjectSet<Q extends ObjectOrInterfaceDefinition>(\n  objectType: Q,\n  clientCtx: MinimalClient,\n  objectSet: WireObjectSet = resolveBaseObjectSetType(objectType),\n): ObjectSet<Q> {\n  const base: ObjectSet<Q> = {\n    aggregate: (aggregate<Q, any>).bind(\n      globalThis,\n      augmentRequestContext(clientCtx, _ => ({ finalMethodCall: \"aggregate\" })),\n      objectType,\n      objectSet,\n    ) as ObjectSet<Q>[\"aggregate\"],\n\n    fetchPage: fetchPageInternal.bind(\n      globalThis,\n      augmentRequestContext(clientCtx, _ => ({ finalMethodCall: \"fetchPage\" })),\n      objectType,\n      objectSet,\n    ) as ObjectSet<Q>[\"fetchPage\"],\n\n    fetchPageWithErrors: fetchPageWithErrorsInternal.bind(\n      globalThis,\n      augmentRequestContext(\n        clientCtx,\n        _ => ({ finalMethodCall: \"fetchPageWithErrors\" }),\n      ),\n      objectType,\n      objectSet,\n    ) as ObjectSet<Q>[\"fetchPageWithErrors\"],\n\n    where: (clause) => {\n      return clientCtx.objectSetFactory(objectType, clientCtx, {\n        type: \"filter\",\n        objectSet: objectSet,\n        where: modernToLegacyWhereClause(clause, objectType),\n      });\n    },\n\n    pivotTo: function<L extends LinkNames<Q>>(\n      type: L,\n    ): ObjectSet<LinkedType<Q, L>> {\n      return createSearchAround(type)();\n    },\n\n    union: (...objectSets) => {\n      return clientCtx.objectSetFactory(objectType, clientCtx, {\n        type: \"union\",\n        objectSets: [\n          objectSet,\n          ...objectSets.map(os => objectSetDefinitions.get(os)!),\n        ],\n      });\n    },\n\n    intersect: (...objectSets) => {\n      return clientCtx.objectSetFactory(objectType, clientCtx, {\n        type: \"intersect\",\n        objectSets: [\n          objectSet,\n          ...objectSets.map(os => objectSetDefinitions.get(os)!),\n        ],\n      });\n    },\n\n    subtract: (...objectSets) => {\n      return clientCtx.objectSetFactory(objectType, clientCtx, {\n        type: \"subtract\",\n        objectSets: [\n          objectSet,\n          ...objectSets.map(os => objectSetDefinitions.get(os)!),\n        ],\n      });\n    },\n\n    asyncIter: async function*<\n      L extends PropertyKeys<Q>,\n      R extends boolean,\n      const A extends Augments,\n      S extends NullabilityAdherence = NullabilityAdherence.Default,\n      T extends boolean = false,\n    >(\n      args?: AsyncIterArgs<Q, L, R, A, S, T>,\n    ): AsyncIterableIterator<SingleOsdkResult<Q, L, R, S, {}, T>> {\n      let $nextPageToken: string | undefined = undefined;\n      do {\n        const result: FetchPageResult<\n          Q,\n          L,\n          R,\n          S,\n          T\n        > = await fetchPageInternal(\n          augmentRequestContext(\n            clientCtx,\n            _ => ({ finalMethodCall: \"asyncIter\" }),\n          ),\n          objectType,\n          objectSet,\n          { ...args, $pageSize: 10000, $nextPageToken },\n        );\n        $nextPageToken = result.nextPageToken;\n\n        for (const obj of result.data) {\n          yield obj as SingleOsdkResult<Q, L, R, S, {}, T>;\n        }\n      } while ($nextPageToken != null);\n    },\n\n    fetchOne: (isObjectTypeDefinition(objectType)\n      ? async <A extends SelectArg<Q>>(\n        primaryKey: PrimaryKeyType<Q>,\n        options: A,\n      ) => {\n        return await fetchSingle(\n          augmentRequestContext(\n            clientCtx,\n            _ => ({ finalMethodCall: \"fetchOne\" }),\n          ),\n          objectType,\n          options,\n          await createWithPk(\n            clientCtx,\n            objectType,\n            objectSet,\n            primaryKey,\n          ),\n        ) as Osdk<Q>;\n      }\n      : undefined) as ObjectSet<Q>[\"fetchOne\"],\n\n    fetchOneWithErrors: (isObjectTypeDefinition(objectType)\n      ? async <A extends SelectArg<Q>>(\n        primaryKey: Q extends ObjectTypeDefinition ? PrimaryKeyType<Q>\n          : never,\n        options: A,\n      ) => {\n        return await fetchSingleWithErrors(\n          augmentRequestContext(\n            clientCtx,\n            _ => ({ finalMethodCall: \"fetchOneWithErrors\" }),\n          ),\n          objectType,\n          options,\n          await createWithPk(\n            clientCtx,\n            objectType,\n            objectSet,\n            primaryKey,\n          ),\n        ) as Result<Osdk<Q>>;\n      }\n      : undefined) as ObjectSet<Q>[\"fetchOneWithErrors\"],\n\n    subscribe: (\n      listener,\n      opts,\n    ) => {\n      const pendingSubscribe = ObjectSetListenerWebsocket.getInstance(\n        clientCtx,\n      ).subscribe(\n        objectType,\n        objectSet,\n        listener,\n        opts?.properties,\n      );\n\n      return { unsubscribe: async () => (await pendingSubscribe)() };\n    },\n\n    withProperties: (clause) => {\n      const definitionMap = new Map<any, DerivedPropertyDefinition>();\n\n      const derivedProperties: Record<string, DerivedPropertyDefinition> = {};\n      for (const key of Object.keys(clause)) {\n        const derivedPropertyDefinition = clause\n          [key](createWithPropertiesObjectSet(\n            objectType,\n            { type: \"methodInput\" },\n            definitionMap,\n            true,\n          ));\n        derivedProperties[key] = definitionMap.get(\n          derivedPropertyDefinition,\n        )!;\n      }\n\n      return clientCtx.objectSetFactory(\n        objectType,\n        clientCtx,\n        {\n          type: \"withProperties\",\n          derivedProperties: derivedProperties,\n          objectSet: objectSet,\n        },\n      );\n    },\n\n    $objectSetInternals: {\n      def: objectType,\n    },\n  };\n\n  function createSearchAround<L extends LinkNames<Q>>(link: L) {\n    return () => {\n      return clientCtx.objectSetFactory(\n        objectType,\n        clientCtx,\n        {\n          type: \"searchAround\",\n          objectSet,\n          link,\n        },\n      );\n    };\n  }\n\n  objectSetDefinitions.set(base, objectSet);\n\n  // we are using a type assertion because the marker symbol defined in BaseObjectSet isn't actually used\n  // at runtime.\n  return base as ObjectSet<Q>;\n}\n\nasync function createWithPk(\n  clientCtx: MinimalClient,\n  objectType: ObjectTypeDefinition,\n  objectSet: WireObjectSet,\n  primaryKey: PrimaryKeyType<ObjectTypeDefinition>,\n) {\n  const objDef = await clientCtx.ontologyProvider.getObjectDefinition(\n    objectType.apiName,\n  );\n\n  const withPk: WireObjectSet = {\n    type: \"filter\",\n    objectSet: objectSet,\n    where: {\n      type: \"eq\",\n      field: objDef.primaryKeyApiName,\n      value: primaryKey,\n    },\n  };\n  return withPk;\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ActionParam } from \"@osdk/api\";\n\n/** @internal */\nexport function isInterfaceActionParam(\n  o: any,\n): o is ActionParam.InterfaceType<any> {\n  return o != null && typeof o === \"object\"\n    && \"$objectType\" in o && \"$primaryKey\" in o;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { PrimaryKeyTypes } from \"@osdk/api\";\n\nexport function isObjectSpecifiersObject(\n  o: any,\n): o is { $apiName: string; $primaryKey: PrimaryKeyTypes } {\n  return o && typeof o === \"object\" && typeof o.$apiName === \"string\"\n    && o.$primaryKey != null;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OntologyObjectV2 } from \"@osdk/foundry.ontologies\";\n\n/** @internal */\nexport function isOntologyObjectV2(o: any): o is OntologyObjectV2 {\n  return o && typeof o === \"object\" && typeof o.__apiName === \"string\"\n    && o.__primaryKey != null;\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isPoint(o: any): o is GeoJSON.Point {\n  return o && typeof o === \"object\" && \"type\" in o && o.type === \"Point\"\n    && \"coordinates\" in o && o.coordinates.length === 2;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ActionMetadata } from \"@osdk/api\";\nimport { type DataValue } from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport {\n  isAttachmentFile,\n  isAttachmentUpload,\n} from \"../object/AttachmentUpload.js\";\nimport { isMediaReference, isMediaUpload } from \"../object/mediaUpload.js\";\nimport { getWireObjectSet, isObjectSet } from \"../objectSet/createObjectSet.js\";\nimport { isInterfaceActionParam } from \"./interfaceUtils.js\";\nimport { isObjectSpecifiersObject } from \"./isObjectSpecifiersObject.js\";\nimport { isOntologyObjectV2 } from \"./isOntologyObjectV2.js\";\nimport { isPoint } from \"./isPoint.js\";\nimport { isWireObjectSet } from \"./WireObjectSet.js\";\n\n/**\n * Marshall user-facing data into the wire DataValue type\n *\n * @see DataValue for the expected payloads\n * @internal\n */\nexport async function toDataValue(\n  value: unknown,\n  client: MinimalClient,\n  actionMetadata: ActionMetadata,\n): Promise<DataValue> {\n  if (value == null) {\n    // typeof null is 'object' so do this first\n    return value;\n  }\n\n  // arrays and sets are both sent over the wire as arrays\n  if (Array.isArray(value) || value instanceof Set) {\n    const values = Array.from(value);\n    if (\n      values.some((dataValue) =>\n        isAttachmentUpload(dataValue) || isAttachmentFile(dataValue)\n      )\n    ) {\n      const converted = [];\n      for (const value of values) {\n        converted.push(await toDataValue(value, client, actionMetadata));\n      }\n      return converted;\n    }\n    const promiseArray = Array.from(\n      value,\n      async (innerValue) =>\n        await toDataValue(innerValue, client, actionMetadata),\n    );\n    return Promise.all(promiseArray);\n  }\n\n  // For uploads, we need to upload ourselves first to get the RID of the attachment\n  if (isAttachmentUpload(value)) {\n    const attachment = await OntologiesV2.Attachments.upload(\n      client,\n      value.data,\n      {\n        filename: value.name,\n      },\n    );\n    return await toDataValue(attachment.rid, client, actionMetadata);\n  }\n\n  if (isAttachmentFile(value)) {\n    const attachment = await OntologiesV2.Attachments.upload(\n      client,\n      value,\n      {\n        filename: value.name as string,\n      },\n    );\n    return await toDataValue(attachment.rid, client, actionMetadata);\n  }\n\n  // new media item upload interface, very similar to how attachments work above\n\n  if (isMediaUpload(value)) {\n    const mediaRef = await OntologiesV2.MediaReferenceProperties\n      .uploadMedia(\n        client,\n        await client.ontologyRid,\n        actionMetadata.apiName,\n        value.data,\n        {\n          mediaItemPath: value.path,\n          preview: true,\n        },\n      );\n    return await toDataValue(mediaRef, client, actionMetadata);\n  }\n\n  // objects just send the JSON'd primaryKey\n  if (isOntologyObjectV2(value)) {\n    return await toDataValue(value.__primaryKey, client, actionMetadata);\n  }\n\n  if (isObjectSpecifiersObject(value)) {\n    return await toDataValue(value.$primaryKey, client, actionMetadata);\n  }\n\n  if (isPoint(value)) {\n    return await toDataValue(\n      `${value.coordinates[1]},${value.coordinates[0]}`,\n      client,\n      actionMetadata,\n    );\n  }\n\n  // object set (the rid as a string (passes through the last return), or the ObjectSet definition directly)\n  if (isWireObjectSet(value)) {\n    return value;\n  }\n  if (isObjectSet(value)) {\n    return getWireObjectSet(value);\n  }\n\n  if (isMediaReference(value)) {\n    return value;\n  }\n\n  if (isInterfaceActionParam(value)) {\n    return {\n      objectTypeApiName: value.$objectType,\n      primaryKeyValue: value.$primaryKey,\n    };\n  }\n\n  // TODO (during queries implementation)\n  // two dimensional aggregation\n  // three dimensional aggregation\n\n  // struct\n  if (typeof value === \"object\") {\n    return Object.entries(value).reduce(\n      async (promisedAcc, [key, structValue]) => {\n        const acc = await promisedAcc;\n        acc[key] = await toDataValue(structValue, client, actionMetadata);\n        return acc;\n      },\n      Promise.resolve({} as { [key: string]: DataValue }),\n    );\n  }\n\n  // expected to pass through - boolean, byte, date, decimal, float, double, integer, long, short, string, timestamp, object type reference\n  return value;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  ActionEditResponse,\n  ActionMetadata,\n  ActionParam,\n  ActionReturnTypeForOptions,\n  ApplyActionOptions,\n  ApplyBatchActionOptions,\n  CompileTimeMetadata as CompileTimeActionMetadata,\n  DataValueClientToWire,\n} from \"@osdk/api\";\nimport type {\n  BatchApplyActionResponseV2,\n  DataValue,\n  SyncApplyActionResponseV2,\n} from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport { augmentRequestContext } from \"../util/augmentRequestContext.js\";\nimport type { NOOP } from \"../util/NOOP.js\";\nimport type { NullableProps } from \"../util/NullableProps.js\";\nimport type { PartialBy } from \"../util/partialBy.js\";\nimport { toDataValue } from \"../util/toDataValue.js\";\nimport { ActionValidationError } from \"./ActionValidationError.js\";\n\ntype BaseType<APD extends Pick<ActionMetadata.Parameter<any>, \"type\">> =\n  APD[\"type\"] extends ActionMetadata.DataType.Object<infer TTargetType>\n    ? ActionParam.ObjectType<TTargetType>\n    : APD[\"type\"] extends ActionMetadata.DataType.ObjectSet<infer TTargetType>\n      ? ActionParam.ObjectSetType<TTargetType>\n    : APD[\"type\"] extends ActionMetadata.DataType.Struct<infer TStructType>\n      ? ActionParam.StructType<TStructType>\n    : APD[\"type\"] extends keyof DataValueClientToWire\n      ? ActionParam.PrimitiveType<APD[\"type\"]>\n    : never;\n\ntype MaybeArrayType<APD extends ActionMetadata.Parameter<any>> =\n  APD[\"multiplicity\"] extends true ? Array<BaseType<APD>>\n    : BaseType<APD>;\n\ntype NotOptionalParams<X extends ActionParametersDefinition> = {\n  [P in keyof X]: MaybeArrayType<X[P]>;\n};\n\nexport type OsdkActionParameters<\n  X extends ActionParametersDefinition,\n> = NullableProps<X> extends never ? NotOptionalParams<X>\n  : PartialBy<NotOptionalParams<X>, NullableProps<X>>;\n\nexport type ActionSignatureFromDef<\n  T extends ActionDefinition<any>,\n> = {\n  applyAction:\n    [CompileTimeActionMetadata<T>[\"signatures\"][\"applyAction\"]] extends [never]\n      ? ActionSignature<CompileTimeActionMetadata<T>[\"parameters\"]>\n      : CompileTimeActionMetadata<T>[\"signatures\"][\"applyAction\"];\n\n  batchApplyAction:\n    [CompileTimeActionMetadata<T>[\"signatures\"][\"batchApplyAction\"]] extends\n      [never] ? BatchActionSignature<CompileTimeActionMetadata<T>[\"parameters\"]>\n      : CompileTimeActionMetadata<T>[\"signatures\"][\"batchApplyAction\"];\n};\n\ntype ActionParametersDefinition = Record<\n  any,\n  ActionMetadata.Parameter<any>\n>;\n\nexport type ActionSignature<\n  X extends Record<any, ActionMetadata.Parameter<any>>,\n> = <\n  A extends NOOP<OsdkActionParameters<X>>,\n  OP extends ApplyActionOptions,\n>(\n  args: A,\n  options?: OP,\n) => Promise<\n  ActionReturnTypeForOptions<OP>\n>;\n\nexport type BatchActionSignature<\n  X extends Record<any, ActionMetadata.Parameter<any>>,\n> = <\n  A extends NOOP<OsdkActionParameters<X>>[],\n  OP extends ApplyBatchActionOptions,\n>(\n  args: A,\n  options?: OP,\n) => Promise<\n  ActionReturnTypeForOptions<OP>\n>;\n\nexport async function applyAction<\n  AD extends ActionDefinition<any>,\n  P extends\n    | OsdkActionParameters<CompileTimeActionMetadata<AD>[\"parameters\"]>\n    | OsdkActionParameters<CompileTimeActionMetadata<AD>[\"parameters\"]>[],\n  Op extends P extends OsdkActionParameters<\n    CompileTimeActionMetadata<AD>[\"parameters\"]\n  >[] ? ApplyBatchActionOptions\n    : ApplyActionOptions,\n>(\n  client: MinimalClient,\n  action: AD,\n  parameters?: P,\n  options: Op = {} as Op,\n): Promise<\n  ActionReturnTypeForOptions<Op>\n> {\n  const clientWithHeaders = addUserAgentAndRequestContextHeaders(\n    augmentRequestContext(client, _ => ({ finalMethodCall: \"applyAction\" })),\n    action,\n  );\n  if (Array.isArray(parameters)) {\n    const response = await OntologiesV2.Actions.applyBatch(\n      clientWithHeaders,\n      await client.ontologyRid,\n      action.apiName,\n      {\n        requests: parameters\n          ? await remapBatchActionParams(\n            parameters,\n            client,\n            await client.ontologyProvider.getActionDefinition(action.apiName),\n          )\n          : [],\n        options: {\n          returnEdits: options?.$returnEdits ? \"ALL\" : \"NONE\",\n        },\n      },\n    );\n\n    const edits = response.edits;\n    return (options?.$returnEdits\n      ? edits?.type === \"edits\" ? remapActionResponse(response) : edits\n      : undefined) as ActionReturnTypeForOptions<Op>;\n  } else {\n    const response = await OntologiesV2.Actions.apply(\n      clientWithHeaders,\n      await client.ontologyRid,\n      action.apiName,\n      {\n        parameters: await remapActionParams(\n          parameters as OsdkActionParameters<\n            CompileTimeActionMetadata<AD>[\"parameters\"]\n          >,\n          client,\n          await client.ontologyProvider.getActionDefinition(action.apiName),\n        ),\n        options: {\n          mode: (options as ApplyActionOptions)?.$validateOnly\n            ? \"VALIDATE_ONLY\"\n            : \"VALIDATE_AND_EXECUTE\",\n          returnEdits: options\n              ?.$returnEdits\n            ? \"ALL_V2_WITH_DELETIONS\"\n            : \"NONE\",\n        },\n      },\n    );\n\n    if ((options as ApplyActionOptions)?.$validateOnly) {\n      return response.validation as ActionReturnTypeForOptions<Op>;\n    }\n\n    if (response.validation && response.validation?.result === \"INVALID\") {\n      const validation = response.validation;\n      throw new ActionValidationError(validation);\n    }\n\n    const edits = response.edits;\n    return (options?.$returnEdits\n      ? edits?.type === \"edits\" ? remapActionResponse(response) : edits\n      : undefined) as ActionReturnTypeForOptions<Op>;\n  }\n}\n\nasync function remapActionParams<AD extends ActionDefinition<any>>(\n  params:\n    | OsdkActionParameters<CompileTimeActionMetadata<AD>[\"parameters\"]>\n    | undefined,\n  client: MinimalClient,\n  actionMetadata: ActionMetadata,\n): Promise<Record<string, DataValue>> {\n  if (params == null) {\n    return {};\n  }\n\n  const parameterMap: { [parameterName: string]: unknown } = {};\n  for (const [key, value] of Object.entries(params)) {\n    parameterMap[key] = await toDataValue(value, client, actionMetadata);\n  }\n\n  return parameterMap;\n}\n\nasync function remapBatchActionParams<\n  AD extends ActionDefinition<any>,\n>(\n  params: OsdkActionParameters<CompileTimeActionMetadata<AD>[\"parameters\"]>[],\n  client: MinimalClient,\n  actionMetadata: ActionMetadata,\n) {\n  const remappedParams = await Promise.all(params.map(\n    async param => {\n      return {\n        parameters: await remapActionParams<AD>(param, client, actionMetadata),\n      };\n    },\n  ));\n\n  return remappedParams;\n}\n\nexport function remapActionResponse(\n  response: SyncApplyActionResponseV2 | BatchApplyActionResponseV2,\n): ActionEditResponse | undefined {\n  const editResponses = response?.edits;\n  if (editResponses?.type === \"edits\") {\n    const remappedActionResponse: ActionEditResponse = {\n      type: editResponses.type,\n      deletedLinksCount: editResponses.deletedLinksCount,\n      deletedObjectsCount: editResponses.deletedObjectsCount,\n      addedLinks: [],\n      deletedLinks: [],\n      addedObjects: [],\n      deletedObjects: [],\n      modifiedObjects: [],\n      editedObjectTypes: [],\n    };\n\n    const editedObjectTypesSet = new Set<string>();\n    for (const edit of editResponses.edits) {\n      if (edit.type === \"addLink\" || edit.type === \"deleteLink\") {\n        const osdkEdit = {\n          linkTypeApiNameAtoB: edit.linkTypeApiNameAtoB,\n          linkTypeApiNameBtoA: edit.linkTypeApiNameBtoA,\n          aSideObject: edit.aSideObject,\n          bSideObject: edit.bSideObject,\n        };\n        edit.type === \"addLink\"\n          ? remappedActionResponse.addedLinks.push(\n            osdkEdit,\n          )\n          : remappedActionResponse.deletedLinks?.push(osdkEdit);\n        editedObjectTypesSet.add(edit.aSideObject.objectType);\n        editedObjectTypesSet.add(edit.bSideObject.objectType);\n      } else if (\n        edit.type === \"addObject\" || edit.type === \"deleteObject\"\n        || edit.type === \"modifyObject\"\n      ) {\n        const osdkEdit = {\n          objectType: edit.objectType,\n          primaryKey: edit.primaryKey,\n        };\n        if (edit.type === \"addObject\") {\n          remappedActionResponse.addedObjects.push(osdkEdit);\n        } else if (edit.type === \"deleteObject\") {\n          remappedActionResponse.deletedObjects?.push(osdkEdit);\n        } else if (edit.type === \"modifyObject\") {\n          remappedActionResponse.modifiedObjects.push(osdkEdit);\n        }\n        editedObjectTypesSet.add(edit.objectType);\n      } else {\n        if (process.env.NODE_ENV !== \"production\") {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Unexpected edit type: ${JSON.stringify(edit)}`,\n          );\n        }\n      }\n    }\n    remappedActionResponse.editedObjectTypes = [...editedObjectTypesSet];\n    return remappedActionResponse;\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  ActionMetadata,\n  CompileTimeMetadata,\n  InterfaceDefinition,\n  InterfaceMetadata,\n  ObjectMetadata,\n  ObjectSet,\n  ObjectTypeDefinition,\n  QueryDefinition,\n  QueryMetadata,\n  VersionBound,\n} from \"@osdk/api\";\nimport type {\n  Experiment,\n  ExperimentFns,\n  MinimalObjectSet,\n} from \"@osdk/api/unstable\";\nimport type { SharedClient } from \"@osdk/shared.client2\";\nimport type { ActionSignatureFromDef } from \"./actions/applyAction.js\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\nimport type { QuerySignatureFromDef } from \"./queries/types.js\";\nimport type { SatisfiesSemver } from \"./SatisfiesSemver.js\";\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype OldSharedClient = import(\"@osdk/shared.client\").SharedClient;\n\nexport type CheckVersionBound<Q> = Q extends VersionBound<infer V> ? (\n    SatisfiesSemver<V, MaxOsdkVersion> extends true ? Q\n      : Q & {\n        [ErrorMessage]:\n          `Your SDK requires a semver compatible version with ${V}. You have ${MaxOsdkVersion}. Update your package.json`;\n      }\n  )\n  : Q;\n\nexport interface Client extends SharedClient, OldSharedClient {\n  <Q extends ObjectTypeDefinition>(\n    o: Q,\n  ): unknown extends CompileTimeMetadata<Q>[\"objectSet\"] ? ObjectSet<Q>\n    : CompileTimeMetadata<Q>[\"objectSet\"];\n\n  <Q extends (InterfaceDefinition)>(\n    o: Q,\n  ): unknown extends CompileTimeMetadata<Q>[\"objectSet\"] ? MinimalObjectSet<Q>\n    : CompileTimeMetadata<Q>[\"objectSet\"];\n\n  <Q extends ActionDefinition<any>>(\n    o: Q,\n  ): ActionSignatureFromDef<Q>;\n\n  <Q extends QueryDefinition<any>>(\n    o: Q,\n  ): QuerySignatureFromDef<Q>;\n\n  <Q extends Experiment<\"2.0.8\"> | Experiment<\"2.1.0\"> | Experiment<\"2.2.0\">>(\n    experiment: Q,\n  ): ExperimentFns<Q>;\n\n  fetchMetadata<\n    Q extends (\n      | ObjectTypeDefinition\n      | InterfaceDefinition\n      | ActionDefinition<any>\n      | QueryDefinition<any>\n    ),\n  >(o: Q): Promise<\n    Q extends ObjectTypeDefinition ? ObjectMetadata\n      : Q extends InterfaceDefinition ? InterfaceMetadata\n      : Q extends ActionDefinition<any> ? ActionMetadata\n      : Q extends QueryDefinition<any> ? QueryMetadata\n      : never\n  >;\n\n  /** @internal */\n  [additionalContext]: MinimalClient;\n}\n\n// DO NOT EXPORT FROM PACKAGE\n/** @internal */\nexport const additionalContext: unique symbol = Symbol(\"additionalContext\");\n\n// BEGIN: THIS IS GENERATED CODE. DO NOT EDIT.\nconst MaxOsdkVersion = \"2.3.0\";\n// END: THIS IS GENERATED CODE. DO NOT EDIT.\nexport type MaxOsdkVersion = typeof MaxOsdkVersion;\nconst ErrorMessage: unique symbol = Symbol(\"ErrorMessage\");\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { SharedClientContext } from \"@osdk/shared.client2\";\nimport { PalantirApiError } from \"@osdk/shared.net.errors\";\nimport {\n  createFetchHeaderMutator,\n  createFetchOrThrow,\n  createRetryingFetch,\n} from \"@osdk/shared.net.fetch\";\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype OldSharedClientContext = import(\"@osdk/shared.client\").SharedClientContext;\n\nexport function createSharedClientContext(\n  baseUrl: string,\n  tokenProvider: () => Promise<string>,\n  userAgent: string,\n  fetchFn: typeof globalThis.fetch = fetch,\n): SharedClientContext & OldSharedClientContext {\n  if (baseUrl.length === 0) {\n    throw new Error(\"baseUrl cannot be empty\");\n  }\n\n  const retryingFetchWithAuthOrThrow = createFetchHeaderMutator(\n    createRetryingFetch(createFetchOrThrow(fetchFn)),\n    async (headers) => {\n      const token = await tokenProvider();\n      headers.set(\"Authorization\", `Bearer ${token}`);\n\n      headers.set(\n        \"Fetch-User-Agent\",\n        [\n          headers.get(\"Fetch-User-Agent\"),\n          userAgent,\n        ].filter(x => x && x?.length > 0).join(\" \"),\n      );\n      return headers;\n    },\n  );\n\n  // because this is async await it preserves stack traces, which the retrying fetch does not\n  const fetchWrapper = async (\n    input: RequestInfo | URL,\n    init?: RequestInit | undefined,\n  ) => {\n    try {\n      return await retryingFetchWithAuthOrThrow(input, init);\n    } catch (e: any) {\n      const betterError = (e instanceof PalantirApiError)\n        ? new PalantirApiError(\n          e.message,\n          e.errorName,\n          e.errorCode,\n          e.statusCode,\n          e.errorInstanceId,\n          e.parameters,\n        )\n        : new Error(\"Captured stack trace for error: \" + (e.message ?? e));\n\n      (betterError as any).cause = e;\n      throw betterError;\n    }\n  };\n\n  return {\n    baseUrl,\n    fetch: fetchWrapper,\n    tokenProvider,\n  };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst START_TOKEN = new Uint8Array([123, 34, 100, 97, 116, 97, 34, 58, 91]); // `{\"data\":[`\nconst OBJECT_OPEN_CHAR_CODE = 123; // '{'\nconst OBJECT_CLOSE_CHAR_CODE = 125; // '}'\n\nexport async function* parseStreamedResponse(\n  asyncIterable: AsyncIterable<Uint8Array>,\n): AsyncGenerator<any, void, unknown> {\n  const utf8decoder = new TextDecoder(\"utf-8\");\n\n  let parsedStart = false;\n  let prevChunks: Uint8Array[] = [];\n  let openBracesCount = 0;\n\n  for await (let chunk of asyncIterable) {\n    // on the first chunk, skip the expected START_TOKEN if we see it\n    let i = 0;\n    if (!parsedStart) {\n      parsedStart = true;\n      if (startsWith(chunk, START_TOKEN)) {\n        i = START_TOKEN.length;\n      }\n    }\n\n    for (; i < chunk.length; i++) {\n      // if we aren't currently parsing an object, skip until we find the next object start\n      while (\n        openBracesCount === 0 && chunk[i] !== OBJECT_OPEN_CHAR_CODE\n        && i < chunk.length\n      ) {\n        i++;\n      }\n\n      // iterate through the chunk looking for the end of the current top level object\n      let j = i;\n      for (; j < chunk.length; j++) {\n        const c = chunk[j];\n        if (c === OBJECT_OPEN_CHAR_CODE) {\n          openBracesCount++;\n        } else if (c === OBJECT_CLOSE_CHAR_CODE) {\n          openBracesCount--;\n\n          // found a complete top level object, emit it\n          if (0 === openBracesCount) {\n            yield combineAndParse(\n              utf8decoder,\n              prevChunks,\n              chunk.subarray(i, j + 1),\n            );\n\n            // if there was a prevChunk, we've consumed it now\n            prevChunks = [];\n\n            // advance the start index to the final '}' of the current object,\n            // which lets us start seeking the beginning of the next object\n            i = j;\n            break;\n          }\n        }\n      }\n\n      // if we reached the end of our chunk before finding the end of the object\n      // store off the relevant remainder of our current chunk and go grab the next one\n      if (j === chunk.length) {\n        prevChunks.push(chunk.subarray(i));\n        break;\n      }\n    }\n  }\n}\n\nfunction startsWith(a: Uint8Array, b: Uint8Array) {\n  if (a.length < b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < b.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction combineAndParse(\n  utf8decoder: TextDecoder,\n  prev: Uint8Array[],\n  curr: Uint8Array,\n) {\n  let str = \"\";\n  for (const chunk of prev) {\n    str += utf8decoder.decode(chunk, { stream: true });\n  }\n  str += utf8decoder.decode(curr);\n\n  return JSON.parse(str);\n}\n\nexport async function* iterateReadableStream(\n  readableStream: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array, void, unknown> {\n  let res = await readableStream.read();\n  while (!res.done) {\n    yield res.value;\n    res = await readableStream.read();\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TimeSeriesQuery } from \"@osdk/api\";\nimport { TimeseriesDurationMapping } from \"@osdk/api\";\nimport type { TimeRange } from \"@osdk/foundry.ontologies\";\nimport { iterateReadableStream, parseStreamedResponse } from \"./streamutils.js\";\n\nexport function getTimeRange(body: TimeSeriesQuery): TimeRange {\n  if (\"$startTime\" in body || \"$endTime\" in body) {\n    return {\n      type: \"absolute\",\n      startTime: body.$startTime,\n      endTime: body.$endTime,\n    };\n  }\n  return body.$before\n    ? {\n      type: \"relative\",\n      startTime: {\n        when: \"BEFORE\",\n        value: body.$before,\n        unit: TimeseriesDurationMapping[body.$unit],\n      },\n    }\n    : {\n      type: \"relative\",\n      endTime: {\n        when: \"AFTER\",\n        value: body.$after!,\n        unit: TimeseriesDurationMapping[body.$unit],\n      },\n    };\n}\n\nexport async function* asyncIterPointsHelper<\n  T extends number | string | GeoJSON.Point,\n>(\n  iterator: Response,\n): AsyncGenerator<\n  {\n    time: any;\n    value: T;\n  },\n  void,\n  unknown\n> {\n  const reader = iterator.body?.getReader()!;\n  for await (\n    const point of parseStreamedResponse(iterateReadableStream(reader))\n  ) {\n    yield {\n      time: point.time,\n      value: point.value as T,\n    };\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  GeotimeSeriesProperty,\n  TimeSeriesPoint,\n  TimeSeriesQuery,\n} from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\nimport { asyncIterPointsHelper, getTimeRange } from \"./util/timeseriesUtils.js\";\n\nexport class GeotimeSeriesPropertyImpl<T extends GeoJSON.Point>\n  implements GeotimeSeriesProperty<T>\n{\n  #triplet: [string, any, string];\n  #client: MinimalClient;\n  lastFetchedValue: TimeSeriesPoint<T> | undefined;\n\n  constructor(\n    client: MinimalClient,\n    objectApiName: string,\n    primaryKey: any,\n    propertyName: string,\n    initialValue?: TimeSeriesPoint<T>,\n  ) {\n    this.#client = client;\n    this.#triplet = [objectApiName, primaryKey, propertyName];\n    if (initialValue != null) {\n      this.lastFetchedValue = initialValue;\n    }\n  }\n\n  public async getLatestValue(): Promise<TimeSeriesPoint<T> | undefined> {\n    const latestPointPromise = OntologiesV2.TimeSeriesValueBankProperties\n      .getLatestValue(\n        this.#client,\n        await this.#client.ontologyRid,\n        ...this.#triplet,\n      );\n    latestPointPromise.then(\n      latestPoint => this.lastFetchedValue = latestPoint,\n      // eslint-disable-next-line no-console\n      err => void console.error(err),\n    );\n    return latestPointPromise;\n  }\n\n  public async getAllValues(\n    query?: TimeSeriesQuery,\n  ): Promise<TimeSeriesPoint<T>[]> {\n    const allPoints: Array<TimeSeriesPoint<T>> = [];\n\n    for await (const point of this.asyncIterValues(query)) {\n      allPoints.push(point);\n    }\n    return allPoints;\n  }\n\n  public async *asyncIterValues(\n    query?: TimeSeriesQuery,\n  ): AsyncGenerator<\n    {\n      time: any;\n      value: T;\n    },\n    void,\n    unknown\n  > {\n    const streamPointsIterator = await OntologiesV2\n      .TimeSeriesValueBankProperties.streamValues(\n        this.#client,\n        await this.#client.ontologyRid,\n        ...this.#triplet,\n        query ? { range: getTimeRange(query) } : {},\n      );\n\n    for await (\n      const timeseriesPoint of asyncIterPointsHelper<T>(streamPointsIterator)\n    ) {\n      yield timeseriesPoint;\n    }\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Media, MediaMetadata, MediaReference } from \"@osdk/api\";\nimport type { MediaReference as CoreMediaReference } from \"@osdk/foundry.core\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\n\nexport class MediaReferencePropertyImpl implements Media {\n  #mediaReference: MediaReference;\n  #triplet: [string, any, string];\n  #client: MinimalClient;\n\n  constructor(args: {\n    client: MinimalClient;\n    objectApiName: string;\n    primaryKey: any;\n    propertyName: string;\n    mediaReference: CoreMediaReference;\n  }) {\n    const {\n      client,\n      objectApiName,\n      primaryKey,\n      propertyName,\n      mediaReference,\n    } = args;\n    this.#client = client;\n    this.#triplet = [objectApiName, primaryKey, propertyName];\n    this.#mediaReference = mediaReference;\n  }\n\n  public async fetchContents(): Promise<Response> {\n    return OntologiesV2.MediaReferenceProperties.getMediaContent(\n      this.#client,\n      await this.#client.ontologyRid,\n      ...this.#triplet,\n      {\n        preview: true, // TODO: Can turn this back off when backend is no longer in beta.\n      },\n    );\n  }\n\n  public async fetchMetadata(): Promise<MediaMetadata> {\n    const r = await OntologiesV2.MediaReferenceProperties.getMediaMetadata(\n      this.#client,\n      await this.#client.ontologyRid,\n      ...this.#triplet,\n      {\n        preview: true, // TODO: Can turn this back off when backend is no longer in beta.\n      },\n    );\n    return {\n      path: r.path as string,\n      sizeBytes: Number(r.sizeBytes),\n      mediaType: r.mediaType,\n    };\n  }\n\n  public getMediaReference(): MediaReference {\n    return this.#mediaReference;\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  TimeSeriesPoint,\n  TimeSeriesProperty,\n  TimeSeriesQuery,\n} from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\nimport { asyncIterPointsHelper, getTimeRange } from \"./util/timeseriesUtils.js\";\n\nexport class TimeSeriesPropertyImpl<T extends number | string>\n  implements TimeSeriesProperty<T>\n{\n  #triplet: [string, any, string];\n  #client: MinimalClient;\n\n  constructor(\n    client: MinimalClient,\n    objectApiName: string,\n    primaryKey: any,\n    propertyName: string,\n  ) {\n    this.#client = client;\n    this.#triplet = [objectApiName, primaryKey, propertyName];\n  }\n\n  public async getFirstPoint(): Promise<TimeSeriesPoint<T>> {\n    return OntologiesV2.TimeSeriesPropertiesV2.getFirstPoint(\n      this.#client,\n      await this.#client.ontologyRid,\n      ...this.#triplet,\n    ) as Promise<TimeSeriesPoint<T>>;\n  }\n\n  public async getLastPoint(): Promise<TimeSeriesPoint<T>> {\n    return OntologiesV2.TimeSeriesPropertiesV2.getLastPoint(\n      this.#client,\n      await this.#client.ontologyRid,\n      ...this.#triplet,\n    ) as Promise<TimeSeriesPoint<T>>;\n  }\n\n  public async getAllPoints(\n    query?: TimeSeriesQuery,\n  ): Promise<TimeSeriesPoint<T>[]> {\n    const allPoints: Array<TimeSeriesPoint<T>> = [];\n\n    for await (const point of this.asyncIterPoints(query)) {\n      allPoints.push(point);\n    }\n    return allPoints;\n  }\n\n  public async *asyncIterPoints(\n    query?: TimeSeriesQuery,\n  ): AsyncGenerator<\n    {\n      time: any;\n      value: T;\n    },\n    void,\n    unknown\n  > {\n    const streamPointsIterator = await OntologiesV2.TimeSeriesPropertiesV2\n      .streamPoints(\n        this.#client,\n        await this.#client.ontologyRid,\n        ...this.#triplet,\n        query ? { range: getTimeRange(query) } : {},\n      );\n\n    for await (\n      const timeseriesPoint of asyncIterPointsHelper<T>(streamPointsIterator)\n    ) {\n      yield timeseriesPoint;\n    }\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Attachment } from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport { additionalContext, type Client } from \"../Client.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\n/**\n * Helper function to create an attachment type from a rid\n * @param client -  An OSDK client.\n * @param rid - The rid of attachment in Foundry.\n * @returns An OSDK attachment object\n */\nexport function hydrateAttachmentFromRid(\n  client: Client,\n  rid: string,\n): Attachment {\n  return hydrateAttachmentFromRidInternal(client[additionalContext], rid);\n}\n\n/** @internal */\nexport function hydrateAttachmentFromRidInternal(\n  client: MinimalClient,\n  rid: string,\n): Attachment {\n  return {\n    rid,\n    async fetchContents() {\n      return OntologiesV2.Attachments.read(client, rid);\n    },\n    async fetchMetadata() {\n      const r = await OntologiesV2.Attachments.get(client, rid);\n      return {\n        ...r,\n        sizeBytes: Number(r.sizeBytes),\n      };\n    },\n  };\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ObjectSpecifier,\n  ObjectTypeDefinition,\n  PrimaryKeyType,\n} from \"@osdk/api\";\n\n/**\n * Creates an Object Specifier. An ObjectSpecifier is a string that uniquely identifies an object in the system,\n * even when loading an interface object where primary key uniqueness is not guaranteed.\n *\n * @param objectDef - An Object Type Definition\n * @param primaryKey - The value you want to use as the primary key\n * @returns An Object Specifier\n */\nexport function createObjectSpecifierFromPrimaryKey<\n  Q extends ObjectTypeDefinition,\n>(objectDef: Q, primaryKey: PrimaryKeyType<Q>): ObjectSpecifier<Q> {\n  return `${objectDef.apiName}:${primaryKey}` as ObjectSpecifier<Q>;\n}\n\n/**\n * Extracts the primary key from an ObjectSpecifier on an OSDK object.\n *\n * @param ObjectSpecifier\n * @returns A string representing the primary key\n */\nexport function extractPrimaryKeyFromObjectSpecifier(\n  ObjectSpecifier: ObjectSpecifier<any>,\n): string {\n  return ObjectSpecifier.split(\":\")[1];\n}\n\n/**\n * Extracts the object type from an ObjectSpecifier on an OSDK object.\n *\n * @param ObjectSpecifier\n * @returns The object type extracted from the ObjectSpecifier\n */\nexport function extractObjectTypeFromObjectSpecifier(\n  ObjectSpecifier: ObjectSpecifier<any>,\n): string {\n  return ObjectSpecifier.split(\":\")[0];\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionMetadata,\n  InterfaceMetadata,\n  ObjectMetadata,\n  QueryMetadata,\n} from \"@osdk/api\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport const InterfaceDefinitions: unique symbol = Symbol(\n  process.env.MODE !== \"production\" ? \"InterfaceDefinitions\" : undefined,\n);\n\nexport interface FetchedObjectTypeDefinition extends ObjectMetadata {\n  // we keep this here so we can depend on these synchronously\n  [InterfaceDefinitions]: {\n    [key: string]: { def: InterfaceMetadata };\n  };\n}\n\nexport interface OntologyProvider {\n  /**\n   * Returns the current known definition for the object.\n   *\n   * May result in multiple network calls. May cache results. May invalidate results\n   * @param apiName\n   * @returns\n   */\n  getObjectDefinition: (\n    apiName: string,\n  ) => Promise<FetchedObjectTypeDefinition>;\n\n  /**\n   * Returns the current known definition for the interface.\n   *\n   * May result in multiple network calls. May cache results. May invalidate results\n   * @param apiName\n   * @returns\n   */\n  getInterfaceDefinition: (\n    apiName: string,\n  ) => Promise<InterfaceMetadata>;\n\n  getQueryDefinition: (\n    apiName: string,\n    version: string | undefined,\n  ) => Promise<QueryMetadata>;\n\n  getActionDefinition: (apiName: string) => Promise<ActionMetadata>;\n}\n\nexport type OntologyProviderFactory<\n  T extends OntologyProvider = OntologyProvider,\n> = (\n  client: MinimalClient,\n) => T;\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectOrInterfaceDefinition, OsdkBase } from \"@osdk/api\";\n\n/** @internal */\nexport const UnderlyingOsdkObject = Symbol(\n  process.env.MODE !== \"production\" ? \"Underlying Object\" : undefined,\n);\n\n/** @internal */\nexport const ObjectDefRef = Symbol(\n  process.env.MODE !== \"production\" ? \"ObjectDefinition\" : undefined,\n);\n\n/** @internal */\nexport const InterfaceDefRef = Symbol(\n  process.env.MODE !== \"production\" ? \"InterfaceDefinition\" : undefined,\n);\n\n/** @internal */\nexport const ClientRef = Symbol(\n  process.env.MODE !== \"production\" ? \"ClientRef\" : undefined,\n);\n\nexport interface HolderBase<T extends ObjectOrInterfaceDefinition> {\n  [UnderlyingOsdkObject]: OsdkBase<any>;\n  [ObjectDefRef]?: T;\n  [InterfaceDefRef]?: T;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { InterfaceMetadata } from \"@osdk/api\";\nimport { extractNamespace } from \"../../internal/conversions/modernToLegacyWhereClause.js\";\nimport type { FetchedObjectTypeDefinition } from \"../../ontology/OntologyProvider.js\";\nimport type { InterfaceHolder } from \"./InterfaceHolder.js\";\nimport {\n  InterfaceDefRef,\n  ObjectDefRef,\n  UnderlyingOsdkObject,\n} from \"./InternalSymbols.js\";\nimport type { ObjectHolder } from \"./ObjectHolder.js\";\n\n/** @internal */\nexport function createOsdkInterface<\n  Q extends FetchedObjectTypeDefinition,\n>(\n  underlying: ObjectHolder,\n  interfaceDef: InterfaceMetadata,\n): InterfaceHolder {\n  const [objApiNamespace] = extractNamespace(interfaceDef.apiName);\n\n  return Object.freeze(\n    Object.defineProperties({}, {\n      // first to minimize hidden classes\n      [UnderlyingOsdkObject]: { value: underlying },\n\n      \"$apiName\": { value: interfaceDef.apiName, enumerable: true },\n      \"$as\": {\n        value: underlying.$as,\n        enumerable: false,\n      },\n      \"$objectType\": {\n        value: underlying.$objectType,\n        enumerable: \"$objectType\" in underlying,\n      },\n      \"$primaryKey\": {\n        value: underlying.$primaryKey,\n        enumerable: \"$primaryKey\" in underlying,\n      },\n      \"$objectSpecifier\": {\n        value: underlying.$objectSpecifier,\n        enumerable: \"$objectSpecifier\" in underlying,\n      },\n      \"$title\": {\n        value: underlying.$title,\n        enumerable: \"$title\" in underlying,\n      },\n      \"$rid\": {\n        value: (underlying as any).$rid,\n        enumerable: \"$rid\" in underlying,\n      },\n      \"$clone\": {\n        value: clone,\n        enumerable: false,\n      },\n\n      [InterfaceDefRef]: { value: interfaceDef },\n\n      ...Object.fromEntries(\n        Object.keys(interfaceDef.properties).map(p => {\n          const objDef = underlying[ObjectDefRef];\n\n          const [apiNamespace, apiName] = extractNamespace(p);\n\n          const targetPropName = objDef\n            .interfaceMap![interfaceDef.apiName][p];\n\n          return [apiNamespace === objApiNamespace ? apiName : p, {\n            enumerable: targetPropName in underlying,\n            value: underlying[targetPropName as keyof typeof underlying],\n          }];\n        }),\n      ),\n    }) as InterfaceHolder,\n  );\n  function clone(update: Record<string, any> | undefined) {\n    if (update == null) {\n      return underlying.$clone().$as(interfaceDef);\n    }\n\n    for (const key of Object.keys(update)) {\n      if (!(key in interfaceDef.properties)) {\n        throw new Error(\n          `Invalid property ${key} for interface ${interfaceDef.apiName}`,\n        );\n      }\n    }\n\n    const remappedProps = Object.fromEntries(\n      Object.keys(update).map(p => mapProperty(p, update[p])).filter(x =>\n        x != null\n      ),\n    );\n\n    return underlying.$clone(remappedProps).$as(interfaceDef);\n  }\n  function mapProperty(propertyName: string, value: any) {\n    const objDef = underlying[ObjectDefRef];\n    const targetPropName =\n      objDef.interfaceMap![interfaceDef.apiName][propertyName];\n    // If the underlying object does not implement the SPT, throw errors\n    if (targetPropName == null) {\n      throw new Error(\n        `Cannot clone interface with ${propertyName} as property is not implemented by the underlying object type ${objDef.apiName}`,\n      );\n    }\n    return [targetPropName, value];\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectOrInterfaceDefinition, OsdkBase } from \"@osdk/api\";\nimport {\n  type FetchedObjectTypeDefinition,\n  InterfaceDefinitions,\n} from \"../../ontology/OntologyProvider.js\";\nimport { createSimpleCache } from \"../SimpleCache.js\";\nimport { createOsdkInterface } from \"./createOsdkInterface.js\";\nimport type { InterfaceHolder } from \"./InterfaceHolder.js\";\nimport { UnderlyingOsdkObject } from \"./InternalSymbols.js\";\nimport type { ObjectHolder } from \"./ObjectHolder.js\";\n\n/** @internal */\nexport type DollarAsFn = <\n  Q extends FetchedObjectTypeDefinition,\n  NEW_Q extends ObjectOrInterfaceDefinition,\n>(\n  this: InterfaceHolder | ObjectHolder,\n  newDef: string | NEW_Q,\n) => OsdkBase<any>;\n\nexport const get$as: (key: FetchedObjectTypeDefinition) => DollarAsFn =\n  createSimpleCache<\n    FetchedObjectTypeDefinition,\n    DollarAsFn\n  >(new WeakMap(), $asFactory).get;\n\nconst osdkObjectToInterfaceView = createSimpleCache(\n  new WeakMap<\n    OsdkBase<any>,\n    Map<string, WeakRef<OsdkBase<any>>>\n  >(),\n  () =>\n    new Map<\n      /* interface api name */ string,\n      /* $as'd object */ WeakRef<OsdkBase<any>>\n    >(),\n);\n\nfunction $asFactory(\n  objDef: FetchedObjectTypeDefinition,\n): DollarAsFn {\n  // We use the exact same logic for both the interface rep and the underlying rep\n\n  return function $as<\n    NEW_Q extends ObjectOrInterfaceDefinition,\n  >(\n    this: OsdkBase<any> & { [UnderlyingOsdkObject]: any },\n    targetMinDef: NEW_Q | string,\n  ): OsdkBase<any> {\n    let targetInterfaceApiName: string;\n\n    if (typeof targetMinDef === \"string\") {\n      if (targetMinDef === objDef.apiName) {\n        return this[UnderlyingOsdkObject];\n      }\n\n      // this is sufficient to determine if we implement the interface\n      if (objDef.interfaceMap?.[targetMinDef] == null) {\n        throw new Error(\n          `Object does not implement interface '${targetMinDef}'.`,\n        );\n      }\n\n      targetInterfaceApiName = targetMinDef;\n    } else if (targetMinDef.apiName === objDef.apiName) {\n      return this[UnderlyingOsdkObject];\n    } else {\n      if (targetMinDef.type === \"object\") {\n        throw new Error(\n          `'${targetMinDef.apiName}' is not an interface nor is it '${objDef.apiName}', which is the object type.`,\n        );\n      }\n      targetInterfaceApiName = targetMinDef.apiName;\n    }\n\n    const def = objDef[InterfaceDefinitions][targetInterfaceApiName];\n    if (!def) {\n      throw new Error(\n        `Object does not implement interface '${targetInterfaceApiName}'.`,\n      );\n    }\n\n    const underlying = this[UnderlyingOsdkObject];\n\n    const existing = osdkObjectToInterfaceView\n      .get(underlying)\n      .get(targetInterfaceApiName)?.deref();\n    if (existing) return existing;\n\n    const osdkInterface = createOsdkInterface(underlying, def.def);\n    osdkObjectToInterfaceView.get(underlying).set(\n      targetInterfaceApiName,\n      new WeakRef(osdkInterface),\n    );\n    return osdkInterface;\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ObjectSet,\n  OsdkObjectLinksObject,\n  SelectArg,\n  SingleLinkAccessor,\n  WhereClause,\n} from \"@osdk/api\";\nimport { getWireObjectSet } from \"../../objectSet/createObjectSet.js\";\nimport { fetchSingle, fetchSingleWithErrors } from \"../fetchSingle.js\";\nimport {\n  ClientRef,\n  ObjectDefRef,\n  UnderlyingOsdkObject,\n} from \"./InternalSymbols.js\";\nimport type { ObjectHolder } from \"./ObjectHolder.js\";\n\n/** @internal */\nexport function get$link(\n  holder: ObjectHolder,\n): OsdkObjectLinksObject<any> {\n  const client = holder[ClientRef];\n  const objDef = holder[ObjectDefRef];\n  const rawObj = holder[UnderlyingOsdkObject];\n  return Object.freeze(Object.fromEntries(\n    Object.keys(objDef.links).map(\n      (linkName) => {\n        const linkDef = objDef.links[linkName as keyof typeof objDef.links];\n        const objectSet =\n          (client.objectSetFactory(objDef, client) as ObjectSet<any>)\n            .where({\n              [objDef.primaryKeyApiName]: rawObj.$primaryKey,\n            } as WhereClause<any>)\n            .pivotTo(linkName);\n\n        const value = !linkDef.multiplicity\n          ? {\n            fetchOne: <A extends SelectArg<any, any, any, any>>(\n              options?: A,\n            ) =>\n              fetchSingle(\n                client,\n                objDef,\n                options ?? {},\n                getWireObjectSet(objectSet),\n              ),\n            fetchOneWithErrors: <A extends SelectArg<any, any, any, any>>(\n              options?: A,\n            ) =>\n              fetchSingleWithErrors(\n                client,\n                objDef,\n                options ?? {},\n                getWireObjectSet(objectSet),\n              ),\n          } as SingleLinkAccessor<any>\n          : objectSet;\n\n        return [linkName, value];\n      },\n    ),\n  ));\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { MediaReference } from \"@osdk/foundry.core\";\nimport type { Attachment, ReferenceValue } from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport { GeotimeSeriesPropertyImpl } from \"../../createGeotimeSeriesProperty.js\";\nimport { MediaReferencePropertyImpl } from \"../../createMediaReferenceProperty.js\";\nimport { TimeSeriesPropertyImpl } from \"../../createTimeseriesProperty.js\";\nimport type { DerivedPropertyRuntimeMetadata } from \"../../derivedProperties/derivedPropertyRuntimeMetadata.js\";\nimport type { MinimalClient } from \"../../MinimalClientContext.js\";\nimport type { FetchedObjectTypeDefinition } from \"../../ontology/OntologyProvider.js\";\nimport { hydrateAttachmentFromRidInternal } from \"../../public-utils/hydrateAttachmentFromRid.js\";\nimport { createObjectSpecifierFromPrimaryKey } from \"../../util/objectSpecifierUtils.js\";\nimport type { SimpleOsdkProperties } from \"../SimpleOsdkProperties.js\";\nimport { get$as } from \"./getDollarAs.js\";\nimport { get$link } from \"./getDollarLink.js\";\nimport {\n  ClientRef,\n  ObjectDefRef,\n  UnderlyingOsdkObject,\n} from \"./InternalSymbols.js\";\nimport type { ObjectHolder } from \"./ObjectHolder.js\";\n\nconst specialPropertyTypes = new Set(\n  [\n    \"attachment\",\n    \"geotimeSeriesReference\",\n    \"mediaReference\",\n    \"numericTimeseries\",\n    \"stringTimeseries\",\n    \"sensorTimeseries\",\n  ],\n);\n\n// kept separate so we are not redefining these functions\n// every time an object is created.\nconst basePropDefs = {\n  \"$as\": {\n    get: function(this: ObjectHolder) {\n      return get$as(this[ObjectDefRef]);\n    },\n  },\n  \"$link\": {\n    get: function(this: ObjectHolder) {\n      return get$link(this);\n    },\n  },\n  \"$clone\": {\n    value: function(\n      this: ObjectHolder,\n      update: Record<string, any> | undefined,\n    ) {\n      // I think `rawObj` is the same thing as `this` and can be removed?\n      const rawObj = this[UnderlyingOsdkObject] as SimpleOsdkProperties;\n      const def = this[ObjectDefRef];\n\n      if (update == null) {\n        return createOsdkObject(this[ClientRef], def, { ...rawObj });\n      }\n\n      if (\n        def.primaryKeyApiName in update\n        && rawObj[def.primaryKeyApiName] !== update[def.primaryKeyApiName]\n      ) {\n        throw new Error(\n          `Cannot update ${def.apiName} object with differing primary key values `,\n        );\n      }\n\n      if (def.titleProperty in update && !(\"$title\" in update)) {\n        update.$title = update[def.titleProperty];\n      }\n\n      const newObject = { ...this[UnderlyingOsdkObject], ...update };\n      return createOsdkObject(this[ClientRef], this[ObjectDefRef], newObject);\n    },\n  },\n  \"$objectSpecifier\": {\n    get: function(this: ObjectHolder) {\n      const rawObj = this[UnderlyingOsdkObject];\n      return createObjectSpecifierFromPrimaryKey(\n        this[ObjectDefRef],\n        rawObj.$primaryKey,\n      );\n    },\n    enumerable: true,\n  },\n};\n\n/**\n * @internal\n * @param client\n * @param objectDef\n * @param simpleOsdkProperties\n */\nexport function createOsdkObject(\n  client: MinimalClient,\n  objectDef: FetchedObjectTypeDefinition,\n  simpleOsdkProperties: SimpleOsdkProperties,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata = {},\n): ObjectHolder {\n  // updates the object's \"hidden class/map\".\n  const rawObj = simpleOsdkProperties as ObjectHolder;\n  Object.defineProperties(\n    rawObj,\n    {\n      [UnderlyingOsdkObject]: {\n        enumerable: false,\n        value: simpleOsdkProperties,\n      },\n      [ObjectDefRef]: { value: objectDef, enumerable: false },\n      [ClientRef]: { value: client, enumerable: false },\n      ...basePropDefs,\n    } satisfies Record<keyof ObjectHolder, PropertyDescriptor>,\n  );\n\n  // Assign the special values\n  for (const propKey of Object.keys(rawObj)) {\n    if (\n      propKey in objectDef.properties\n      && typeof (objectDef.properties[propKey].type) === \"string\"\n      && specialPropertyTypes.has(objectDef.properties[propKey].type)\n    ) {\n      rawObj[propKey] = createSpecialProperty(\n        client,\n        objectDef,\n        rawObj,\n        propKey,\n      );\n    } else if (propKey in derivedPropertyTypeByName) {\n      rawObj[propKey] = modifyRdpProperties(\n        client,\n        derivedPropertyTypeByName,\n        rawObj[propKey],\n        propKey,\n      );\n    }\n  }\n\n  return Object.freeze(rawObj);\n}\n\nfunction modifyRdpProperties(\n  client: MinimalClient,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata,\n  rawValue: any,\n  propKey: string,\n): any {\n  if (\n    derivedPropertyTypeByName[propKey].definition.type === \"selection\"\n    && derivedPropertyTypeByName[propKey].definition.operation.type\n      === \"count\"\n  ) {\n    const num = Number(rawValue);\n    invariant(\n      Number.isSafeInteger(num),\n      \"Count aggregation for derived property \" + propKey\n        + \" returned a value larger than safe integer.\",\n    );\n    return num;\n  } // Selected or collected properties need to be deserialized specially when constructed with RDP\n  else if (\n    derivedPropertyTypeByName[propKey].selectedOrCollectedPropertyType\n      != null\n    && typeof (derivedPropertyTypeByName[propKey]\n        .selectedOrCollectedPropertyType.type)\n      === \"string\"\n    && specialPropertyTypes.has(\n      derivedPropertyTypeByName[propKey].selectedOrCollectedPropertyType\n        .type,\n    )\n  ) {\n    switch (\n      derivedPropertyTypeByName[propKey].selectedOrCollectedPropertyType\n        ?.type\n    ) {\n      case \"attachment\":\n        if (Array.isArray(rawValue)) {\n          return rawValue.map(a =>\n            hydrateAttachmentFromRidInternal(client, a.rid)\n          );\n        } else {\n          return hydrateAttachmentFromRidInternal(\n            client,\n            (rawValue as Attachment).rid,\n          );\n        }\n        break;\n      default:\n        invariant(\n          false,\n          \"Derived property aggregations for Timeseries and Media are not supported\",\n        );\n    }\n  }\n  return rawValue;\n}\n\nfunction createSpecialProperty(\n  client: MinimalClient,\n  objectDef: FetchedObjectTypeDefinition,\n  rawObject: ObjectHolder,\n  p: keyof typeof rawObject & string | symbol,\n) {\n  const rawValue = rawObject[p as any];\n  const propDef = objectDef.properties[p as any];\n  if (process.env.NODE_ENV !== \"production\") {\n    invariant(\n      propDef != null && typeof propDef.type === \"string\"\n        && specialPropertyTypes.has(propDef.type),\n    );\n  }\n  if (propDef.type === \"attachment\") {\n    if (Array.isArray(rawValue)) {\n      return rawValue.map(a => hydrateAttachmentFromRidInternal(client, a.rid));\n    }\n    return hydrateAttachmentFromRidInternal(\n      client,\n      (rawValue as Attachment).rid,\n    );\n  }\n\n  if (\n    propDef.type === \"numericTimeseries\"\n    || propDef.type === \"stringTimeseries\"\n    || propDef.type === \"sensorTimeseries\"\n  ) {\n    return new TimeSeriesPropertyImpl<\n      (typeof propDef)[\"type\"] extends \"numericTimeseries\" ? number\n        : (typeof propDef)[\"type\"] extends \"stringTimeseries\" ? string\n        : number | string\n    >(\n      client,\n      objectDef.apiName,\n      rawObject[objectDef.primaryKeyApiName as string],\n      p as string,\n    );\n  }\n\n  if (propDef.type === \"geotimeSeriesReference\") {\n    return new GeotimeSeriesPropertyImpl<GeoJSON.Point>(\n      client,\n      objectDef.apiName,\n      rawObject[objectDef.primaryKeyApiName as string],\n      p as string,\n      (rawValue as ReferenceValue).type === \"geotimeSeriesValue\"\n        ? {\n          time: (rawValue as ReferenceValue).timestamp,\n          value: {\n            type: \"Point\",\n            coordinates: (rawValue as ReferenceValue).position,\n          },\n        }\n        : undefined,\n    );\n  }\n  if (propDef.type === \"mediaReference\") {\n    return new MediaReferencePropertyImpl({\n      client,\n      objectApiName: objectDef.apiName,\n      primaryKey: rawObject[objectDef.primaryKeyApiName as string],\n      propertyName: p as string,\n      mediaReference: rawValue as MediaReference,\n    });\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  InterfaceMetadata,\n  NullabilityAdherence,\n  ObjectMetadata,\n} from \"@osdk/api\";\nimport type {\n  InterfaceToObjectTypeMappings,\n  InterfaceTypeApiName,\n  OntologyObjectV2,\n} from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport type { DerivedPropertyRuntimeMetadata } from \"../derivedProperties/derivedPropertyRuntimeMetadata.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport {\n  type FetchedObjectTypeDefinition,\n} from \"../ontology/OntologyProvider.js\";\nimport { createOsdkObject } from \"./convertWireToOsdkObjects/createOsdkObject.js\";\nimport type { InterfaceHolder } from \"./convertWireToOsdkObjects/InterfaceHolder.js\";\nimport type { ObjectHolder } from \"./convertWireToOsdkObjects/ObjectHolder.js\";\nimport type { SimpleOsdkProperties } from \"./SimpleOsdkProperties.js\";\n\n/**\n * If interfaceApiName is not undefined, converts the instances of the\n * interface into their respective\n * underlying concrete types and then returns the $as() representation\n * for the consumers.\n *\n * Otherwise just does the conversion\n *\n * May mutate in place for performance reasons. If you need a clean copy,\n * keep it first.\n *\n * However, you must use the returned value, which will be whatever is correct.\n *\n * @internal\n * @param interfaceApiName - if undefined\n */\nexport async function convertWireToOsdkObjects(\n  client: MinimalClient,\n  objects: OntologyObjectV2[],\n  interfaceApiName: string | undefined,\n  forceRemoveRid: boolean = false,\n  derivedPropertyTypesByName: DerivedPropertyRuntimeMetadata,\n  selectedProps?: ReadonlyArray<string>,\n  strictNonNull: NullabilityAdherence = false,\n): Promise<Array<ObjectHolder | InterfaceHolder>> {\n  // remove the __ prefixed properties and convert them to $ prefixed.\n  // updates in place\n  fixObjectPropertiesInPlace(objects, forceRemoveRid);\n\n  const ifaceDef = interfaceApiName\n    ? await client.ontologyProvider.getInterfaceDefinition(interfaceApiName)\n    : undefined;\n  const ifaceSelected = ifaceDef\n    ? (selectedProps ?? Object.keys(ifaceDef.properties))\n    : undefined;\n\n  const ret = [];\n  for (const rawObj of objects) {\n    const objectDef = await client.ontologyProvider.getObjectDefinition(\n      rawObj.$apiName,\n    );\n    invariant(objectDef, `Missing definition for '${rawObj.$apiName}'`);\n\n    // default value for when we are checking an object\n    let objProps;\n\n    let conforming = true;\n    if (ifaceDef && ifaceSelected) {\n      // API returns interface spt names but we cache by real values\n      invariantInterfacesAsViews(objectDef, ifaceDef.apiName, client);\n\n      conforming &&= isConforming(client, ifaceDef, rawObj, ifaceSelected);\n\n      reframeAsObjectInPlace(objectDef, ifaceDef.apiName, rawObj);\n\n      objProps = convertInterfacePropNamesToObjectPropNames(\n        objectDef,\n        ifaceDef.apiName,\n        ifaceSelected,\n      );\n    } else {\n      objProps = selectedProps ?? Object.keys(objectDef.properties);\n    }\n\n    conforming &&= isConforming(client, objectDef, rawObj, objProps);\n\n    if (strictNonNull === \"throw\" && !conforming) {\n      throw new Error(\n        \"Unable to safely convert objects as some non nullable properties are null\",\n      );\n    } else if (strictNonNull === \"drop\" && !conforming) {\n      continue;\n    }\n\n    let osdkObject: ObjectHolder | InterfaceHolder = createOsdkObject(\n      client,\n      objectDef,\n      rawObj,\n      derivedPropertyTypesByName,\n    );\n    if (interfaceApiName) osdkObject = osdkObject.$as(interfaceApiName);\n\n    ret.push(osdkObject);\n  }\n\n  return ret;\n}\n\nexport async function convertWireToOsdkObjects2(\n  client: MinimalClient,\n  objects: OntologyObjectV2[],\n  interfaceApiName: string,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata,\n  forceRemoveRid?: boolean,\n  selectedProps?: ReadonlyArray<string>,\n  strictNonNull?: NullabilityAdherence,\n  interfaceToObjectTypeMappings?: Record<\n    InterfaceTypeApiName,\n    InterfaceToObjectTypeMappings\n  >,\n): Promise<Array<InterfaceHolder>>;\nexport async function convertWireToOsdkObjects2(\n  client: MinimalClient,\n  objects: OntologyObjectV2[],\n  interfaceApiName: undefined,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata,\n  forceRemoveRid?: boolean,\n  selectedProps?: ReadonlyArray<string>,\n  strictNonNull?: NullabilityAdherence,\n  interfaceToObjectTypeMappings?: Record<\n    InterfaceTypeApiName,\n    InterfaceToObjectTypeMappings\n  >,\n): Promise<Array<ObjectHolder>>;\nexport async function convertWireToOsdkObjects2(\n  client: MinimalClient,\n  objects: OntologyObjectV2[],\n  interfaceApiName: string | undefined,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata,\n  forceRemoveRid?: boolean,\n  selectedProps?: ReadonlyArray<string>,\n  strictNonNull?: NullabilityAdherence,\n  interfaceToObjectTypeMappings?: Record<\n    InterfaceTypeApiName,\n    InterfaceToObjectTypeMappings\n  >,\n): Promise<Array<ObjectHolder | InterfaceHolder>>;\n/**\n * @internal\n */\nexport async function convertWireToOsdkObjects2(\n  client: MinimalClient,\n  objects: OntologyObjectV2[],\n  interfaceApiName: string | undefined,\n  derivedPropertyTypeByName: DerivedPropertyRuntimeMetadata,\n  forceRemoveRid: boolean = false,\n  selectedProps?: ReadonlyArray<string>,\n  strictNonNull: NullabilityAdherence = false,\n  interfaceToObjectTypeMappings: Record<\n    InterfaceTypeApiName,\n    InterfaceToObjectTypeMappings\n  > = {},\n): Promise<Array<ObjectHolder | InterfaceHolder>> {\n  fixObjectPropertiesInPlace(objects, forceRemoveRid);\n\n  const ret = [];\n  for (const rawObj of objects) {\n    const objectDef = await client.ontologyProvider.getObjectDefinition(\n      rawObj.$apiName,\n    );\n    invariant(objectDef, `Missing definition for '${rawObj.$apiName}'`);\n\n    const interfaceToObjMapping = interfaceApiName\n      ? interfaceToObjectTypeMappings[interfaceApiName as InterfaceTypeApiName][\n        rawObj.$apiName\n      ]\n      : undefined;\n\n    const ifaceSelected = interfaceApiName && interfaceToObjMapping\n      ? (selectedProps\n        ? Object.keys(interfaceToObjMapping).filter(\n          val => {\n            selectedProps?.includes(interfaceToObjMapping[val]);\n          },\n        )\n        : [\n          ...Object.values(interfaceToObjMapping),\n          objectDef.primaryKeyApiName,\n        ])\n      : undefined;\n\n    // default value for when we are checking an object\n    let objProps;\n\n    let conforming = true;\n    if (interfaceApiName && ifaceSelected) {\n      invariantInterfacesAsViews(objectDef, interfaceApiName, client);\n\n      objProps = ifaceSelected;\n    } else {\n      objProps = selectedProps ?? Object.keys(objectDef.properties);\n    }\n\n    conforming &&= isConforming(client, objectDef, rawObj, objProps);\n\n    if (strictNonNull === \"throw\" && !conforming) {\n      throw new Error(\n        \"Unable to safely convert objects as some non nullable properties are null\",\n      );\n    } else if (strictNonNull === \"drop\" && !conforming) {\n      continue;\n    }\n\n    let osdkObject: ObjectHolder | InterfaceHolder = createOsdkObject(\n      client,\n      objectDef,\n      rawObj,\n      derivedPropertyTypeByName,\n    );\n    if (interfaceApiName) osdkObject = osdkObject.$as(interfaceApiName);\n\n    ret.push(osdkObject);\n  }\n\n  return ret;\n}\n\n/**\n * @internal\n *\n * Utility function that lets us take down selected property names from an interface\n * and convert them to an array of property names on an object.\n */\nexport function convertInterfacePropNamesToObjectPropNames(\n  objectDef: FetchedObjectTypeDefinition,\n  interfaceApiName: string,\n  ifacePropsToMap: readonly string[],\n): string[] {\n  return ifacePropsToMap.map((ifaceProp) =>\n    objectDef.interfaceMap[interfaceApiName][ifaceProp]\n  );\n}\n\n/**\n * Takes a raw object from the wire (contextually as an interface) and\n * updates the fields to reflect the underlying objectDef instead\n * @param objectDef\n * @param interfaceApiName\n * @param client\n * @param rawObj\n */\nfunction reframeAsObjectInPlace(\n  objectDef: FetchedObjectTypeDefinition,\n  interfaceApiName: string,\n  rawObj: OntologyObjectV2,\n) {\n  const newProps: Record<string, any> = {};\n  for (\n    const [sptProp, regularProp] of Object.entries(\n      objectDef.interfaceMap[interfaceApiName],\n    )\n  ) {\n    if (sptProp in rawObj) {\n      const value = rawObj[sptProp];\n      delete rawObj[sptProp];\n      if (value !== undefined) {\n        newProps[regularProp] = value;\n      }\n    }\n  }\n  Object.assign(rawObj, newProps);\n\n  if (!(objectDef.primaryKeyApiName in rawObj)) {\n    rawObj[objectDef.primaryKeyApiName] = rawObj.$primaryKey;\n  }\n}\n\nfunction isConforming(\n  client: MinimalClient,\n  def:\n    | InterfaceMetadata\n    | ObjectMetadata,\n  obj: OntologyObjectV2,\n  propsToCheck: readonly string[],\n) {\n  for (const propName of propsToCheck) {\n    if (\n      propName in def.properties && def.properties[propName].nullable === false\n      && obj[propName] == null\n    ) {\n      if (process.env.NODE_ENV !== \"production\") {\n        client.logger?.debug(\n          {\n            obj: {\n              $apiName: obj[\"$apiName\"],\n              $objectType: obj[\"$objectType\"],\n              $primaryKey: obj[\"$primaryKey\"],\n            },\n          },\n          `Found object that does not conform to its definition. Expected ${def.apiName}'s ${propName} to not be null.`,\n        );\n      }\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction invariantInterfacesAsViews(\n  objectDef: FetchedObjectTypeDefinition,\n  interfaceApiName: string,\n  client: MinimalClient,\n): asserts objectDef is typeof objectDef & { interfaceMap: {} } {\n  if (objectDef.interfaceMap?.[interfaceApiName] == null) {\n    const warning =\n      \"Interfaces are only supported 'as views' but your metadata object is missing the correct information. This suggests your interfaces have not been migrated to the newer version yet and you cannot use this version of the SDK.\";\n    if (client.logger) {\n      client.logger.warn(warning);\n    } else {\n      // eslint-disable-next-line no-console\n      console.error(`WARNING! ${warning}`);\n    }\n    throw new Error(warning);\n  }\n}\n\nfunction fixObjectPropertiesInPlace(\n  objs: OntologyObjectV2[],\n  forceRemoveRid: boolean,\n): asserts objs is SimpleOsdkProperties[] {\n  for (const obj of objs) {\n    if (forceRemoveRid) {\n      delete obj.__rid;\n    }\n\n    if (obj.__rid) {\n      obj.$rid = obj.__rid;\n      delete obj.__rid;\n    }\n\n    // Backend returns as __apiName but we want to stick to $ structure\n    obj.$apiName ??= obj.__apiName;\n\n    // for now these are the same but when we start doing interface projections the $objectType will always be underlying and\n    // the $apiName will be for the current view (in current designs)\n    obj.$objectType = obj.$apiName;\n\n    // copying over for now as its always returned. In the future, this should just be inferred from underlying\n    obj.$primaryKey ??= obj.__primaryKey;\n    obj.$title ??= obj.__title;\n\n    // we don't want people to use these\n    delete obj.__apiName;\n    delete obj.__primaryKey;\n    delete obj.__title;\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ClientCacheKey, MinimalClient } from \"../MinimalClientContext.js\";\n\n/**\n * A simple cache that can be used to store values for a given client.\n */\ninterface ClientCache<K, V> {\n  get: (client: MinimalClient, key: K) => V;\n  set: <X extends V>(client: MinimalClient, key: K, value: X) => X;\n  remove: (client: MinimalClient, key: K) => boolean;\n}\n\n/**\n * @internal\n * A simple async cache that can be used to store values for a given client.\n */\nexport interface AsyncClientCache<K, V> {\n  getOrUndefined: (client: MinimalClient, key: K) => V | undefined;\n\n  get: (client: MinimalClient, key: K) => Promise<V>;\n\n  /**\n   * @param client the client to key from\n   * @param key the sub-key to use\n   * @param value the value or a promise to the value\n   * @returns a new promise to the resolved value\n   */\n  set: (\n    client: MinimalClient,\n    key: K,\n    value: V | Promise<V>,\n  ) => Promise<V>;\n}\n\n/** @internal */\nexport type Factory<K, V> = (client: MinimalClient, key: K) => V;\n\n/**\n * @internal\n * Create a new cache without a factory function.\n */\nexport function createClientCache<K, V extends {}>(): ClientCache<\n  K,\n  V | undefined\n>;\n/**\n * @internal\n * Create a new cache with a factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n */\nexport function createClientCache<K, V extends {}>(\n  fn: Factory<K, V>,\n): ClientCache<K, V>;\nexport function createClientCache<K, V extends {}>(\n  fn?: Factory<K, V>,\n): typeof fn extends undefined ? ClientCache<K, V | undefined>\n  : ClientCache<K, V>\n{\n  const cache = new WeakMap<\n    ClientCacheKey,\n    typeof fn extends undefined ? Map<K, V | undefined> : Map<K, V>\n  >();\n\n  function get(client: MinimalClient, key: K) {\n    if (cache.get(client.clientCacheKey) == null) {\n      cache.set(client.clientCacheKey, new Map());\n    }\n    let r = cache.get(client.clientCacheKey)!.get(key);\n    if (r === undefined && fn !== undefined) {\n      return set(client, key, fn(client, key));\n    } else {\n      return r;\n    }\n  }\n\n  function set(client: MinimalClient, key: K, value: V) {\n    if (cache.get(client.clientCacheKey) == null) {\n      cache.set(client.clientCacheKey, new Map());\n    }\n\n    cache.get(client.clientCacheKey)!.set(key, value);\n    return value;\n  }\n\n  function remove(client: MinimalClient, key: K) {\n    if (cache.get(client.clientCacheKey) == null) return false;\n    return cache.get(client.clientCacheKey)!.delete(key);\n  }\n\n  return { get, set, remove } as ClientCache<K, V>;\n}\n\n/** @internal */\nexport type AsyncFactory<K, V extends {}> = (\n  client: MinimalClient,\n  key: K,\n) => Promise<V>;\n\n/**\n * @internal\n * Create a new cache with an async factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n * @returns\n */\nexport function createAsyncClientCache<K, V extends {}>(\n  fn: AsyncFactory<K, V>,\n  createCacheLocal: typeof createClientCache = createClientCache,\n): AsyncClientCache<K, V> {\n  const cache = createCacheLocal<K, V>();\n  const inProgress = createCacheLocal<K, Promise<V> | V>();\n\n  const ret = {\n    getOrUndefined: function getOrUndefined(client: MinimalClient, key: K) {\n      return cache.get(client, key);\n    },\n\n    get: async function get(client: MinimalClient, key: K) {\n      return cache.get(client, key) ?? inProgress.get(client, key)\n        ?? ret.set(client, key, fn(client, key));\n    },\n\n    set: async function set(client: MinimalClient, k: K, v: V | Promise<V>) {\n      // the `.set` happens first to prevent races.\n      try {\n        const r = await inProgress.set(client, k, v); // returns v\n\n        cache.set(client, k, r);\n        inProgress.remove(client, k);\n        return r;\n      } catch (e) {\n        // we don't want to cache failures\n        inProgress.remove(client, k);\n        throw e;\n      }\n    },\n  };\n\n  return ret;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  BaseWirePropertyTypes,\n  ObjectMetadata,\n  WirePropertyTypes,\n} from \"@osdk/api\";\nimport type {\n  ObjectPropertyType,\n  PropertyV2,\n  SharedPropertyType,\n} from \"@osdk/foundry.ontologies\";\n\nexport function wirePropertyV2ToSdkPropertyDefinition(\n  input: (PropertyV2 | SharedPropertyType) & { nullable?: boolean },\n  isNullable: boolean = true,\n  log?: { info: (msg: string) => void },\n): ObjectMetadata.Property | undefined {\n  const sdkPropDefinition = objectPropertyTypeToSdkPropertyDefinition(\n    input.dataType,\n    log,\n  );\n  if (sdkPropDefinition == null) {\n    return undefined;\n  }\n  switch (input.dataType.type) {\n    case \"integer\":\n    case \"string\":\n    case \"byte\":\n    case \"decimal\":\n    case \"double\":\n    case \"float\":\n    case \"long\":\n    case \"short\":\n    case \"boolean\":\n    case \"date\":\n    case \"attachment\":\n    case \"mediaReference\":\n    case \"geopoint\":\n    case \"geoshape\":\n    case \"timestamp\":\n    case \"timeseries\":\n    case \"marking\":\n    case \"geotimeSeriesReference\":\n    case \"struct\":\n      return {\n        displayName: input.displayName,\n        multiplicity: false,\n        description: input.description,\n        type: sdkPropDefinition,\n        nullable: input.nullable == null ? isNullable : input.nullable,\n      };\n    case \"array\": {\n      return {\n        displayName: input.displayName,\n        multiplicity: true,\n        description: input.description,\n        type: sdkPropDefinition,\n        nullable: true,\n      };\n    }\n    case \"cipherText\":\n    case \"vector\": {\n      log?.info(\n        `${JSON.stringify(input.dataType.type)} is not a supported dataType`,\n      );\n\n      return undefined;\n    }\n    default:\n      const _: never = input.dataType;\n      log?.info(\n        `${JSON.stringify(input.dataType)} is not a supported dataType`,\n      );\n\n      return undefined;\n  }\n}\n\nfunction objectPropertyTypeToSdkPropertyDefinition(\n  propertyType: ObjectPropertyType,\n  log?: { info: (msg: string) => void },\n): WirePropertyTypes | undefined {\n  switch (propertyType.type) {\n    case \"integer\":\n    case \"string\":\n    case \"byte\":\n    case \"decimal\":\n    case \"double\":\n    case \"float\":\n    case \"long\":\n    case \"short\":\n    case \"boolean\":\n    case \"attachment\":\n    case \"geopoint\":\n    case \"geoshape\":\n    case \"timestamp\":\n    case \"marking\":\n    case \"geotimeSeriesReference\":\n    case \"mediaReference\":\n      return propertyType.type;\n    case \"date\":\n      return \"datetime\";\n    case \"array\":\n      return objectPropertyTypeToSdkPropertyDefinition(propertyType.subType);\n    case \"timeseries\":\n      if (propertyType.itemType?.type === \"string\") {\n        return \"stringTimeseries\";\n      } else if (propertyType.itemType?.type === \"double\") {\n        return \"numericTimeseries\";\n      } else return \"sensorTimeseries\";\n    case \"struct\": {\n      return propertyType.structFieldTypes.reduce(\n        (structMap: Record<string, BaseWirePropertyTypes>, structField) => {\n          structMap[structField.apiName] =\n            objectPropertyTypeToSdkPropertyDefinition(\n              structField.dataType,\n            ) as BaseWirePropertyTypes;\n          return structMap;\n        },\n        {},\n      );\n    }\n    case \"cipherText\":\n    case \"vector\": {\n      log?.info(\n        `${JSON.stringify(propertyType.type)} is not a supported propertyType`,\n      );\n\n      return undefined;\n    }\n    default: {\n      const _: never = propertyType;\n      log?.info(\n        `${JSON.stringify(propertyType)} is not a supported propertyType`,\n      );\n\n      return undefined;\n    }\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { InterfaceMetadata } from \"@osdk/api\";\nimport type { InterfaceType } from \"@osdk/foundry.ontologies\";\nimport { wirePropertyV2ToSdkPropertyDefinition } from \"./wirePropertyV2ToSdkPropertyDefinition.js\";\n\nexport function __UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition(\n  interfaceType: InterfaceType,\n  v2: boolean,\n  log?: { info: (msg: string) => void },\n): InterfaceMetadata {\n  return {\n    type: \"interface\",\n    rid: interfaceType.rid,\n    apiName: interfaceType.apiName,\n    displayName: interfaceType.displayName,\n    description: interfaceType.description,\n    implements: interfaceType.allExtendsInterfaces\n      ?? interfaceType.extendsInterfaces,\n    properties: Object.fromEntries(\n      Object.entries(interfaceType.allProperties ?? interfaceType.properties)\n        .map((\n          [key, value],\n        ) => {\n          return [\n            key,\n            wirePropertyV2ToSdkPropertyDefinition(\n              value,\n              true,\n              log,\n            ),\n          ];\n        }).filter(([key, value]) => value != null),\n    ),\n    links: {},\n    implementedBy: interfaceType.implementedByObjectTypes,\n  };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ActionTypeV2 } from \"@osdk/foundry.ontologies\";\n\nexport type ModifiedEntityTypes = {\n  addedObjects: Set<string>;\n  modifiedObjects: Set<string>;\n};\n\nexport function getModifiedEntityTypes(\n  action: ActionTypeV2,\n): ModifiedEntityTypes {\n  const addedObjects = new Set<string>();\n  const modifiedObjects = new Set<string>();\n  for (const operation of action.operations) {\n    switch (operation.type) {\n      case \"createObject\":\n        addedObjects.add(operation.objectTypeApiName);\n        break;\n      case \"modifyObject\":\n        modifiedObjects.add(operation.objectTypeApiName);\n        break;\n      case \"deleteObject\":\n      case \"createLink\":\n      case \"deleteLink\":\n      case \"createInterfaceObject\":\n      case \"modifyInterfaceObject\":\n      case \"deleteInterfaceObject\":\n        break;\n      default:\n        const _: never = operation;\n    }\n  }\n  return { addedObjects, modifiedObjects };\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { PrimaryKeyTypes } from \"@osdk/api\";\nimport type { PropertyV2 } from \"@osdk/foundry.ontologies\";\n\nexport function wirePropertyV2ToSdkPrimaryKeyTypeDefinition(\n  input: PropertyV2,\n): PrimaryKeyTypes {\n  switch (input.dataType.type) {\n    case \"integer\":\n    case \"double\":\n    case \"string\":\n    case \"byte\":\n    case \"long\":\n    case \"short\":\n    case \"timestamp\": {\n      return input.dataType.type;\n    }\n    case \"date\": {\n      return \"datetime\";\n    }\n    case \"boolean\":\n    case \"geopoint\":\n    case \"geoshape\":\n    case \"decimal\":\n    case \"attachment\":\n    case \"timeseries\":\n    case \"array\":\n    case \"marking\":\n    case \"float\":\n    case \"geotimeSeriesReference\":\n    case \"mediaReference\":\n    case \"struct\":\n    case \"cipherText\":\n    case \"vector\":\n      throw new Error(\n        `Primary key of type ${input.dataType.type} is not supported`,\n      );\n    default:\n      const _: never = input.dataType;\n      throw new Error(\n        `Unknown type encountered for primaryKey: ${input.dataType}`,\n      );\n  }\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectMetadata } from \"@osdk/api\";\nimport type {\n  ObjectTypeFullMetadata,\n  PropertyApiName,\n  PropertyV2,\n} from \"@osdk/foundry.ontologies\";\nimport { wirePropertyV2ToSdkPrimaryKeyTypeDefinition } from \"./wirePropertyV2ToSdkPrimaryKeyTypeDefinition.js\";\nimport { wirePropertyV2ToSdkPropertyDefinition } from \"./wirePropertyV2ToSdkPropertyDefinition.js\";\n\nexport function wireObjectTypeFullMetadataToSdkObjectMetadata(\n  objectTypeWithLink: ObjectTypeFullMetadata & {\n    objectType: {\n      properties: Record<PropertyApiName, PropertyV2 & { nullable?: boolean }>;\n    };\n  },\n  v2: boolean,\n  log?: { info: (msg: string) => void },\n): ObjectMetadata {\n  if (\n    objectTypeWithLink.objectType\n      .properties[objectTypeWithLink.objectType.primaryKey] === undefined\n  ) {\n    throw new Error(\n      `Primary key ${objectTypeWithLink.objectType.primaryKey} not found in ${objectTypeWithLink.objectType.apiName}`,\n    );\n  }\n\n  // saved ontology.json files may not have this implementsInterfaces2 so we need to handle\n  if (\n    objectTypeWithLink.implementsInterfaces2 == null\n    && objectTypeWithLink.implementsInterfaces != null\n  ) {\n    throw new Error(\n      \"Your ontology.json file is missing the implementsInterfaces2 field. Please regenerate it.\",\n    );\n  }\n\n  const interfaceMap = objectTypeWithLink.implementsInterfaces2\n    ? Object.fromEntries(\n      Object.entries(objectTypeWithLink.implementsInterfaces2).map(\n        ([interfaceApiName, impl]) => [interfaceApiName, impl.properties],\n      ),\n    )\n    : {};\n\n  return {\n    type: \"object\",\n    apiName: objectTypeWithLink.objectType.apiName,\n    description: objectTypeWithLink.objectType.description,\n    primaryKeyApiName: objectTypeWithLink.objectType.primaryKey,\n    primaryKeyType: wirePropertyV2ToSdkPrimaryKeyTypeDefinition(\n      objectTypeWithLink.objectType\n        .properties[objectTypeWithLink.objectType.primaryKey],\n    ),\n    links: Object.fromEntries(objectTypeWithLink.linkTypes.map(linkType => {\n      return [linkType.apiName, {\n        multiplicity: linkType.cardinality === \"MANY\",\n        targetType: linkType.objectTypeApiName,\n      }];\n    })),\n    properties: Object.fromEntries(\n      Object.entries(objectTypeWithLink.objectType.properties).map((\n        [key, value],\n      ) => [\n        key,\n        wirePropertyV2ToSdkPropertyDefinition(\n          value,\n          !(v2 && objectTypeWithLink.objectType.primaryKey === key),\n          log,\n        ),\n      ]).filter(([key, value]) => value != null),\n    ),\n    implements: objectTypeWithLink.implementsInterfaces as string[],\n    interfaceMap,\n    inverseInterfaceMap: Object.fromEntries(\n      Object.entries(interfaceMap).map((\n        [interfaceApiName, props],\n      ) => [interfaceApiName, invertProps(props)]),\n    ),\n    icon: supportedIconTypes.includes(objectTypeWithLink.objectType.icon.type)\n      ? objectTypeWithLink.objectType.icon\n      : undefined,\n    titleProperty: objectTypeWithLink.objectType.titleProperty,\n    displayName: objectTypeWithLink.objectType.displayName,\n    pluralDisplayName: objectTypeWithLink.objectType.pluralDisplayName,\n    status: ensureStringEnumSupportedOrUndefined(\n      objectTypeWithLink.objectType.status,\n      supportedReleaseStatus,\n    ),\n    rid: objectTypeWithLink.objectType.rid,\n    visibility: ensureStringEnumSupportedOrUndefined(\n      objectTypeWithLink.objectType.visibility,\n      supportedObjectTypeVisibility,\n    ),\n  };\n}\n\nfunction invertProps(\n  a?: Record<string, string>,\n): typeof a extends undefined ? typeof a : Record<string, string> {\n  return (a\n    ? Object.fromEntries(Object.entries(a).map(([k, v]) => [v, k]))\n    : undefined) as typeof a extends undefined ? typeof a\n      : Record<string, string>;\n}\n\nexport const supportedIconTypes = [\"blueprint\"] as const;\n\nexport const supportedReleaseStatus = [\n  \"ACTIVE\",\n  \"EXPERIMENTAL\",\n  \"DEPRECATED\",\n  \"ENDORSED\",\n] as const;\n\nexport const supportedObjectTypeVisibility = [\n  \"NORMAL\",\n  \"PROMINENT\",\n  \"HIDDEN\",\n] as const;\n\nexport function ensureStringEnumSupportedOrUndefined<T extends string>(\n  value: T | undefined,\n  supportedValues: readonly string[],\n): T | undefined {\n  return value && supportedValues.includes(value) ? value : undefined;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ActionMetadata } from \"@osdk/api\";\nimport type {\n  ActionParameterType,\n  ActionParameterV2,\n  ActionTypeV2,\n} from \"@osdk/foundry.ontologies\";\nimport { getModifiedEntityTypes } from \"./getEditedEntities.js\";\nimport {\n  ensureStringEnumSupportedOrUndefined,\n  supportedReleaseStatus,\n} from \"./wireObjectTypeFullMetadataToSdkObjectMetadata.js\";\n\nexport function wireActionTypeV2ToSdkActionMetadata(\n  input: ActionTypeV2,\n): ActionMetadata {\n  const modifiedEntityTypes = getModifiedEntityTypes(input);\n  return {\n    type: \"action\",\n    apiName: input.apiName,\n    parameters: Object.fromEntries(\n      Object.entries(input.parameters).map((\n        [key, value],\n      ) => [key, wireActionParameterV2ToSdkParameterDefinition(value)]),\n    ),\n    displayName: input.displayName,\n    description: input.description,\n    modifiedEntities: createModifiedEntities(\n      modifiedEntityTypes.addedObjects,\n      modifiedEntityTypes.modifiedObjects,\n    ),\n    rid: input.rid,\n    status: ensureStringEnumSupportedOrUndefined(\n      input.status,\n      supportedReleaseStatus,\n    ),\n  };\n}\n\nfunction wireActionParameterV2ToSdkParameterDefinition(\n  value: ActionParameterV2,\n): ActionMetadata.Parameter<any> {\n  return {\n    multiplicity: value.dataType.type === \"array\",\n    type: actionPropertyToSdkPropertyDefinition(\n      value.dataType.type === \"array\" ? value.dataType.subType : value.dataType,\n    ),\n    nullable: !value.required,\n    description: value.description,\n  };\n}\n\nfunction actionPropertyToSdkPropertyDefinition(\n  parameterType: ActionParameterType,\n): ActionMetadata.Parameter[\"type\"] {\n  switch (parameterType.type) {\n    case \"string\":\n    case \"boolean\":\n    case \"attachment\":\n    case \"double\":\n    case \"integer\":\n    case \"long\":\n    case \"timestamp\":\n    case \"mediaReference\":\n    case \"marking\":\n    case \"objectType\":\n    case \"geohash\":\n    case \"geoshape\":\n      return parameterType.type;\n    case \"date\":\n      return \"datetime\";\n    case \"objectSet\":\n      return { type: \"objectSet\", objectSet: parameterType.objectTypeApiName! };\n    case \"object\":\n      return { type: \"object\", object: parameterType.objectTypeApiName };\n    case \"array\":\n      return actionPropertyToSdkPropertyDefinition(parameterType.subType);\n    case \"interfaceObject\":\n      return {\n        type: \"interface\",\n        interface: parameterType.interfaceTypeApiName,\n      };\n    case \"struct\":\n      return {\n        type: \"struct\",\n        struct: parameterType.fields.reduce(\n          (\n            structMap: Record<\n              string,\n              ActionMetadata.DataType.BaseActionParameterTypes\n            >,\n            structField,\n          ) => {\n            structMap[structField.name] = actionPropertyToSdkPropertyDefinition(\n              structField.fieldType as ActionParameterType,\n            ) as ActionMetadata.DataType.BaseActionParameterTypes;\n            return structMap;\n          },\n          {},\n        ),\n      };\n    default:\n      throw new Error(\n        `Unsupported action parameter type: ${JSON.stringify(parameterType)}`,\n      );\n  }\n}\n\nfunction createModifiedEntities<K extends string>(\n  addedObjects: Set<K>,\n  modifiedObjects: Set<K>,\n): ActionMetadata[\"modifiedEntities\"] {\n  const entities = {} as Record<\n    K,\n    {\n      created: boolean;\n      modified: boolean;\n    }\n  >;\n\n  for (const key of addedObjects) {\n    entities[key] = { created: true, modified: false };\n  }\n\n  for (const key of modifiedObjects) {\n    if (entities[key]) {\n      entities[key].modified = true;\n    } else {\n      entities[key] = { created: false, modified: true };\n    }\n  }\n\n  return entities;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { QueryDataType } from \"@osdk/foundry.ontologies\";\n\nexport function isNullableQueryDataType(input: QueryDataType): boolean {\n  if (input.type === \"null\") {\n    return true;\n  }\n  if (input.type === \"union\") {\n    return input.unionTypes.some(t => isNullableQueryDataType(t));\n  }\n  return false;\n}\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  QueryDataTypeDefinition,\n  ThreeDimensionalQueryAggregationDefinition,\n  TwoDimensionalQueryAggregationDefinition,\n} from \"@osdk/api\";\nimport type {\n  QueryAggregationKeyType,\n  QueryDataType,\n  ThreeDimensionalAggregation,\n  TwoDimensionalAggregation,\n} from \"@osdk/foundry.ontologies\";\nimport { isNullableQueryDataType } from \"./isNullableQueryDataType.js\";\n\nexport function wireQueryDataTypeToQueryDataTypeDefinition<\n  K extends string,\n>(\n  input: QueryDataType,\n): QueryDataTypeDefinition {\n  switch (input.type) {\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"attachment\":\n    case \"boolean\":\n    case \"date\":\n    case \"string\":\n    case \"timestamp\":\n      return {\n        type: input.type,\n        nullable: false,\n      };\n\n    case \"object\":\n      return {\n        type: \"object\",\n        object: input.objectTypeApiName as K,\n        nullable: false,\n      };\n\n    case \"objectSet\":\n      return {\n        type: \"objectSet\",\n        objectSet: input.objectTypeApiName as K,\n        nullable: false,\n      };\n\n    case \"array\":\n      return {\n        ...wireQueryDataTypeToQueryDataTypeDefinition(input.subType),\n        multiplicity: true,\n      };\n\n    case \"set\":\n      return {\n        type: \"set\",\n        set: wireQueryDataTypeToQueryDataTypeDefinition(input.subType),\n        nullable: false,\n      };\n\n    case \"union\":\n      const allowNulls = isNullableQueryDataType(input);\n\n      // special case for a union where one half is nullable to skip the union step and just allow nulls directly\n      if (allowNulls && input.unionTypes.length === 2) {\n        const nonNull = input.unionTypes.find(t => t.type != null);\n        if (nonNull) {\n          return {\n            ...wireQueryDataTypeToQueryDataTypeDefinition(nonNull),\n            nullable: true,\n          };\n        }\n      }\n\n      return {\n        type: \"union\",\n        union: input.unionTypes.reduce<QueryDataTypeDefinition[]>((acc, t) => {\n          if (t.type === \"null\") {\n            return acc;\n          }\n          acc.push(wireQueryDataTypeToQueryDataTypeDefinition(t));\n          return acc;\n        }, []),\n        nullable: allowNulls,\n      };\n\n    case \"struct\":\n      return {\n        type: \"struct\",\n        struct: Object.fromEntries(input.fields.map(f => [\n          f.name,\n          wireQueryDataTypeToQueryDataTypeDefinition(f.fieldType),\n        ])),\n        nullable: false,\n      };\n\n    case \"twoDimensionalAggregation\":\n      return {\n        type: \"twoDimensionalAggregation\",\n        twoDimensionalAggregation: get2DQueryAggregationProps(input),\n        nullable: false,\n      };\n\n    case \"threeDimensionalAggregation\":\n      return {\n        type: \"threeDimensionalAggregation\",\n        threeDimensionalAggregation: get3DQueryAggregationProps(input),\n        nullable: false,\n      };\n\n    case \"entrySet\":\n      const keyType = wireQueryDataTypeToQueryDataTypeDefinition(input.keyType);\n\n      if (!validMapKeyTypes.includes(keyType.type)) {\n        throw new Error(\n          \"Map types with a key type of \" + keyType.type + \" are not supported\"\n            + validMapKeyTypes.toString(),\n        );\n      }\n\n      if (keyType.multiplicity === true) {\n        throw new Error(\n          \"Map types cannot have keys as arrays\",\n        );\n      }\n\n      return {\n        type: \"map\",\n        nullable: false,\n        keyType,\n        valueType: wireQueryDataTypeToQueryDataTypeDefinition(input.valueType),\n      };\n\n    case \"null\":\n    case \"unsupported\":\n      throw new Error(\n        `Unable to process query because the server indicated an unsupported QueryDataType.type: ${input.type}. Please check that your query is using supported types.`,\n      );\n\n    default:\n      const _: never = input;\n      throw new Error(`Unsupported QueryDataType.type ${(input as any).type}`);\n  }\n}\n\nfunction get2DQueryAggregationProps(\n  input: TwoDimensionalAggregation,\n): TwoDimensionalQueryAggregationDefinition {\n  if (input.keyType.type === \"range\") {\n    return {\n      keyType: input.keyType.type,\n      keySubtype: input.keyType.subType.type,\n      valueType: input.valueType.type,\n    };\n  } else {\n    if (guardInvalidKeyTypes(input.keyType)) {\n      return {\n        keyType: input.keyType.type,\n        valueType: input.valueType.type,\n      };\n    }\n    throw new Error(\n      `Cannot create 2D aggregation with ${input.keyType.type} as its type`,\n    );\n  }\n}\n\nfunction get3DQueryAggregationProps(\n  input: ThreeDimensionalAggregation,\n): ThreeDimensionalQueryAggregationDefinition {\n  if (input.keyType.type === \"range\") {\n    return {\n      keyType: input.keyType.type,\n      keySubtype: input.keyType.subType.type,\n      valueType: get2DQueryAggregationProps(input.valueType),\n    };\n  } else {\n    if (guardInvalidKeyTypes(input.keyType)) {\n      return {\n        keyType: input.keyType.type,\n        valueType: get2DQueryAggregationProps(input.valueType),\n      };\n    }\n    throw new Error(\n      `Cannot create 3D aggregation with ${input.keyType.type} as its type`,\n    );\n  }\n}\n\n/**\n * Guard against aggregation key types that are allowed by the backend types but are illegal to actually use\n */\nfunction guardInvalidKeyTypes(\n  key: QueryAggregationKeyType,\n): key is QueryAggregationKeyType & ({ type: \"string\" | \"boolean\" }) {\n  return key.type === \"string\" || key.type === \"boolean\";\n}\n\n/**\n * The set of all valid key types for maps. This includes all types that are represented by strings or numbers in the OSDK, and  Ontology Objects.\n */\nconst validMapKeyTypes = [\n  \"string\",\n  \"object\",\n  \"double\",\n  \"float\",\n  \"integer\",\n  \"long\",\n  \"date\",\n  \"timestamp\",\n  \"byte\",\n  \"datetime\",\n  \"decimal\",\n  \"marking\",\n  \"short\",\n  \"objectType\",\n];\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { QueryMetadata, QueryParameterDefinition } from \"@osdk/api\";\nimport type { QueryParameterV2, QueryTypeV2 } from \"@osdk/foundry.ontologies\";\nimport {\n  wireQueryDataTypeToQueryDataTypeDefinition,\n} from \"./wireQueryDataTypeToQueryDataTypeDefinition.js\";\n\nexport function wireQueryTypeV2ToSdkQueryMetadata(\n  input: QueryTypeV2,\n): QueryMetadata {\n  return {\n    type: \"query\",\n    apiName: input.apiName,\n    description: input.description,\n    displayName: input.displayName,\n    version: input.version,\n    parameters: Object.fromEntries(\n      Object.entries(input.parameters).map((\n        [name, parameter],\n      ) => [name, wireQueryParameterV2ToQueryParameterDefinition(parameter)]),\n    ),\n    output: wireQueryDataTypeToQueryDataTypeDefinition(input.output),\n    rid: input.rid,\n  };\n}\n\nexport function wireQueryTypeV2ToSdkQueryDefinitionNoParams(\n  input: QueryTypeV2,\n): {\n  type: string;\n  apiName: string;\n  description: string | undefined;\n  displayName: string | undefined;\n  version: string;\n  rid: string;\n} {\n  return {\n    type: \"query\",\n    apiName: input.apiName,\n    description: input.description,\n    displayName: input.displayName,\n    version: input.version,\n    rid: input.rid,\n  };\n}\n\nexport function wireQueryParameterV2ToQueryParameterDefinition(\n  parameter: QueryParameterV2,\n): QueryParameterDefinition<any> {\n  return {\n    description: parameter.description,\n    ...wireQueryDataTypeToQueryDataTypeDefinition(parameter.dataType),\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ActionMetadata } from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport {\n  wireActionTypeV2ToSdkActionMetadata,\n} from \"@osdk/generator-converters\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport async function loadActionMetadata(\n  client: MinimalClient,\n  actionType: string,\n): Promise<ActionMetadata> {\n  const r = await OntologiesV2.ActionTypesV2.get(\n    client,\n    await client.ontologyRid,\n    actionType,\n  );\n\n  return wireActionTypeV2ToSdkActionMetadata(r);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectMetadata } from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport { wireObjectTypeFullMetadataToSdkObjectMetadata } from \"@osdk/generator-converters\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport async function loadFullObjectMetadata(\n  client: MinimalClient,\n  objectType: string,\n): Promise<ObjectMetadata & { rid: string }> {\n  const full = await OntologiesV2.ObjectTypesV2.getFullMetadata(\n    client,\n    await client.ontologyRid,\n    objectType,\n    { preview: true },\n  );\n  const ret = wireObjectTypeFullMetadataToSdkObjectMetadata(full, true);\n  return { ...ret };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { InterfaceMetadata } from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport { __UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition } from \"@osdk/generator-converters\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport async function loadInterfaceMetadata(\n  client: MinimalClient,\n  objectType: string,\n): Promise<InterfaceMetadata> {\n  const r = await OntologiesV2.OntologyInterfaces.get(\n    client,\n    await client.ontologyRid,\n    objectType,\n    { preview: true },\n  );\n\n  return __UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition(r, true);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { QueryMetadata } from \"@osdk/api\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport { wireQueryTypeV2ToSdkQueryMetadata } from \"@osdk/generator-converters\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\n\nexport async function loadQueryMetadata(\n  client: MinimalClient,\n  queryTypeApiNameAndVersion: string,\n): Promise<QueryMetadata> {\n  const [apiName, version] = queryTypeApiNameAndVersion.split(\":\");\n  const r = await OntologiesV2.QueryTypes.get(\n    client,\n    await client.ontologyRid,\n    apiName,\n    { version },\n  );\n\n  return wireQueryTypeV2ToSdkQueryMetadata(r);\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionMetadata,\n  InterfaceMetadata,\n  ObjectOrInterfaceDefinition,\n  QueryMetadata,\n} from \"@osdk/api\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { createAsyncClientCache } from \"../object/Cache.js\";\nimport { loadActionMetadata } from \"./loadActionMetadata.js\";\nimport { loadFullObjectMetadata } from \"./loadFullObjectMetadata.js\";\nimport { loadInterfaceMetadata } from \"./loadInterfaceMetadata.js\";\nimport { loadQueryMetadata } from \"./loadQueryMetadata.js\";\nimport {\n  type FetchedObjectTypeDefinition,\n  InterfaceDefinitions,\n  type OntologyProviderFactory,\n} from \"./OntologyProvider.js\";\n\nexport interface OntologyCachingOptions {\n}\n\nexport const createStandardOntologyProviderFactory: (\n  opts: OntologyCachingOptions,\n) => OntologyProviderFactory = (client) => {\n  return (client) => {\n    async function loadObject(\n      client: MinimalClient,\n      key: string,\n    ): Promise<FetchedObjectTypeDefinition> {\n      const objectDef = await loadFullObjectMetadata(client, key);\n\n      // ensure we have all of the interfaces loaded\n      const interfaceDefs = Object.fromEntries<\n        { def: InterfaceMetadata; handler: undefined }\n      >(\n        (await Promise.all<InterfaceMetadata>(\n          objectDef.implements?.map((i) => ret.getInterfaceDefinition(i)) ?? [],\n        )).map(i => [i.apiName, { def: i, handler: undefined }]),\n      );\n\n      const fullObjectDef = {\n        ...objectDef,\n        [InterfaceDefinitions]: interfaceDefs,\n      };\n\n      return fullObjectDef;\n    }\n\n    async function loadInterface(\n      client: MinimalClient,\n      key: string,\n    ) {\n      return loadInterfaceMetadata(client, key);\n    }\n\n    async function loadQuery(\n      client: MinimalClient,\n      key: string,\n    ) {\n      return loadQueryMetadata(client, key);\n    }\n\n    async function loadAction(\n      client: MinimalClient,\n      key: string,\n    ) {\n      const r = await loadActionMetadata(client, key);\n      return r;\n    }\n\n    function makeGetter<\n      N extends\n        | ObjectOrInterfaceDefinition\n        | QueryMetadata\n        | ActionMetadata,\n    >(\n      fn: (\n        client: MinimalClient,\n        key: string,\n        skipCache?: boolean,\n      ) => Promise<N>,\n    ) {\n      const cache = createAsyncClientCache<string, N>((client, key) =>\n        fn(client, key, false)\n      );\n      return async (apiName: string) => {\n        return await cache.get(client, apiName);\n      };\n    }\n\n    function makeQueryGetter(\n      client: MinimalClient,\n      fn: (\n        client: MinimalClient,\n        key: string,\n        skipCache?: boolean,\n      ) => Promise<QueryMetadata>,\n    ) {\n      const queryCache = createAsyncClientCache<string, QueryMetadata>(\n        (client, key) => {\n          return fn(client, key);\n        },\n      );\n      return async (apiName: string, version?: string) => {\n        const key = version ? `${apiName}:${version}` : apiName;\n        return await queryCache.get(client, key);\n      };\n    }\n\n    const ret = {\n      getObjectDefinition: makeGetter(loadObject),\n      getInterfaceDefinition: makeGetter(loadInterface),\n      getActionDefinition: makeGetter(loadAction),\n      getQueryDefinition: makeQueryGetter(client, loadQuery),\n    };\n    return ret;\n  };\n};\n", "/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const USER_AGENT: string = `osdk-client/${process.env.PACKAGE_VERSION}`;\nexport const OBSERVABLE_USER_AGENT: string =\n  `osdk-observable-client/${process.env.PACKAGE_VERSION}`;\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Logger } from \"@osdk/api\";\nimport { createSharedClientContext } from \"@osdk/shared.client.impl\";\nimport type {\n  ClientCacheKey,\n  MinimalClient,\n  MinimalClientParams,\n} from \"./MinimalClientContext.js\";\nimport {\n  convertWireToOsdkObjects,\n  convertWireToOsdkObjects2,\n} from \"./object/convertWireToOsdkObjects.js\";\nimport { createObjectSet } from \"./objectSet/createObjectSet.js\";\nimport type { ObjectSetFactory } from \"./objectSet/ObjectSetFactory.js\";\nimport type { OntologyProvider } from \"./ontology/OntologyProvider.js\";\nimport {\n  createStandardOntologyProviderFactory,\n  type OntologyCachingOptions,\n} from \"./ontology/StandardOntologyProvider.js\";\nimport { USER_AGENT } from \"./util/UserAgent.js\";\n\n/** @internal */\nexport function createMinimalClient(\n  metadata: MinimalClientParams[\"metadata\"],\n  baseUrl: string,\n  tokenProvider: () => Promise<string>,\n  options: OntologyCachingOptions & { logger?: Logger } = {},\n  fetchFn: (\n    input: Request | URL | string,\n    init?: RequestInit | undefined,\n  ) => Promise<Response> = global.fetch,\n  objectSetFactory: ObjectSetFactory<any, any> = createObjectSet,\n  createOntologyProviderFactory: (\n    a: OntologyCachingOptions & { logger?: Logger },\n  ) => (minimalClient: MinimalClient) => OntologyProvider =\n    createStandardOntologyProviderFactory,\n) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      new URL(baseUrl);\n    } catch (e) {\n      const hint =\n        !baseUrl.startsWith(\"http://\") || !baseUrl.startsWith(\"https://\")\n          ? \". Did you forget to add 'http://' or 'https://'?\"\n          : \"\";\n      throw new Error(`Invalid stack URL: ${baseUrl}${hint}`);\n    }\n  }\n  const processedBaseUrl = new URL(baseUrl);\n  processedBaseUrl.pathname += processedBaseUrl.pathname.endsWith(\"/\")\n    ? \"\"\n    : \"/\";\n  const minimalClient: MinimalClient = {\n    ...createSharedClientContext(\n      processedBaseUrl.toString(),\n      tokenProvider,\n      USER_AGENT,\n      fetchFn,\n    ),\n    objectSetFactory,\n    objectFactory: convertWireToOsdkObjects,\n    objectFactory2: convertWireToOsdkObjects2,\n    ontologyRid: metadata.ontologyRid,\n    logger: options.logger,\n    clientCacheKey: {} as ClientCacheKey,\n    requestContext: {},\n  } satisfies Omit<\n    MinimalClient,\n    \"ontologyProvider\"\n  > as any;\n\n  return Object.freeze(Object.assign(minimalClient, {\n    ontologyProvider: createOntologyProviderFactory(\n      options,\n    )(minimalClient),\n  }));\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  ActionMetadata,\n  InterfaceDefinition,\n  InterfaceMetadata,\n  ObjectMetadata,\n  ObjectTypeDefinition,\n  QueryDefinition,\n  QueryMetadata,\n} from \"@osdk/api\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\nimport { InterfaceDefinitions } from \"./ontology/OntologyProvider.js\";\n\n/** @internal */\nexport const fetchMetadataInternal = async <\n  Q extends (\n    | ObjectTypeDefinition\n    | InterfaceDefinition\n    | ActionDefinition<any>\n    | QueryDefinition<any>\n  ),\n>(\n  client: MinimalClient,\n  definition: Q,\n): Promise<\n  Q extends ObjectTypeDefinition ? ObjectMetadata\n    : Q extends InterfaceDefinition ? InterfaceMetadata\n    : Q extends ActionDefinition<any> ? ActionMetadata\n    : Q extends QueryDefinition<any> ? QueryMetadata\n    : never\n> => {\n  if (definition.type === \"object\") {\n    const { [InterfaceDefinitions]: interfaceDefs, ...objectTypeDef } =\n      await client.ontologyProvider\n        .getObjectDefinition(definition.apiName);\n    return objectTypeDef as any;\n  } else if (definition.type === \"interface\") {\n    return client.ontologyProvider.getInterfaceDefinition(\n      definition.apiName,\n    ) as any;\n  } else if (definition.type === \"action\") {\n    return client.ontologyProvider.getActionDefinition(\n      definition.apiName,\n    ) as any;\n  } else if (definition.type === \"query\") {\n    return client.ontologyProvider.getQueryDefinition(\n      definition.apiName,\n      definition.isFixedVersion ? definition.version : undefined,\n    ) as any;\n  } else {\n    throw new Error(\"Not implemented for given definition\");\n  }\n};\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Logger } from \"@osdk/api\";\n\nexport function noop(): any {\n}\n\ninterface LoggerConstructor {\n  new(\n    bindings: Record<string, any>,\n    options?: { level?: string; msgPrefix?: string },\n  ): Logger;\n}\n\nconst levels = {\n  trace: 10,\n  debug: 20,\n  info: 30,\n  warn: 40,\n  error: 50,\n  fatal: 60,\n};\n\nexport abstract class BaseLogger implements Logger {\n  protected bindings: Record<string, any>;\n  protected options: { level?: string; msgPrefix?: string } | undefined;\n  #factory: LoggerConstructor;\n\n  constructor(\n    bindings: Record<string, any>,\n    options: { level?: string; msgPrefix?: string } = {},\n    factory: LoggerConstructor,\n  ) {\n    this.bindings = bindings;\n    this.options = options;\n    this.#factory = factory;\n\n    for (\n      const k of [\"trace\", \"debug\", \"info\", \"warn\", \"error\", \"fatal\"] as const\n    ) {\n      if (this.options?.level && !this.isLevelEnabled(k)) {\n        continue;\n      }\n      this[k] = this.createLogMethod(k, bindings);\n    }\n  }\n\n  protected abstract createLogMethod(\n    name: \"trace\" | \"debug\" | \"info\" | \"warn\" | \"error\" | \"fatal\",\n    bindings: Record<string, any>,\n  ): Logger.LogFn;\n\n  trace: Logger.LogFn = noop;\n  debug: Logger.LogFn = noop;\n  warn: Logger.LogFn = noop;\n  info: Logger.LogFn = noop;\n  error: Logger.LogFn = noop;\n  fatal: Logger.LogFn = noop;\n\n  child(\n    bindings: Record<string, any>,\n    options?: { level?: string; msgPrefix?: string },\n  ): Logger {\n    return new this.#factory({\n      ...this.bindings,\n      ...bindings,\n    }, {\n      level: options?.level ?? this.options?.level,\n      msgPrefix: [this.options?.msgPrefix, options?.msgPrefix].filter(x => x)\n        .join(\" \"),\n    });\n  }\n\n  isLevelEnabled(level: string): boolean {\n    const ourLevel = (this.options?.level ?? \"info\") as keyof typeof levels;\n\n    return level in levels && ourLevel in levels\n      && levels[level as keyof typeof levels] >= levels[ourLevel];\n  }\n}\n", "/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Logger } from \"@osdk/api\";\nimport { BaseLogger } from \"./BaseLogger.js\";\n\nexport class MinimalLogger extends BaseLogger implements Logger {\n  constructor(\n    bindings: Record<string, any> = {},\n    options: { level?: string; msgPrefix?: string } = {},\n  ) {\n    super(\n      bindings,\n      { ...options, level: options.level ?? \"error\" },\n      MinimalLogger,\n    );\n  }\n\n  createLogMethod(\n    name: \"trace\" | \"debug\" | \"info\" | \"warn\" | \"error\" | \"fatal\",\n    bindings: Record<string, any>,\n  ): Logger.LogFn {\n    const msgs: string[] = [name];\n\n    if (this.options?.msgPrefix) {\n      msgs.push(this.options.msgPrefix);\n    }\n\n    if (typeof bindings === \"object\" && \"methodName\" in bindings) {\n      msgs.push(`.${bindings.methodName}()`);\n    }\n\n    return (...args: any[]) => {\n      // eslint-disable-next-line no-console\n      console[name === \"fatal\" ? \"error\" : name](msgs.join(\" \"), ...args);\n    };\n  }\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { QueryDataTypeDefinition } from \"@osdk/api\";\nimport { type DataValue } from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport {\n  isAttachmentFile,\n  isAttachmentUpload,\n} from \"../object/AttachmentUpload.js\";\nimport { getWireObjectSet, isObjectSet } from \"../objectSet/createObjectSet.js\";\nimport { isObjectSpecifiersObject } from \"./isObjectSpecifiersObject.js\";\nimport { extractPrimaryKeyFromObjectSpecifier } from \"./objectSpecifierUtils.js\";\nimport { isWireObjectSet } from \"./WireObjectSet.js\";\n\n/**\n * Marshall user-facing data into the wire DataValue type\n *\n * @see DataValue for the expected payloads\n * @internal\n */\nexport async function toDataValueQueries(\n  value: unknown,\n  client: MinimalClient,\n  desiredType: QueryDataTypeDefinition,\n): Promise<DataValue> {\n  if (value == null) {\n    return value;\n  }\n\n  if (Array.isArray(value) && desiredType.multiplicity) {\n    const values = Array.from(value);\n    if (\n      values.some((dataValue) =>\n        isAttachmentUpload(dataValue) || isAttachmentFile(dataValue)\n      )\n    ) {\n      const converted = [];\n      for (const value of values) {\n        converted.push(await toDataValueQueries(value, client, desiredType));\n      }\n      return converted;\n    }\n    const promiseArray = Array.from(\n      value,\n      async (innerValue) =>\n        await toDataValueQueries(innerValue, client, desiredType),\n    );\n    return Promise.all(promiseArray);\n  }\n\n  switch (desiredType.type) {\n    case \"attachment\": {\n      if (isAttachmentUpload(value)) {\n        const attachment = await OntologiesV2.Attachments.upload(\n          client,\n          value.data,\n          {\n            filename: value.name,\n          },\n        );\n        return attachment.rid;\n      }\n\n      if (\n        isAttachmentFile(value)\n      ) {\n        const attachment = await OntologiesV2.Attachments.upload(\n          client,\n          value,\n          {\n            filename: value.name as string,\n          },\n        );\n        return attachment.rid;\n      }\n\n      // If it's not an upload, it's just an attachment rid string which we can pass through\n      return value;\n    }\n    case \"twoDimensionalAggregation\": {\n      return {\n        groups: value,\n      };\n    }\n    case \"threeDimensionalAggregation\": {\n      return {\n        groups: value,\n      };\n    }\n\n    case \"set\": {\n      if (value instanceof Set) {\n        const promiseArray = Array.from(\n          value,\n          async (innerValue) =>\n            await toDataValueQueries(innerValue, client, desiredType[\"set\"]),\n        );\n        return Promise.all(promiseArray);\n      }\n      break;\n    }\n    case \"object\": {\n      if (isObjectSpecifiersObject(value)) {\n        return value.$primaryKey;\n      }\n      break;\n    }\n    case \"objectSet\": {\n      // object set (the rid as a string (passes through the last return), or the ObjectSet definition directly)\n      if (isWireObjectSet(value)) {\n        return value;\n      }\n      if (isObjectSet(value)) {\n        return getWireObjectSet(value);\n      }\n      break;\n    }\n\n    case \"map\": {\n      if (typeof value === \"object\") {\n        const entrySet: Array<{ key: any; value: any }> = [];\n        for (const [key, mapValue] of Object.entries(value)) {\n          entrySet.push({\n            key: desiredType.keyType.type === \"object\"\n              ? extractPrimaryKeyFromObjectSpecifier(key as any)\n              : await toDataValueQueries(\n                key,\n                client,\n                desiredType.keyType,\n              ),\n            value: await toDataValueQueries(\n              mapValue,\n              client,\n              desiredType.valueType,\n            ),\n          });\n        }\n        return entrySet;\n      }\n      break;\n    }\n\n    case \"struct\": {\n      if (typeof value === \"object\") {\n        const structMap: { [key: string]: unknown } = {};\n        for (const [key, structValue] of Object.entries(value)) {\n          structMap[key] = await toDataValueQueries(\n            structValue,\n            client,\n            desiredType[\"struct\"][key],\n          );\n        }\n        return structMap;\n      }\n    }\n\n    case \"boolean\":\n    case \"date\":\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"string\":\n    case \"timestamp\":\n      return value;\n  }\n  return value;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AllowedBucketKeyTypes,\n  AllowedBucketTypes,\n  CompileTimeMetadata,\n  ObjectOrInterfaceDefinition,\n  ObjectTypeDefinition,\n  OsdkBase,\n  PrimaryKeyType,\n  QueryDataTypeDefinition,\n  QueryDefinition,\n  QueryParameterDefinition,\n} from \"@osdk/api\";\nimport type { DataValue } from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { createObjectSet } from \"../objectSet/createObjectSet.js\";\nimport { hydrateAttachmentFromRidInternal } from \"../public-utils/hydrateAttachmentFromRid.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport { augmentRequestContext } from \"../util/augmentRequestContext.js\";\nimport { createObjectSpecifierFromPrimaryKey } from \"../util/objectSpecifierUtils.js\";\nimport { toDataValueQueries } from \"../util/toDataValueQueries.js\";\nimport type { QueryParameterType, QueryReturnType } from \"./types.js\";\n\nexport async function applyQuery<\n  QD extends QueryDefinition<any>,\n  P extends QueryParameterType<CompileTimeMetadata<QD>[\"parameters\"]>,\n>(\n  client: MinimalClient,\n  query: QD,\n  params?: P,\n): Promise<\n  QueryReturnType<CompileTimeMetadata<QD>[\"output\"]>\n> {\n  const qd = await client.ontologyProvider.getQueryDefinition(\n    query.apiName,\n    query.isFixedVersion ? query.version : undefined,\n  );\n\n  const response = await OntologiesV2.Queries.execute(\n    addUserAgentAndRequestContextHeaders(\n      augmentRequestContext(client, _ => ({ finalMethodCall: \"applyQuery\" })),\n      query,\n    ),\n    await client.ontologyRid,\n    query.apiName,\n    {\n      parameters: params\n        ? await remapQueryParams(\n          params as { [parameterId: string]: any },\n          client,\n          qd.parameters,\n        )\n        : {},\n    },\n    { version: qd.version },\n  );\n  const objectOutputDefs = await getRequiredDefinitions(qd.output, client);\n  const remappedResponse = await remapQueryResponse(\n    client,\n    qd.output,\n    response.value,\n    objectOutputDefs,\n  );\n  return remappedResponse as QueryReturnType<CompileTimeMetadata<QD>[\"output\"]>;\n}\n\nasync function remapQueryParams(\n  params: { [parameterId: string]: any },\n  client: MinimalClient,\n  paramTypes: Record<string, QueryParameterDefinition<any>>,\n): Promise<{ [parameterId: string]: any }> {\n  const parameterMap: { [parameterName: string]: unknown } = {};\n  for (const [key, value] of Object.entries(params)) {\n    parameterMap[key] = await toDataValueQueries(\n      value,\n      client,\n      paramTypes[key],\n    );\n  }\n  return parameterMap;\n}\n\nasync function remapQueryResponse<\n  Q extends ObjectTypeDefinition,\n  T extends QueryDataTypeDefinition<Q | never>,\n>(\n  client: MinimalClient,\n  responseDataType: T,\n  responseValue: DataValue,\n  definitions: Map<string, ObjectOrInterfaceDefinition>,\n): Promise<QueryReturnType<T>> {\n  // handle null responses\n  if (responseValue == null) {\n    if (responseDataType.nullable) {\n      return undefined as unknown as QueryReturnType<typeof responseDataType>;\n    } else {\n      throw new Error(\"Got null response when nullable was not allowed\");\n    }\n  }\n\n  if (\n    responseDataType.multiplicity != null\n    && responseDataType.multiplicity\n  ) {\n    const withoutMultiplicity = { ...responseDataType, multiplicity: false };\n    for (let i = 0; i < responseValue.length; i++) {\n      responseValue[i] = await remapQueryResponse(\n        client,\n        withoutMultiplicity,\n        responseValue[i],\n        definitions,\n      );\n    }\n    return responseValue as QueryReturnType<typeof responseDataType>;\n  }\n\n  switch (responseDataType.type) {\n    case \"union\": {\n      throw new Error(\"Union return types are not yet supported\");\n    }\n\n    case \"set\": {\n      for (let i = 0; i < responseValue.length; i++) {\n        responseValue[i] = await remapQueryResponse(\n          client,\n          responseDataType.set,\n          responseValue[i],\n          definitions,\n        );\n      }\n\n      return responseValue as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"attachment\": {\n      return hydrateAttachmentFromRidInternal(\n        client,\n        responseValue,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n    case \"object\": {\n      const def = definitions.get(responseDataType.object);\n      if (!def || def.type !== \"object\") {\n        throw new Error(\n          `Missing definition for ${responseDataType.object}`,\n        );\n      }\n      return createQueryObjectResponse(\n        responseValue,\n        def,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n\n    case \"objectSet\": {\n      const def = definitions.get(responseDataType.objectSet);\n      if (!def) {\n        throw new Error(\n          `Missing definition for ${responseDataType.objectSet}`,\n        );\n      }\n      if (typeof responseValue === \"string\") {\n        return createObjectSet(def, client, {\n          type: \"intersect\",\n          objectSets: [\n            { type: \"base\", objectType: responseDataType.objectSet },\n            { type: \"reference\", reference: responseValue },\n          ],\n        }) as QueryReturnType<typeof responseDataType>;\n      }\n\n      return createObjectSet(\n        def,\n        client,\n        responseValue,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n    case \"struct\": {\n      // figure out what keys need to be fixed up\n      for (const [key, subtype] of Object.entries(responseDataType.struct)) {\n        if (requiresConversion(subtype)) {\n          responseValue[key] = await remapQueryResponse(\n            client,\n            subtype,\n            responseValue[key],\n            definitions,\n          );\n        }\n      }\n\n      return responseValue as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"map\": {\n      const map = {} as any;\n\n      invariant(Array.isArray(responseValue), \"Expected array entry\");\n      for (const entry of responseValue) {\n        invariant(entry.key, \"Expected key\");\n        invariant(entry.value, \"Expected value\");\n        const key = responseDataType.keyType.type === \"object\"\n          ? getObjectSpecifier(\n            entry.key,\n            responseDataType.keyType.object,\n            definitions,\n          )\n          : entry.key;\n        const value = await remapQueryResponse(\n          client,\n          responseDataType.valueType,\n          entry.value,\n          definitions,\n        );\n        map[key] = value;\n      }\n      return map;\n    }\n\n    case \"twoDimensionalAggregation\": {\n      const result: {\n        key: AllowedBucketKeyTypes;\n        value: AllowedBucketTypes;\n      }[] = [];\n      for (const { key, value } of responseValue.groups) {\n        result.push({ key, value });\n      }\n      return result as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"threeDimensionalAggregation\": {\n      const result: {\n        key: AllowedBucketKeyTypes;\n        groups: { key: AllowedBucketKeyTypes; value: AllowedBucketTypes }[];\n      }[] = [];\n      for (const { key, groups } of responseValue.groups) {\n        const subResult: { key: any; value: any }[] = [];\n        for (const { key: subKey, value } of groups) {\n          subResult.push({ key: subKey, value });\n        }\n        result.push({ key, groups: subResult });\n      }\n      return result as QueryReturnType<typeof responseDataType>;\n    }\n  }\n\n  return responseValue as QueryReturnType<typeof responseDataType>;\n}\n\nasync function getRequiredDefinitions(\n  dataType: QueryDataTypeDefinition,\n  client: MinimalClient,\n): Promise<Map<string, ObjectOrInterfaceDefinition>> {\n  const result = new Map<string, ObjectOrInterfaceDefinition>();\n  switch (dataType.type) {\n    case \"objectSet\": {\n      const objectDef = await client.ontologyProvider.getObjectDefinition(\n        dataType.objectSet,\n      );\n      result.set(dataType.objectSet, objectDef);\n      break;\n    }\n    case \"object\": {\n      const objectDef = await client.ontologyProvider.getObjectDefinition(\n        dataType.object,\n      );\n      result.set(dataType.object, objectDef);\n      break;\n    }\n\n    case \"set\": {\n      return getRequiredDefinitions(dataType.set, client);\n    }\n\n    case \"map\": {\n      for (const value of [dataType.keyType, dataType.valueType]) {\n        for (\n          const [type, objectDef] of await getRequiredDefinitions(value, client)\n        ) {\n          result.set(type, objectDef);\n        }\n      }\n      break;\n    }\n\n    case \"struct\": {\n      for (const value of Object.values(dataType.struct)) {\n        for (\n          const [type, objectDef] of await getRequiredDefinitions(value, client)\n        ) {\n          result.set(type, objectDef);\n        }\n      }\n      break;\n    }\n    case \"attachment\":\n    case \"boolean\":\n    case \"date\":\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"string\":\n    case \"threeDimensionalAggregation\":\n    case \"timestamp\":\n    case \"twoDimensionalAggregation\":\n    case \"union\":\n      break;\n  }\n\n  return result;\n}\nfunction requiresConversion(dataType: QueryDataTypeDefinition) {\n  switch (dataType.type) {\n    case \"boolean\":\n    case \"date\":\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"string\":\n    case \"timestamp\":\n      return false;\n\n    case \"union\":\n      return true;\n\n    case \"struct\":\n      return Object.values(dataType.struct).some(requiresConversion);\n\n    case \"set\":\n      return requiresConversion(dataType.set);\n\n    case \"attachment\":\n    case \"objectSet\":\n    case \"twoDimensionalAggregation\":\n    case \"threeDimensionalAggregation\":\n    case \"object\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction getObjectSpecifier(\n  primaryKey: any,\n  objectTypeApiName: string,\n  definitions: Map<string, ObjectOrInterfaceDefinition>,\n): string {\n  const def = definitions.get(objectTypeApiName);\n  if (!def || def.type !== \"object\") {\n    throw new Error(\n      `Missing definition for ${objectTypeApiName}`,\n    );\n  }\n  return createObjectSpecifierFromPrimaryKey(\n    def,\n    primaryKey,\n  );\n}\n\nexport function createQueryObjectResponse<\n  Q extends ObjectTypeDefinition,\n>(\n  primaryKey: PrimaryKeyType<Q>,\n  objectDef: Q,\n): OsdkBase<Q> {\n  return {\n    $apiName: objectDef.apiName,\n    $title: undefined,\n    $objectType: objectDef.apiName,\n    $primaryKey: primaryKey,\n    $objectSpecifier: createObjectSpecifierFromPrimaryKey(\n      objectDef,\n      primaryKey,\n    ),\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  FetchPageArgs,\n  InterfaceDefinition,\n  Logger,\n  NullabilityAdherence,\n  ObjectOrInterfaceDefinition,\n  ObjectSet,\n  ObjectTypeDefinition,\n  Osdk,\n  PropertyKeys,\n  QueryDefinition,\n  SelectArg,\n} from \"@osdk/api\";\nimport type {\n  Experiment,\n  ExperimentFns,\n  MinimalObjectSet,\n} from \"@osdk/api/unstable\";\nimport {\n  __EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference,\n  __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid,\n  __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid,\n  __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks,\n} from \"@osdk/api/unstable\";\nimport type { ObjectSet as WireObjectSet } from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport { symbolClientContext as oldSymbolClientContext } from \"@osdk/shared.client\";\nimport { createBulkLinksAsyncIterFactory } from \"./__unstable/createBulkLinksAsyncIterFactory.js\";\nimport type { ActionSignatureFromDef } from \"./actions/applyAction.js\";\nimport { applyAction } from \"./actions/applyAction.js\";\nimport { additionalContext, type Client } from \"./Client.js\";\nimport { createMinimalClient } from \"./createMinimalClient.js\";\nimport { fetchMetadataInternal } from \"./fetchMetadata.js\";\nimport { MinimalLogger } from \"./logger/MinimalLogger.js\";\nimport type { MinimalClient } from \"./MinimalClientContext.js\";\nimport { fetchPage } from \"./object/fetchPage.js\";\nimport { fetchSingle } from \"./object/fetchSingle.js\";\nimport { createObjectSet } from \"./objectSet/createObjectSet.js\";\nimport type { ObjectSetFactory } from \"./objectSet/ObjectSetFactory.js\";\nimport { applyQuery } from \"./queries/applyQuery.js\";\nimport type { QuerySignatureFromDef } from \"./queries/types.js\";\n\n// We import it this way to keep compatible with CJS. If we referenced the\n// value of `symbolClientContext` directly, then we would have to a dynamic import\n// in `createClientInternal` which would make it async and a break.\n// Since this is just a string in `@osdk/shared.client2` instead of a symbol,\n// we can safely perform this trick.\ntype newSymbolClientContext =\n  // eslint-disable-next-line @typescript-eslint/consistent-type-imports\n  typeof import(\"@osdk/shared.client2\").symbolClientContext;\n\nclass ActionInvoker<Q extends ActionDefinition<any>>\n  implements ActionSignatureFromDef<Q>\n{\n  constructor(\n    clientCtx: MinimalClient,\n    actionDef: ActionDefinition<any>,\n  ) {\n    // We type the property as a generic function as binding `applyAction`\n    // doesn't return a type thats all that useful anyway\n    // The implements covers us for the most part here as this exact type doesn't\n    // escape this file\n    this.applyAction = applyAction.bind(undefined, clientCtx, actionDef);\n    this.batchApplyAction = applyAction.bind(undefined, clientCtx, actionDef);\n  }\n\n  applyAction: (...args: any[]) => any;\n  batchApplyAction: (...args: any[]) => any;\n}\n\nclass QueryInvoker<Q extends QueryDefinition<any>>\n  implements QuerySignatureFromDef<Q>\n{\n  constructor(\n    clientCtx: MinimalClient,\n    queryDef: QueryDefinition<any>,\n  ) {\n    this.executeFunction = applyQuery.bind(undefined, clientCtx, queryDef);\n  }\n\n  executeFunction: (...args: any[]) => any;\n}\n\n/** @internal */\nexport function createClientInternal(\n  objectSetFactory: ObjectSetFactory<any, any>, // first so i can bind\n  baseUrl: string,\n  ontologyRid: string | Promise<string>,\n  tokenProvider: () => Promise<string>,\n  options: { logger?: Logger } | undefined = undefined,\n  fetchFn: typeof globalThis.fetch = fetch,\n): Client {\n  if (typeof ontologyRid === \"string\") {\n    if (!ontologyRid.startsWith(\"ri.\")) {\n      throw new Error(\"Invalid ontology RID\");\n    }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    ontologyRid.then((ontologyRid) => {\n      if (!ontologyRid.startsWith(\"ri.\")) {\n        // FIXME this promise is not await so this just shows up as an unhandled promise rejection\n        throw new Error(\"Invalid ontology RID\");\n      }\n    });\n  }\n\n  const clientCtx: MinimalClient = createMinimalClient(\n    { ontologyRid },\n    baseUrl,\n    tokenProvider,\n    { ...options, logger: options?.logger ?? new MinimalLogger() },\n    fetchFn,\n    objectSetFactory,\n  );\n\n  return createClientFromContext(clientCtx);\n}\n\n/**\n * @internal\n */\nexport function createClientFromContext(clientCtx: MinimalClient) {\n  function clientFn<\n    T extends\n      | ObjectOrInterfaceDefinition\n      | ActionDefinition<any>\n      | QueryDefinition<any>\n      | Experiment<\"2.0.8\">\n      | Experiment<\"2.1.0\">,\n  >(o: T): T extends ObjectTypeDefinition ? ObjectSet<T>\n    : T extends InterfaceDefinition ? MinimalObjectSet<T>\n    : T extends ActionDefinition<any> ? ActionSignatureFromDef<T>\n    : T extends QueryDefinition<any> ? QuerySignatureFromDef<T>\n    : T extends Experiment<\"2.0.8\"> | Experiment<\"2.1.0\">\n      ? { invoke: ExperimentFns<T> }\n    : never\n  {\n    if (o.type === \"object\" || o.type === \"interface\") {\n      return clientCtx.objectSetFactory(o, clientCtx) as any;\n    } else if (o.type === \"action\") {\n      return new ActionInvoker(\n        clientCtx,\n        o,\n      ) as (T extends ActionDefinition<any>\n        // first `as` to the action definition for our \"real\" typecheck\n        ? ActionSignatureFromDef<T>\n        : never) as any; // then as any for dealing with the conditional return value\n    } else if (o.type === \"query\") {\n      return new QueryInvoker(\n        clientCtx,\n        o,\n      ) as (T extends QueryDefinition<any> ? QuerySignatureFromDef<T>\n        : never) as any;\n    } else if (o.type === \"experiment\") {\n      switch (o.name) {\n        case __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks.name:\n          return {\n            getBulkLinks: createBulkLinksAsyncIterFactory(\n              clientCtx,\n            ),\n          } as any;\n        case __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid.name:\n          return {\n            fetchOneByRid: async <\n              Q extends ObjectTypeDefinition,\n              const L extends PropertyKeys<Q>,\n              const R extends boolean,\n              const S extends false | \"throw\" = NullabilityAdherence.Default,\n            >(\n              objectType: Q,\n              rid: string,\n              options: SelectArg<Q, L, R, S>,\n            ) => {\n              return await fetchSingle(\n                clientCtx,\n                objectType,\n                options,\n                createWithRid(\n                  [rid],\n                ),\n              ) as Osdk<Q>;\n            },\n          } as any;\n        case __EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference.name:\n          return {\n            createMediaReference: async <\n              Q extends ObjectTypeDefinition,\n              const L extends PropertyKeys.Filtered<Q, \"mediaReference\">,\n            >(args: {\n              data: Blob;\n              fileName: string;\n              objectType: Q;\n              propertyType: L;\n            }) => {\n              const { data, fileName, objectType, propertyType } = args;\n              return await OntologiesV2.MediaReferenceProperties.upload(\n                clientCtx,\n                await clientCtx.ontologyRid,\n                objectType.apiName,\n                propertyType as string,\n                data,\n                {\n                  mediaItemPath: fileName,\n                  preview: true,\n                },\n              );\n            },\n          } as any;\n\n        case __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid.name:\n          return {\n            fetchPageByRid: async <\n              Q extends ObjectOrInterfaceDefinition,\n              const L extends PropertyKeys<Q>,\n              const R extends boolean,\n              const S extends false | \"throw\" = NullabilityAdherence.Default,\n            >(\n              objectOrInterfaceType: Q,\n              rids: string[],\n              options: FetchPageArgs<Q, L, R, any, S> = {},\n            ) => {\n              return await fetchPage(\n                clientCtx,\n                objectOrInterfaceType,\n                options,\n                createWithRid(rids),\n              );\n            },\n          } as any;\n      }\n\n      throw new Error(\"not implemented\");\n    } else {\n      throw new Error(\"not implemented\");\n    }\n  }\n\n  const fetchMetadata = fetchMetadataInternal.bind(\n    undefined,\n    clientCtx,\n  );\n\n  const symbolClientContext: newSymbolClientContext = \"__osdkClientContext\";\n\n  const client: Client = Object.defineProperties<Client>(\n    clientFn as Client,\n    {\n      [oldSymbolClientContext]: {\n        value: clientCtx,\n      },\n      [symbolClientContext]: {\n        value: clientCtx,\n      },\n      [additionalContext]: {\n        value: clientCtx,\n      },\n      fetchMetadata: {\n        value: fetchMetadata,\n      },\n    } satisfies Record<keyof Client, PropertyDescriptor>,\n  );\n\n  return client;\n}\n\nexport const createClient: (\n  baseUrl: string,\n  ontologyRid: string | Promise<string>,\n  tokenProvider: () => Promise<string>,\n  options?: {\n    logger?: Logger;\n  } | undefined,\n  fetchFn?: typeof fetch | undefined,\n) => Client = createClientInternal.bind(\n  undefined,\n  createObjectSet,\n);\n\nfunction createWithRid(\n  rids: string[],\n) {\n  const withRid: WireObjectSet = {\n    type: \"static\",\n    \"objects\": rids,\n  };\n\n  return withRid;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createSharedClientContext } from \"@osdk/shared.client.impl\";\nimport type { SharedClientContext } from \"@osdk/shared.client2\";\nimport { USER_AGENT } from \"./util/UserAgent.js\";\n\nexport interface PlatformClient extends SharedClientContext {}\n\n/**\n * Creates a client that can only be used with Platform APIs.\n *\n * If you already have an OSDK Client (from `createClient`), you do not need to\n * create one of these - those clients can be used with Platform APIs as well.\n *\n * @param baseUrl\n * @param tokenProvider\n * @param options Currently unused, reserved for future use.\n * @param fetchFn\n * @returns\n */\nexport function createPlatformClient(\n  baseUrl: string,\n  tokenProvider: () => Promise<string>,\n  options: undefined = undefined,\n  fetchFn: typeof globalThis.fetch = fetch,\n): PlatformClient {\n  return createSharedClientContext(\n    baseUrl,\n    tokenProvider,\n    USER_AGENT,\n    fetchFn,\n  );\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport invariant from \"tiny-invariant\";\n\nconst isoRegex =\n  /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:\\d{2})?$/;\n\n/**\n * Extracts the date from a ISO 8601 formatted date time string. Throws if the input is not in the correct format.\n *\n * @param dateTime An ISO 8601 formatted date time string\n * @returns The date part of the input string\n */\nexport const extractDate = (dateTime: string): string => {\n  invariant(\n    dateTime.length < 33,\n    \"Invalid date format. Provided input is too long.\",\n  );\n  invariant(\n    isoRegex.test(dateTime),\n    `Invalid date format. Expected ISO 8601 format, but received ${dateTime}`,\n  );\n  return extractDateFromIsoString(dateTime);\n};\n\n/**\n * Generates a string representation of the input date (YYYY-MM-DD). The resulting date string reflects the given date in UTC time.\n *\n * @param date\n * @returns The date part of a ISO 8601 formatted date time string\n */\nexport const extractDateInUTC = (date: Date): string => {\n  return extractDateFromIsoString(date.toISOString());\n};\n\n/**\n * Generates a string representation of the input date (YYYY-MM-DD). The resulting date string reflects the given date in the local time zone.\n *\n * @param date\n * @returns The date part of a ISO 8601 formatted date time string\n */\nexport const extractDateInLocalTime = (date: Date): string => {\n  return extractDateFromIsoString(generateOffsetUtcString(date));\n};\n\n/** @internal */\nexport const generateOffsetUtcString = (date: Date) => {\n  const offsetMs = date.getTimezoneOffset() * 60 * 1000;\n  return new Date(date.getTime() - offsetMs).toISOString();\n};\n\nconst extractDateFromIsoString = (dateTime: string) => {\n  return dateTime.split(\"T\")[0];\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,KAAC,SAAUA,SAAQ,SAAS;AAC1B,aAAO,YAAY,YAAY,OAAO,WAAW,cAAc,OAAO,UAAU,QAAQ,IACxF,OAAO,WAAW,cAAc,OAAO,MAAM,OAAO,OAAO,KAC1DA,UAAS,OAAO,eAAe,cAAc,aAAaA,WAAU,MAAMA,QAAO,aAAa,QAAQ;AAAA,IACzG,GAAG,SAAO,WAAY;AAAE;AAEtB,UAAIC,cAAa,SAAUC,QAAO,UAAU;AAC1C,mBAAW,YAAY,CAAC;AACxB,YAAI,OAAOA,WAAU,YAAY;AAC/B,gBAAM,IAAI,cAAc,0BAA0B;AAAA,QACpD;AAEA,YAAI,OAAO,aAAa,UAAU;AAChC,gBAAM,IAAI,cAAc,4BAA4B;AAAA,QACtD;AAEA,YAAI,SAAS,YAAY,UAAa,CAAC,kBAAkB,SAAS,OAAO,GAAG;AAC1E,gBAAM,IAAI,cAAc,oCAAoC;AAAA,QAC9D;AAEA,YAAI,SAAS,eAAe,UAAa,CAAC,kBAAkB,SAAS,UAAU,KAAK,OAAO,SAAS,eAAe,YAAY;AAC7H,gBAAM,IAAI,cAAc,kFAAkF;AAAA,QAC5G;AAEA,YAAI,SAAS,YAAY,UAAa,CAAC,MAAM,QAAQ,SAAS,OAAO,KAAK,OAAO,SAAS,YAAY,YAAY;AAChH,gBAAM,IAAI,cAAc,+CAA+C;AAAA,QACzE;AAEA,YAAI,eAAe;AAAA,UACjB,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,SAAS,CAAC;AAAA,QACZ;AAEA,mBAAW,OAAO,OAAO,cAAc,QAAQ;AAE/C,eAAO,SAASD,YAAW,OAAO,MAAM;AACtC,cAAI,UAAU,SAAS;AACvB,cAAI,aAAa,SAAS;AAC1B,cAAI,UAAU,SAAS;AAEvB,cAAI,QAAQ,KAAK,YAAY,QAAW;AACtC,gBAAI,kBAAkB,KAAK,OAAO,GAAG;AACnC,wBAAU,KAAK;AAAA,YACjB,OAAO;AACL,oBAAM,IAAI,cAAc,oCAAoC;AAAA,YAC9D;AAAA,UACF;AAEA,cAAI,QAAQ,KAAK,eAAe,QAAW;AACzC,gBAAI,kBAAkB,KAAK,UAAU,KAAM,OAAO,KAAK,eAAe,YAAa;AACjF,2BAAa,KAAK;AAAA,YACpB,OAAO;AACL,oBAAM,IAAI,cAAc,kFAAkF;AAAA,YAC5G;AAAA,UACF;AAEA,cAAI,QAAQ,KAAK,SAAS;AACxB,gBAAI,MAAM,QAAQ,KAAK,OAAO,KAAM,OAAO,KAAK,YAAY,YAAa;AACvE,wBAAU,KAAK;AAAA,YACjB,OAAO;AACL,oBAAM,IAAI,cAAc,+CAA+C;AAAA,YACzE;AAAA,UACF;AAGA,iBAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC5C,gBAAI,eAAe,SAAU,SAAS;AAGpC,kBAAI,SACF,OAAO,YAAY,eAAe,iBAAiB,UAC/C,MAAM,MAAM,IACZ;AACN,cAAAC,OAAM,QAAQ,IAAI,EACf,KAAK,SAAU,UAAU;AACxB,oBAAI,MAAM,QAAQ,OAAO,KAAK,QAAQ,QAAQ,SAAS,MAAM,MAAM,IAAI;AACrE,0BAAQ,QAAQ;AAAA,gBAClB,WAAW,OAAO,YAAY,YAAY;AACxC,sBAAI;AAEF,2BAAO,QAAQ,QAAQ,QAAQ,SAAS,MAAM,QAAQ,CAAC,EACpD,KAAK,SAAU,iBAAiB;AAC/B,0BAAG,iBAAiB;AAClB,8BAAM,SAAS,MAAM,QAAQ;AAAA,sBAC/B,OAAO;AACL,gCAAQ,QAAQ;AAAA,sBAClB;AAAA,oBACF,CAAC,EAAE,MAAM,MAAM;AAAA,kBACnB,SAAS,OAAO;AACd,2BAAO,KAAK;AAAA,kBACd;AAAA,gBACF,OAAO;AACL,sBAAI,UAAU,SAAS;AACrB,0BAAM,SAAS,MAAM,QAAQ;AAAA,kBAC/B,OAAO;AACL,4BAAQ,QAAQ;AAAA,kBAClB;AAAA,gBACF;AAAA,cACF,CAAC,EACA,MAAM,SAAU,OAAO;AACtB,oBAAI,OAAO,YAAY,YAAY;AACjC,sBAAI;AAEF,4BAAQ,QAAQ,QAAQ,SAAS,OAAO,IAAI,CAAC,EAC1C,KAAK,SAAU,iBAAiB;AAC/B,0BAAG,iBAAiB;AAClB,8BAAM,SAAS,OAAO,IAAI;AAAA,sBAC5B,OAAO;AACL,+BAAO,KAAK;AAAA,sBACd;AAAA,oBACF,CAAC,EACA,MAAM,SAASC,QAAO;AACrB,6BAAOA,MAAK;AAAA,oBACd,CAAC;AAAA,kBACL,SAAQA,QAAO;AACb,2BAAOA,MAAK;AAAA,kBACd;AAAA,gBACF,WAAW,UAAU,SAAS;AAC5B,wBAAM,SAAS,OAAO,IAAI;AAAA,gBAC5B,OAAO;AACL,yBAAO,KAAK;AAAA,gBACd;AAAA,cACF,CAAC;AAAA,YACL;AAEA,qBAAS,MAAM,SAAS,OAAO,UAAU;AACvC,kBAAI,QAAS,OAAO,eAAe,aACjC,WAAW,SAAS,OAAO,QAAQ,IAAI;AACzC,yBAAW,WAAY;AACrB,6BAAa,EAAE,OAAO;AAAA,cACxB,GAAG,KAAK;AAAA,YACV;AAEA,yBAAa,CAAC;AAAA,UAChB,CAAC;AAAA,QACH;AAAA,MACF;AAEA,eAAS,kBAAkB,OAAO;AAChC,eAAO,OAAO,UAAU,KAAK,KAAK,SAAS;AAAA,MAC7C;AAEA,eAAS,cAAc,SAAS;AAC9B,aAAK,OAAO;AACZ,aAAK,UAAU;AAAA,MACjB;AAEA,aAAOF;AAAA,IAET,CAAE;AAAA;AAAA;;;AChGK,IAAMG,sBAqBT;EACF,cAAc;EACd,eAAe;EACf,MAAM;EACN,SAAS;EACT,UAAU;EACV,KAAK;EACL,aAAa;EACb,cAAc;EACd,MAAM;EACN,QAAQ;EACR,UAAU;EACV,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,SAAS;EACT,QAAQ;EACR,SAAS;EACT,iBAAiB;EACjB,gBAAgB;EAChB,kBAAkB;AACpB;;;AChFO,IAAMC,sBAqBT;EACF,OAAO;EACP,WAAW;EACX,OAAO;EACP,UAAU;EACV,WAAW;EACX,MAAM;EACN,OAAO;EACP,QAAQ;EACR,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,QAAQ;EACR,SAAS;EACT,OAAO;EACP,SAAS;EACT,UAAU;EACV,MAAM;EACN,QAAQ;EACR,SAAS;AACX;;;ACMO,IAAMC,kBAuBT;EACF,GAAGC;EACH,WAAW;EACX,YAAY;AACd;;;AClEO,SAASC,KAAQC,GAAgC;AACtD,SAAQ,WAAWA;AACrB;;;AC+BO,IAAMC,4BAuBT;EACF,MAAM;EACN,gBAAgB;EAChB,GAAGC;AACL;;;ACrEO,IAAMC,mBAAN,cAA+BC,MAAkC;EAQtEC,YACEC,SACAC,WACAC,WACAC,YACAC,iBACAC,YACA;AACA,UAAML,OAAO;AACb,SAAKA,UAAUA;AACf,SAAKC,YAAYA;AACjB,SAAKC,YAAYA;AACjB,SAAKC,aAAaA;AAClB,SAAKC,kBAAkBA;AACvB,SAAKC,aAAaA;EACpB;AACF;;;ACtBO,IAAMC,eAAN,cAA2BC,iBAAiB;EAEjDC,YACEC,SACAC,WACAC,eACAC,YACA;AACA,UAAMH,SAASC,WAAWG,QAAWD,UAAU;AAC/C,SAAKD,gBAAgBA;EACvB;AACF;;;ACXO,IAAMG,wBAAN,cAAoCC,MAAM;EAC/CC,YAAmBC,YAAsC;AACvD,UAAM,uBAAuBC,KAAKC,UAAUF,YAAY,MAAM,CAAC,CAAC;AAAE,SADjDA,aAAAA;EAEnB;AACF;;;ACyBO,IAAMG,0DAKP;EACFC,MAAM;EACNC,MAAM;EACNC,SAAS;AACX;;;ACnBK,IAAMC,mDAIT;EACFC,MAAM;EACNC,MAAM;EACNC,SAAS;AACX;;;ACLO,IAAMC,oDAIT;EACFC,MAAM;EACNC,MAAM;EACNC,SAAS;AACX;;;ACpBO,IAAMC,kDAIT;EACFC,MAAM;EACNC,MAAM;EACNC,SAAS;AACX;;;ACpCA;;;;;;AAiBA,IAAMC,SAAS,CAAC,GAAG,wCAAwC,CAAC;AAkBrD,SAASC,MAAMC,SAASC,MAAM;AACjC,SAAOC,qBAAsBF,MAAMF,QAAQ,GAAGG,IAAI;AACtD;AACA,IAAME,cAAc,CAAC,GAAG,6CAA6C,CAAC;AAkB/D,SAASC,WAAWJ,SAASC,MAAM;AACtC,SAAOC,qBAAsBF,MAAMG,aAAa,GAAGF,IAAI;AAC3D;AACA,IAAMI,cAAc,CAAC,GAAG,6CAA6C,CAAC;AAoB/D,SAASC,WAAWN,SAASC,MAAM;AACtC,SAAOC,qBAAsBF,MAAMK,aAAa,GAAGJ,IAAI;AAC3D;;;ACjFA;;;;;;AAiBA,IAAMM,QAAQ,CAAC,GAAG,kCAAkC,CAAC;AAc9C,SAASC,KAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,OAAO,GAAGG,IAAI;AACrD;AACA,IAAME,OAAO,CAAC,GAAG,sCAAsC,CAAC;AAWjD,SAASC,IAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,MAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,YAAY,CAAC,GAAG,4CAA4C,CAAC;AAW5D,SAASC,SAASN,SAASC,MAAM;AACpC,SAAOC,qBAAsBF,MAAMK,WAAW,GAAGJ,IAAI;AACzD;;;AC7DA;;aAAAM;EAAA;;;AAiBA,IAAMC,UAAU,CAAC,GAAG,qCAAqC,GAAG,KAAK;AAgB1D,SAASC,OAAOC,SAASC,MAAM;AAjCtC;AAkCI,QAAMC,eAAe;IACjB,GAAGD,KAAK,CAAC;IACT,kBAAgBA,UAAK,CAAC,MAANA,mBAAU,oBAAmBA,KAAK,CAAC,EAAEE;IACrD,kBAAkBF,KAAK,CAAC,EAAEG,KAAKC,SAAS;EAC5C;AACA,SAAOC,qBAAsBN,MAAMF,SAASG,KAAK,CAAC,GAAGA,KAAK,CAAC,GAAGC,YAAY;AAC9E;AACA,IAAMK,QAAQ,CAAC,GAAG,0CAAwC,EAAA,EAAM,KAAK;AAY9D,SAASC,KAAKR,SAASC,MAAM;AAChC,SAAOK,qBAAsBN,MAAMO,OAAO,GAAGN,IAAI;AACrD;AACA,IAAMQ,QAAO,CAAC,GAAG,gCAAgC;AAY1C,SAASC,KAAIV,SAASC,MAAM;AAC/B,SAAOK,qBAAsBN,MAAMS,OAAM,GAAGR,IAAI;AACpD;;;ACtEA;;;;;;;AAiBA,IAAMU,iBAAiB,CAAC,GAAG,sDAAsD,CAAC;AAY3E,SAASC,cAAcC,SAASC,MAAM;AACzC,SAAOC,qBAAsBF,MAAMF,gBAAgB,GAAGG,IAAI;AAC9D;AACA,IAAME,sBAAsB,CAAC,GAAG,0DAA0D,CAAC;AAYpF,SAASC,mBAAmBJ,SAASC,MAAM;AAC9C,SAAOC,qBAAsBF,MAAMG,qBAAqB,GAAGF,IAAI;AACnE;AACA,IAAMI,kBAAkB,CACpB,GACA,8DACA,GAAC,EAED,KAAK;AAaF,SAASC,eAAeN,SAASC,MAAM;AAC1C,SAAOC,qBAAsBF,MAAMK,iBAAiB,GAAGJ,IAAI;AAC/D;AACA,IAAMM,uBAAuB,CACzB,GACA,kEACA,GAAC,EAED,KAAK;AAeF,SAASC,oBAAoBR,SAASC,MAAM;AAC/C,SAAOC,qBAAsBF,MAAMO,sBAAsB,GAAGN,IAAI;AACpE;;;AC1FA;;;;AAiBA,IAAMQ,WAAW,CAAC,GAAG,4DAA4D;AAY1E,SAASC,QAAQC,SAASC,MAAM;AACnC,SAAOC,qBAAsBF,MAAMF,UAAU,GAAGG,IAAI;AACxD;;;AC/BA;;;;;AAiBA,IAAME,qBAAqB,CAAC,GAAG,gDAAgD,CAAC;AAuBzE,SAASC,kBAAkBC,SAASC,MAAM;AAC7C,SAAOC,qBAAsBF,MAAMF,oBAAoB,GAAGG,IAAI;AAClE;AACA,IAAME,mBAAmB,CAAC,GAAG,oDAAoD,CAAC;AAa3E,SAASC,gBAAgBJ,SAASC,MAAM;AAC3C,SAAOC,qBAAsBF,MAAMG,kBAAkB,GAAGF,IAAI;AAChE;;;AC1DA;;;;gBAAAI;EAAA;;AAiBA,IAAMC,mBAAmB,CAAC,GAAG,wDAAwD,GAAC,EAAI,KAAK;AAWxF,SAASC,gBAAgBC,SAASC,MAAM;AAC3C,SAAOC,qBAAsBF,MAAMF,kBAAkB,GAAGG,IAAI;AAChE;AACA,IAAME,oBAAoB,CAAC,GAAG,yDAAyD,CAAC;AAWjF,SAASC,iBAAiBJ,SAASC,MAAM;AAC5C,SAAOC,qBAAsBF,MAAMG,mBAAmB,GAAGF,IAAI;AACjE;AACA,IAAMI,WAAU,CAAC,GAAG,uDAAuD,GAAG,KAAK;AAY5E,SAASC,QAAON,SAASC,MAAM;AAClC,SAAOC,qBAAsBF,MAAMK,UAAS,GAAGJ,IAAI;AACvD;AACA,IAAMM,eAAe,CAAC,GAAG,+CAA+C,GAAG,KAAK;AAazE,SAASC,YAAYR,SAASC,MAAM;AACvC,SAAOC,qBAAsBF,MAAMO,cAAc,GAAGN,IAAI;AAC5D;;;AC3EA;;aAAAQ;EAAA;;cAAAC;EAAA;;AAiBA,IAAMC,SAAQ,CAAC,GAAG,kCAAkC,CAAC;AAe9C,SAASC,MAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,QAAO,GAAGG,IAAI;AACrD;AACA,IAAME,QAAO,CAAC,GAAG,sCAAsC,CAAC;AAWjD,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,mBAAmB,CAAC,GAAG,mDAAmD,CAAC;AAW1E,SAASC,gBAAgBN,SAASC,MAAM;AAC3C,SAAOC,qBAAsBF,MAAMK,kBAAkB,GAAGJ,IAAI;AAChE;AACA,IAAMM,yBAAyB,CAAC,GAAG,wDAAwD,CAAC;AAYrF,SAASC,sBAAsBR,SAASC,MAAM;AACjD,SAAOC,qBAAsBF,MAAMO,wBAAwB,GAAGN,IAAI;AACtE;AACA,IAAMQ,uBAAuB,CAAC,GAAG,4DAA4D,CAAC;AAYvF,SAASC,oBAAoBV,SAASC,MAAM;AAC/C,SAAOC,qBAAsBF,MAAMS,sBAAsB,GAAGR,IAAI;AACpE;;;AC5FA;;;aAAAU;EAAA,YAAAC;EAAA;;AAiBA,IAAMC,SAAQ,CAAC,GAAG,qCAAqC,CAAC;AAmBjD,SAASC,MAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,QAAO,GAAGG,IAAI;AACrD;AACA,IAAME,QAAO,CAAC,GAAG,yCAAyC,CAAC;AAgBpD,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,UAAU,CAAC,GAAG,4CAA4C,CAAC;AA4C1D,SAASC,OAAON,SAASC,MAAM;AAClC,SAAOC,qBAAsBF,MAAMK,SAAS,GAAGJ,IAAI;AACvD;AACA,IAAMM,aAAa,CAAC,GAAG,+CAA+C,CAAC;AAqBhE,SAASC,UAAUR,SAASC,MAAM;AACrC,SAAOC,qBAAsBF,MAAMO,YAAY,GAAGN,IAAI;AAC1D;;;AChIA;;mBAAAQ;EAAA;aAAAC;EAAA;;;;AAiBA,IAAMC,mBAAmB,CAAC,GAAG,iDAAiD,CAAC;AAYxE,SAASC,gBAAgBC,SAASC,MAAM;AAC3C,SAAOC,qBAAsBF,MAAMF,kBAAkB,GAAGG,IAAI;AAChE;AACA,IAAME,QAAO,CAAC,GAAG,mCAAmC;AAW7C,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,QAAQ,CAAC,GAAG,6CAA6C,CAAC;AAkBzD,SAASC,KAAKN,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMK,OAAO,GAAGJ,IAAI;AACrD;AACA,IAAMM,2BAA2B,CAAC,GAAG,gEAAgE,CAAC;AAuB/F,SAASC,wBAAwBR,SAASC,MAAM;AACnD,SAAOC,qBAAsBF,MAAMO,0BAA0B,GAAGN,IAAI;AACxE;AACA,IAAMQ,2BAA2B,CAAC,GAAG,yDAAyD,CAAC;AAyBxF,SAASC,wBAAwBV,SAASC,MAAM;AACnD,SAAOC,qBAAsBF,MAAMS,0BAA0B,GAAGR,IAAI;AACxE;AACA,IAAMU,cAAa,CAAC,GAAG,2CAA2C,CAAC;AAW5D,SAASC,WAAUZ,SAASC,MAAM;AACrC,SAAOC,qBAAsBF,MAAMW,aAAY,GAAGV,IAAI;AAC1D;;;ACtIA;;mBAAAY;EAAA;aAAAC;EAAA,YAAAC;EAAA,cAAAC;;AAiBA,IAAMC,SAAQ,CAAC,GAAG,kCAAkC,CAAC;AAuB9C,SAASC,MAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,QAAO,GAAGG,IAAI;AACrD;AACA,IAAME,QAAO,CAAC,GAAG,sCAAsC,CAAC;AAWjD,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,SAAS,CAAC,GAAG,wCAAwC,CAAC;AAWrD,SAASC,MAAMN,SAASC,MAAM;AACjC,SAAOC,qBAAsBF,MAAMK,QAAQ,GAAGJ,IAAI;AACtD;AACA,IAAMM,WAAU,CAAC,GAAG,yCAAyC,CAAC;AAiCvD,SAASC,QAAOR,SAASC,MAAM;AAClC,SAAOC,qBAAsBF,MAAMO,UAAS,GAAGN,IAAI;AACvD;AACA,IAAMQ,cAAa,CAAC,GAAG,4CAA4C,CAAC;AAW7D,SAASC,WAAUV,SAASC,MAAM;AACrC,SAAOC,qBAAsBF,MAAMS,aAAY,GAAGR,IAAI;AAC1D;;;ACxHA;;aAAAU;EAAA,uBAAAC;EAAA,YAAAC;EAAA;;AAiBA,IAAMC,SAAQ,CAAC,GAAG,gBAAgB;AAW3B,SAASC,MAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,QAAO,GAAGG,IAAI;AACrD;AACA,IAAME,QAAO,CAAC,GAAG,oBAAoB;AAW9B,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;AACA,IAAMI,oBAAmB,CAAC,GAAG,mCAAmC,CAAC;AAS1D,SAASC,iBAAgBN,SAASC,MAAM;AAC3C,SAAOC,qBAAsBF,MAAMK,mBAAkB,GAAGJ,IAAI;AAChE;AACA,IAAMM,gBAAgB,CAAC,GAAG,+BAA+B,CAAC;AASnD,SAASC,aAAaR,SAASC,MAAM;AACxC,SAAOC,qBAAsBF,MAAMO,eAAe,GAAGN,IAAI;AAC7D;;;ACpEA;;;;AAiBA,IAAMQ,WAAW,CAAC,GAAG,0CAA0C,CAAC;AAczD,SAASC,QAAQC,SAASC,MAAM;AACnC,SAAOC,qBAAsBF,MAAMF,UAAU,GAAGG,IAAI;AACxD;;;ACjCA;;aAAAE;EAAA,YAAAC;;AAiBA,IAAMC,SAAQ,CAAC,GAAG,iCAAiC,CAAC;AAc7C,SAASC,MAAKC,SAASC,MAAM;AAChC,SAAOC,qBAAsBF,MAAMF,QAAO,GAAGG,IAAI;AACrD;AACA,IAAME,QAAO,CAAC,GAAG,qCAAqC,CAAC;AAWhD,SAASC,KAAIJ,SAASC,MAAM;AAC/B,SAAOC,qBAAsBF,MAAMG,OAAM,GAAGF,IAAI;AACpD;;;AC/CA;;;;;;AAiBA,IAAMI,iBAAiB,CAAC,GAAG,gEAAgE,CAAC;AAYrF,SAASC,cAAcC,SAASC,MAAM;AACzC,SAAOC,qBAAsBF,MAAMF,gBAAgB,GAAGG,IAAI;AAC9D;AACA,IAAME,gBAAgB,CAAC,GAAG,+DAA+D,CAAC;AAYnF,SAASC,aAAaJ,SAASC,MAAM;AACxC,SAAOC,qBAAsBF,MAAMG,eAAe,GAAGF,IAAI;AAC7D;AACA,IAAMI,gBAAgB,CAClB,GACA,kEACA,GAAC,EAED,KAAK;AAaF,SAASC,aAAaN,SAASC,MAAM;AACxC,SAAOC,qBAAsBF,MAAMK,eAAe,GAAGJ,IAAI;AAC7D;;;ACnEA;;;;;AAiBA,IAAMM,kBAAkB,CAAC,GAAG,iEAAiE,CAAC;AAYvF,SAASC,eAAeC,SAASC,MAAM;AAC1C,SAAOC,qBAAsBF,MAAMF,iBAAiB,GAAGG,IAAI;AAC/D;AACA,IAAME,gBAAgB,CAClB,GACA,kEACA,GAAC,EAED,KAAK;AAaF,SAASC,aAAaJ,SAASC,MAAM;AACxC,SAAOC,qBAAsBF,MAAMG,eAAe,GAAGF,IAAI;AAC7D;;;ACpDA,eAAe,aACb,EAAE,SAAS,SAAS,aAAa,cAAc,GAC/C,KACA,QACA,MACA,QACA,aACA,QACA;AACA,MAAI,MAAM;AACR,QACE,gBAAgB,mBAAmB,gBAAgB,QAAQ,gBAAgB,YACxE,OAAO,SAAS,YAAY,gBAAgB,YAChD;AAAA,SACI;AACH,aAAO,KAAK,UAAU,IAAI;AAAA,IAC5B;AAAA,EACF;AACA,QAAM,cAAc,OAAO,QAAQ,UAAU,CAAC,CAAC,EAAE;AAAA,IAC/C,CAAC,CAAC,KAAK,KAAK,MAAM;AAChB,UAAI,SAAS,MAAM;AACjB,eAAO,CAAC;AAAA,MACV;AACA,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,eAAO,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,IAAI,CAAC;AAAA,MACxC;AACA,YAAM,cAAc,KAAK;AACzB,aAAO,YAAY,WAAW,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,WAAW,CAAC;AAAA,IAC5D;AAAA,EACF;AACA,QAAM,QAAQ,OAAO,KAAK,WAAW,EAAE,WAAW,IAC9C,KACA,IAAI,IAAI,gBAAgB,WAAW,EAAE,SAAS,CAAC;AACnD,QAAM,WAAW,OAAO,WAAW,OAAO,GAAG,OAAO,GAAG,WAAW,GAAG,GAAG,GAAG,KAAK,IAAI;AAAA,IAClF;AAAA,IACA,aAAa;AAAA,IACb,SAAS;AAAA,MACP,oBAAoB;AAAA,MACpB,gBAAgB,eAAe;AAAA,MAC/B,QAAQ,UAAU;AAAA,MAClB,GAAG,gBAAgB,EAAE,iBAAiB,UAAU,MAAM,cAAc,CAAC,GAAG,IAAI,CAAC;AAAA,IAC/E;AAAA,IACA,GAAG,OAAO,EAAE,KAAK,IAAI,CAAC;AAAA,EACxB,CAAC;AACD,MAAI;AACF,QAAI,SAAS,WAAW,KAAK;AAC3B,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,MAAM,SAAS,QAAQ;AACrC,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,aAAa,UAAU,QAAQ,SAAS,QAAQ,KAAK;AAAA,IACjE;AACA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,QAAI,iBAAiB,cAAc;AACjC,YAAM;AAAA,IACR,WAAW,iBAAiB,WAAW;AACrC,YAAM,IAAI,aAAa,WAAW,KAAK;AAAA,IACzC,OAAO;AACL,YAAM,IAAI,aAAa,SAAS,KAAK;AAAA,IACvC;AAAA,EACF;AACF;AACA,eAAe,SAAS,UAAU;AAChC,QAAM,cAAc,SAAS,QAAQ,IAAI,cAAc,KAAK,OACxD,SAAS,QAAQ,IAAI,cAAc,IACnC;AACJ,MAAI;AACF,QAAI,YAAY,SAAS,kBAAkB,GAAG;AAC5C,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B,WAAW,YAAY,SAAS,0BAA0B,GAAG;AAC3D,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B,OAAO;AACL,aAAO,MAAM,SAAS,KAAK;AAAA,IAC7B;AAAA,EACF,SAAS,OAAO;AACd,UAAM,IAAI,aAAa,SAAS,OAAO,SAAS,MAAM;AAAA,EACxD;AACF;AACA,IAAM,eAAN,MAAmB;AAAA,EAKjB,YAAY,WAAW,eAAe,QAAQ,MAAM;AAJpD;AACA;AACA;AACA;AAEE,SAAK,OAAO;AACZ,SAAK,gBAAgB;AACrB,SAAK,SAAS;AACd,SAAK,OAAO;AAAA,EACd;AAAA,EACA,WAAW;AACT,WAAO,KAAK;AAAA,MACV;AAAA,QACE,MAAM,KAAK;AAAA,QACX,eAAe,KAAK,iBAAiB,KAAK,cAAc,SAAS;AAAA,QACjE,QAAQ,KAAK;AAAA,QACb,MAAM,KAAK;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AExEA,eAAsB,iBAAiB,KAAK,SAAS;AACnD,SAAOI,aAAa,KAAK,eAAe,OAAO,OAAO;AACxD;ACNA,eAAsB,yBAAyB,KAAK,YAAY,SAAS;AACvE,SAAOA,aAAa,KAAK,uCAAuC,QAAQ,OAAO;AACjF;ACAA,eAAsB,2BAA2B,KAAK,SAAS;AAC7D,SAAOA,aAAa,KAAK,qCAAqC,QAAQ,OAAO;AAC/E;ACRA,eAAsB,kBAAkB,KAAK,SAAS;AACpD,SAAOA,aAAa,KAAK,0CAA0C,QAAQ,OAAO;AACpF;;;ACCO,SAASC,iBACdC,MACAC,OAC2C;AAC3C,SAAO;IACLD;IACA,CAACA,IAAI,GAAGC;EACV;AACF;;;ACdO,SAASC,mBACd;EAAEC;EAASC,OAAOC;EAASC;AAAmC,GAC9DC,aACgB;AAChB,SAAO;IACLJ;IACAI;IACAF;IACAC;EACF;AACF;;;ACbO,SAASE,WAAyCC,GAAoB;AAC3E,SAAOA,EAAEC;AACX;AACO,SAASC,eAIdC,SACA;EAAEC;AAAwC,GACd;AAC5B,SAAOA,YACH;IACA,GAAGD;IACHC;EACF,IACEC;AACN;AACA,gBAAuBC,uBACrBC,MACAC,QACAC,UACAC,gBAC2C;AAC3C,MAAIP,UAAyBO;AAE7B,SAAOP,SAAS;AACd,UAAMQ,IAAI,MAAMJ,KAAKJ,OAAO;AAC5B,eAAWS,KAAKJ,OAAOG,CAAC,GAAG;AACzB,YAAMC;IACR;AACAT,cAAUM,SAASN,SAASQ,CAAC;EAC/B;AACF;;;ACLO,SAASE,kBACdC,MACE,oBAAIC,IAAI,GACVC,IAGF;AAUE,WAASC,IAAIC,KAAQC,OAAU;AAC7BL,QAAIG,IAAIC,KAAYC,KAAK;AACzB,WAAOA;EACT;AAMA,SAAO;IAAEC,KAlBT,SAAaF,KAAQ;AACnB,UAAIG,IAAKP,IAAkBM,IAAIF,GAAU;AACzC,UAAIG,MAAMC,UAAaN,OAAOM,QAAW;AACvC,eAAOL,IAAIC,KAAKF,GAAGE,GAAG,CAAC;MACzB,OAAO;AACL,eAAOG;MACT;IACF;IAWcJ;IAAKM,QAJnB,SAAgBL,KAAQ;AACtB,aAAOJ,IAAIU,OAAON,GAAU;IAC9B;EAE0B;AAC5B;AA2BO,SAASO,uBACdC,MACAV,IACAW,mBAA6Cd,mBACvB;AACtB,QAAMe,QAAQD,iBACXD,SAAS,SAAS,oBAAIG,QAAQ,IAAI,oBAAId,IAAI,CAC7C;AACA,QAAMe,aAAaH,iBAChBD,SAAS,SAAS,oBAAIG,QAAQ,IAAI,oBAAId,IAAI,CAC7C;AAEA,QAAMgB,MAAM;IACVC,gBAAgB,SAAwBd,KAAQ;AAC9C,aAAOU,MAAMR,IAAIF,GAAG;IACtB;IAEAE,KAAK,eAAmBF,KAAQ;AAC9B,aAAOU,MAAMR,IAAIF,GAAG,KAAKY,WAAWV,IAAIF,GAAG,KACtCa,IAAId,IAAIC,KAAKF,GAAGE,GAAG,CAAC;IAC3B;IAEAD,KAAK,eAAmBgB,GAAMC,GAAmB;AAE/C,UAAI;AACF,cAAMb,IAAI,MAAMS,WAAWb,IAAIgB,GAAGC,CAAC;AAEnCN,cAAMX,IAAIgB,GAAGZ,CAAC;AACdS,mBAAWP,OAAOU,CAAC;AACnB,eAAOZ;MACT,SAASc,GAAG;AAEVL,mBAAWP,OAAOU,CAAC;AACnB,cAAME;MACR;IACF;EACF;AAEA,SAAOJ;AACT;;;AChFA,IAAIK;AACJ,eAAeC,yBACbC,KACAC,aACA;AACAH,gDAAwB,MAAMI,kBAAkBF,KAAK,CAAC,CAAC;AACvD,GACEF,oBAAoBK,WAAWF,WAAW,IAACG,OAD7CC,UAAS,OAEP,2BAA2B,IAF7BA,UAAS,KAAA,IAAA;AAKT,SAAOP,oBAAoBK,WAAWF,WAAW,EAAEK;AACrD;AAQA,IAAMC,kBAAyBC,QAC7BC,uBAA6B,UAAUD,EAAE,EAAEE;AAE7C,IAAMC,gBAAuBH,QAC3BC,uBAA6B,QAAQD,EAAE,EAAEE;AA/E3C;AAiFO,IAAME,iBAAN,MAAqB;EAK1BC,YAAYC,QAAuB;AAJnC;AACA;AACA;AAYAC,0CAKKR,gBAAgB,OAAOS,QAAgB;AAC1C,aAAOC,QAAQC,QAAQ;QACrBC,oBAAoB,mBAAK,wBAAuBC,KAAK,MAAMJ,GAAG;QAC9DK,gBAAgB,mBAAK,oBAAmBD,KAAK,MAAMJ,GAAG;QACtDM,QAAQA,MAAMN;QACdO,YAAY,aAAa,MAAM,mBAAK,uBAAL,WAA2BP,MAAMQ;MAClE,CAAC;IACH,CAAC;AAEDC,8CAKKlB,gBACH,OAAOmB,kBAA0B;AAC/B,YAAMC,YAAY,MAAM,mBAAK,SAAQC,iBAAiBC,oBACpDH,aACF;AACA,aAAO,KAAKX,eAAeY,UAAUX,GAAG;IAC1C,CACF;AAEA,+CAAyBT,gBAAgB,OAAOuB,kBAA0B;AACxE,YAAMC,oBAAoB,MAAM,mBAAK,uBAAL,WAA2BD;AAC3D,aAAOE,4BAA4BD,iBAAiB;IACtD,CAAC;AAED,2CAAqBxB,gBAAgB,OAAOuB,kBAA0B;AACpE,YAAMG,YAAY,MAAMC,2BAA2B,mBAAK,OAAM;QAC5DC,gDAAgD;QAChDC,cAAc;QACdC,oBAAoB,CAAC;QACrBC,oBAAoB;UAClB,CAACR,aAAa,GAAG,MAAM,KAAKS,gBAAgB,EAAE;QAChD;MACF,CAAC;AACD,OACEN,UAAUA,UAAUH,aAAa,IAACU,OADpCC,UAAS,OAEP,4BAA4B,IAF9BA,UAAS,KAAA,IAAA;AAMT,YAAMC,MAAyB,CAAC;AAChC,iBAAWC,KAAKV,UAAUA,UAAUH,aAAa,GAAG;AAClD,cAAMc,SAASA,CACb;UAAEpB;QAA0B,GAC5BqB,UACAC,oBACG;AACH,cAAItB,SAAS;AACXkB,gBAAIlB,OAAO,IAAI;cACbA;cACAuB,qBAAqB;gBACnBC,aAAaL,EAAE3B;gBACf6B;cACF;cACAC;YACF;UACF;QACF;AACA,YAAIH,EAAEM,WAAWC,SAAS,aAAa;AACrC,gBAAM;YACJC,WAAW;cACTC;cACAC;cACAC;cACAC;YACF;UACF,IAAIZ,EAAEM;AACN,cAAIG,0BAA0BtB,eAAe;AAC3Cc,mBACES,uBACA,UACAC,oBACF;UACF;AACA,cAAIA,yBAAyBxB,eAAe;AAC1Cc,mBACEW,uBACA,UACAH,qBACF;UACF;QACF,WAAWT,EAAEM,WAAWC,SAAS,cAAc;AAC7C,gBAAM;YACJM,YAAY;cACVC;cACAC;cACAC;cACAC;YACF;UACF,IAAIjB,EAAEM;AACN,cAAIQ,mBAAmB3B,eAAe;AACpCc,mBACEc,4BACA,UACAC,cACF;UACF;AAEA,cAAIA,mBAAmB7B,eAAe;AACpCc,mBACEgB,4BACA,UACAH,cACF;UACF;QACF;MACF;AAEA,aAAOf;IACT,CAAC;AAED,8CAAwBnC,gBAAgB,OAAOuB,kBAA0B;AAvN3E;AAwNI,+BAAK,aAAL,mBAAc+B,MAAM,wBAAwB/B,aAAa;AACzD,YAAMgC,OAAO;QACXC,iBAAiB,CAAA;QACjBC,aAAa,CAAC;UACZC,YAAY;YACVf,MAAM;YACNpB;UACF;UACAoC,kBAAkB;YAChBhB,MAAM;YACNX,iBAAiB,MAAM,KAAKA,gBAAgB,EAAE;UAChD;QACF,CAAC;QACDN,WAAW,CAAA;QACXkC,qBAAqB,CAAA;QACrBC,gBAAgB,CAAA;QAChBC,YAAY,CAAA;QACZjC,cAAc;QACdkC,wBAAwBC;QACxBpC,gDAAgD;QAChDqC,uBAAuBD;QACvBE,aAAa,CAAA;QACbC,+BAA+BH;QAC/BI,gBAAgBJ;MAClB;AACA,YAAMK,WAAW,MAAMC,yBAAyB,mBAAK,OAAMN,QAAWT,IAAI;AAC1E,SACEc,cAASZ,YAAY,CAAC,MAAtBY,mBAAyBE,cAAUtC,OADrCC,UAAS,OAEP,8BAA8B,IAFhCA,UAAS,KAAA,IAAA;AAIT,aAAOmC,SAASZ,YAAY,CAAC,EAAEc;IACjC,CAAC;AAEDvC,2CAAoDhC,gBAAgB,YAE/DwE,yBAAyB,mBAAK,OAAM,MAAM,mBAAK,SAAQC,WAAW,CAAC;AA3P1E;AAuFI,uBAAK,SAAUlE;AACf,uBAAK,MAAOmE,mBAAmBnE,QAAQ,uBAAuB;AAC9D,uBAAK,SAAQc,iBAAiBC;AAE9B,uBAAK,UAAU,wBAAK,SAAQqD,WAAb,mBAAqBC,MAAM;MACxCC,KAAK;IACP;EACF;AA8JF;AA1KE;AACA;AACA;AAwCA;AAKA;AAsFA;AAuCK,IAAMC,sBAEkB1E,cAC5BG,YAA0BG,QAAQC,QAAQ,IAAIN,eAAeE,MAAM,CAAC,CACvE;AAEA,SAASkB,4BACPsD,WACuB;AACvB,IACEA,UAAUC,YAAYC,WAAW,KAAChD,OADpCC,UAAS,OAEP,uCAAuC6C,UAAUC,YAAYC,MAAM,EAAE,IAFvE/C,UAAS,KAAA,IAAA;AAIT,QAAMgD,QAAQH,UAAUC,YAAY,CAAC;AAErC,QAAMG,aAAaC,OAAOC,OAAON,UAAUO,aAAa,EAAEC,KAAKC,OAC7DA,EAAE/E,QAAQyE,KACZ;AACA,MAAI,CAACC,YAAY;AACf,UAAM,IAAIM,MAAM,sCAAsCP,KAAK,EAAE;EAC/D;AAEA,QAAMQ,6BAAqDN,OACxDO,YACCP,OAAOC,OAAON,UAAUO,aAAa,EAAEM,IACrCC,cAAY;AACV,WAAO,CAACA,SAASC,IAAID,SAAS5E,OAAO;EACvC,CACF,CACF;AAEF,QAAM8E,6BAAqDX,OACxDO,YACCP,OAAOC,OAAON,UAAUO,aAAa,EAAEM,IACrCC,cAAY;AACV,WAAO,CAACA,SAAS5E,SAAU4E,SAASC,EAAE;EACxC,CACF,CACF;AAEF,SAAO;IACL7E,SAAS8D,UAAU9D;IACnB6E,IAAIf,UAAUe;IACdJ;IACAK;IACAC,IAAI;MACFvF,KAAKyE;MACLjE,SAASkE,WAAWlE;MACpB0B,MAAMwC,WAAWxC;IACnB;EACF;AACF;;;AC7QO,SAASsD,gCAAgCC,KAAoB;AAClE,SAAO,iBACLC,MACAC,WAC+C;AAxCnD;AAyCI,QAAID,KAAKE,WAAW,GAAG;AACrB;IACF;AAEAH,cAAII,WAAJJ,mBAAYK,MAAM;AAGlB,KAAUJ,KAAKK,MAAMC,OAAKA,EAAEC,gBAAgBP,KAAK,CAAC,EAAEO,WAAW,IAACC,OAAhEC,UAAS,KAAA,IAATA,UAAS,KAAA,IAAA;AAET,UAAMC,MAAM,MAAMC,oBAAoBZ,GAAG;AACzC,UAAMa,SAAS,MAAMF,IAAIG,mBAAmBb,KAAK,CAAC,EAAEO,WAAW;AAE/D,UAAM,CAACO,eAAeC,iBAAiBC,eAAe,IAAI,MAAMC,QAAQC,IACtE,CACEN,OAAOO,OAAO,GACdP,OAAOQ,mBAAmB,GAC1BR,OAAOS,eAAe,CAAC,CAE3B;AAEA,UAAMC,cAAcC,OAAOC,YACzBD,OAAOE,QAAQT,eAAe,EAC3BU,OAAO,CAAC,CAACC,OAAO,MAAM1B,UAAU2B,SAASD,OAAO,CAAC,CACtD;AAGA,eAAWE,YAAY5B,WAAW;AAChC,UAAIqB,YAAYO,QAAQ,KAAK,MAAM;AACjC,cAAM,+BAA+BA;MACvC;IACF;AAEA,UAAMC,MAA+B;MACnCC,kBAAkB;QAChBC,SAASC;QACTC,wBAAwB;UAAEC,oBAAoB,CAAC;QAAE;QACjDC,mBAAmBH;QACnBI,WAAWJ;QACXK,aAAaL;QACbM,cAAcN;MAChB;MACAO,iBAAiB;QACfC,0BAA0B;QAC1BC,kBAAkB;MACpB;MACAC,UAAU;MACVC,WAAWX;MACXY,eAAe,CAAC;QACdC,mBAAmBvB,OAAOwB,OAAOzB,WAAW,EACzC0B,IAAyB,CAAC;UAAEC;QAAoB,MAC/CA,mBACF;QACFC,SAASC,iBACP,WACAnD,KAAKgD,IAAsBI,OACzBD,iBAAiB,mBAAmB;UAClCrC;UACAuC,kBAAkB;YAChB,CAACtC,gBAAgBuC,GAAGC,GAAG,GAAGJ,iBACxBpC,gBAAgBuC,GAAGE,KAAKA,MACxBJ,EAAEK,WACJ;UACF;QACF,CAAC,CACH,CACF;MACF,CAAC;IACH;AAEA,UAAMC,gBAAgBC,uBACpBC,iBAAiBC,KACf5B,QACA6B,mBAAmB/D,KAAK,wBAAwB,CAClD,GACAgE,YACA,CAACC,SAASC,eACRC,eAAe;MAAE,GAAGF;MAASpB,WAAWqB,WAAWrB;IAAU,GAAG;MAC9DA,WAAWqB,WAAWrB;IACxB,CAAC,GACHd,GACF;AAEA,qBAAiBqC,QAAQT,eAAe;AACtC,YAAM;QAAEU;MAAiB,IAAID;AAC7B,YAAME,MAAMC,WAAWF,kBAAkBpE,IAAI;AAE7C,iBAAWuE,QAAQJ,KAAKK,OAAO;AAC7B,cAAMC,MAAMF,KAAKA,KACfA,KAAKG,aAAa,WACd,gBACA,aAAa;AAEnB,cAAMpB,KAAKqB,qBAAqBF,GAAG;AACnC,cAAMG,qBACJ,OAAO,MAAMlE,IAAImE,eAAevB,GAAGxC,aAAa,GAC7CgE,WAAW;AAEhB,cAAMC,aAAaxD,OAAOwB,OAAOzB,WAAW,EAAE0D,KAAK1E,OACjDA,EAAE2C,oBAAoBgC,gBAAgBV,KAAKA,KAAKU,eAC7C3E,EAAE2C,oBAAoByB,aAAaH,KAAKG,QAC7C;AACA,YAAI,CAACK,WAAY,OAAM,IAAIG,MAAM,0BAA0B;AAE3D,cAAM;UACJC,QAAQd;UACRe,aAAaL,WAAWpD;UACxBiD;UACAS,eAAe/B,GAAGgC;QACpB;MACF;IACF;EACF;AACF;AAEA,SAAShB,WACPF,kBACApE,MACA;AACA,QAAM;IAAEsF;EAAQ,IAAIX,qBAAqBP,gBAAgB;AAEzD,QAAMC,MAAMrE,KAAKgF,KAAK5B,OAAKA,EAAEK,gBAAgB6B,OAAO;AACpD,MAAIjB,OAAO,MAAM;AACf,UAAM,IAAIa,MACR,iCAAiCI,OAAO,iBAC1C;EACF;AACA,SAAOjB;AACT;AAEA,SAASM,qBACPF,KACA;AACA,MAAI,UAAUA,OAAOA,IAAIjB,SAAS,mBAAmB;AACnD,UAAM,IAAI0B,MAAM,4CAA4C;EAC9D;AAEA,QAAMK,MAAMhE,OAAOE,QAAQgD,IAAIe,gBAAgBnC,gBAAgB;AAC/D,MAAIkC,IAAIrF,WAAW,GAAG;AACpB,UAAM,IAAIgF,MACR,oDACF;EACF;AAEA,SAAO;IACLpE,eAAe2D,IAAIe,gBAAgB1E;IACnCwE,SAAUC,IAAI,CAAC,EAAE,CAAC,EAAUA,IAAI,CAAC,EAAE,CAAC,EAAE/B,IAAI;EAC5C;AACF;;;AC5KO,SAASiC,yBACdC,UAAoCC,OACpCC,SACc;AACd,SAAO,eACLC,KACAC,aACA;AACA,QAAI,CAACA,aAAa;AAChB,aAAOJ,QAAQG,KAAK;QAAEE,SAAS,MAAMH,QAAQ,IAAII,QAAQ,CAAC;MAAE,CAAC;IAC/D;AAEA,WAAON,QAAQG,KAAK;MAClB,GAAGC;MACHC,SAAS,MAAMH,QAAQ,IAAII,QAAQF,YAAYC,OAAO,CAAC;IACzD,CAAC;EACH;AACF;;;ACPO,SAASE,mBAAmBC,UAAwBC,OAAO;AAChE,SAAO,eACLC,KACAC,aACmB;AACnB,QAAIC;AAEJ,QAAI;AACFA,iBAAW,MAAMJ,QAAQE,KAAKC,WAAW;IAC3C,SAASE,GAAG;AACV,YAAMC,aAAaD,GAAG,0BAA0B;IAClD;AAEA,QAAI,CAACD,SAASG,IAAI;AAChB,YAAMC,kBACJ,mBAAmBJ,SAASK,MAAM,IAAIL,SAASM,UAAU;AAE3D,UAAIN,SAASO,QAAQC,IAAI,cAAc,MAAM,cAAc;AACzD,cAAMC,aAAa,MAAMT,SAASU,KAAK,GAAGV,SAASK,MAAM;MAC3D;AAEA,UAAIL,SAASO,QAAQC,IAAI,cAAc,MAAM,aAAa;AACxD,cAAMC,aACJL,iBACAJ,SAASK,QACT,IAAIM,MAAM,+BAA+B,MAAMX,SAASU,KAAK,CAAC,CAChE;MACF;AAEA,UAAIE;AACJ,UAAI;AACFA,eAAO,MAAMZ,SAASa,KAAK;MAC7B,SAASZ,GAAG;AACV,cAAMQ,aACJL,iBACAJ,SAASK,QACTJ,aAAaU,QAAQV,IAAIa,MAC3B;MACF;AAEA,YAAM,IAAIC,kBACRH,6BAAMI,YACDZ,iBACLQ,6BAAMK,WACNL,6BAAMM,WACNlB,SAASK,QACTO,6BAAMO,iBACNP,6BAAMQ,UACR;IACF;AACA,WAAOpB;EACT;AACF;AAEA,SAASE,aACPD,GACAoB,gBAAwB,6BACxB;AACA,MAAIpB,aAAaU,OAAO;AACtB,WAAOF,aAAaR,EAAEe,SAASF,QAAWb,CAAC;EAC7C;AACA,SAAOQ,aAAaY,eAAeP,MAAS;AAC9C;AAEA,SAASL,aACPO,SACAM,YACAC,eACA;AACA,SAAO,IAAIC,aAAaR,SAASF,QAAWS,eAAeD,UAAU;AACvE;;;AC9EA,yBAAuB;AAEvB,IAAMG,gBAAgB;AACtB,IAAMC,gBAAgB;AACtB,IAAMC,cAAc;AAEb,SAASC,oBACdC,QASuC;AACvC,aAAOC,mBAAAA,SAAWD,QAAO;IACvBE,WAAWC,SAAS;AAClB,YAAMC,QAAQR,gBAAgB,KAAKO;AACnC,YAAME,SAASD,QAAQP,iBAAiBS,KAAKC,OAAO,IAAI,IAAI;AAC5D,aAAOH,QAAQC;IACjB;IACAG,QAAQL,SAASM,OAAOC,UAAU;AAChC,YAAMC,UAASD,qCAAUC,WAAU;AACnC,aACE,EAAEA,UAAU,OAAOA,SAAS,QACzBC,YAAYH,KAAK,KACjBN,UAAUL;IAEjB;EACF,CAAC;AACH;AAEA,SAASc,YAAYC,GAAiB;AACpC,MAAIA,aAAaC,kBAAkB;AACjC,QACED,EAAEE,eAAeC,uBACdH,EAAEE,eAAeE,mBACpB;AACA,aAAO;IACT;EACF;AACA,SAAO;AACT;AAEA,IAAMD,sBAAsB;AAC5B,IAAMC,oBAAoB;;;AC7CnB,IAAMC,uCAAuCA,CAClDC,QACAC,kBACmB;EACnB,GAAGD;EACHE,OAAOC,yBACLH,OAAOE,OACNE,aAAY;AACXA,YAAQC,IACN,0BACAC,KAAKC,UAAUP,OAAOQ,cAAc,CACtC;AAEA,QAAIP,aAAaQ,cAAc;AAC7BL,cAAQC,IACN,oBACAJ,aAAaQ,aAAaC,cAC5B;IACF;AACA,WAAON;EACT,CACF;AACF;;;ACKO,IAAMO,wBAAwBA,CACnCC,QACAC,aACmB;EACnB,GAAGD;EACHE,gBAAgB;IACd,GAAGF,OAAOE;IACV,GAAGD,QAAQD,OAAOE,cAAc;EAClC;AACF;;;ACtCO,SAASC,mBAAmBC,GAA+B;AAChE,SAAO,OAAOA,MAAM,YAAY,UAAUA,KAAK,UAAUA,KACpDA,EAAEC,gBAAgBC;AACzB;AAEO,SAASC,iBACdH,GACuC;AACvC,SAAO,OAAOA,MAAM,YAAYA,aAAaE,QAAQ,UAAUF;AACjE;AAEO,SAASI,uBACdH,MACAI,MACkB;AAClB,SAAO;IAAEJ;IAAMI;EAAK;AACtB;;;AChBO,SAASC,iBAAiBC,GAA6B;AAC5D,SAAO,OAAOA,MAAM,YACf,OAAOA,EAAEC,aAAa,YACtB,eAAeD,KACf,OAAOA,EAAEE,cAAc,YACvBF,EAAEE,UAAUC,SAAS,sBACrB,sBAAsBH,EAAEE,aACxB,OAAOF,EAAEE,UAAUE,qBAAqB,YACxC,OAAOJ,EAAEE,UAAUE,iBAAiBC,gBAAgB,YACpD,OAAOL,EAAEE,UAAUE,iBAAiBE,oBAAoB,YACxD,OAAON,EAAEE,UAAUE,iBAAiBG,iBAAiB;AAC5D;AAEO,SAASC,cAAcR,GAA0B;AACtD,SAAO,OAAOA,MAAM,YACf,UAAUA,KACV,OAAOA,EAAES,SAAS,YAClB,UAAUT,KACV,OAAOA,EAAEU,SAAS,YAClBV,EAAEU,gBAAgBC;AACzB;;;ACPO,SAASC,iBACdC,WAC8B;AAC9B,QAAMC,OAAOD,UAAUE,YAAY,GAAG;AACtC,MAAID,SAAS,GAAI,QAAO,CAACE,QAAWH,SAAS;AAC7C,SAAO,CAACA,UAAUI,MAAM,GAAGH,IAAI,GAAGD,UAAUI,MAAMH,OAAO,CAAC,CAAC;AAC7D;AAGO,SAASI,0BAGdC,aACAC,mBACmB;AACnB,MAAI,UAAUD,aAAa;AACzB,WAAO;MACLE,MAAM;MACNC,OAAQH,YAAYI,KAA0BC,IAC3CC,YAAWP,0BAA0BO,QAAQL,iBAAiB,CACjE;IACF;EACF,WAAW,SAASD,aAAa;AAC/B,WAAO;MACLE,MAAM;MACNC,OAAQH,YAAYO,IAAyBF,IAC1CC,YAAWP,0BAA0BO,QAAQL,iBAAiB,CACjE;IACF;EACF,WAAW,UAAUD,aAAa;AAChC,WAAO;MACLE,MAAM;MACNC,OAAOJ,0BACLC,YAAYQ,MACZP,iBACF;IACF;EACF;AAEA,QAAMQ,QAAQC,OAAOC,QAAQX,WAAW;AAExC,MAAIS,MAAMG,WAAW,GAAG;AACtB,WAAOC,gBAAgBJ,MAAM,CAAC,GAAGR,iBAAiB;EACpD;AAEA,SAAO;IACLC,MAAM;IACNC,OAAOM,MAAMJ,IACXS,OAAKD,gBAAgBC,GAAGb,iBAAiB,CAC3C;EACF;AACF;AAEA,SAASc,kBACPC,MACAC,YACAC,oBACAC,OACmB;AACnB,SAAO;IACLjB,MAAMe,eAAe,YACjB,sBACA;;;;;;IAMJ,GAAIC,sBAAsB,QAAQ;MAAEA;IAAmB;IACvDC;IACAhB,OAAO;MACLiB,SAAS;QACPlB,MAAM;QACNmB,aAAa,CAACL,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC;MAChC;MACAM,aAAa;QACXpB,MAAM;QACNmB,aAAa,CAACL,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC;MAChC;IACF;EACF;AACF;AAEA,SAASO,qBACPF,aACAJ,YACAC,oBACAC,OACmB;AACnB,SAAO;IACLjB,MAAMe;IACN,GAAIC,sBAAsB,QAAQ;MAAEA;IAAmB;IACvDC;IACAhB,OAAO;MACLD,MAAM;MACNmB;IACF;EACF;AACF;AAEA,SAASR,gBACP,CAACW,WAAWC,MAAM,GAClBxB,mBACAyB,qBACmB;AACnB,IACED,UAAU,QAAIE,OADhBC,UAAS,OAEP,kEAAkE,IAFpEA,UAAS,KAAA,IAAA;AAKT,QAAMV,qBACJQ,uBAAuB,OACnB;IACAxB,MAAM;IACN,GAAGwB;IACHG,iBAAiBC,qBACfJ,oBAAoBG,iBACpB5B,iBACF;EACF,IACEJ;AACN,QAAMsB,QAAQO,uBAAuB,OACjCI,qBAAqBN,WAAWvB,iBAAiB,IACjDJ;AAEJ,MACE,OAAO4B,WAAW,YAAY,OAAOA,WAAW,YAC7C,OAAOA,WAAW,WACrB;AAEA,WAAO;MACLvB,MAAM;MACN,GAAIgB,sBAAsB,QACrB;QAAEA;MAAmB;MAC1BC;MACAhB,OAAOsB;IACT;EACF;AAEA,QAAMM,eAAerB,OAAOsB,KAAKP,MAAM;AAIvC,QAAMQ,gBAAgBF,aAAaG,KAAMC,SAAQA,IAAIC,WAAW,GAAG,CAAC;AACpE,IACE,CAACH,iBACIF,aAAanB,WAAW,KAACe,OAFhCC,UAAS,OAGP,kIAAkI,IAHpIA,UAAS,KAAA,IAAA;AAMT,MAAI,CAACK,eAAe;AAClB,UAAMI,eAAe3B,OAAOC,QAAQc,MAAM;AAC1C,MACEY,aAAazB,WAAW,KAACe,OAD3BC,UAAS,OAEP,2FAA2F,IAF7FA,UAAS,KAAA,IAAA;AAIT,UAAMU,qBAAqBP,aAAa,CAAC;AACzC,WAAOlB,gBAAgBH,OAAOC,QAAQc,MAAM,EAAE,CAAC,GAAGxB,mBAAmB;MACnE4B,iBAAiBL;MACjBc;IACF,CAAC;EACH;AAEA,QAAMC,WAAWR,aAAa,CAAC;AAC/B,IAAUN,OAAOc,QAAQ,KAAK,QAAIZ,OAAlCC,UAAS,KAAA,IAATA,UAAS,KAAA,IAAA;AAET,MAAIW,aAAa,OAAO;AACtB,WAAO;MACLrC,MAAM;MACNC,OAAO;QACLD,MAAM;QACN,GAAIgB,sBAAsB,QAAQ;UAAEA;QAAmB;QACvDC;QACAhB,OAAOsB,OAAOc,QAAQ;MACxB;IACF;EACF;AAEA,MAAIA,aAAa,WAAW;AAC1B,UAAMC,aAAaf,OAAOc,QAAQ;AAElC,QAAIE,MAAMC,QAAQF,UAAU,GAAG;AAC7B,aAAOzB,kBAAkByB,YAAYD,UAAUrB,oBAAoBC,KAAK;IAC1E,WAAW,WAAWqB,cAAcA,WAAWG,SAAS,MAAM;AAC5D,aAAO5B,kBACLyB,WAAWG,OACXJ,UACArB,oBACAC,KACF;IACF,WACG,eAAeqB,cAAc,SAASA,cACpCA,WAAWI,aAAa,QACxBJ,WAAWK,OAAO,MACrB;AACA,aAAO;QACL3C,MAAM;QACN,GAAIgB,sBAAsB,QAAQ;UAAEA;QAAmB;QACvDC;QACAhB,OAAO;UACL2C,QAAQL,MAAMC,QAAQF,WAAWK,GAAG,IAChC;YACA3C,MAAM;YACNmB,aAAamB,WAAWK;UAC1B,IACEL,WAAWK;UACfE,UAAU;YACR5C,OAAOqC,WAAWI,UAAU,CAAC;YAC7BI,MAAMC,oBAAoBT,WAAWI,UAAU,CAAC,CAAC;UACnD;QACF;MACF;IACF,OAAO;AACL,YAAMvB,cAAe,cAAcmB,aAC/BA,WAAWU,WACXV,WAAWnB;AACf,aAAOE,qBACLF,aACA,iBACAH,oBACAM,SACF;IACF;EACF;AACA,MAAIe,aAAa,eAAe;AAC9B,UAAMY,iBAAiB1B,OAAOc,QAAQ;AACtC,QAAIE,MAAMC,QAAQS,cAAc,GAAG;AACjC,aAAOpC,kBACLoC,gBACAZ,UACArB,oBACAC,KACF;IACF,WAAW,WAAWgC,kBAAkBA,eAAeR,SAAS,MAAM;AACpE,aAAO5B,kBACLoC,eAAeR,OACfJ,UACArB,oBACAC,KACF;IACF,OAAO;AACL,YAAME,cAAe,cAAc8B,iBAC/BA,eAAeD,WACfC,eAAe9B;AACnB,aAAOE,qBACLF,aACA,qBACAH,oBACAC,KACF;IACF;EACF;AAEA,MAAIoB,aAAa,uBAAuBA,aAAa,oBAAoB;AACvE,WAAO;MACLrC,MAAMqC,SAASa,UAAU,CAAC;MAC1B,GAAIlC,sBAAsB,QAAQ;QAAEA;MAAmB;MACvDC;MACAhB,OAAO,OAAOsB,OAAOc,QAAQ,MAAM,WAC/Bd,OAAOc,QAAQ,IACfd,OAAOc,QAAQ,EAAE,MAAM;MAC3Bc,OAAO,OAAO5B,OAAOc,QAAQ,MAAM,WAC/B,QACAd,OAAOc,QAAQ,EAAE,aAAa,KAAK;IACzC;EACF;AAEA,SAAO;IACLrC,MAAMqC,SAASa,UAAU,CAAC;IAC1B,GAAIlC,sBAAsB,QAAQ;MAAEA;IAAmB;IACvDC;IACAhB,OAAOsB,OAAOc,QAAQ;EACxB;AACF;AAKA,SAAST,qBACPN,WACAvB,mBACA;AACA,MAAIA,kBAAkBC,SAAS,aAAa;AAC1C,UAAM,CAACoD,eAAe,IAAI7D,iBAAiBQ,kBAAkBsD,OAAO;AACpE,UAAM,CAACC,mBAAmBC,cAAc,IAAIhE,iBAAiB+B,SAAS;AACtE,WAAQgC,qBAAqB,QAAQF,mBAAmB,OACpD,GAAGA,eAAe,IAAIG,cAAc,KACpCjC;EACN;AACA,SAAOA;AACT;;;AC5SO,SAASkC,iCACdC,gBACAC,eAMA;AAKA,QAAMC,aAOA;IACFC,MAAM;AACJ,aAAOJ,iCAAiC;QACtCK,MAAM;QACNC,UAAUL;MACZ,GAAGC,aAAa;IAClB;IACAK,SAAS;AACP,aAAOP,iCAAiC;QACtCK,MAAM;QACNC,UAAUL;MACZ,GAAGC,aAAa;IAClB;IACAM,IAAIC,OAAO;AACT,aAAOT,iCAAiC;QACtCK,MAAM;QACNK,YAAY,CACVT,gBACAU,qBAAqBF,OAAOP,aAAa,CAAC;MAE9C,GAAGA,aAAa;IAClB;IACAU,IAAIH,OAAO;AACT,aAAOT,iCAAiC;QACtCK,MAAM;QACNK,YAAY,CACVT,gBACAU,qBAAqBF,OAAOP,aAAa,CAAC;MAE9C,GAAGA,aAAa;IAClB;IACAW,IACEJ,OACA;AACA,aAAOT,iCAAiC;QACtCK,MAAM;QACNK,YAAY,CACVT,gBACAU,qBAAqBF,OAAOP,aAAa,CAAC;MAE9C,GAAGA,aAAa;IAClB;IACAY,SACEL,OACA;AACA,aAAOT,iCAAiC;QACtC,QAAQ;QACR,QAAQC;QACR,SAASU,qBAAqBF,OAAOP,aAAa;MACpD,GAAGA,aAAa;IAClB;IACAa,SACEN,OACA;AACA,aAAOT,iCAAiC;QACtCK,MAAM;QACNK,YAAY,CACVT,gBACAU,qBAAqBF,OAAOP,aAAa,CAAC;MAE9C,GAAGA,aAAa;IAClB;IACAc,OACEP,OACA;AACA,aAAOT,iCAAiC;QACtC,QAAQ;QACR,QAAQC;QACR,SAASU,qBAAqBF,OAAOP,aAAa;MACpD,GAAGA,aAAa;IAClB;IACAe,aAAcC,UAAS;AACrB,aAAOlB,iCAAiC;QACtCK,MAAM;QACNa;QACAZ,UAAUL;MACZ,GAAGC,aAAa;IAClB;EACF;AAEFA,gBAAciB,IAAIhB,YAAYF,cAAc;AAC5C,SAAOE;AACT;AAEA,IAAMQ,uBAAuBA,CAC3BS,KACAlB,kBAC8B;AAC9B,MAAI,OAAOkB,QAAQ,UAAU;AAC3B,UAAMjB,aAAaD,cAAcmB,IAAID,GAAG;AACxC,KAAUjB,aAAUmB,OAApBC,UAAS,OAAa,iCAAiC,IAAvDA,UAAS,KAAA,IAAA;AACT,WAAOpB;EACT,WAAW,OAAOiB,QAAQ,UAAU;AAClCE,WAAAC,UAAS,OAAQ,uDAAuD,IAAxEA,UAAS,KAAA;EACX;AACAD,SAAAC,UAAS,OAAQ,8CAA8C,IAA/DA,UAAS,KAAA;AACX;;;ACxGO,SAASC,8BAGdC,YACAC,WACAC,eACAC,oBAA6B,OACT;AACpB,SAAO;IACLC,SAAUC,UAAS;AACjB,aAAON,8BAA8BC,YAAY;QAC/CM,MAAM;QACNL;QACAI;MACF,GAAGH,aAAa;IAClB;IACAK,OAAQC,YAAW;AACjB,aAAOT,8BAA8BC,YAAY;QAC/CM,MAAM;QACNL;QACAM,OAAOE,0BAA0BD,QAAQR,UAAU;MACrD,GAAGE,aAAa;IAClB;IACAQ,WAAWA,CAACC,aAAqBC,QAAa;AAC5C,YAAMC,mBAAmBF,YAAYG,MAAM,GAAG;AAC9C,QACED,iBAAiBE,WAAW,KAAKF,iBAAiB,CAAC,MAAM,YAAQG,OADnEC,UAAS,OAEP,4BAA4B,IAF9BA,UAAS,KAAA,IAAA;AAIT,YAAM,CAACC,yBAAyBC,oBAAoB,IAAIN;AACxD,UAAIO;AACJ,cAAQD,sBAAoB;QAC1B,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AACHC,2CAAiC;YAC/Bd,MAAMa;YACNE,yBAAyBH;UAC3B;AACA;QACF,KAAK;AACHE,2CAAiC;YAC/Bd,MAAM;YACNe,yBAAyBH;YACzBI,wBAAuBV,2BAAKW,eAAc;UAC5C;AACA;QACF,KAAK;QACL,KAAK;AACHH,2CAAiC;YAC/Bd,MAAMa;YACNE,yBAAyBH;YACzBM,QAAOZ,2BAAKY,UAAS;UACvB;AACA;QACF,KAAKC;AACH,cAAIP,4BAA4B,UAAU;AACxCE,6CAAiC;cAC/Bd,MAAM;YACR;AACA;UACF;QACF;AACEU,iBAAAC,UAAS,OAEP,mCAAmCE,oBAAoB,IAFzDF,UAAS,KAAA;MAIb;AACA,YAAMS,mBAA8C;QAClDpB,MAAM;QACNL;QACA0B,WAAWP;MACb;AACA,YAAMQ,iBACJC,iCAAiCH,kBAAkBxB,aAAa;AAClEA,oBAAc4B,IAAIF,gBAAgBF,gBAAgB;AAClD,aAAOE;IACT;IACAG,gBAAiBC,UAAS;AACxB,UAAI7B,mBAAmB;AACrB,cAAMuB,oBAA8C;UAClDpB,MAAM;UACN2B,SAASD;QACX;AACA,cAAMJ,kBACJC,iCAAiCH,mBAAkBxB,aAAa;AAClEA,sBAAc4B,IAAIF,iBAAgBF,iBAAgB;AAClD,eAAOE;MACT;AACA,YAAMF,mBAA8C;QAClDpB,MAAM;QACNL;QACA0B,WAAW;UACTrB,MAAM;UACNe,yBAAyBW;QAC3B;MACF;AACA,YAAMJ,iBACJC,iCAAiCH,kBAAkBxB,aAAa;AAClEA,oBAAc4B,IAAIF,gBAAgBF,gBAAgB;AAClD,aAAOE;IACT;IACAM,UAAU;MACRC,QAAQA,MAAW;AACjBnB,eAAAC,UAAS,OAAQ,eAAe,IAAhCA,UAAS,KAAA;MACX;MACAmB,SAASA,MAAW;AAClBpB,eAAAC,UAAS,OAAQ,eAAe,IAAhCA,UAAS,KAAA;MACX;MACAoB,MAAMA,MAAW;AACfrB,eAAAC,UAAS,OAAQ,eAAe,IAAhCA,UAAS,KAAA;MACX;MACAqB,UAAUA,MAAW;AACnBtB,eAAAC,UAAS,OAAQ,eAAe,IAAhCA,UAAS,KAAA;MACX;MACAsB,WAAWA,MAAW;AACpBvB,eAAAC,UAAS,OAAQ,eAAe,IAAhCA,UAAS,KAAA;MACX;IACF;EACF;AACF;;;AClIO,SAASuB,sCAIdC,OACwC;AACxC,SAAOA,MAAMC,QAAQC,OACnB,CAACC,aAAqDC,aAAa;AACjE,UAAMC,QAAQD,SAASE,KAAKC,MAAM,GAAG;AACrC,QAAIF,MAAM,CAAC,MAAM,SAAS;AACxB,aAAOF;IACT;AACA,MACEE,MAAMG,WAAW,KAACC,OADpBC,UAAS,OAEP,4CAA4C,IAF9CA,UAAS,KAAA,IAAA;AAIT,UAAMC,WAAWN,MAAM,CAAC;AACxB,UAAMO,aAAaP,MAAM,CAAC;AAC1B,QAAI,EAAEM,YAAYR,cAAc;AAC9BA,kBAAYQ,QAAQ,IAAI,CAAC;IAC3B;AACCR,gBAAYQ,QAAQ,EAAUC,UAAU,IAAIR,SAASS;AAEtD,WAAOV;EACT,GACA,CAAC,CACH;AACF;;;AClCA,IAAMW,oBAAqBC,SACzBA,QAAQ,QAAQ,QAAQA,QAAQ,SAAS,SAASC;AAG7C,SAASC,gCAEdC,QAAY;AACZ,SAAOC,OAAOC,QAAQF,MAAM,EAAEG,QAC5B,CAAC,CAACC,eAAeC,eAAe,MAAM;AACpC,QAAID,kBAAkB,UAAU;AAC9B,aAAO;QACLE,MAAM;QACNC,MAAM;QACNC,WAAWZ,kBAAkBS,eAAe;MAC9C;IACF;AAEA,UAAMI,WAAWL,cAAcM,YAAY,GAAG;AAC9C,UAAMC,WAAWP,cAAcQ,MAAM,GAAGH,QAAQ;AAChD,UAAMI,SAAST,cAAcQ,MAAMH,WAAW,CAAC;AAE/C,WAAO,CACL;MACEH,MAAMO;MASNN,MAAM,GAAGI,QAAQ,IAAIE,MAAM;MAC3BL,WAAWZ,kBAAkBS,eAAe;MAC5CS,OAAOH;IACT,CAAC;EAEL,CACF;AACF;;;AClCO,SAASI,4BACdC,eACA;AACA,MAAI,CAACA,cAAe,QAAO,CAAA;AAE3B,SAAOC,OAAOC,QACZF,aACF,EAAEG,QAA8B,CAAC,CAACC,OAAOC,IAAI,MAAM;AA/BrD;AAgCI,QAAIA,SAAS,SAAS;AACpB,aAAO,CAAC;QAAEA;QAAMD;MAAM,CAAC;IACzB,WAAW,qBAAqBC,MAAM;AACpC;AACE,eAAO,CACL;UACEA,MAAM;UACND;UACAE,eAAeD,KAAKE;QACtB,CAAC;MAEL;IACF,WAAW,YAAYF,MAAM;AAC3B,aAAO,CACL;QACEA,MAAM;QACND;QACAE,iBAAeD,UAAKG,WAALH,mBAAaI,WAAUC;QACtCC,cAAcN,KAAKG,OAAOI,iBAAiBF;MAC7C,CAAC;IAEL,WAAW,iBAAiBL,MAAM;AAChC,aAAO,CAAC;QACNA,MAAM;QACND;QACAS,YAAYR,KAAKS;MACnB,CAAC;IACH,WAAW,aAAaT,MAAM;AAC5B,aAAO,CAAC;QACNA,MAAM;QACND;QACAW,QAAQV,KAAKW,QAAQC,IAAIC,WAASC,aAAaD,KAAK,CAAC;MACvD,CAAC;IACH,WAAW,eAAeb,MAAM;AAC9B,aAAO,CAAC;QACNA,MAAM;QACND;QACAgB,OAAOf,KAAKgB,UAAU,CAAC;QACvBC,MAAMC,gBAAgBlB,KAAKgB,UAAU,CAAC,CAAC;MACzC,CAAC;IACH,MAAO,QAAO,CAAA;EAChB,CAAC;AACH;AAEA,SAASF,aACPD,OACoB;AACpB,SAAO;IAAEM,YAAYN,MAAM,CAAC;IAAGO,UAAUP,MAAM,CAAC;EAAE;AACpD;;;AC7DO,SAASQ,yBACdC,YACe;AACf,SAAOA,WAAWC,SAAS,cACvB;IACAA,MAAM;IACNC,eAAeF,WAAW,SAAS;EACrC,IACE;IACAC,MAAM;IACND,YAAYA,WAAW,SAAS;EAClC;AACJ;;;ACQA,eAAsBG,WAIpBC,WACAC,YACAC,YAAuBC,yBAAyBF,UAAU,GAC1DG,KACqC;AACXD,2BAAyBF,UAAU;AAC7D,QAAMI,OAAkC;IACtCC,aAAaC,gCACXH,IAAII,OACN;IACAC,SAAS,CAAA;IACTC,OAAOC;EACT;AAEA,MAAIP,IAAIQ,UAAU;AAChBP,SAAKI,UAAUI,4BAA4BT,IAAIQ,QAAQ;EACzD;AAEA,QAAME,SAAS,MAAmBC,0BAAmBhB,UACnDiB,qCAAqChB,WAAWC,UAAU,GAC1D,MAAMD,UAAUiB,aAChB;IACEf;IACAO,SAASJ,KAAKI;IACdH,aAAaD,KAAKC;EACpB,CACF;AAEA,MAAI,CAACF,IAAIQ,UAAU;AACjB,MACEE,OAAOI,KAAKC,WAAW,KAACC,OAD1BC,UAAS,OAEP,qDAAqD,IAFvDA,UAAS,KAAA,IAAA;AAKT,WAAO;MACL,GAAGC,yBAAyBR,OAAOI,KAAK,CAAC,CAAC;MAC1C,GAAGK,sCACDT,OAAOI,KAAK,CAAC,CACf;IACF;EACF;AAEA,QAAMM,MAA2DV,OAAOI,KACrEO,IAAKC,WAAU;AACd,WAAO;MACLC,QAAQD,MAAME;MACd,GAAGN,yBAAyBI,KAAK;MACjC,GAAGH,sCAAsCG,KAAK;IAChD;EACF,CAAC;AAEH,SAAOF;AACT;AAEA,SAASF,yBACPI,OACgC;AAChC,aAAWG,mBAAmBH,MAAMI,SAAS;AAC3C,QAAID,gBAAgBE,SAAS,SAAS;AACpC,aAAO;QAAEC,QAAQH,gBAAgBI;MAAM;IACzC;EACF;AACF;;;ACpFA,eAAsBC,qBACpBC,WACAC,WAGA;AACA,UAAQ,MAAMC,6BACZF,WACAC,WACAE,MACF,GAAGC;AACL;AAKA,eAAeF,6BACbF,WACAC,WACAI,uBAMA;AA9CF;AA+CE,UAAQJ,UAAUK,MAAI;IACpB,KAAK,gBAAgB;AACnB,YAAM;QAAEF,aAAAA;QAAaG;MAAgB,IACnC,MAAML,6BACJF,WACAC,UAAUA,WACVI,qBACF;AAEF,UAAIE,oBAAoBJ,UAAaI,oBAAoB,IAAI;AAC3D,eAAO;UAAEH,aAAa,CAAC;QAAE;MAC3B;AACA,YAAMI,SAAS,MAAMR,UAAUS,iBAAiBC,oBAC9CH,eACF;AACA,YAAMI,UAAUH,OAAOI,MAAMX,UAAUY,IAAI;AAC3C,OAAUF,UAAOG,OAAjBC,UAAS,OAAU,gCAAgCd,UAAUY,IAAI,GAAG,IAApEE,UAAS,KAAA,IAAA;AACT,aAAO;QACLX,aAAAA;QACAG,iBAAiBC,OAAOI,MAAMX,UAAUY,IAAI,EAAEG;MAChD;IACF;IACA,KAAK,kBAAkB;AAErB,YAAM;QAAEZ,aAAAA;QAAaG;MAAgB,IACnC,MAAML,6BACJF,WACAC,UAAUA,WACVI,qBACF;AACF,UAAIE,oBAAoBJ,UAAaI,oBAAoB,IAAI;AAC3D,eAAO;UAAEH,aAAa,CAAC;QAAE;MAC3B;AAEA,iBACQ,CAACa,MAAMC,UAAU,KAAKC,OAAOC,QAAQnB,UAAUoB,iBAAiB,GACtE;AACA,YAAIH,WAAWZ,SAAS,aAAa;AACnCF,UAAAA,aAAYa,IAAI,IAAI;YAClBK,iCAAiCnB;YACjCe;UACF;AACA;QACF;AAEA,gBAAQA,WAAWK,UAAUjB,MAAI;UAC/B,KAAK;UACL,KAAK;UACL,KAAK;AAEH,kBAAM;cAAEC,iBAAiBiB;YAAyB,IAChD,MAAMtB,6BACJF,WACAkB,WAAWjB,WACXM,eACF;AACF,gBACEiB,6BAA6BrB,UAC1BqB,6BAA6B,IAChC;AACA,qBAAO;gBAAEpB,aAAa,CAAC;cAAE;YAC3B;AACA,kBAAMI,SAAS,MAAMR,UAAUS,iBAAiBC,oBAC9Cc,wBACF;AAEApB,YAAAA,aAAYa,IAAI,IAAI;cAClBK,iCACEd,OAAOiB,WAAWP,WAAWK,UAAUG,uBAAuB;cAChER;YACF;AACA;UAEF;AACEd,YAAAA,aAAYa,IAAI,IAAI;cAClBK,iCAAiCnB;cACjCe;YACF;QACJ;MACF;AACA,aAAO;QAAEd,aAAAA;QAAaG;MAAgB;IACxC;IACA,KAAK;AACH,aAAO;QAAEH,aAAa,CAAC;QAAGG,iBAAiBF;MAAsB;IACnE,KAAK;AACH,aAAO;QAAED,aAAa,CAAC;QAAGG,iBAAiBN,UAAU0B;MAAW;IAClE,KAAK;AACH,aAAO;QAAEvB,aAAa,CAAC;QAAGG,iBAAiBN,UAAU2B;MAAc;IACrE,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO1B,6BACLF,WACAC,UAAUA,WACVI,qBACF;;IAEF,KAAK;IACL,KAAK;IACL,KAAK;AACH,YAAMwB,aAAa5B,UAAU4B;AAC7B,YAAMC,iBAAiB,MAAMC,QAAQC,IACnCH,WAAWI,IAAKC,QACdhC,6BACEF,WACAkC,IACA7B,qBACF,CACF,CACF;AAEA,YAAMD,cAAc0B,eAAeK,OACjC,CAACC,KAAK;QAAEhC,aAAAA;MAAY,OAAO;QAAE,GAAGgC;QAAK,GAAGhC;MAAY,IACpD,CAAC,CACH;AACA,QACEe,OAAOkB,KAAKjC,WAAW,EAAEkC,WAAW,KAACxB,OADvCC,UAAS,OAEP,4GAA4G,IAF9GA,UAAS,KAAA,IAAA;AAKT,YAAMwB,6BAA4BT,oBAAeU,KAC/C,CAAC;QAAEjC;MAAgB,MAAMA,mBAAmB,IAC9C,MAFkCuB,mBAE/BvB;AACH,OACEuB,eAAeW,MACb,CAAC;QAAElC;MAAgB,MACjBA,oBAAoBgC,6BACjBhC,mBAAmB,IAC1B,IAACO,OALHC,UAAS,OAMP,0FAA0F,IAN5FA,UAAS,KAAA,IAAA;AAST,aAAO;QACLX,aAAa,CAAC;QACdG,iBAAiBgC;MACnB;IACF,KAAK;IACL,KAAK;AAEH,aAAO;QAAEnC,aAAa,CAAC;MAAE;;IAE3B,KAAK;AACHU,aAAAC,UAAS,OAEP,4DAA4D,IAF9DA,UAAS,KAAA;IAIX;AAEED,aAAAC,UAAS,OAEP,4DAA4D,IAF9DA,UAAS,KAAA;EAIb;AACF;;;AClJO,SAAS2B,wBACdC,WACAC,iBACAC,gBAA+CC,QAChB;AAC/B,MAAIH,UAAUI,SAAS,UAAUJ,UAAUI,SAAS,iBAAiB;AACnE,QAAIJ,UAAUI,SAAS,UAAUJ,UAAUK,eAAeJ,iBAAiB;AACzE,YAAM,IAAIK,MACR,uCAAuCL,eAAe,aAAaD,UAAUK,UAAU,EACzF;IACF;AACA,QACEL,UAAUI,SAAS,mBAChBJ,UAAUO,kBAAkBN,iBAC/B;AACA,YAAM,IAAIK,MACR,uCAAuCL,eAAe,aAAaD,UAAUO,aAAa,EAC5F;IACF;AAEA,WAAOL;EACT;AAEA,MAAIF,UAAUI,SAAS,UAAU;AAC/B,WAAOL,wBACLC,UAAUA,WACVC,iBACAC,iBAAiB,OAAOF,UAAUQ,QAAQ;MACxCJ,MAAM;MACNK,OAAO,CAACP,eAAeF,UAAUQ,KAAK;IACxC,CACF;EACF;AAEA,QAAM,IAAIF,MAAM,+BAA+BN,UAAUI,IAAI,EAAE;AACjE;AAGO,SAASM,0BACdV,WACAW,sBACAC,MACW;AACX,UAAOA,6BAAMC,mCACT;IACAT,MAAM;IACNU,YAAY,CAACd,WAAW;MACtBI,MAAM;MACNG,eAAeI;MACfI,gCAAgC;IAClC,CAAC;EACH,IACEf;AACN;AAEA,eAAegB,mBAObC,QACAV,eACAK,MACAZ,WACyC;AACzC,MAAIY,KAAKM,iCAAiC;AACxC,UAAMC,UAAS,MAAmBC,0BAC/BC,OACCC,qCAAqCL,QAAQV,aAAa,GAC1D,MAAMU,OAAOM,aACbhB,cAAciB,SACdC,eAAiDb,MAAM;MACrDc,qBAAqB,CAAC;MACtBC,8BAA8B,CAAC;MAC/BC,qBAAqB,CAAA;MACrBC,qBAAqB,CAAA;MACrBC,6BAA6BlB,KAAKmB,WAC7B,CAAA;MACLvB,OAAOT,wBAAwBC,WAAWO,cAAciB,OAAO;IACjE,CAAC,GACD;MAAEQ,SAAS;IAAK,CAClB;AAEFb,IAAAA,QAAOc,OAAO,MAAMhB,OAAOiB;MACzBjB;MACAE,QAAOc;;MACP1B,cAAciB;MACd,CAACZ,KAAKuB;MACN,MAAMC,qBAAqBnB,QAAQjB,SAAS;IAC9C;AACA,WAAOmB;EACT;AACA,QAAMA,SAAS,MAAmBkB,0BAAmBC,wBACnDhB,qCAAqCL,QAAQV,aAAa,GAC1D,MAAMU,OAAOM,aACbE,eAA0Db,MAAM;IAC9DZ,WAAWU,0BACTV,WACAO,cAAciB,SACdZ,IACF;IACA2B,SAAU3B,6BAAMmB,YAAoC,CAAA;IACpDS,YAAY,EAAC5B,6BAAMuB;EACrB,CAAC,GACD;IAAEH,SAAS;EAAK,CAClB;AACA,SAAOS,QAAQC,QAAQ;IACrBT,MAAM,MAAMhB,OAAO0B,eACjB1B,QACAE,OAAOc,MACP1B,cAAciB,SACd,CAAC,GACD,CAACZ,KAAKuB,aACNvB,KAAKmB,SACL,OACAZ,OAAOyB,6BACT;IACAC,eAAe1B,OAAO0B;IACtBC,YAAY3B,OAAO2B;EACrB,CAAC;AACH;AAGA,eAAsBC,kBAQpB9B,QACAZ,YACAL,WACAY,OAAwC,CAAC,GACA;AACzC,MAAIP,WAAWD,SAAS,aAAa;AACnC,WAAO,MAAMY,mBACXC,QACAZ,YACAO,MACAZ,SACF;EACF,OAAO;AACL,WAAO,MAAMgD,gBACX/B,QACAZ,YACAO,MACAZ,SACF;EACF;AACF;AAGA,eAAsBiD,4BAQpBhC,QACAZ,YACAL,WACAY,OAAwC,CAAC,GACQ;AACjD,MAAI;AACF,UAAMO,SAAS,MAAM4B,kBAAkB9B,QAAQZ,YAAYL,WAAWY,IAAI;AAC1E,WAAO;MAAEH,OAAOU;IAAO;EACzB,SAAS+B,GAAG;AACV,QAAIA,aAAa5C,OAAO;AACtB,aAAO;QAAE6C,OAAOD;MAAE;IACpB;AACA,WAAO;MAAEC,OAAOD;IAAW;EAC7B;AACF;AAUA,eAAsBE,UAOpBnC,QACAZ,YACAO,MACAZ,YAAuBqD,yBAAyBhD,UAAU,GACjB;AACzC,SAAO0C,kBAAkB9B,QAAQZ,YAAYL,WAAWY,IAAI;AAC9D;AAkBA,SAAS0C,eAOPC,MACAC,MACG;AACH,MAAID,6BAAME,gBAAgB;AACxBD,SAAKE,YAAYH,KAAKE;EACxB;AAEA,OAAIF,6BAAMI,cAAa,MAAM;AAC3BH,SAAKI,WAAWL,KAAKI;EACvB;AAEA,OAAIJ,6BAAMM,aAAY,MAAM;AAC1BL,SAAKM,UAAU;MACbC,QAAQC,OAAOC,QAAQV,KAAKM,QAAQ,EAAEK,IAAI,CAAC,CAACC,OAAOC,SAAS,OAAO;QACjED;QACAC;MACF,EAAE;IACJ;EACF;AAEA,SAAOZ;AACT;AAGA,eAAsBa,gBAOpBC,QACAC,YACAhB,MACAiB,WACyC;AACzC,QAAMC,IAAI,MAAmBC,0BAAmBC,KAC9CC,qCAAqCN,QAAQC,UAAU,GACvD,MAAMD,OAAOO,aACbvB,eAAuCC,MAAM;IAC3CiB;;IAEAM,SAAUvB,6BAAMwB,YAAoC,CAAA;;IACpDC,YAAY,EAACzB,6BAAM0B;EACrB,CAAC,CACH;AAEA,SAAOC,QAAQC,QAAQ;IACrBC,MAAM,MAAMd,OAAOe,cACjBf,QACAG,EAAEW,MACFE,QACAA,QACA,MAAMC,qBAAqBjB,QAAQE,SAAS,GAC5CjB,KAAKwB,OACP;IACAS,eAAef,EAAEe;IACjBC,YAAYhB,EAAEgB;EAChB,CAAC;AACH;;;ACxTA,eAAsBC,YAIpBC,QACAC,YACAC,MACAC,WAKA;AACA,QAAMC,SAAS,MAAMC,UACnBL,QACAC,YACA;IAAE,GAAGC;IAAMI,WAAW;EAAE,GACxBH,SACF;AAEA,MAAIC,OAAOG,KAAKC,WAAW,KAAKJ,OAAOK,iBAAiB,MAAM;AAC5D,UAAM,IAAIC,iBACR,oCAAoCN,OAAOG,KAAKC,MAAM,WACpDJ,OAAOK,iBAAiB,OAAO,4BAA4B,EAAE,EAEjE;EACF;AAEA,SAAOL,OAAOG,KAAK,CAAC;AACtB;AAGA,eAAsBI,sBAIpBX,QACAC,YACAC,MACAC,WAOA;AACA,MAAI;AACF,UAAMC,SAAS,MAAML,YAAYC,QAAQC,YAAYC,MAAMC,SAAS;AACpE,WAAO;MAAES,OAAOR;IAAc;EAChC,SAASS,GAAG;AACV,QAAIA,aAAaC,OAAO;AACtB,aAAO;QAAEC,OAAOF;MAAE;IACpB;AACA,WAAO;MAAEE,OAAOF;IAAW;EAC7B;AACF;;;AClEA,IAAMG,wBAAwB,oBAAIC,IAAI,CACpC,QACA,UACA,aACA,aACA,gBACA,UACA,YACA,OAAO,CACR;AAGM,SAASC,gBAAgBC,GAA4B;AAC1D,SAAOA,KAAK,QAAQ,OAAOA,MAAM,YAC5BH,sBAAsBI,IAAID,EAAEE,IAAI;AACvC;;;AC/BA,IAAI,KAAK;AAET,IAAI,OAAO,cAAc,aAAa;AACpC,OAAK;AACP,WAAW,OAAO,iBAAiB,aAAa;AAC9C,OAAK;AACP,WAAW,OAAO,WAAW,aAAa;AACxC,OAAK,OAAO,aAAa,OAAO;AAClC,WAAW,OAAO,WAAW,aAAa;AACxC,OAAK,OAAO,aAAa,OAAO;AAClC,WAAW,OAAO,SAAS,aAAa;AACtC,OAAK,KAAK,aAAa,KAAK;AAC9B;AAEA,IAAO,kBAAQ;;;ACsBf,IAAMC,6BAA6B,IAAI;AAGvC,SAASC,YAAY;AAAC;AAKtB,SAASC,gBAIP;EACEC,WAAWF;EACXG,UAAUH;EACVI,cAAcJ;EACdK,2BAA2BL;AACS,GACU;AAChD,SAAO;IAAEE;IAAUC;IAASC;IAAaC;EAAyB;AACpE;AAyBA,SAASC,QAIPC,KAC8D;AAC9D,SAAOA,IAAID,WAAW;AACxB;AAEA,SAASE,mBAAmBD,KAA6B;AACvD,SAAOA,IAAIE,WAAW,UAAUF,IAAIE,WAAW;AACjD;AA9FA,qCAAAC,UAAAC,UAAA;AAiGO,IAAMC,8BAAN,MAAMA,4BAA2B;;EAoDtCC,YACEC,QACA;IACEC,0BAA0BhB;EAC5B,IAAI,CAAC,GACL;AAzDG;AAsBL;AACA,uCAAiB;AACjB,uBAAAW;AAEA,uBAAAC;AAKA;;;8CAAwB,oBAAIK,IAG1B;AAMF;;;;uCAAiB,oBAAIA,IAGnB;AAEF,4CAAsB,oBAAIC,IAExB;AAEF;AAoQA,gCAAUC,MAAM;AAEd,4BAAK,gEAAL;IACF;AAEA,mCAAa,OAAOC,YAAmD;AA3ZzE;AA4ZI,YAAMC,OAAOC,KAAKC,MAAMH,QAAQC,KAAKG,SAAS,CAAC;AAC/C,UAAIC,MAAuC;AACzC,iCAAKb,cAAL,mBAAcc,MAAM;UAAEC,SAASN;QAAK,GAAG;MACzC;AACA,cAAQA,KAAKO,MAAI;QACf,KAAK;AACH,gBAAM,mBAAK,iCAAL,WAAqCP;AAC3C;QAEF,KAAK;AACH,6BAAK,iCAAL,WAAqCA;AACrC;QAEF,KAAK;AACH,6BAAK,mCAAL,WAAuCA;AACvC;QAEF,KAAK,sBAAsB;AACzB,gCAAK,4EAAL,WAAuCA;AACvC;QACF;QAEA;AAEEI,iBAAAI,UAAS,OAAQ,yBAAyB,IAA1CA,UAAS,KAAA;MACb;IACF;AAEA,wDAAkC,OAChCF,YACG;AA1bP;AA2bI,YAAMnB,MAAM,mBAAK,gBAAesB,IAAIH,QAAQI,EAAE;AAC9C,UAAIvB,OAAO,KAAM;AAEjB,YAAMwB,gBAAgBL,QAAQM,QAAQC,OAAQC,YAC5CA,OAAOP,SAAS,QAClB;AACA,YAAMQ,mBAAmBT,QAAQM,QAAQC,OAAQC,YAC/CA,OAAOP,SAAS,WAClB;AACA,YAAMS,kCAAkC,MAAMC,QAAQC,IACpDH,iBAAiBI,IAAI,OAAOC,MAAM;AAChC,cAAMC,kBAAkB,MAAM,mBAAK/B,UAAQgC,eACzC,mBAAKhC,WACL,CAAC;UACCiC,WAAWH,EAAEI;UACbC,cAActC,IAAIuC,0BAA0B,OACxCN,EAAEO,WAAWxC,IAAIuC,sBAAsB,IACvCE;UACJ,GAAGR,EAAEO;UACL,CAACP,EAAES,QAAQ,GAAGT,EAAEU;QAClB,CAAC,GACD3C,IAAI4C,kBACJ,CAAC,GACD,OACAH,QACA,OACA,MAAM,sBAAK,iEAAL,WACJR,EAAEI,YACFrC,IAAI4C,iBAER;AACA,cAAMC,mBAAmBX,gBAAgB,CAAC,KAAKO;AAC/C,eAAOI,oBAAoB,OACvB;UACAC,QAAQD;UACRE,OAAO;QACT,IACEN;MACN,CAAC,CACH;AAEA,iBAAWd,UAAUE,iCAAiC;AACpD,YAAIF,UAAU,MAAM;AAClB,cAAI;AACF3B,4BAAIgD,UAASrD,aAAbK,4BAAwB2B;UAC1B,SAASsB,OAAO;AACd,qCAAK7C,cAAL,mBAAc6C,MAAMA,OAAO;AAC3B,+BAAK,kBAAL,WAAsBjD,KAAK,OAAOiD;UACpC;QACF;MACF;AAEA,YAAMC,cAAc,MAAMpB,QAAQC,IAAIP,cAAcQ,IAAI,OAAOC,MAAM;AACnE,cAAMkB,eAAeC,OAAOC,KAAKpB,EAAEa,MAAM,EAAEpB,OAAQ4B,SACjDtD,IAAIuD,6BAA6BC,SAASF,GAAG,CAC/C;AACA,mBAAWA,OAAOH,cAAc;AAC9B,iBAAOlB,EAAEa,OAAOQ,GAAG;QACrB;AAEA,cAAMpB,kBAAkB,MAAM,mBAAK/B,UAAQgC,eACzC,mBAAKhC,WACL,CAAC8B,EAAEa,MAAM,GACT9C,IAAI4C,kBACJ,CAAC,GACD,OACAH,QACA,OACA,MAAM,sBAAK,iEAAL,WACJR,EAAEa,OAAOV,WACTpC,IAAI4C,iBAER;AACA,cAAMC,mBAAmBX,gBAAgB,CAAC,KAAKO;AAC/C,eAAOI,oBAAoB,OACvB;UACAC,QAAQD;UACRE,OAAOd,EAAEc;QACX,IACEN;MACN,CAAC,CAAC;AAEF,iBAAWgB,cAAcP,aAAa;AACpC,YAAIO,cAAc,MAAM;AACtB,cAAI;AACFzD,4BAAIgD,UAASrD,aAAbK,4BAAwByD;UAC1B,SAASR,OAAO;AACd,qCAAK7C,cAAL,mBAAc6C,MAAMA,OAAO;AAC3B,+BAAK,kBAAL,WAAsBjD,KAAK,OAAOiD;UACpC;QACF;MACF;IACF;AAgBA,wDAAmC9B,aAA8B;AAviBnE;AAwiBI,YAAMnB,MAAM,mBAAK,gBAAesB,IAAIH,QAAQI,EAAE;AAC9C,OAAUvB,MAAGiB,OAAbI,UAAS,OAAM,4BAA4BF,QAAQI,EAAE,EAAE,IAAvDF,UAAS,KAAA,IAAA;AACT,UAAI;AACFrB,YAAIgD,SAASnD,YAAY;MAC3B,SAASoD,OAAO;AACd,iCAAK7C,cAAL,mBAAc6C,MAAMA,OAAO;AAC3B,2BAAK,kBAAL,WAAsBjD,KAAK,OAAOiD;MACpC;IACF;AAEA,0DACE9B,aACG;AApjBP;AAqjBI,YAAM;QAAEI;QAAImC;MAAU,IAAIvC;AAE1B,YAAMwC,OAAO,mBAAK,uBAAsBrC,IAAIC,EAAE;AAC9C,OAAUoC,OAAI1C,OAAdI,UAAS,OAAO,0CAA0CE,EAAE,EAAE,IAA9DF,UAAS,KAAA,IAAA;AACT,yBAAK,uBAAsBuC,OAAOrC,EAAE;AAEpC,eAASsC,IAAI,GAAGA,IAAIH,UAAUI,QAAQD,KAAK;AACzC,cAAM7D,MAAM2D,KAAKE,CAAC;AAClB,cAAME,WAAWL,UAAUG,CAAC;AAE5B,gBAAQE,SAAS3C,MAAI;UACnB,KAAK;AACH,+BAAK,kBAAL,WAAsBpB,KAAK,MAAM+D,SAASC;AAC1C,kCAAK,uDAAL,WAAkBhE,KAAK;AACvB;UAEF,KAAK;AAEH,+BAAK,iBAAL;AACA;UAEF,KAAK;AAEH,kBAAMiE,sBAAsBjE,IAAIE,WAAW,aACtCF,IAAIE,WAAW;AAEpB,gBAAIe,MAAuC;AACzC,uCAAKb,cAAL,mBAAcc,MAAM;gBAAE+C;cAAoB,GAAG;YAC/C;AACAjE,gBAAIE,SAAS;AACb,gBAAIF,IAAIkE,mBAAmBH,SAASxC,IAAI;AAEtC,iCAAK,gBAAeqC,OAAO5D,IAAIkE,cAAc;AAC7ClE,kBAAIkE,iBAAiBH,SAASxC;AAC9B,iCAAK,gBAAe4C,IAAInE,IAAIkE,gBAAgBlE,GAAG;YACjD;AACA,gBAAI;AACF,kBAAIiE,oBAAqBjE,KAAIgD,SAASnD,YAAY;kBAC7CG,KAAIgD,SAASlD,yBAAyB;YAC7C,SAASmD,OAAO;AACd,uCAAK7C,cAAL,mBAAc6C,MACZA,OACA;AAEF,iCAAK,kBAAL,WAAsBjD,KAAK,OAAOiD;YACpC;AACA;UACF;AACE,+BAAK,kBAAL,WAAsBjD,KAAK,MAAM+D;QACrC;MACF;IACF;AAUA,iCAAYK,WAAgC;AAlnB9C;AAmnBI,UAAInD,MAAuC;AACzC,iCAAKb,cAAL,mBAAcc,MAAM;UAAEkD;QAAM,GAAG,gCAAgCA;MACjE;AAEA,yBAAK,iBAAL;IACF;AAEA,wCAAkBC,MAAM;AACtB,UAAI,mBAAK,MAAK;AACZ,2BAAK,KAAIC,oBAAoB,QAAQ,mBAAK,QAAO;AACjD,2BAAK,KAAIA,oBAAoB,WAAW,mBAAK,WAAU;AACvD,2BAAK,KAAIA,oBAAoB,SAAS,mBAAK,SAAQ;AAEnD,YACE,mBAAK,KAAIC,eAAeC,gBAAUC,WAC/B,mBAAK,KAAIF,eAAeC,gBAAUE,QACrC;AACA,6BAAK,KAAIC,MAAM;QACjB;AACA,2BAAK,KAAMlC;MACb;AAGA,UAAI,mBAAK,gBAAemC,OAAO,GAAG;AAChC,YAAI3D,MAAuC;AACzC,qBAAW4D,KAAK,mBAAK,gBAAeC,OAAO,GAAG;AAC5C,cACED,EAAE3E,WAAW,UAAU2E,EAAE3E,WAAW,WAAOe,OAD7CI,UAAS,OAEP,gDAAgD,IAFlDA,UAAS,KAAA,IAAA;UAIX;QACF;AAEA,mBAAWwD,KAAK,mBAAK,gBAAeC,OAAO,GAAG;AAC5C,cAAID,EAAE3E,WAAW,aAAc2E,GAAE3E,SAAS;QAC5C;AAIA,aAAK,sBAAK,2DAAL;MACP;IACF;AAEA,yCAAmB6E,CACjB/E,KACAgF,oBACA/B,UACG;AAlqBP;AAmqBI,UAAI;AACFjD,YAAIgD,SAASpD,QAAQ;UAAEoF;UAAwC/B;QAAM,CAAC;MACxE,SAASgC,cAAc;AAErBC,gBAAQjC,MACN,qEACAgC,YACF;AAEAC,gBAAQjC,MACN,mEACAA,KACF;AAEAiC,gBAAQjC,MACN,qCACAA,KACF;AAEA,YAAI,CAAC+B,oBAAoB;AACvB,mCAAK5E,cAAL,mBAAc6C,MAAMA,OAAO;AAC3B,gCAAK,uDAAL,WAAkBjD,KAAK;AACvB,6BAAK,kBAAL,WAAsBA,KAAK,MAAMiF;QACnC;MACF;IACF;AA5rBF;AA2JI,SAAKzF,6BAA6BgB;AAClC,uBAAKL,UAAUI;AACf,uBAAKH,WAAUG,YAAO4E,WAAP5E,mBAAe6E,MAAM,CAAC,GAAG;MACtCC,WAAW;IACb;AACA,MACE9E,OAAO+E,QAAQC,WAAW,UAAU,KAC/BhF,OAAO+E,QAAQC,WAAW,SAAS,KAACtE,OAF3CI,UAAS,OAGP,qBAAqB,IAHvBA,UAAS,KAAA,IAAA;EAKX;;EA5DA,OAAOmE,YAAYjF,QAAmD;AACpE,QAAIkF,WAAWpF,0CAA2B,YAAWiB,IACnDf,OAAOmF,cACT;AACA,QAAID,YAAY,MAAM;AACpBA,iBAAW,IAAIpF,4BAA2BE,MAAM;AAChDF,gDAA2B,YAAW8D,IACpC5D,OAAOmF,gBACPD,QACF;IACF;AACA,WAAOA;EACT;EAkDA,MAAME,UAIJtD,YACAuD,WACA5C,UACA6C,aAAuB,CAAA,GACF;AACrB,UAAMC,oBAAoBzD,WAAWjB,SAAS,WAC1C,MAAM,mBAAKjB,UAAQ4F,iBAAiBC,oBACpC3D,WAAW4D,OACb,IACE,MAAM,mBAAK9F,UAAQ4F,iBAAiBG,uBACpC7D,WAAW4D,OACb;AAEF,QAAIE,mBAA6B,CAAA;AACjC,QAAIC,sBAAgC,CAAA;AAEpC,QAAIP,WAAW/B,WAAW,GAAG;AAC3B+B,mBAAazC,OAAOC,KAAKyC,kBAAkBD,UAAU;IACvD;AAEAM,uBAAmBN,WAAWnE,OAAQ2E,OACpCP,kBAAkBD,WAAWQ,CAAC,EAAEjF,SAAS,wBAC3C;AAEAgF,0BAAsBP,WAAWnE,OAAQ2E,OACvCP,kBAAkBD,WAAWQ,CAAC,EAAEjF,SAAS,wBAC3C;AAEA,UAAMpB,MAA0B;MAC9BgD,UAAUtD,gBAAsBsD,QAAQ;MACxC4C;MACArD,wBAAwBuD,kBAAkB1E,SAAS,cAC/CqB,SACAqD,kBAAkBQ;MACtBC,qBAAqBJ;MACrB5C,8BAA8B6C;MAC9BlG,QAAQ;;;MAGRgE,gBAAgB,OAAOsC,SAAS,CAAC;MACjC5D,kBAAkBkD,kBAAkB1E,SAAS,WACzCqB,SACAqD,kBAAkBG;IACxB;AAEA,uBAAK,gBAAe9B,IAAInE,IAAIkE,gBAAgBlE,GAAG;AAI/C,SAAK,sBAAK,6DAAL,WAAwBA;AAE7B,WAAO,MAAM;AACX,4BAAK,uDAAL,WAAkBA;IACpB;EACF;AA4dF;AA3lBS;AAqBP;AACA;AACAG,WAAA;AAEAC,WAAA;AAKA;AASA;AAKA;AAIA;AAjDK;AA2IC,uBAAkBqG,eAACzG,KAA6B;AA5OxD;AA6OI,MAAIiB,MAAuC;AACzC,6BAAKb,cAAL,mBAAcc,MAAM;EACtB;AAEA,MAAI;AACF,UAAM,sBAAK,2DAAL;AAIN,QAAIjB,mBAAmBD,GAAG,GAAG;AAC3B;IACF;AACAA,QAAID,UAAU;AAEd,UAAI,wBAAK,SAAL,mBAAUwE,gBAAeC,gBAAUkC,MAAM;AAC3C,4BAAK,gEAAL;IACF;EACF,SAASzD,OAAO;AACd,6BAAK7C,cAAL,mBAAc6C,MAAMA,OAAO;AAC3B,uBAAK,kBAAL,WAAsBjD,KAAK,MAAMiD;EACnC;AACF;AAEA,0BAAqB0D,WAAG;AApQ1B;AAqQI,MAAI1F,MAAuC;AACzC,6BAAKb,cAAL,mBAAcc,MAAM;EACtB;AAIA,QAAM0F,YAAY,CAAC,GAAG,mBAAK,gBAAe9B,OAAO,CAAC,EAAEpD,OAAO3B,OAAO;AAElE,QAAMwB,KAAKiF,SAAS;AAEpB,qBAAK,uBAAsBrC,IAAI5C,IAAIqF,SAAS;AAI5C,QAAMjB,YAA8C;IAClDpE;IACAsF,UAAUD,UAAU5E,IAAqC,CACvD;MACE4D;MACAW;MACAhD;MACAX;IACF,MACG;AACH,aAAO;QACLgD;QACAkB,aAAaP;QACbQ,cAAcxD;MAChB;IACF,CAAC;EACH;AAEA,MAAItC,MAAuC;AACzC,6BAAKb,cAAL,mBAAcc,MACZ;MAAEC,SAASwE;IAAU,GACrB;EAEJ;AACA,2BAAK,SAAL,mBAAUqB,KAAKlG,KAAKmG,UAAUtB,SAAS;AACzC;AAEA,iBAAYuB,SACVlH,KACAmH,YAA8B,QAC9B;AACA,MAAIlH,mBAAmBD,GAAG,GAAG;AAE3B;EACF;AAEAA,MAAIE,SAASiH;AAGbnH,MAAIgD,WAAWtD,gBAAwB,CAAC,CAAC;AAEzC,qBAAK,gBAAekE,OAAO5D,IAAIkE,cAAc;AAC7C,qBAAK,qBAAoBkD,IAAIpH,IAAIkE,cAAc;AAC/C,wBAAK,gEAAL;AAOA,MAAI,mBAAK,0BAAyB;AAShCmD,iBAAa,mBAAK,wBAAuB;EAC3C;AACA,qBAAK,yBAA0BC;IAAW,MAAM;AAC9C,yBAAK,yBAA0B7E;AAC/B,UAAI,mBAAK,gBAAemC,SAAS,GAAG;AAClC,2BAAK,iBAAL;MACF;IACF;IAAG;;EAAe;AACpB;AAEM,qBAAgB2C,iBAAG;AAxV3B;AAyVI,MAAI,mBAAK,QAAO,MAAM;AACpB,UAAM;MAAEjC;MAASkC;IAAc,IAAI,mBAAKrH;AACxC,UAAMsH,MAAMC,sBACVpC,SACA,MAAM,mBAAKnF,UAAQwH,WACrB;AAEA,UAAMC,QAAQ,MAAMJ,cAAc;AAIlC,QAAI,mBAAK,QAAO,MAAM;AAGpB,YAAMK,mBAAmB,mBAAK,mBAAkB,KAC5C,KAAKrI;AACT,UAAIqI,kBAAkBC,KAAKC,IAAI,GAAG;AAChC,cAAM,IAAIjG,QAASkG,aAAY;AAC7BV,qBAAWU,SAASH,kBAAkBC,KAAKC,IAAI,CAAC;QAClD,CAAC;MACH;AAEA,yBAAK,gBAAiBD,KAAKC,IAAI;AAG/B,UAAI,mBAAK,QAAO,MAAM;AACpB,YAAI9G,MAAuC;AACzC,mCAAKb,cAAL,mBAAcc,MAAM;QACtB;AACA,2BAAK,KAAM,IAAIsD,gBAAUiD,KAAK,CAAC,UAAUG,KAAK,EAAE,CAAC;AACjD,2BAAK,KAAIK,iBAAiB,SAAS,mBAAK,SAAQ;AAChD,2BAAK,KAAIA,iBAAiB,WAAW,mBAAK,WAAU;AACpD,2BAAK,KAAIA,iBAAiB,QAAQ,mBAAK,QAAO;MAChD;IACF;AAGA,QAAI,mBAAK,KAAI1D,eAAeC,gBAAU0D,YAAY;AAChD,YAAMC,MAAK,mBAAK;AAChB,aAAO,IAAIrG,QAAc,CAACkG,SAASI,WAAW;AAC5C,iBAASC,UAAU;AACjBF,UAAAA,IAAG7D,oBAAoB,QAAQgE,IAAI;AACnCH,UAAAA,IAAG7D,oBAAoB,SAASrB,KAAK;AACrCkF,UAAAA,IAAG7D,oBAAoB,SAAS+D,OAAO;QACzC;AACA,iBAASC,OAAO;AACdD,kBAAQ;AACRL,kBAAQ;QACV;AACA,iBAAS/E,MAAMsF,KAAc;AAC3BF,kBAAQ;AACRD,iBAAOG,GAAG;QACZ;AACAJ,QAAAA,IAAGF,iBAAiB,QAAQK,IAAI;AAChCH,QAAAA,IAAGF,iBAAiB,SAAShF,KAAK;AAClCkF,QAAAA,IAAGF,iBAAiB,SAASI,OAAO;MACtC,CAAC;IACH;EACF;AACF;AAEA;AAKA;AA6BA;AAiGM,2BAAsBG,eAC1BC,mBACA7F,kBACiE;AACjE,MAAIA,oBAAoB,KAAM,QAAO,CAAC;AACtC,QAAM8F,gBAAgB,MAAM,mBAAKvI,UAAQ4F,iBACtCC,oBAAoByC,iBAAiB,GAAGC;AAC3C,SAAO;IACL,CAAC9F,gBAAgB,GAAG;MAClB,CAAC6F,iBAAiB,GAAGC,aAAa9F,gBAAgB;IACpD;EACF;AACF;AAEA;AAWA;AAwDA,sCAAiC+F,SAACxH,SAA6B;AAC7D,QAAMnB,MAAM,mBAAK,gBAAesB,IAAIH,QAAQI,EAAE;AAC9C,MAAIvB,OAAO,QAAQ,mBAAK,qBAAoB4I,IAAIzH,QAAQI,EAAE,EAAG;AAC7D,GAAUvB,MAAGiB,OAAbI,UAAS,OAAM,4BAA4BF,QAAQI,EAAE,EAAE,IAAvDF,UAAS,KAAA,IAAA;AACT,qBAAK,kBAAL,WAAsBrB,KAAK,MAAMmB,QAAQ0H;AACzC,wBAAK,uDAAL,WAAkB7I,KAAK;AACzB;AAEA;AAQA;AAoCA;AA5jBA,aADWK,6BACJ,YAAa,oBAAIyI,QAGtB;AAJG,IAAMzI,6BAAN;AA+lBA,SAASqH,sBACdpC,SACAqC,aACA;AACA,QAAMoB,OAAO,IAAIC,IAAI1D,OAAO;AAC5B,QAAMmC,MAAM,IAAIuB,IACd,2CAA2CrB,WAAW,wBACtDoB,IACF;AACAtB,MAAIwB,WAAWxB,IAAIwB,SAASC,QAAQ,SAAS,KAAK;AAClD,SAAOzB;AACT;AAEA,IAAI0B,cAAc;AAElB,SAAS3C,WAAW;AAClB,SAAO,4BACJ2C,eAAenI,SAAS,EAAEoI,SAAS,IAAI,GAAG,CAAC;AAEhD;;;AC/pBA,SAASC,uBACPC,KAC6B;AAC7B,SAAOA,IAAIC,SAAS;AACtB;AAGO,SAASC,YAAYC,GAA6B;AACvD,SAAOA,KAAK,QAAQ,OAAOA,MAAM,YAC5BC,gBAAgBC,qBAAqBC,IAAIH,CAAC,CAAC;AAClD;AAGO,SAASI,iBACdC,WACe;AACf,SAAOH,qBAAqBC,IAAIE,SAAS;AAC3C;AAEA,IAAMH,uBAAuB,oBAAII,QAG/B;AAGK,SAASC,gBACdC,YACAC,WACAJ,YAA2BK,yBAAyBF,UAAU,GAChD;AACd,QAAMG,OAAqB;IACzBC,WAAYA,WAAmBC,KAC7BC,YACAC,sBAAsBN,WAAW,OAAM;MAAEO,iBAAiB;IAAY,EAAE,GACxER,YACAH,SACF;IAEAY,WAAWC,kBAAkBL,KAC3BC,YACAC,sBAAsBN,WAAW,OAAM;MAAEO,iBAAiB;IAAY,EAAE,GACxER,YACAH,SACF;IAEAc,qBAAqBC,4BAA4BP,KAC/CC,YACAC,sBACEN,WACA,OAAM;MAAEO,iBAAiB;IAAsB,EACjD,GACAR,YACAH,SACF;IAEAgB,OAAQC,YAAW;AACjB,aAAOb,UAAUc,iBAAiBf,YAAYC,WAAW;QACvDX,MAAM;QACNO;QACAgB,OAAOG,0BAA0BF,QAAQd,UAAU;MACrD,CAAC;IACH;IAEAiB,SAAS,SACP3B,MAC6B;AAC7B,aAAO4B,mBAAmB5B,IAAI,EAAE;IAClC;IAEA6B,OAAOA,IAAIC,eAAe;AACxB,aAAOnB,UAAUc,iBAAiBf,YAAYC,WAAW;QACvDX,MAAM;QACN8B,YAAY,CACVvB,WACA,GAAGuB,WAAWC,IAAIC,QAAM5B,qBAAqBC,IAAI2B,EAAE,CAAE,CAAC;MAE1D,CAAC;IACH;IAEAC,WAAWA,IAAIH,eAAe;AAC5B,aAAOnB,UAAUc,iBAAiBf,YAAYC,WAAW;QACvDX,MAAM;QACN8B,YAAY,CACVvB,WACA,GAAGuB,WAAWC,IAAIC,QAAM5B,qBAAqBC,IAAI2B,EAAE,CAAE,CAAC;MAE1D,CAAC;IACH;IAEAE,UAAUA,IAAIJ,eAAe;AAC3B,aAAOnB,UAAUc,iBAAiBf,YAAYC,WAAW;QACvDX,MAAM;QACN8B,YAAY,CACVvB,WACA,GAAGuB,WAAWC,IAAIC,QAAM5B,qBAAqBC,IAAI2B,EAAE,CAAE,CAAC;MAE1D,CAAC;IACH;IAEAG,WAAW,iBAOTC,MAC4D;AAC5D,UAAIC,iBAAqCC;AACzC,SAAG;AACD,cAAMC,SAMF,MAAMnB,kBACRH,sBACEN,WACA,OAAM;UAAEO,iBAAiB;QAAY,EACvC,GACAR,YACAH,WACA;UAAE,GAAG6B;UAAMI,WAAW;UAAOH;QAAe,CAC9C;AACAA,yBAAiBE,OAAOE;AAExB,mBAAWC,OAAOH,OAAOI,MAAM;AAC7B,gBAAMD;QACR;MACF,SAASL,kBAAkB;IAC7B;IAEAO,UAAW9C,uBAAuBY,UAAU,IACxC,OACAmC,YACAC,YACG;AACH,aAAO,MAAMC,YACX9B,sBACEN,WACA,OAAM;QAAEO,iBAAiB;MAAW,EACtC,GACAR,YACAoC,SACA,MAAME,aACJrC,WACAD,YACAH,WACAsC,UACF,CACF;IACF,IACEP;IAEJW,oBAAqBnD,uBAAuBY,UAAU,IAClD,OACAmC,YAEAC,YACG;AACH,aAAO,MAAMI,sBACXjC,sBACEN,WACA,OAAM;QAAEO,iBAAiB;MAAqB,EAChD,GACAR,YACAoC,SACA,MAAME,aACJrC,WACAD,YACAH,WACAsC,UACF,CACF;IACF,IACEP;IAEJa,WAAWA,CACTC,UACAC,SACG;AACH,YAAMC,mBAAmBC,2BAA2BC,YAClD7C,SACF,EAAEwC,UACAzC,YACAH,WACA6C,UACAC,6BAAMI,UACR;AAEA,aAAO;QAAEC,aAAa,aAAa,MAAMJ,kBAAkB;MAAE;IAC/D;IAEAK,gBAAiBnC,YAAW;AAC1B,YAAMoC,gBAAgB,oBAAIC,IAAoC;AAE9D,YAAMC,oBAA+D,CAAC;AACtE,iBAAWC,OAAOC,OAAOC,KAAKzC,MAAM,GAAG;AACrC,cAAM0C,4BAA4B1C,OAC/BuC,GAAG,EAAEI,8BACJzD,YACA;UAAEV,MAAM;QAAc,GACtB4D,eACA,IACF,CAAC;AACHE,0BAAkBC,GAAG,IAAIH,cAAcvD,IACrC6D,yBACF;MACF;AAEA,aAAOvD,UAAUc,iBACff,YACAC,WACA;QACEX,MAAM;QACN8D;QACAvD;MACF,CACF;IACF;IAEA6D,qBAAqB;MACnBrE,KAAKW;IACP;EACF;AAEA,WAASkB,mBAA2CyC,MAAS;AAC3D,WAAO,MAAM;AACX,aAAO1D,UAAUc,iBACff,YACAC,WACA;QACEX,MAAM;QACNO;QACA8D;MACF,CACF;IACF;EACF;AAEAjE,uBAAqBkE,IAAIzD,MAAMN,SAAS;AAIxC,SAAOM;AACT;AAEA,eAAemC,aACbrC,WACAD,YACAH,WACAsC,YACA;AACA,QAAM0B,SAAS,MAAM5D,UAAU6D,iBAAiBC,oBAC9C/D,WAAWgE,OACb;AAEA,QAAMC,SAAwB;IAC5B3E,MAAM;IACNO;IACAgB,OAAO;MACLvB,MAAM;MACN4E,OAAOL,OAAOM;MACdC,OAAOjC;IACT;EACF;AACA,SAAO8B;AACT;;;AC7SO,SAASI,uBACdC,GACqC;AACrC,SAAOA,KAAK,QAAQ,OAAOA,MAAM,YAC5B,iBAAiBA,KAAK,iBAAiBA;AAC9C;;;ACNO,SAASC,yBACdC,GACyD;AACzD,SAAOA,KAAK,OAAOA,MAAM,YAAY,OAAOA,EAAEC,aAAa,YACtDD,EAAEE,eAAe;AACxB;;;ACJO,SAASC,mBAAmBC,GAA+B;AAChE,SAAOA,KAAK,OAAOA,MAAM,YAAY,OAAOA,EAAEC,cAAc,YACvDD,EAAEE,gBAAgB;AACzB;;;ACNO,SAASC,QAAQC,GAA4B;AAClD,SAAOA,KAAK,OAAOA,MAAM,YAAY,UAAUA,KAAKA,EAAEC,SAAS,WAC1D,iBAAiBD,KAAKA,EAAEE,YAAYC,WAAW;AACtD;;;ACmBA,eAAsBC,YACpBC,OACAC,QACAC,gBACoB;AACpB,MAAIF,SAAS,MAAM;AAEjB,WAAOA;EACT;AAGA,MAAIG,MAAMC,QAAQJ,KAAK,KAAKA,iBAAiBK,KAAK;AAChD,UAAMC,SAASH,MAAMI,KAAKP,KAAK;AAC/B,QACEM,OAAOE,KAAMC,eACXC,mBAAmBD,SAAS,KAAKE,iBAAiBF,SAAS,CAC7D,GACA;AACA,YAAMG,YAAY,CAAA;AAClB,iBAAWZ,UAASM,QAAQ;AAC1BM,kBAAUC,KAAK,MAAMd,YAAYC,QAAOC,QAAQC,cAAc,CAAC;MACjE;AACA,aAAOU;IACT;AACA,UAAME,eAAeX,MAAMI,KACzBP,OACA,OAAOe,eACL,MAAMhB,YAAYgB,YAAYd,QAAQC,cAAc,CACxD;AACA,WAAOc,QAAQC,IAAIH,YAAY;EACjC;AAGA,MAAIJ,mBAAmBV,KAAK,GAAG;AAC7B,UAAMkB,aAAa,MAAmBC,mBAAYC,OAChDnB,QACAD,MAAMqB,MACN;MACEC,UAAUtB,MAAMuB;IAClB,CACF;AACA,WAAO,MAAMxB,YAAYmB,WAAWM,KAAKvB,QAAQC,cAAc;EACjE;AAEA,MAAIS,iBAAiBX,KAAK,GAAG;AAC3B,UAAMkB,aAAa,MAAmBC,mBAAYC,OAChDnB,QACAD,OACA;MACEsB,UAAUtB,MAAMuB;IAClB,CACF;AACA,WAAO,MAAMxB,YAAYmB,WAAWM,KAAKvB,QAAQC,cAAc;EACjE;AAIA,MAAIuB,cAAczB,KAAK,GAAG;AACxB,UAAM0B,WAAW,MAAmBC,+BACjCC,YACC3B,QACA,MAAMA,OAAO4B,aACb3B,eAAe4B,SACf9B,MAAMqB,MACN;MACEU,eAAe/B,MAAMgC;MACrBC,SAAS;IACX,CACF;AACF,WAAO,MAAMlC,YAAY2B,UAAUzB,QAAQC,cAAc;EAC3D;AAGA,MAAIgC,mBAAmBlC,KAAK,GAAG;AAC7B,WAAO,MAAMD,YAAYC,MAAMmC,cAAclC,QAAQC,cAAc;EACrE;AAEA,MAAIkC,yBAAyBpC,KAAK,GAAG;AACnC,WAAO,MAAMD,YAAYC,MAAMqC,aAAapC,QAAQC,cAAc;EACpE;AAEA,MAAIoC,QAAQtC,KAAK,GAAG;AAClB,WAAO,MAAMD,YACX,GAAGC,MAAMuC,YAAY,CAAC,CAAC,IAAIvC,MAAMuC,YAAY,CAAC,CAAC,IAC/CtC,QACAC,cACF;EACF;AAGA,MAAIsC,gBAAgBxC,KAAK,GAAG;AAC1B,WAAOA;EACT;AACA,MAAIyC,YAAYzC,KAAK,GAAG;AACtB,WAAO0C,iBAAiB1C,KAAK;EAC/B;AAEA,MAAI2C,iBAAiB3C,KAAK,GAAG;AAC3B,WAAOA;EACT;AAEA,MAAI4C,uBAAuB5C,KAAK,GAAG;AACjC,WAAO;MACL6C,mBAAmB7C,MAAM8C;MACzBC,iBAAiB/C,MAAMqC;IACzB;EACF;AAOA,MAAI,OAAOrC,UAAU,UAAU;AAC7B,WAAOgD,OAAOC,QAAQjD,KAAK,EAAEkD,OAC3B,OAAOC,aAAa,CAACC,KAAKC,WAAW,MAAM;AACzC,YAAMC,MAAM,MAAMH;AAClBG,UAAIF,GAAG,IAAI,MAAMrD,YAAYsD,aAAapD,QAAQC,cAAc;AAChE,aAAOoD;IACT,GACAtC,QAAQuC,QAAQ,CAAC,CAAiC,CACpD;EACF;AAGA,SAAOvD;AACT;;;ACvDA,eAAsBwD,YAUpBC,QACAC,QACAC,YACAC,UAAc,CAAC,GAGf;AA7HF;AA8HE,QAAMC,oBAAoBC,qCACxBC,sBAAsBN,QAAQ,OAAM;IAAEO,iBAAiB;EAAc,EAAE,GACvEN,MACF;AACA,MAAIO,MAAMC,QAAQP,UAAU,GAAG;AAC7B,UAAMQ,WAAW,MAAmBC,eAAQC,WAC1CR,mBACA,MAAMJ,OAAOa,aACbZ,OAAOa,SACP;MACEC,UAAUb,aACN,MAAMc,uBACNd,YACAF,QACA,MAAMA,OAAOiB,iBAAiBC,oBAAoBjB,OAAOa,OAAO,CAClE,IACE,CAAA;MACJX,SAAS;QACPgB,cAAahB,mCAASiB,gBAAe,QAAQ;MAC/C;IACF,CACF;AAEA,UAAMC,QAAQX,SAASW;AACvB,YAAQlB,mCAASiB,iBACbC,+BAAOC,UAAS,UAAUC,oBAAoBb,QAAQ,IAAIW,QAC1DG;EACN,OAAO;AACL,UAAMd,WAAW,MAAmBC,eAAQc,MAC1CrB,mBACA,MAAMJ,OAAOa,aACbZ,OAAOa,SACP;MACEZ,YAAY,MAAMwB,kBAChBxB,YAGAF,QACA,MAAMA,OAAOiB,iBAAiBC,oBAAoBjB,OAAOa,OAAO,CAClE;MACAX,SAAS;QACPwB,OAAOxB,mCAAgCyB,iBACnC,kBACA;QACJT,cAAahB,mCACPiB,gBACF,0BACA;MACN;IACF,CACF;AAEA,QAAKjB,mCAAgCyB,eAAe;AAClD,aAAOlB,SAASmB;IAClB;AAEA,QAAInB,SAASmB,gBAAcnB,cAASmB,eAATnB,mBAAqBoB,YAAW,WAAW;AACpE,YAAMD,aAAanB,SAASmB;AAC5B,YAAM,IAAIE,sBAAsBF,UAAU;IAC5C;AAEA,UAAMR,QAAQX,SAASW;AACvB,YAAQlB,mCAASiB,iBACbC,+BAAOC,UAAS,UAAUC,oBAAoBb,QAAQ,IAAIW,QAC1DG;EACN;AACF;AAEA,eAAeE,kBACbM,QAGAhC,QACAiC,gBACoC;AACpC,MAAID,UAAU,MAAM;AAClB,WAAO,CAAC;EACV;AAEA,QAAME,eAAqD,CAAC;AAC5D,aAAW,CAACC,KAAKC,KAAK,KAAKC,OAAOC,QAAQN,MAAM,GAAG;AACjDE,iBAAaC,GAAG,IAAI,MAAMI,YAAYH,OAAOpC,QAAQiC,cAAc;EACrE;AAEA,SAAOC;AACT;AAEA,eAAelB,uBAGbgB,QACAhC,QACAiC,gBACA;AACA,QAAMO,iBAAiB,MAAMC,QAAQC,IAAIV,OAAOW,IAC9C,OAAMC,UAAS;AACb,WAAO;MACL1C,YAAY,MAAMwB,kBAAsBkB,OAAO5C,QAAQiC,cAAc;IACvE;EACF,CACF,CAAC;AAED,SAAOO;AACT;AAEO,SAASjB,oBACdb,UACgC;AAzOlC;AA0OE,QAAMmC,gBAAgBnC,qCAAUW;AAChC,OAAIwB,+CAAevB,UAAS,SAAS;AACnC,UAAMwB,yBAA6C;MACjDxB,MAAMuB,cAAcvB;MACpByB,mBAAmBF,cAAcE;MACjCC,qBAAqBH,cAAcG;MACnCC,YAAY,CAAA;MACZC,cAAc,CAAA;MACdC,cAAc,CAAA;MACdC,gBAAgB,CAAA;MAChBC,iBAAiB,CAAA;MACjBC,mBAAmB,CAAA;IACrB;AAEA,UAAMC,uBAAuB,oBAAIC,IAAY;AAC7C,eAAWC,QAAQZ,cAAcxB,OAAO;AACtC,UAAIoC,KAAKnC,SAAS,aAAamC,KAAKnC,SAAS,cAAc;AACzD,cAAMoC,WAAW;UACfC,qBAAqBF,KAAKE;UAC1BC,qBAAqBH,KAAKG;UAC1BC,aAAaJ,KAAKI;UAClBC,aAAaL,KAAKK;QACpB;AACAL,aAAKnC,SAAS,YACVwB,uBAAuBG,WAAWc,KAClCL,QACF,KACEZ,4BAAuBI,iBAAvBJ,mBAAqCiB,KAAKL;AAC9CH,6BAAqBS,IAAIP,KAAKI,YAAYI,UAAU;AACpDV,6BAAqBS,IAAIP,KAAKK,YAAYG,UAAU;MACtD,WACER,KAAKnC,SAAS,eAAemC,KAAKnC,SAAS,kBACxCmC,KAAKnC,SAAS,gBACjB;AACA,cAAMoC,WAAW;UACfO,YAAYR,KAAKQ;UACjBC,YAAYT,KAAKS;QACnB;AACA,YAAIT,KAAKnC,SAAS,aAAa;AAC7BwB,iCAAuBK,aAAaY,KAAKL,QAAQ;QACnD,WAAWD,KAAKnC,SAAS,gBAAgB;AACvCwB,uCAAuBM,mBAAvBN,mBAAuCiB,KAAKL;QAC9C,WAAWD,KAAKnC,SAAS,gBAAgB;AACvCwB,iCAAuBO,gBAAgBU,KAAKL,QAAQ;QACtD;AACAH,6BAAqBS,IAAIP,KAAKQ,UAAU;MAC1C,OAAO;AACL,YAAIE,MAAuC;AAEzCC,kBAAQC,KACN,yBAAyBC,KAAKC,UAAUd,IAAI,CAAC,EAC/C;QACF;MACF;IACF;AACAX,2BAAuBQ,oBAAoB,CAAC,GAAGC,oBAAoB;AACnE,WAAOT;EACT;AACF;;;ACpMO,IAAM0B,oBAAmCC,OAAO,mBAAmB;AAM1E,IAAMC,eAA8BC,OAAO,cAAc;;;AC3ElD,SAASC,0BACdC,SACAC,eACAC,WACAC,UAAmCC,OACW;AAC9C,MAAIJ,QAAQK,WAAW,GAAG;AACxB,UAAM,IAAIC,MAAM,yBAAyB;EAC3C;AAEA,QAAMC,+BAA+BC,yBACnCC,oBAAoBC,mBAAmBP,OAAO,CAAC,GAC/C,OAAOQ,YAAY;AACjB,UAAMC,QAAQ,MAAMX,cAAc;AAClCU,YAAQE,IAAI,iBAAiB,UAAUD,KAAK,EAAE;AAE9CD,YAAQE,IACN,oBACA,CACEF,QAAQG,IAAI,kBAAkB,GAC9BZ,SAAS,EACTa,OAAOC,OAAKA,MAAKA,uBAAGX,UAAS,CAAC,EAAEY,KAAK,GAAG,CAC5C;AACA,WAAON;EACT,CACF;AA0BA,SAAO;IACLX;IACAI,OAzBmB,OACnBc,OACAC,SACG;AACH,UAAI;AACF,eAAO,MAAMZ,6BAA6BW,OAAOC,IAAI;MACvD,SAASC,GAAQ;AACf,cAAMC,cAAeD,aAAaE,mBAC9B,IAAIA,iBACJF,EAAEG,SACFH,EAAEI,WACFJ,EAAEK,WACFL,EAAEM,YACFN,EAAEO,iBACFP,EAAEQ,UACJ,IACE,IAAItB,MAAM,sCAAsCc,EAAEG,WAAWH,EAAE;AAElEC,oBAAoBQ,QAAQT;AAC7B,cAAMC;MACR;IACF;IAKEpB;EACF;AACF;;;ACnEA,IAAM6B,cAAc,IAAIC,WAAW,CAAC,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI,IAAI,EAAE,CAAC;AAC1E,IAAMC,wBAAwB;AAC9B,IAAMC,yBAAyB;AAE/B,gBAAuBC,sBACrBC,eACoC;AACpC,QAAMC,cAAc,IAAIC,YAAY,OAAO;AAE3C,MAAIC,cAAc;AAClB,MAAIC,aAA2B,CAAA;AAC/B,MAAIC,kBAAkB;AAEtB,iBAAeC,SAASN,eAAe;AAErC,QAAIO,IAAI;AACR,QAAI,CAACJ,aAAa;AAChBA,oBAAc;AACd,UAAIK,WAAWF,OAAOX,WAAW,GAAG;AAClCY,YAAIZ,YAAYc;MAClB;IACF;AAEA,WAAOF,IAAID,MAAMG,QAAQF,KAAK;AAE5B,aACEF,oBAAoB,KAAKC,MAAMC,CAAC,MAAMV,yBACnCU,IAAID,MAAMG,QACb;AACAF;MACF;AAGA,UAAIG,IAAIH;AACR,aAAOG,IAAIJ,MAAMG,QAAQC,KAAK;AAC5B,cAAMC,IAAIL,MAAMI,CAAC;AACjB,YAAIC,MAAMd,uBAAuB;AAC/BQ;QACF,WAAWM,MAAMb,wBAAwB;AACvCO;AAGA,cAAI,MAAMA,iBAAiB;AACzB,kBAAMO,gBACJX,aACAG,YACAE,MAAMO,SAASN,GAAGG,IAAI,CAAC,CACzB;AAGAN,yBAAa,CAAA;AAIbG,gBAAIG;AACJ;UACF;QACF;MACF;AAIA,UAAIA,MAAMJ,MAAMG,QAAQ;AACtBL,mBAAWU,KAAKR,MAAMO,SAASN,CAAC,CAAC;AACjC;MACF;IACF;EACF;AACF;AAEA,SAASC,WAAWO,GAAeC,GAAe;AAChD,MAAID,EAAEN,SAASO,EAAEP,QAAQ;AACvB,WAAO;EACT;AAEA,WAASF,IAAI,GAAGA,IAAIS,EAAEP,QAAQF,KAAK;AACjC,QAAIQ,EAAER,CAAC,MAAMS,EAAET,CAAC,GAAG;AACjB,aAAO;IACT;EACF;AAEA,SAAO;AACT;AAEA,SAASK,gBACPX,aACAgB,MACAC,MACA;AACA,MAAIC,MAAM;AACV,aAAWb,SAASW,MAAM;AACxBE,WAAOlB,YAAYmB,OAAOd,OAAO;MAAEe,QAAQ;IAAK,CAAC;EACnD;AACAF,SAAOlB,YAAYmB,OAAOF,IAAI;AAE9B,SAAOI,KAAKC,MAAMJ,GAAG;AACvB;AAEA,gBAAuBK,sBACrBC,gBAC2C;AAC3C,MAAIC,MAAM,MAAMD,eAAeE,KAAK;AACpC,SAAO,CAACD,IAAIE,MAAM;AAChB,UAAMF,IAAIG;AACVH,UAAM,MAAMD,eAAeE,KAAK;EAClC;AACF;;;ACrGO,SAASG,aAAaC,MAAkC;AAC7D,MAAI,gBAAgBA,QAAQ,cAAcA,MAAM;AAC9C,WAAO;MACLC,MAAM;MACNC,WAAWF,KAAKG;MAChBC,SAASJ,KAAKK;IAChB;EACF;AACA,SAAOL,KAAKM,UACR;IACAL,MAAM;IACNC,WAAW;MACTK,MAAM;MACNC,OAAOR,KAAKM;MACZG,MAAMC,0BAA0BV,KAAKW,KAAK;IAC5C;EACF,IACE;IACAV,MAAM;IACNG,SAAS;MACPG,MAAM;MACNC,OAAOR,KAAKY;MACZH,MAAMC,0BAA0BV,KAAKW,KAAK;IAC5C;EACF;AACJ;AAEA,gBAAuBE,sBAGrBC,UAQA;AA3DF;AA4DE,QAAMC,UAASD,cAASd,SAATc,mBAAeE;AAC9B,mBACQC,SAASC,sBAAsBC,sBAAsBJ,MAAM,CAAC,GAClE;AACA,UAAM;MACJK,MAAMH,MAAMG;MACZZ,OAAOS,MAAMT;IACf;EACF;AACF;;;ACrEA,cAAAa;AAyBO,IAAMC,4BAAN,MAEP;EAKEC,YACEC,QACAC,eACAC,YACAC,cACAC,cACA;AAVF;AACA,uBAAAP;AAUE,uBAAKA,UAAUG;AACf,uBAAK,UAAW,CAACC,eAAeC,YAAYC,YAAY;AACxD,QAAIC,gBAAgB,MAAM;AACxB,WAAKC,mBAAmBD;IAC1B;EACF;EAEA,MAAaE,iBAA0D;AACrE,UAAMC,qBAAkCC,oCACrCF,eACC,mBAAKT,WACL,MAAM,mBAAKA,UAAQY,aACnB,GAAG,mBAAK,SACV;AACFF,uBAAmBG;MACjBC,iBAAe,KAAKN,mBAAmBM;;MAEvCC,SAAO,KAAKC,QAAQC,MAAMF,GAAG;IAC/B;AACA,WAAOL;EACT;EAEA,MAAaQ,aACXC,OAC+B;AAC/B,UAAMC,YAAuC,CAAA;AAE7C,qBAAiBC,SAAS,KAAKC,gBAAgBH,KAAK,GAAG;AACrDC,gBAAUG,KAAKF,KAAK;IACtB;AACA,WAAOD;EACT;EAEA,OAAcE,gBACZH,OAQA;AACA,UAAMK,uBAAuB,MAC1Bb,oCAA8Bc,aAC7B,mBAAKzB,WACL,MAAM,mBAAKA,UAAQY,aACnB,GAAG,mBAAK,WACRO,QAAQ;MAAEO,OAAOC,aAAaR,KAAK;IAAE,IAAI,CAAC,CAC5C;AAEF,qBACQS,mBAAmBC,sBAAyBL,oBAAoB,GACtE;AACA,YAAMI;IACR;EACF;AACF;AApEE;AACA5B,WAAA;;;AC7BF,qBAAA8B,WAAAC;AAqBO,IAAMC,6BAAN,MAAkD;EAKvDC,YAAYC,MAMT;AAVH;AACA,uBAAAJ;AACA,uBAAAC;AASE,UAAM;MACJI;MACAC;MACAC;MACAC;MACAC;IACF,IAAIL;AACJ,uBAAKH,UAAUI;AACf,uBAAKL,WAAW,CAACM,eAAeC,YAAYC,YAAY;AACxD,uBAAK,iBAAkBC;EACzB;EAEA,MAAaC,gBAAmC;AAC9C,WAAoBC,+BAAyBC,gBAC3C,mBAAKX,WACL,MAAM,mBAAKA,UAAQY,aACnB,GAAG,mBAAKb,YACR;MACEc,SAAS;;IACX,CACF;EACF;EAEA,MAAaC,gBAAwC;AACnD,UAAMC,IAAI,MAAmBL,+BAAyBM,iBACpD,mBAAKhB,WACL,MAAM,mBAAKA,UAAQY,aACnB,GAAG,mBAAKb,YACR;MACEc,SAAS;;IACX,CACF;AACA,WAAO;MACLI,MAAMF,EAAEE;MACRC,WAAWC,OAAOJ,EAAEG,SAAS;MAC7BE,WAAWL,EAAEK;IACf;EACF;EAEOC,oBAAoC;AACzC,WAAO,mBAAK;EACd;AACF;AArDE;AACAtB,YAAA;AACAC,WAAA;;;ACxBF,IAAAsB,WAAAC;AAyBO,IAAMC,yBAAN,MAEP;EAIEC,YACEC,QACAC,eACAC,YACAC,cACA;AARF,uBAAAP;AACA,uBAAAC;AAQE,uBAAKA,UAAUG;AACf,uBAAKJ,WAAW,CAACK,eAAeC,YAAYC,YAAY;EAC1D;EAEA,MAAaC,gBAA6C;AACxD,WAAoBC,6BAAuBD,cACzC,mBAAKP,WACL,MAAM,mBAAKA,UAAQS,aACnB,GAAG,mBAAKV,UACV;EACF;EAEA,MAAaW,eAA4C;AACvD,WAAoBF,6BAAuBE,aACzC,mBAAKV,WACL,MAAM,mBAAKA,UAAQS,aACnB,GAAG,mBAAKV,UACV;EACF;EAEA,MAAaY,aACXC,OAC+B;AAC/B,UAAMC,YAAuC,CAAA;AAE7C,qBAAiBC,SAAS,KAAKC,gBAAgBH,KAAK,GAAG;AACrDC,gBAAUG,KAAKF,KAAK;IACtB;AACA,WAAOD;EACT;EAEA,OAAcE,gBACZH,OAQA;AACA,UAAMK,uBAAuB,MAAmBT,6BAC7CU,aACC,mBAAKlB,WACL,MAAM,mBAAKA,UAAQS,aACnB,GAAG,mBAAKV,YACRa,QAAQ;MAAEO,OAAOC,aAAaR,KAAK;IAAE,IAAI,CAAC,CAC5C;AAEF,qBACQS,mBAAmBC,sBAAyBL,oBAAoB,GACtE;AACA,YAAMI;IACR;EACF;AACF;AAhEEtB,YAAA;AACAC,WAAA;;;ACMK,SAASuB,iCACdC,QACAC,KACY;AACZ,SAAO;IACLA;IACA,MAAMC,gBAAgB;AACpB,aAAoBC,mBAAYC,KAAKJ,QAAQC,GAAG;IAClD;IACA,MAAMI,gBAAgB;AACpB,YAAMC,IAAI,MAAmBH,mBAAYI,IAAIP,QAAQC,GAAG;AACxD,aAAO;QACL,GAAGK;QACHE,WAAWC,OAAOH,EAAEE,SAAS;MAC/B;IACF;EACF;AACF;;;ACtBO,SAASE,oCAEdC,WAAcC,YAAmD;AACjE,SAAO,GAAGD,UAAUE,OAAO,IAAID,UAAU;AAC3C;AAQO,SAASE,qCACdC,iBACQ;AACR,SAAOA,gBAAgBC,MAAM,GAAG,EAAE,CAAC;AACrC;;;ACtBO,IAAMC,uBAAsCC,OACb,sBACtC;;;ACPO,IAAMC,uBAAuBC,OACE,mBACtC;AAGO,IAAMC,eAAeD,OACU,kBACtC;AAGO,IAAME,kBAAkBF,OACO,qBACtC;AAGO,IAAMG,YAAYH,OACa,WACtC;;;ACRO,SAASI,oBAGdC,YACAC,cACiB;AACjB,QAAM,CAACC,eAAe,IAAIC,iBAAiBF,aAAaG,OAAO;AAE/D,SAAOC,OAAOC,OACZD,OAAOE,iBAAiB,CAAC,GAAG;;IAE1B,CAACC,oBAAoB,GAAG;MAAEC,OAAOT;IAAW;IAE5C,YAAY;MAAES,OAAOR,aAAaG;MAASM,YAAY;IAAK;IAC5D,OAAO;MACLD,OAAOT,WAAWW;MAClBD,YAAY;IACd;IACA,eAAe;MACbD,OAAOT,WAAWY;MAClBF,YAAY,iBAAiBV;IAC/B;IACA,eAAe;MACbS,OAAOT,WAAWa;MAClBH,YAAY,iBAAiBV;IAC/B;IACA,oBAAoB;MAClBS,OAAOT,WAAWc;MAClBJ,YAAY,sBAAsBV;IACpC;IACA,UAAU;MACRS,OAAOT,WAAWe;MAClBL,YAAY,YAAYV;IAC1B;IACA,QAAQ;MACNS,OAAQT,WAAmBgB;MAC3BN,YAAY,UAAUV;IACxB;IACA,UAAU;MACRS,OAAOQ;MACPP,YAAY;IACd;IAEA,CAACQ,eAAe,GAAG;MAAET,OAAOR;IAAa;IAEzC,GAAGI,OAAOc,YACRd,OAAOe,KAAKnB,aAAaoB,UAAU,EAAEC,IAAIC,OAAK;AAC5C,YAAMC,SAASxB,WAAWyB,YAAY;AAEtC,YAAM,CAACC,cAActB,OAAO,IAAID,iBAAiBoB,CAAC;AAElD,YAAMI,iBAAiBH,OACpBI,aAAc3B,aAAaG,OAAO,EAAEmB,CAAC;AAExC,aAAO,CAACG,iBAAiBxB,kBAAkBE,UAAUmB,GAAG;QACtDb,YAAYiB,kBAAkB3B;QAC9BS,OAAOT,WAAW2B,cAAc;MAClC,CAAC;IACH,CAAC,CACH;EACF,CAAC,CACH;AACA,WAASV,MAAMY,QAAyC;AACtD,QAAIA,UAAU,MAAM;AAClB,aAAO7B,WAAW8B,OAAO,EAAEnB,IAAIV,YAAY;IAC7C;AAEA,eAAW8B,OAAO1B,OAAOe,KAAKS,MAAM,GAAG;AACrC,UAAI,EAAEE,OAAO9B,aAAaoB,aAAa;AACrC,cAAM,IAAIW,MACR,oBAAoBD,GAAG,kBAAkB9B,aAAaG,OAAO,EAC/D;MACF;IACF;AAEA,UAAM6B,gBAAgB5B,OAAOc,YAC3Bd,OAAOe,KAAKS,MAAM,EAAEP,IAAIC,OAAKW,YAAYX,GAAGM,OAAON,CAAC,CAAC,CAAC,EAAEY,OAAOC,OAC7DA,KAAK,IACP,CACF;AAEA,WAAOpC,WAAW8B,OAAOG,aAAa,EAAEtB,IAAIV,YAAY;EAC1D;AACA,WAASiC,YAAYG,cAAsB5B,OAAY;AACrD,UAAMe,SAASxB,WAAWyB,YAAY;AACtC,UAAME,iBACJH,OAAOI,aAAc3B,aAAaG,OAAO,EAAEiC,YAAY;AAEzD,QAAIV,kBAAkB,MAAM;AAC1B,YAAM,IAAIK,MACR,+BAA+BK,YAAY,iEAAiEb,OAAOpB,OAAO,EAC5H;IACF;AACA,WAAO,CAACuB,gBAAgBlB,KAAK;EAC/B;AACF;;;ACvFO,IAAM6B,SACXC,kBAGE,oBAAIC,QAAQ,GAAGC,UAAU,EAAEC;AAE/B,IAAMC,4BAA4BJ,kBAChC,oBAAIC,QAGF,GACF,MACE,oBAAII,IAGF,CACN;AAEA,SAASH,WACPI,QACY;AAGZ,SAAO,SAILC,cACe;AAhEnB;AAiEI,QAAIC;AAEJ,QAAI,OAAOD,iBAAiB,UAAU;AACpC,UAAIA,iBAAiBD,OAAOG,SAAS;AACnC,eAAO,KAAKC,oBAAoB;MAClC;AAGA,YAAIJ,YAAOK,iBAAPL,mBAAsBC,kBAAiB,MAAM;AAC/C,cAAM,IAAIK,MACR,wCAAwCL,YAAY,IACtD;MACF;AAEAC,+BAAyBD;IAC3B,WAAWA,aAAaE,YAAYH,OAAOG,SAAS;AAClD,aAAO,KAAKC,oBAAoB;IAClC,OAAO;AACL,UAAIH,aAAaM,SAAS,UAAU;AAClC,cAAM,IAAID,MACR,IAAIL,aAAaE,OAAO,oCAAoCH,OAAOG,OAAO,8BAC5E;MACF;AACAD,+BAAyBD,aAAaE;IACxC;AAEA,UAAMK,MAAMR,OAAOS,oBAAoB,EAAEP,sBAAsB;AAC/D,QAAI,CAACM,KAAK;AACR,YAAM,IAAIF,MACR,wCAAwCJ,sBAAsB,IAChE;IACF;AAEA,UAAMQ,aAAa,KAAKN,oBAAoB;AAE5C,UAAMO,YAAWb,+BACdD,IAAIa,UAAU,EACdb,IAAIK,sBAAsB,MAFZJ,mBAEec;AAChC,QAAID,SAAU,QAAOA;AAErB,UAAME,gBAAgBC,oBAAoBJ,YAAYF,IAAIA,GAAG;AAC7DV,8BAA0BD,IAAIa,UAAU,EAAEK,IACxCb,wBACA,IAAIc,QAAQH,aAAa,CAC3B;AACA,WAAOA;EACT;AACF;;;AC/EO,SAASI,SACdC,QAC4B;AAC5B,QAAMC,SAASD,OAAOE,SAAS;AAC/B,QAAMC,SAASH,OAAOI,YAAY;AAClC,QAAMC,SAASL,OAAOM,oBAAoB;AAC1C,SAAOC,OAAOC,OAAOD,OAAOE,YAC1BF,OAAOG,KAAKP,OAAOQ,KAAK,EAAEC,IACvBC,cAAa;AACZ,UAAMC,UAAUX,OAAOQ,MAAME,QAAQ;AACrC,UAAME,YACHd,OAAOe,iBAAiBb,QAAQF,MAAM,EACpCgB,MAAM;MACL,CAACd,OAAOe,iBAAiB,GAAGb,OAAOc;IACrC,CAAqB,EACpBC,QAAQP,QAAQ;AAErB,UAAMQ,QAAQ,CAACP,QAAQQ,eACnB;MACAC,UACEC,aAEAC,YACExB,QACAE,QACAqB,WAAW,CAAC,GACZE,iBAAiBX,SAAS,CAC5B;MACFY,oBACEH,aAEAI,sBACE3B,QACAE,QACAqB,WAAW,CAAC,GACZE,iBAAiBX,SAAS,CAC5B;IACJ,IACEA;AAEJ,WAAO,CAACF,UAAUQ,KAAK;EACzB,CACF,CACF,CAAC;AACH;;;ACxCA,IAAMQ,uBAAuB,oBAAIC,IAC/B,CACE,cACA,0BACA,kBACA,qBACA,oBACA,kBAAkB,CAEtB;AAIA,IAAMC,eAAe;EACnB,OAAO;IACLC,KAAK,WAA6B;AAChC,aAAOC,OAAO,KAAKC,YAAY,CAAC;IAClC;EACF;EACA,SAAS;IACPF,KAAK,WAA6B;AAChC,aAAOG,SAAS,IAAI;IACtB;EACF;EACA,UAAU;IACRC,OAAO,SAELC,QACA;AAEA,YAAMC,SAAS,KAAKC,oBAAoB;AACxC,YAAMC,MAAM,KAAKN,YAAY;AAE7B,UAAIG,UAAU,MAAM;AAClB,eAAOI,iBAAiB,KAAKC,SAAS,GAAGF,KAAK;UAAE,GAAGF;QAAO,CAAC;MAC7D;AAEA,UACEE,IAAIG,qBAAqBN,UACtBC,OAAOE,IAAIG,iBAAiB,MAAMN,OAAOG,IAAIG,iBAAiB,GACjE;AACA,cAAM,IAAIC,MACR,iBAAiBJ,IAAIK,OAAO,4CAC9B;MACF;AAEA,UAAIL,IAAIM,iBAAiBT,UAAU,EAAE,YAAYA,SAAS;AACxDA,eAAOU,SAASV,OAAOG,IAAIM,aAAa;MAC1C;AAEA,YAAME,YAAY;QAAE,GAAG,KAAKT,oBAAoB;QAAG,GAAGF;MAAO;AAC7D,aAAOI,iBAAiB,KAAKC,SAAS,GAAG,KAAKR,YAAY,GAAGc,SAAS;IACxE;EACF;EACA,oBAAoB;IAClBhB,KAAK,WAA6B;AAChC,YAAMM,SAAS,KAAKC,oBAAoB;AACxC,aAAOU,oCACL,KAAKf,YAAY,GACjBI,OAAOY,WACT;IACF;IACAC,YAAY;EACd;AACF;AAQO,SAASV,iBACdW,QACAC,WACAC,sBACAC,4BAA4D,CAAC,GAC/C;AAEd,QAAMjB,SAASgB;AACfE,SAAOC,iBACLnB,QACA;IACE,CAACC,oBAAoB,GAAG;MACtBY,YAAY;MACZf,OAAOkB;IACT;IACA,CAACpB,YAAY,GAAG;MAAEE,OAAOiB;MAAWF,YAAY;IAAM;IACtD,CAACT,SAAS,GAAG;MAAEN,OAAOgB;MAAQD,YAAY;IAAM;IAChD,GAAGpB;EACL,CACF;AAGA,aAAW2B,WAAWF,OAAOG,KAAKrB,MAAM,GAAG;AACzC,QACEoB,WAAWL,UAAUO,cAClB,OAAQP,UAAUO,WAAWF,OAAO,EAAEG,SAAU,YAChDhC,qBAAqBiC,IAAIT,UAAUO,WAAWF,OAAO,EAAEG,IAAI,GAC9D;AACAvB,aAAOoB,OAAO,IAAIK,sBAChBX,QACAC,WACAf,QACAoB,OACF;IACF,WAAWA,WAAWH,2BAA2B;AAC/CjB,aAAOoB,OAAO,IAAIM,oBAChBZ,QACAG,2BACAjB,OAAOoB,OAAO,GACdA,OACF;IACF;EACF;AAEA,SAAOF,OAAOS,OAAO3B,MAAM;AAC7B;AAEA,SAAS0B,oBACPZ,QACAG,2BACAW,UACAR,SACK;AAjKP;AAkKE,MACEH,0BAA0BG,OAAO,EAAES,WAAWN,SAAS,eACpDN,0BAA0BG,OAAO,EAAES,WAAWC,UAAUP,SACrD,SACN;AACA,UAAMQ,MAAMC,OAAOJ,QAAQ;AAC3B,KACEI,OAAOC,cAAcF,GAAG,IAACG,OAD3BC,UAAS,OAEP,4CAA4Cf,UACxC,6CAA6C,IAHnDe,UAAS,KAAA,IAAA;AAKT,WAAOJ;EACT,WAEEd,0BAA0BG,OAAO,EAAEgB,mCAC9B,QACF,OAAQnB,0BAA0BG,OAAO,EACvCgB,gCAAgCb,SAC/B,YACHhC,qBAAqBiC,IACtBP,0BAA0BG,OAAO,EAAEgB,gCAChCb,IACL,GACA;AACA,aACEN,+BAA0BG,OAAO,EAAEgB,oCAAnCnB,mBACIM,MAAI;MAER,KAAK;AACH,YAAIc,MAAMC,QAAQV,QAAQ,GAAG;AAC3B,iBAAOA,SAASW,IAAIC,OAClBC,iCAAiC3B,QAAQ0B,EAAEE,GAAG,CAChD;QACF,OAAO;AACL,iBAAOD,iCACL3B,QACCc,SAAwBc,GAC3B;QACF;AACA;MACF;AACER,eAAAC,UAAS,OAEP,0EAA0E,IAF5EA,UAAS,KAAA;IAIb;EACF;AACA,SAAOP;AACT;AAEA,SAASH,sBACPX,QACAC,WACA4B,WACAC,GACA;AACA,QAAMhB,WAAWe,UAAUC,CAAC;AAC5B,QAAMC,UAAU9B,UAAUO,WAAWsB,CAAC;AACtC,MAAIV,MAAuC;AACzC,MACEW,WAAW,QAAQ,OAAOA,QAAQtB,SAAS,YACtChC,qBAAqBiC,IAAIqB,QAAQtB,IAAI,KAACW,OAF7CC,UAAS,KAAA,IAATA,UAAS,KAAA,IAAA;EAIX;AACA,MAAIU,QAAQtB,SAAS,cAAc;AACjC,QAAIc,MAAMC,QAAQV,QAAQ,GAAG;AAC3B,aAAOA,SAASW,IAAIC,OAAKC,iCAAiC3B,QAAQ0B,EAAEE,GAAG,CAAC;IAC1E;AACA,WAAOD,iCACL3B,QACCc,SAAwBc,GAC3B;EACF;AAEA,MACEG,QAAQtB,SAAS,uBACdsB,QAAQtB,SAAS,sBACjBsB,QAAQtB,SAAS,oBACpB;AACA,WAAO,IAAIuB,uBAKThC,QACAC,UAAUR,SACVoC,UAAU5B,UAAUV,iBAAiB,GACrCuC,CACF;EACF;AAEA,MAAIC,QAAQtB,SAAS,0BAA0B;AAC7C,WAAO,IAAIwB,0BACTjC,QACAC,UAAUR,SACVoC,UAAU5B,UAAUV,iBAAiB,GACrCuC,GACChB,SAA4BL,SAAS,uBAClC;MACAyB,MAAOpB,SAA4BqB;MACnCnD,OAAO;QACLyB,MAAM;QACN2B,aAActB,SAA4BuB;MAC5C;IACF,IACEC,MACN;EACF;AACA,MAAIP,QAAQtB,SAAS,kBAAkB;AACrC,WAAO,IAAI8B,2BAA2B;MACpCvC;MACAwC,eAAevC,UAAUR;MACzBgD,YAAYZ,UAAU5B,UAAUV,iBAAiB;MACjDmD,cAAcZ;MACda,gBAAgB7B;IAClB,CAAC;EACH;AACF;;;AClOA,eAAsB8B,yBACpBC,QACAC,SACAC,kBACAC,iBAA0B,OAC1BC,4BACAC,eACAC,gBAAsC,OACU;AAGhDC,6BAA2BN,SAASE,cAAc;AAElD,QAAMK,WAAWN,mBACb,MAAMF,OAAOS,iBAAiBC,uBAAuBR,gBAAgB,IACrES;AACJ,QAAMC,gBAAgBJ,WACjBH,iBAAiBQ,OAAOC,KAAKN,SAASO,UAAU,IACjDJ;AAEJ,QAAMK,MAAM,CAAA;AACZ,aAAWC,UAAUhB,SAAS;AAC5B,UAAMiB,YAAY,MAAMlB,OAAOS,iBAAiBU,oBAC9CF,OAAOG,QACT;AACA,KAAUF,YAASG,OAAnBC,UAAS,OAAY,2BAA2BL,OAAOG,QAAQ,GAAG,IAAlEE,UAAS,KAAA,IAAA;AAGT,QAAIC;AAEJ,QAAIC,aAAa;AACjB,QAAIhB,YAAYI,eAAe;AAE7Ba,iCAA2BP,WAAWV,SAASkB,SAAS1B,MAAM;AAE9DwB,kCAAeG,aAAa3B,QAAQQ,UAAUS,QAAQL,aAAa;AAEnEgB,6BAAuBV,WAAWV,SAASkB,SAAST,MAAM;AAE1DM,iBAAWM,2CACTX,WACAV,SAASkB,SACTd,aACF;IACF,OAAO;AACLW,iBAAWlB,iBAAiBQ,OAAOC,KAAKI,UAAUH,UAAU;IAC9D;AAEAS,gCAAeG,aAAa3B,QAAQkB,WAAWD,QAAQM,QAAQ;AAE/D,QAAIjB,kBAAkB,WAAW,CAACkB,YAAY;AAC5C,YAAM,IAAIM,MACR,2EACF;IACF,WAAWxB,kBAAkB,UAAU,CAACkB,YAAY;AAClD;IACF;AAEA,QAAIO,aAA6CC,iBAC/ChC,QACAkB,WACAD,QACAb,0BACF;AACA,QAAIF,iBAAkB6B,cAAaA,WAAWE,IAAI/B,gBAAgB;AAElEc,QAAIkB,KAAKH,UAAU;EACrB;AAEA,SAAOf;AACT;AA4CA,eAAsBmB,0BACpBnC,QACAC,SACAC,kBACAkC,2BACAjC,iBAA0B,OAC1BE,eACAC,gBAAsC,OACtC+B,gCAGI,CAAC,GAC2C;AAChD9B,6BAA2BN,SAASE,cAAc;AAElD,QAAMa,MAAM,CAAA;AACZ,aAAWC,UAAUhB,SAAS;AAC5B,UAAMiB,YAAY,MAAMlB,OAAOS,iBAAiBU,oBAC9CF,OAAOG,QACT;AACA,KAAUF,YAASG,OAAnBC,UAAS,OAAY,2BAA2BL,OAAOG,QAAQ,GAAG,IAAlEE,UAAS,KAAA,IAAA;AAET,UAAMgB,wBAAwBpC,mBAC1BmC,8BAA8BnC,gBAAgB,EAC9Ce,OAAOG,QAAQ,IAEfT;AAEJ,UAAMC,gBAAgBV,oBAAoBoC,wBACrCjC,gBACCQ,OAAOC,KAAKwB,qBAAqB,EAAEC,OACnCC,SAAO;AACLnC,qDAAeoC,SAASH,sBAAsBE,GAAG;IACnD,CACF,IACE,CACA,GAAG3B,OAAO6B,OAAOJ,qBAAqB,GACtCpB,UAAUyB,iBAAiB,IAE7BhC;AAGJ,QAAIY;AAEJ,QAAIC,aAAa;AACjB,QAAItB,oBAAoBU,eAAe;AACrCa,iCAA2BP,WAAWhB,kBAAkBF,MAAM;AAE9DuB,iBAAWX;IACb,OAAO;AACLW,iBAAWlB,iBAAiBQ,OAAOC,KAAKI,UAAUH,UAAU;IAC9D;AAEAS,gCAAeG,aAAa3B,QAAQkB,WAAWD,QAAQM,QAAQ;AAE/D,QAAIjB,kBAAkB,WAAW,CAACkB,YAAY;AAC5C,YAAM,IAAIM,MACR,2EACF;IACF,WAAWxB,kBAAkB,UAAU,CAACkB,YAAY;AAClD;IACF;AAEA,QAAIO,aAA6CC,iBAC/ChC,QACAkB,WACAD,QACAmB,yBACF;AACA,QAAIlC,iBAAkB6B,cAAaA,WAAWE,IAAI/B,gBAAgB;AAElEc,QAAIkB,KAAKH,UAAU;EACrB;AAEA,SAAOf;AACT;AAQO,SAASa,2CACdX,WACAhB,kBACA0C,iBACU;AACV,SAAOA,gBAAgBC,IAAKC,eAC1B5B,UAAU6B,aAAa7C,gBAAgB,EAAE4C,SAAS,CACpD;AACF;AAUA,SAASlB,uBACPV,WACAhB,kBACAe,QACA;AACA,QAAM+B,WAAgC,CAAC;AACvC,aACQ,CAACC,SAASC,WAAW,KAAKrC,OAAOsC,QACrCjC,UAAU6B,aAAa7C,gBAAgB,CACzC,GACA;AACA,QAAI+C,WAAWhC,QAAQ;AACrB,YAAMmC,QAAQnC,OAAOgC,OAAO;AAC5B,aAAOhC,OAAOgC,OAAO;AACrB,UAAIG,UAAUzC,QAAW;AACvBqC,iBAASE,WAAW,IAAIE;MAC1B;IACF;EACF;AACAvC,SAAOwC,OAAOpC,QAAQ+B,QAAQ;AAE9B,MAAI,EAAE9B,UAAUyB,qBAAqB1B,SAAS;AAC5CA,WAAOC,UAAUyB,iBAAiB,IAAI1B,OAAOqC;EAC/C;AACF;AAEA,SAAS3B,aACP3B,QACAuD,KAGAC,KACAC,cACA;AA7SF;AA8SE,aAAWC,YAAYD,cAAc;AACnC,QACEC,YAAYH,IAAIxC,cAAcwC,IAAIxC,WAAW2C,QAAQ,EAAEC,aAAa,SACjEH,IAAIE,QAAQ,KAAK,MACpB;AACA,UAAIrC,MAAuC;AACzCrB,qBAAO4D,WAAP5D,mBAAe6D,MACb;UACEL,KAAK;YACHpC,UAAUoC,IAAI,UAAU;YACxBM,aAAaN,IAAI,aAAa;YAC9BF,aAAaE,IAAI,aAAa;UAChC;QACF,GACA,kEAAkED,IAAI7B,OAAO,MAAMgC,QAAQ;MAE/F;AACA,aAAO;IACT;EACF;AACA,SAAO;AACT;AAEA,SAASjC,2BACPP,WACAhB,kBACAF,QAC8D;AAzUhE;AA0UE,QAAIkB,eAAU6B,iBAAV7B,mBAAyBhB,sBAAqB,MAAM;AACtD,UAAM6D,UACJ;AACF,QAAI/D,OAAO4D,QAAQ;AACjB5D,aAAO4D,OAAOI,KAAKD,OAAO;IAC5B,OAAO;AAELE,cAAQC,MAAM,YAAYH,OAAO,EAAE;IACrC;AACA,UAAM,IAAIjC,MAAMiC,OAAO;EACzB;AACF;AAEA,SAASxD,2BACP4D,MACAhE,gBACwC;AACxC,aAAWqD,OAAOW,MAAM;AACtB,QAAIhE,gBAAgB;AAClB,aAAOqD,IAAIY;IACb;AAEA,QAAIZ,IAAIY,OAAO;AACbZ,UAAIa,OAAOb,IAAIY;AACf,aAAOZ,IAAIY;IACb;AAGAZ,QAAIpC,aAAJoC,IAAIpC,WAAaoC,IAAIc;AAIrBd,QAAIM,cAAcN,IAAIpC;AAGtBoC,QAAIF,gBAAJE,IAAIF,cAAgBE,IAAIe;AACxBf,QAAIgB,WAAJhB,IAAIgB,SAAWhB,IAAIiB;AAGnB,WAAOjB,IAAIc;AACX,WAAOd,IAAIe;AACX,WAAOf,IAAIiB;EACb;AACF;;;ACjTO,SAASC,kBACdC,IAGF;AACE,QAAMC,QAAQ,oBAAIC,QAGhB;AAcF,WAASC,IAAIC,QAAuBC,KAAQC,OAAU;AACpD,QAAIL,MAAMM,IAAIH,OAAOI,cAAc,KAAK,MAAM;AAC5CP,YAAME,IAAIC,OAAOI,gBAAgB,oBAAIC,IAAI,CAAC;IAC5C;AAEAR,UAAMM,IAAIH,OAAOI,cAAc,EAAGL,IAAIE,KAAKC,KAAK;AAChD,WAAOA;EACT;AAOA,SAAO;IAAEC,KA1BT,SAAaH,QAAuBC,KAAQ;AAC1C,UAAIJ,MAAMM,IAAIH,OAAOI,cAAc,KAAK,MAAM;AAC5CP,cAAME,IAAIC,OAAOI,gBAAgB,oBAAIC,IAAI,CAAC;MAC5C;AACA,UAAIC,IAAIT,MAAMM,IAAIH,OAAOI,cAAc,EAAGD,IAAIF,GAAG;AACjD,UAAIK,MAAMC,UAAaX,OAAOW,QAAW;AACvC,eAAOR,IAAIC,QAAQC,KAAKL,GAAGI,QAAQC,GAAG,CAAC;MACzC,OAAO;AACL,eAAOK;MACT;IACF;IAgBcP;IAAKS,QALnB,SAAgBR,QAAuBC,KAAQ;AAC7C,UAAIJ,MAAMM,IAAIH,OAAOI,cAAc,KAAK,KAAM,QAAO;AACrD,aAAOP,MAAMM,IAAIH,OAAOI,cAAc,EAAGK,OAAOR,GAAG;IACrD;EAE0B;AAC5B;AAcO,SAASS,uBACdd,IACAe,mBAA6ChB,mBACrB;AACxB,QAAME,QAAQc,iBAAuB;AACrC,QAAMC,aAAaD,iBAAoC;AAEvD,QAAME,MAAM;IACVC,gBAAgB,SAAwBd,QAAuBC,KAAQ;AACrE,aAAOJ,MAAMM,IAAIH,QAAQC,GAAG;IAC9B;IAEAE,KAAK,eAAmBH,QAAuBC,KAAQ;AACrD,aAAOJ,MAAMM,IAAIH,QAAQC,GAAG,KAAKW,WAAWT,IAAIH,QAAQC,GAAG,KACtDY,IAAId,IAAIC,QAAQC,KAAKL,GAAGI,QAAQC,GAAG,CAAC;IAC3C;IAEAF,KAAK,eAAmBC,QAAuBe,GAAMC,GAAmB;AAEtE,UAAI;AACF,cAAMV,IAAI,MAAMM,WAAWb,IAAIC,QAAQe,GAAGC,CAAC;AAE3CnB,cAAME,IAAIC,QAAQe,GAAGT,CAAC;AACtBM,mBAAWJ,OAAOR,QAAQe,CAAC;AAC3B,eAAOT;MACT,SAASW,GAAG;AAEVL,mBAAWJ,OAAOR,QAAQe,CAAC;AAC3B,cAAME;MACR;IACF;EACF;AAEA,SAAOJ;AACT;;;AC9HO,SAASK,sCACdC,OACAC,aAAsB,MACtBC,KACqC;AACrC,QAAMC,oBAAoBC,0CACxBJ,MAAMK,UACNH,GACF;AACA,MAAIC,qBAAqB,MAAM;AAC7B,WAAOG;EACT;AACA,UAAQN,MAAMK,SAASE,MAAI;IACzB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;QACLC,aAAaR,MAAMQ;QACnBC,cAAc;QACdC,aAAaV,MAAMU;QACnBH,MAAMJ;QACNQ,UAAUX,MAAMW,YAAY,OAAOV,aAAaD,MAAMW;MACxD;IACF,KAAK,SAAS;AACZ,aAAO;QACLH,aAAaR,MAAMQ;QACnBC,cAAc;QACdC,aAAaV,MAAMU;QACnBH,MAAMJ;QACNQ,UAAU;MACZ;IACF;IACA,KAAK;IACL,KAAK,UAAU;AACbT,iCAAKU,KACH,GAAGC,KAAKC,UAAUd,MAAMK,SAASE,IAAI,CAAC;AAGxC,aAAOD;IACT;IACA;AACmBN,YAAMK;AACvBH,iCAAKU,KACH,GAAGC,KAAKC,UAAUd,MAAMK,QAAQ,CAAC;AAGnC,aAAOC;EACX;AACF;AAEA,SAASF,0CACPW,cACAb,KAC+B;AAhGjC;AAiGE,UAAQa,aAAaR,MAAI;IACvB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAOQ,aAAaR;IACtB,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAOH,0CAA0CW,aAAaC,OAAO;IACvE,KAAK;AACH,YAAID,kBAAaE,aAAbF,mBAAuBR,UAAS,UAAU;AAC5C,eAAO;MACT,aAAWQ,kBAAaE,aAAbF,mBAAuBR,UAAS,UAAU;AACnD,eAAO;MACT,MAAO,QAAO;IAChB,KAAK,UAAU;AACb,aAAOQ,aAAaG,iBAAiBC,OACnC,CAACC,WAAkDC,gBAAgB;AACjED,kBAAUC,YAAYC,OAAO,IAC3BlB,0CACEiB,YAAYhB,QACd;AACF,eAAOe;MACT,GACA,CAAC,CACH;IACF;IACA,KAAK;IACL,KAAK,UAAU;AACblB,iCAAKU,KACH,GAAGC,KAAKC,UAAUC,aAAaR,IAAI,CAAC;AAGtC,aAAOD;IACT;IACA,SAAS;AAEPJ,iCAAKU,KACH,GAAGC,KAAKC,UAAUC,YAAY,CAAC;AAGjC,aAAOT;IACT;EACF;AACF;;;ACtIO,SAASiB,oDACdC,eACAC,IACAC,KACmB;AACnB,SAAO;IACLC,MAAM;IACNC,KAAKJ,cAAcI;IACnBC,SAASL,cAAcK;IACvBC,aAAaN,cAAcM;IAC3BC,aAAaP,cAAcO;IAC3BC,YAAYR,cAAcS,wBACrBT,cAAcU;IACnBC,YAAYC,OAAOC,YACjBD,OAAOE,QAAQd,cAAce,iBAAiBf,cAAcW,UAAU,EACnEK,IAAI,CACH,CAACC,KAAKC,KAAK,MACR;AACH,aAAO,CACLD,KACAE,sCACED,OACA,MACAhB,GACF,CAAC;IAEL,CAAC,EAAEkB,OAAO,CAAC,CAACH,KAAKC,KAAK,MAAMA,SAAS,IAAI,CAC7C;IACAG,OAAO,CAAC;IACRC,eAAetB,cAAcuB;EAC/B;AACF;;;AC5BO,SAASC,uBACdC,QACqB;AACrB,QAAMC,eAAe,oBAAIC,IAAY;AACrC,QAAMC,kBAAkB,oBAAID,IAAY;AACxC,aAAWE,aAAaJ,OAAOK,YAAY;AACzC,YAAQD,UAAUE,MAAI;MACpB,KAAK;AACHL,qBAAaM,IAAIH,UAAUI,iBAAiB;AAC5C;MACF,KAAK;AACHL,wBAAgBI,IAAIH,UAAUI,iBAAiB;AAC/C;MACF,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACH;MACF;IAEF;EACF;AACA,SAAO;IAAEP;IAAcE;EAAgB;AACzC;;;AC7BO,SAASM,4CACdC,OACiB;AACjB,UAAQA,MAAMC,SAASC,MAAI;IACzB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK,aAAa;AAChB,aAAOF,MAAMC,SAASC;IACxB;IACA,KAAK,QAAQ;AACX,aAAO;IACT;IACA,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,YAAM,IAAIC,MACR,uBAAuBH,MAAMC,SAASC,IAAI,mBAC5C;IACF;AACmBF,YAAMC;AACvB,YAAM,IAAIE,MACR,4CAA4CH,MAAMC,QAAQ,EAC5D;EACJ;AACF;;;ACjCO,SAASG,8CACdC,oBAKAC,IACAC,KACgB;AAChB,MACEF,mBAAmBG,WAChBC,WAAWJ,mBAAmBG,WAAWE,UAAU,MAAMC,QAC5D;AACA,UAAM,IAAIC,MACR,eAAeP,mBAAmBG,WAAWE,UAAU,iBAAiBL,mBAAmBG,WAAWK,OAAO,EAC/G;EACF;AAGA,MACER,mBAAmBS,yBAAyB,QACzCT,mBAAmBU,wBAAwB,MAC9C;AACA,UAAM,IAAIH,MACR,2FACF;EACF;AAEA,QAAMI,eAAeX,mBAAmBS,wBACpCG,OAAOC,YACPD,OAAOE,QAAQd,mBAAmBS,qBAAqB,EAAEM,IACvD,CAAC,CAACC,kBAAkBC,IAAI,MAAM,CAACD,kBAAkBC,KAAKb,UAAU,CAClE,CACF,IACE,CAAC;AAEL,SAAO;IACLc,MAAM;IACNV,SAASR,mBAAmBG,WAAWK;IACvCW,aAAanB,mBAAmBG,WAAWgB;IAC3CC,mBAAmBpB,mBAAmBG,WAAWE;IACjDgB,gBAAgBC,4CACdtB,mBAAmBG,WAChBC,WAAWJ,mBAAmBG,WAAWE,UAAU,CACxD;IACAkB,OAAOX,OAAOC,YAAYb,mBAAmBwB,UAAUT,IAAIU,cAAY;AACrE,aAAO,CAACA,SAASjB,SAAS;QACxBkB,cAAcD,SAASE,gBAAgB;QACvCC,YAAYH,SAASI;MACvB,CAAC;IACH,CAAC,CAAC;IACFzB,YAAYQ,OAAOC,YACjBD,OAAOE,QAAQd,mBAAmBG,WAAWC,UAAU,EAAEW,IAAI,CAC3D,CAACe,KAAKC,KAAK,MACR,CACHD,KACAE,sCACED,OACA,EAAE9B,MAAMD,mBAAmBG,WAAWE,eAAeyB,MACrD5B,GACF,CAAC,CACF,EAAE+B,OAAO,CAAC,CAACH,KAAKC,KAAK,MAAMA,SAAS,IAAI,CAC3C;IACAG,YAAYlC,mBAAmBU;IAC/BC;IACAwB,qBAAqBvB,OAAOC,YAC1BD,OAAOE,QAAQH,YAAY,EAAEI,IAAI,CAC/B,CAACC,kBAAkBoB,KAAK,MACrB,CAACpB,kBAAkBqB,YAAYD,KAAK,CAAC,CAAC,CAC7C;IACAE,MAAMC,mBAAmBC,SAASxC,mBAAmBG,WAAWmC,KAAKpB,IAAI,IACrElB,mBAAmBG,WAAWmC,OAC9BhC;IACJmC,eAAezC,mBAAmBG,WAAWsC;IAC7CC,aAAa1C,mBAAmBG,WAAWuC;IAC3CC,mBAAmB3C,mBAAmBG,WAAWwC;IACjDC,QAAQC,qCACN7C,mBAAmBG,WAAWyC,QAC9BE,sBACF;IACAC,KAAK/C,mBAAmBG,WAAW4C;IACnCC,YAAYH,qCACV7C,mBAAmBG,WAAW6C,YAC9BC,6BACF;EACF;AACF;AAEA,SAASZ,YACPa,GACgE;AAChE,SAAQA,IACJtC,OAAOC,YAAYD,OAAOE,QAAQoC,CAAC,EAAEnC,IAAI,CAAC,CAACoC,GAAGC,CAAC,MAAM,CAACA,GAAGD,CAAC,CAAC,CAAC,IAC5D7C;AAEN;AAEO,IAAMiC,qBAAqB,CAAC,WAAW;AAEvC,IAAMO,yBAAyB,CACpC,UACA,gBACA,cACA,UAAU;AAGL,IAAMG,gCAAgC,CAC3C,UACA,aACA,QAAQ;AAGH,SAASJ,qCACdd,OACAsB,iBACe;AACf,SAAOtB,SAASsB,gBAAgBb,SAAST,KAAK,IAAIA,QAAQzB;AAC5D;;;AClHO,SAASgD,oCACdC,OACgB;AAChB,QAAMC,sBAAsBC,uBAAuBF,KAAK;AACxD,SAAO;IACLG,MAAM;IACNC,SAASJ,MAAMI;IACfC,YAAYC,OAAOC,YACjBD,OAAOE,QAAQR,MAAMK,UAAU,EAAEI,IAAI,CACnC,CAACC,KAAKC,KAAK,MACR,CAACD,KAAKE,8CAA8CD,KAAK,CAAC,CAAC,CAClE;IACAE,aAAab,MAAMa;IACnBC,aAAad,MAAMc;IACnBC,kBAAkBC,uBAChBf,oBAAoBgB,cACpBhB,oBAAoBiB,eACtB;IACAC,KAAKnB,MAAMmB;IACXC,QAAQC,qCACNrB,MAAMoB,QACNE,sBACF;EACF;AACF;AAEA,SAASV,8CACPD,OAC+B;AAC/B,SAAO;IACLY,cAAcZ,MAAMa,SAASrB,SAAS;IACtCA,MAAMsB,sCACJd,MAAMa,SAASrB,SAAS,UAAUQ,MAAMa,SAASE,UAAUf,MAAMa,QACnE;IACAG,UAAU,CAAChB,MAAMiB;IACjBd,aAAaH,MAAMG;EACrB;AACF;AAEA,SAASW,sCACPI,eACkC;AAClC,UAAQA,cAAc1B,MAAI;IACxB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO0B,cAAc1B;IACvB,KAAK;AACH,aAAO;IACT,KAAK;AACH,aAAO;QAAEA,MAAM;QAAa2B,WAAWD,cAAcE;MAAmB;IAC1E,KAAK;AACH,aAAO;QAAE5B,MAAM;QAAU6B,QAAQH,cAAcE;MAAkB;IACnE,KAAK;AACH,aAAON,sCAAsCI,cAAcH,OAAO;IACpE,KAAK;AACH,aAAO;QACLvB,MAAM;QACN8B,WAAWJ,cAAcK;MAC3B;IACF,KAAK;AACH,aAAO;QACL/B,MAAM;QACNgC,QAAQN,cAAcO,OAAOC,OAC3B,CACEC,WAIAC,gBACG;AACHD,oBAAUC,YAAYC,IAAI,IAAIf,sCAC5Bc,YAAYE,SACd;AACA,iBAAOH;QACT,GACA,CAAC,CACH;MACF;IACF;AACE,YAAM,IAAII,MACR,sCAAsCC,KAAKC,UAAUf,aAAa,CAAC,EACrE;EACJ;AACF;AAEA,SAASb,uBACPC,cACAC,iBACoC;AACpC,QAAM2B,WAAW,CAAC;AAQlB,aAAWnC,OAAOO,cAAc;AAC9B4B,aAASnC,GAAG,IAAI;MAAEoC,SAAS;MAAMC,UAAU;IAAM;EACnD;AAEA,aAAWrC,OAAOQ,iBAAiB;AACjC,QAAI2B,SAASnC,GAAG,GAAG;AACjBmC,eAASnC,GAAG,EAAEqC,WAAW;IAC3B,OAAO;AACLF,eAASnC,GAAG,IAAI;QAAEoC,SAAS;QAAOC,UAAU;MAAK;IACnD;EACF;AAEA,SAAOF;AACT;;;AClIO,SAASG,wBAAwBC,OAA+B;AACrE,MAAIA,MAAMC,SAAS,QAAQ;AACzB,WAAO;EACT;AACA,MAAID,MAAMC,SAAS,SAAS;AAC1B,WAAOD,MAAME,WAAWC,KAAKC,OAAKL,wBAAwBK,CAAC,CAAC;EAC9D;AACA,SAAO;AACT;;;ACGO,SAASC,2CAGdC,OACyB;AACzB,UAAQA,MAAMC,MAAI;IAChB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;QACLA,MAAMD,MAAMC;QACZC,UAAU;MACZ;IAEF,KAAK;AACH,aAAO;QACLD,MAAM;QACNE,QAAQH,MAAMI;QACdF,UAAU;MACZ;IAEF,KAAK;AACH,aAAO;QACLD,MAAM;QACNI,WAAWL,MAAMI;QACjBF,UAAU;MACZ;IAEF,KAAK;AACH,aAAO;QACL,GAAGH,2CAA2CC,MAAMM,OAAO;QAC3DC,cAAc;MAChB;IAEF,KAAK;AACH,aAAO;QACLN,MAAM;QACNO,KAAKT,2CAA2CC,MAAMM,OAAO;QAC7DJ,UAAU;MACZ;IAEF,KAAK;AACH,YAAMO,aAAaC,wBAAwBV,KAAK;AAGhD,UAAIS,cAAcT,MAAMW,WAAWC,WAAW,GAAG;AAC/C,cAAMC,UAAUb,MAAMW,WAAWG,KAAKC,OAAKA,EAAEd,QAAQ,IAAI;AACzD,YAAIY,SAAS;AACX,iBAAO;YACL,GAAGd,2CAA2Cc,OAAO;YACrDX,UAAU;UACZ;QACF;MACF;AAEA,aAAO;QACLD,MAAM;QACNe,OAAOhB,MAAMW,WAAWM,OAAkC,CAACC,KAAKH,MAAM;AACpE,cAAIA,EAAEd,SAAS,QAAQ;AACrB,mBAAOiB;UACT;AACAA,cAAIC,KAAKpB,2CAA2CgB,CAAC,CAAC;AACtD,iBAAOG;QACT,GAAG,CAAA,CAAE;QACLhB,UAAUO;MACZ;IAEF,KAAK;AACH,aAAO;QACLR,MAAM;QACNmB,QAAQC,OAAOC,YAAYtB,MAAMuB,OAAOC,IAAIC,OAAK,CAC/CA,EAAEC,MACF3B,2CAA2C0B,EAAEE,SAAS,CAAC,CACxD,CAAC;QACFzB,UAAU;MACZ;IAEF,KAAK;AACH,aAAO;QACLD,MAAM;QACN2B,2BAA2BC,2BAA2B7B,KAAK;QAC3DE,UAAU;MACZ;IAEF,KAAK;AACH,aAAO;QACLD,MAAM;QACN6B,6BAA6BC,2BAA2B/B,KAAK;QAC7DE,UAAU;MACZ;IAEF,KAAK;AACH,YAAM8B,UAAUjC,2CAA2CC,MAAMgC,OAAO;AAExE,UAAI,CAACC,iBAAiBC,SAASF,QAAQ/B,IAAI,GAAG;AAC5C,cAAM,IAAIkC,MACR,kCAAkCH,QAAQ/B,OAAO,uBAC7CgC,iBAAiBG,SAAS,CAChC;MACF;AAEA,UAAIJ,QAAQzB,iBAAiB,MAAM;AACjC,cAAM,IAAI4B,MACR,sCACF;MACF;AAEA,aAAO;QACLlC,MAAM;QACNC,UAAU;QACV8B;QACAK,WAAWtC,2CAA2CC,MAAMqC,SAAS;MACvE;IAEF,KAAK;IACL,KAAK;AACH,YAAM,IAAIF,MACR,2FAA2FnC,MAAMC,IAAI,0DACvG;IAEF;AAEE,YAAM,IAAIkC,MAAM,kCAAmCnC,MAAcC,IAAI,EAAE;EAC3E;AACF;AAEA,SAAS4B,2BACP7B,OAC0C;AAC1C,MAAIA,MAAMgC,QAAQ/B,SAAS,SAAS;AAClC,WAAO;MACL+B,SAAShC,MAAMgC,QAAQ/B;MACvBqC,YAAYtC,MAAMgC,QAAQ1B,QAAQL;MAClCoC,WAAWrC,MAAMqC,UAAUpC;IAC7B;EACF,OAAO;AACL,QAAIsC,qBAAqBvC,MAAMgC,OAAO,GAAG;AACvC,aAAO;QACLA,SAAShC,MAAMgC,QAAQ/B;QACvBoC,WAAWrC,MAAMqC,UAAUpC;MAC7B;IACF;AACA,UAAM,IAAIkC,MACR,qCAAqCnC,MAAMgC,QAAQ/B,IAAI,cACzD;EACF;AACF;AAEA,SAAS8B,2BACP/B,OAC4C;AAC5C,MAAIA,MAAMgC,QAAQ/B,SAAS,SAAS;AAClC,WAAO;MACL+B,SAAShC,MAAMgC,QAAQ/B;MACvBqC,YAAYtC,MAAMgC,QAAQ1B,QAAQL;MAClCoC,WAAWR,2BAA2B7B,MAAMqC,SAAS;IACvD;EACF,OAAO;AACL,QAAIE,qBAAqBvC,MAAMgC,OAAO,GAAG;AACvC,aAAO;QACLA,SAAShC,MAAMgC,QAAQ/B;QACvBoC,WAAWR,2BAA2B7B,MAAMqC,SAAS;MACvD;IACF;AACA,UAAM,IAAIF,MACR,qCAAqCnC,MAAMgC,QAAQ/B,IAAI,cACzD;EACF;AACF;AAKA,SAASsC,qBACPC,KACmE;AACnE,SAAOA,IAAIvC,SAAS,YAAYuC,IAAIvC,SAAS;AAC/C;AAKA,IAAMgC,mBAAmB,CACvB,UACA,UACA,UACA,SACA,WACA,QACA,QACA,aACA,QACA,YACA,WACA,WACA,SACA,YAAY;;;ACjNP,SAASQ,kCACdC,OACe;AACf,SAAO;IACLC,MAAM;IACNC,SAASF,MAAME;IACfC,aAAaH,MAAMG;IACnBC,aAAaJ,MAAMI;IACnBC,SAASL,MAAMK;IACfC,YAAYC,OAAOC,YACjBD,OAAOE,QAAQT,MAAMM,UAAU,EAAEI,IAAI,CACnC,CAACC,MAAMC,SAAS,MACb,CAACD,MAAME,+CAA+CD,SAAS,CAAC,CAAC,CACxE;IACAE,QAAQC,2CAA2Cf,MAAMc,MAAM;IAC/DE,KAAKhB,MAAMgB;EACb;AACF;AAsBO,SAASC,+CACdC,WAC+B;AAC/B,SAAO;IACLC,aAAaD,UAAUC;IACvB,GAAGC,2CAA2CF,UAAUG,QAAQ;EAClE;AACF;;;AC7CA,eAAsBC,mBACpBC,QACAC,YACyB;AACzB,QAAMC,IAAI,MAAmBC,qBAAcC,IACzCJ,QACA,MAAMA,OAAOK,aACbJ,UACF;AAEA,SAAOK,oCAAoCJ,CAAC;AAC9C;;;ACbA,eAAsBK,uBACpBC,QACAC,YAC2C;AAC3C,QAAMC,OAAO,MAAmBC,qBAAcC,gBAC5CJ,QACA,MAAMA,OAAOK,aACbJ,YACA;IAAEK,SAAS;EAAK,CAClB;AACA,QAAMC,MAAMC,8CAA8CN,MAAM,IAAI;AACpE,SAAO;IAAE,GAAGK;EAAI;AAClB;;;ACZA,eAAsBE,sBACpBC,QACAC,YAC4B;AAC5B,QAAMC,IAAI,MAAmBC,0BAAmBC,IAC9CJ,QACA,MAAMA,OAAOK,aACbJ,YACA;IAAEK,SAAS;EAAK,CAClB;AAEA,SAAOC,oDAAoDL,GAAG,IAAI;AACpE;;;ACZA,eAAsBM,kBACpBC,QACAC,4BACwB;AACxB,QAAM,CAACC,SAASC,OAAO,IAAIF,2BAA2BG,MAAM,GAAG;AAC/D,QAAMC,IAAI,MAAmBC,kBAAWC,IACtCP,QACA,MAAMA,OAAOQ,aACbN,SACA;IAAEC;EAAQ,CACZ;AAEA,SAAOM,kCAAkCJ,CAAC;AAC5C;;;ACGO,IAAMK,wCAEkBA,MAAY;AACzC,SAAQC,YAAW;AA8CjB,aAASC,WAMPC,IAKA;AACA,YAAMC,QAAQC,uBAAkC,CAACJ,SAAQK,QACvDH,GAAGF,SAAQK,KAAK,KAAK,CACvB;AACA,aAAO,OAAOC,YAAoB;AAChC,eAAO,MAAMH,MAAMI,IAAIP,QAAQM,OAAO;MACxC;IACF;AAqBA,UAAME,MAAM;MACVC,qBAAqBR,WArFvB,eACED,SACAK,KACsC;AA5C5C;AA6CM,cAAMK,YAAY,MAAMC,uBAAuBX,SAAQK,GAAG;AAG1D,cAAMO,gBAAgBC,OAAOC,aAG1B,MAAMC,QAAQC,MACbN,eAAUO,eAAVP,mBAAsBQ,IAAKC,OAAMX,IAAIY,uBAAuBD,CAAC,OAAM,CAAA,CACrE,GAAGD,IAAIC,OAAK,CAACA,EAAEb,SAAS;UAAEe,KAAKF;UAAGG,SAASC;QAAU,CAAC,CAAC,CACzD;AAEA,cAAMC,gBAAgB;UACpB,GAAGd;UACH,CAACe,oBAAoB,GAAGb;QAC1B;AAEA,eAAOY;MACT,CAgE4C;MAC1CJ,wBAAwBnB,WA/D1B,eACED,SACAK,KACA;AACA,eAAOqB,sBAAsB1B,SAAQK,GAAG;MAC1C,CA0DkD;MAChDsB,qBAAqB1B,WAlDvB,eACED,SACAK,KACA;AACA,cAAMuB,IAAI,MAAMC,mBAAmB7B,SAAQK,GAAG;AAC9C,eAAOuB;MACT,CA4C4C;MAC1CE,oBAvBF,SACE9B,SACAE,IAKA;AACA,cAAM6B,aAAa3B,uBACjB,CAACJ,SAAQK,QAAQ;AACf,iBAAOH,GAAGF,SAAQK,GAAG;QACvB,CACF;AACA,eAAO,OAAOC,SAAiB0B,YAAqB;AAClD,gBAAM3B,MAAM2B,UAAU,GAAG1B,OAAO,IAAI0B,OAAO,KAAK1B;AAChD,iBAAO,MAAMyB,WAAWxB,IAAIP,SAAQK,GAAG;QACzC;MACF,EAMsCL,QA1DtC,eACEA,SACAK,KACA;AACA,eAAO4B,kBAAkBjC,SAAQK,GAAG;MACtC,CAqDuD;IACvD;AACA,WAAOG;EACT;AACF;;;ACrHO,IAAM0B,aAAqB,eAAA,cAAA;;;ACqB3B,SAASC,oBACdC,UACAC,SACAC,eACAC,UAAwD,CAAC,GACzDC,UAGyBC,OAAOC,OAChCC,mBAA+CC,iBAC/CC,gCAGEC,uCACF;AACA,MAAIC,MAAuC;AACzC,QAAI;AACF,UAAIC,IAAIX,OAAO;IACjB,SAASY,GAAG;AACV,YAAMC,OACJ,CAACb,QAAQc,WAAW,SAAS,KAAK,CAACd,QAAQc,WAAW,UAAU,IAC5D,qDACA;AACN,YAAM,IAAIC,MAAM,sBAAsBf,OAAO,GAAGa,IAAI,EAAE;IACxD;EACF;AACA,QAAMG,mBAAmB,IAAIL,IAAIX,OAAO;AACxCgB,mBAAiBC,YAAYD,iBAAiBC,SAASC,SAAS,GAAG,IAC/D,KACA;AACJ,QAAMC,gBAA+B;IACnC,GAAGC,0BACDJ,iBAAiBK,SAAS,GAC1BpB,eACAqB,YACAnB,OACF;IACAG;IACAiB,eAAeC;IACfC,gBAAgBC;IAChBC,aAAa5B,SAAS4B;IACtBC,QAAQ1B,QAAQ0B;IAChBC,gBAAgB,CAAC;IACjBC,gBAAgB,CAAC;EACnB;AAKA,SAAOC,OAAOC,OAAOD,OAAOE,OAAOd,eAAe;IAChDe,kBAAkB1B,8BAChBN,OACF,EAAEiB,aAAa;EACjB,CAAC,CAAC;AACJ;;;AC7DO,IAAMgB,wBAAwB,OAQnCC,QACAC,eAOG;AACH,MAAIA,WAAWC,SAAS,UAAU;AAChC,UAAM;MAAE,CAACC,oBAAoB,GAAGC;MAAe,GAAGC;IAAc,IAC9D,MAAML,OAAOM,iBACVC,oBAAoBN,WAAWO,OAAO;AAC3C,WAAOH;EACT,WAAWJ,WAAWC,SAAS,aAAa;AAC1C,WAAOF,OAAOM,iBAAiBG,uBAC7BR,WAAWO,OACb;EACF,WAAWP,WAAWC,SAAS,UAAU;AACvC,WAAOF,OAAOM,iBAAiBI,oBAC7BT,WAAWO,OACb;EACF,WAAWP,WAAWC,SAAS,SAAS;AACtC,WAAOF,OAAOM,iBAAiBK,mBAC7BV,WAAWO,SACXP,WAAWW,iBAAiBX,WAAWY,UAAUC,MACnD;EACF,OAAO;AACL,UAAM,IAAIC,MAAM,sCAAsC;EACxD;AACF;;;AClDO,SAASC,OAAY;AAC5B;AASA,IAAMC,SAAS;EACbC,OAAO;EACPC,OAAO;EACPC,MAAM;EACNC,MAAM;EACNC,OAAO;EACPC,OAAO;AACT;AAnCA;AAqCO,IAAeC,aAAf,MAA4C;EAKjDC,YACEC,UACAC,UAAkD,CAAC,GACnDC,SACA;AANF;AA0BAV,iCAAsBF;AACtBG,iCAAsBH;AACtBK,gCAAqBL;AACrBI,gCAAqBJ;AACrBM,iCAAsBN;AACtBO,iCAAsBP;AAvExB;AA+CI,SAAKU,WAAWA;AAChB,SAAKC,UAAUA;AACf,uBAAK,UAAWC;AAEhB,eACQC,KAAK,CAAC,SAAS,SAAS,QAAQ,QAAQ,SAAS,OAAO,GAC9D;AACA,YAAI,UAAKF,YAAL,mBAAcG,UAAS,CAAC,KAAKC,eAAeF,CAAC,GAAG;AAClD;MACF;AACA,WAAKA,CAAC,IAAI,KAAKG,gBAAgBH,GAAGH,QAAQ;IAC5C;EACF;EAcAO,MACEP,UACAC,SACQ;AA5EZ;AA6EI,WAAO,KAAI,mBAAK,WAAS;MACvB,GAAG,KAAKD;MACR,GAAGA;IACL,GAAG;MACDI,QAAOH,mCAASG,YAAS,UAAKH,YAAL,mBAAcG;MACvCI,WAAW,EAAC,UAAKP,YAAL,mBAAcO,WAAWP,mCAASO,SAAS,EAAEC,OAAOC,OAAKA,CAAC,EACnEC,KAAK,GAAG;IACb,CAAC;EACH;EAEAN,eAAeD,OAAwB;AAvFzC;AAwFI,UAAMQ,aAAY,UAAKX,YAAL,mBAAcG,UAAS;AAEzC,WAAOA,SAASb,UAAUqB,YAAYrB,UACjCA,OAAOa,KAAK,KAA4Bb,OAAOqB,QAAQ;EAC9D;AACF;AArDE;;;ACrBK,IAAMC,gBAAN,MAAMA,uBAAsBC,WAA6B;EAC9DC,YACEC,WAAgC,CAAC,GACjCC,UAAkD,CAAC,GACnD;AACA,UACED,UACA;MAAE,GAAGC;MAASC,OAAOD,QAAQC,SAAS;IAAQ,GAC9CL,cACF;EACF;EAEAM,gBACEC,MACAJ,UACc;AAlClB;AAmCI,UAAMK,OAAiB,CAACD,IAAI;AAE5B,SAAI,UAAKH,YAAL,mBAAcK,WAAW;AAC3BD,WAAKE,KAAK,KAAKN,QAAQK,SAAS;IAClC;AAEA,QAAI,OAAON,aAAa,YAAY,gBAAgBA,UAAU;AAC5DK,WAAKE,KAAK,IAAIP,SAASQ,UAAU,IAAI;IACvC;AAEA,WAAO,IAAIC,SAAgB;AAEzBC,cAAQN,SAAS,UAAU,UAAUA,IAAI,EAAEC,KAAKM,KAAK,GAAG,GAAG,GAAGF,IAAI;IACpE;EACF;AACF;;;ACfA,eAAsBG,mBACpBC,OACAC,QACAC,aACoB;AACpB,MAAIF,SAAS,MAAM;AACjB,WAAOA;EACT;AAEA,MAAIG,MAAMC,QAAQJ,KAAK,KAAKE,YAAYG,cAAc;AACpD,UAAMC,SAASH,MAAMI,KAAKP,KAAK;AAC/B,QACEM,OAAOE,KAAMC,eACXC,mBAAmBD,SAAS,KAAKE,iBAAiBF,SAAS,CAC7D,GACA;AACA,YAAMG,YAAY,CAAA;AAClB,iBAAWZ,UAASM,QAAQ;AAC1BM,kBAAUC,KAAK,MAAMd,mBAAmBC,QAAOC,QAAQC,WAAW,CAAC;MACrE;AACA,aAAOU;IACT;AACA,UAAME,eAAeX,MAAMI,KACzBP,OACA,OAAOe,eACL,MAAMhB,mBAAmBgB,YAAYd,QAAQC,WAAW,CAC5D;AACA,WAAOc,QAAQC,IAAIH,YAAY;EACjC;AAEA,UAAQZ,YAAYgB,MAAI;IACtB,KAAK,cAAc;AACjB,UAAIR,mBAAmBV,KAAK,GAAG;AAC7B,cAAMmB,aAAa,MAAmBC,mBAAYC,OAChDpB,QACAD,MAAMsB,MACN;UACEC,UAAUvB,MAAMwB;QAClB,CACF;AACA,eAAOL,WAAWM;MACpB;AAEA,UACEd,iBAAiBX,KAAK,GACtB;AACA,cAAMmB,aAAa,MAAmBC,mBAAYC,OAChDpB,QACAD,OACA;UACEuB,UAAUvB,MAAMwB;QAClB,CACF;AACA,eAAOL,WAAWM;MACpB;AAGA,aAAOzB;IACT;IACA,KAAK,6BAA6B;AAChC,aAAO;QACL0B,QAAQ1B;MACV;IACF;IACA,KAAK,+BAA+B;AAClC,aAAO;QACL0B,QAAQ1B;MACV;IACF;IAEA,KAAK,OAAO;AACV,UAAIA,iBAAiB2B,KAAK;AACxB,cAAMb,eAAeX,MAAMI,KACzBP,OACA,OAAOe,eACL,MAAMhB,mBAAmBgB,YAAYd,QAAQC,YAAY,KAAK,CAAC,CACnE;AACA,eAAOc,QAAQC,IAAIH,YAAY;MACjC;AACA;IACF;IACA,KAAK,UAAU;AACb,UAAIc,yBAAyB5B,KAAK,GAAG;AACnC,eAAOA,MAAM6B;MACf;AACA;IACF;IACA,KAAK,aAAa;AAEhB,UAAIC,gBAAgB9B,KAAK,GAAG;AAC1B,eAAOA;MACT;AACA,UAAI+B,YAAY/B,KAAK,GAAG;AACtB,eAAOgC,iBAAiBhC,KAAK;MAC/B;AACA;IACF;IAEA,KAAK,OAAO;AACV,UAAI,OAAOA,UAAU,UAAU;AAC7B,cAAMiC,WAA4C,CAAA;AAClD,mBAAW,CAACC,KAAKC,QAAQ,KAAKC,OAAOC,QAAQrC,KAAK,GAAG;AACnDiC,mBAASpB,KAAK;YACZqB,KAAKhC,YAAYoC,QAAQpB,SAAS,WAC9BqB,qCAAqCL,GAAU,IAC/C,MAAMnC,mBACNmC,KACAjC,QACAC,YAAYoC,OACd;YACFtC,OAAO,MAAMD,mBACXoC,UACAlC,QACAC,YAAYsC,SACd;UACF,CAAC;QACH;AACA,eAAOP;MACT;AACA;IACF;IAEA,KAAK,UAAU;AACb,UAAI,OAAOjC,UAAU,UAAU;AAC7B,cAAMyC,YAAwC,CAAC;AAC/C,mBAAW,CAACP,KAAKQ,WAAW,KAAKN,OAAOC,QAAQrC,KAAK,GAAG;AACtDyC,oBAAUP,GAAG,IAAI,MAAMnC,mBACrB2C,aACAzC,QACAC,YAAY,QAAQ,EAAEgC,GAAG,CAC3B;QACF;AACA,eAAOO;MACT;IACF;IAEA,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAOzC;EACX;AACA,SAAOA;AACT;;;AC9IA,eAAsB2C,WAIpBC,QACAC,OACAC,QAGA;AACA,QAAMC,KAAK,MAAMH,OAAOI,iBAAiBC,mBACvCJ,MAAMK,SACNL,MAAMM,iBAAiBN,MAAMO,UAAUC,MACzC;AAEA,QAAMC,WAAW,MAAmBC,cAAQC,QAC1CC,qCACEC,sBAAsBd,QAAQ,OAAM;IAAEe,iBAAiB;EAAa,EAAE,GACtEd,KACF,GACA,MAAMD,OAAOgB,aACbf,MAAMK,SACN;IACEW,YAAYf,SACR,MAAMgB,iBACNhB,QACAF,QACAG,GAAGc,UACL,IACE,CAAC;EACP,GACA;IAAET,SAASL,GAAGK;EAAQ,CACxB;AACA,QAAMW,mBAAmB,MAAMC,uBAAuBjB,GAAGkB,QAAQrB,MAAM;AACvE,QAAMsB,mBAAmB,MAAMC,mBAC7BvB,QACAG,GAAGkB,QACHX,SAASc,OACTL,gBACF;AACA,SAAOG;AACT;AAEA,eAAeJ,iBACbhB,QACAF,QACAyB,YACyC;AACzC,QAAMC,eAAqD,CAAC;AAC5D,aAAW,CAACC,KAAKH,KAAK,KAAKI,OAAOC,QAAQ3B,MAAM,GAAG;AACjDwB,iBAAaC,GAAG,IAAI,MAAMG,mBACxBN,OACAxB,QACAyB,WAAWE,GAAG,CAChB;EACF;AACA,SAAOD;AACT;AAEA,eAAeH,mBAIbvB,QACA+B,kBACAC,eACAC,aAC6B;AAE7B,MAAID,iBAAiB,MAAM;AACzB,QAAID,iBAAiBG,UAAU;AAC7B,aAAOzB;IACT,OAAO;AACL,YAAM,IAAI0B,MAAM,iDAAiD;IACnE;EACF;AAEA,MACEJ,iBAAiBK,gBAAgB,QAC9BL,iBAAiBK,cACpB;AACA,UAAMC,sBAAsB;MAAE,GAAGN;MAAkBK,cAAc;IAAM;AACvE,aAASE,IAAI,GAAGA,IAAIN,cAAcO,QAAQD,KAAK;AAC7CN,oBAAcM,CAAC,IAAI,MAAMf,mBACvBvB,QACAqC,qBACAL,cAAcM,CAAC,GACfL,WACF;IACF;AACA,WAAOD;EACT;AAEA,UAAQD,iBAAiBS,MAAI;IAC3B,KAAK,SAAS;AACZ,YAAM,IAAIL,MAAM,0CAA0C;IAC5D;IAEA,KAAK,OAAO;AACV,eAASG,IAAI,GAAGA,IAAIN,cAAcO,QAAQD,KAAK;AAC7CN,sBAAcM,CAAC,IAAI,MAAMf,mBACvBvB,QACA+B,iBAAiBU,KACjBT,cAAcM,CAAC,GACfL,WACF;MACF;AAEA,aAAOD;IACT;IAEA,KAAK,cAAc;AACjB,aAAOU,iCACL1C,QACAgC,aACF;IAGF;IACA,KAAK,UAAU;AACb,YAAMW,MAAMV,YAAYW,IAAIb,iBAAiBc,MAAM;AACnD,UAAI,CAACF,OAAOA,IAAIH,SAAS,UAAU;AACjC,cAAM,IAAIL,MACR,0BAA0BJ,iBAAiBc,MAAM,EACnD;MACF;AACA,aAAOC,0BACLd,eACAW,GACF;IAGF;IAEA,KAAK,aAAa;AAChB,YAAMA,MAAMV,YAAYW,IAAIb,iBAAiBgB,SAAS;AACtD,UAAI,CAACJ,KAAK;AACR,cAAM,IAAIR,MACR,0BAA0BJ,iBAAiBgB,SAAS,EACtD;MACF;AACA,UAAI,OAAOf,kBAAkB,UAAU;AACrC,eAAOgB,gBAAgBL,KAAK3C,QAAQ;UAClCwC,MAAM;UACNS,YAAY,CACV;YAAET,MAAM;YAAQU,YAAYnB,iBAAiBgB;UAAU,GACvD;YAAEP,MAAM;YAAaW,WAAWnB;UAAc,CAAC;QAEnD,CAAC;MACH;AAEA,aAAOgB,gBACLL,KACA3C,QACAgC,aACF;IAGF;IACA,KAAK,UAAU;AAEb,iBAAW,CAACL,KAAKyB,OAAO,KAAKxB,OAAOC,QAAQE,iBAAiBsB,MAAM,GAAG;AACpE,YAAIC,mBAAmBF,OAAO,GAAG;AAC/BpB,wBAAcL,GAAG,IAAI,MAAMJ,mBACzBvB,QACAoD,SACApB,cAAcL,GAAG,GACjBM,WACF;QACF;MACF;AAEA,aAAOD;IACT;IAEA,KAAK,OAAO;AACV,YAAMuB,MAAM,CAAC;AAEb,OAAUC,MAAMC,QAAQzB,aAAa,IAAC0B,OAAtCC,UAAS,OAA+B,sBAAsB,IAA9DA,UAAS,KAAA,IAAA;AACT,iBAAWC,SAAS5B,eAAe;AACjC,SAAU4B,MAAMjC,MAAG+B,OAAnBC,UAAS,OAAY,cAAc,IAAnCA,UAAS,KAAA,IAAA;AACT,SAAUC,MAAMpC,QAAKkC,OAArBC,UAAS,OAAc,gBAAgB,IAAvCA,UAAS,KAAA,IAAA;AACT,cAAMhC,MAAMI,iBAAiB8B,QAAQrB,SAAS,WAC1CsB,mBACAF,MAAMjC,KACNI,iBAAiB8B,QAAQhB,QACzBZ,WACF,IACE2B,MAAMjC;AACV,cAAMH,QAAQ,MAAMD,mBAClBvB,QACA+B,iBAAiBgC,WACjBH,MAAMpC,OACNS,WACF;AACAsB,YAAI5B,GAAG,IAAIH;MACb;AACA,aAAO+B;IACT;IAEA,KAAK,6BAA6B;AAChC,YAAMS,SAGA,CAAA;AACN,iBAAW;QAAErC;QAAKH;MAAM,KAAKQ,cAAciC,QAAQ;AACjDD,eAAOE,KAAK;UAAEvC;UAAKH;QAAM,CAAC;MAC5B;AACA,aAAOwC;IACT;IAEA,KAAK,+BAA+B;AAClC,YAAMA,SAGA,CAAA;AACN,iBAAW;QAAErC;QAAKsC;MAAO,KAAKjC,cAAciC,QAAQ;AAClD,cAAME,YAAwC,CAAA;AAC9C,mBAAW;UAAExC,KAAKyC;UAAQ5C;QAAM,KAAKyC,QAAQ;AAC3CE,oBAAUD,KAAK;YAAEvC,KAAKyC;YAAQ5C;UAAM,CAAC;QACvC;AACAwC,eAAOE,KAAK;UAAEvC;UAAKsC,QAAQE;QAAU,CAAC;MACxC;AACA,aAAOH;IACT;EACF;AAEA,SAAOhC;AACT;AAEA,eAAeZ,uBACbiD,UACArE,QACmD;AACnD,QAAMgE,SAAS,oBAAIM,IAAyC;AAC5D,UAAQD,SAAS7B,MAAI;IACnB,KAAK,aAAa;AAChB,YAAM+B,YAAY,MAAMvE,OAAOI,iBAAiBoE,oBAC9CH,SAAStB,SACX;AACAiB,aAAOvB,IAAI4B,SAAStB,WAAWwB,SAAS;AACxC;IACF;IACA,KAAK,UAAU;AACb,YAAMA,YAAY,MAAMvE,OAAOI,iBAAiBoE,oBAC9CH,SAASxB,MACX;AACAmB,aAAOvB,IAAI4B,SAASxB,QAAQ0B,SAAS;AACrC;IACF;IAEA,KAAK,OAAO;AACV,aAAOnD,uBAAuBiD,SAAS5B,KAAKzC,MAAM;IACpD;IAEA,KAAK,OAAO;AACV,iBAAWwB,SAAS,CAAC6C,SAASR,SAASQ,SAASN,SAAS,GAAG;AAC1D,mBACQ,CAACvB,MAAM+B,SAAS,KAAK,MAAMnD,uBAAuBI,OAAOxB,MAAM,GACrE;AACAgE,iBAAOvB,IAAID,MAAM+B,SAAS;QAC5B;MACF;AACA;IACF;IAEA,KAAK,UAAU;AACb,iBAAW/C,SAASI,OAAO6C,OAAOJ,SAAShB,MAAM,GAAG;AAClD,mBACQ,CAACb,MAAM+B,SAAS,KAAK,MAAMnD,uBAAuBI,OAAOxB,MAAM,GACrE;AACAgE,iBAAOvB,IAAID,MAAM+B,SAAS;QAC5B;MACF;AACA;IACF;IACA,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH;EACJ;AAEA,SAAOP;AACT;AACA,SAASV,mBAAmBe,UAAmC;AAC7D,UAAQA,SAAS7B,MAAI;IACnB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAET,KAAK;AACH,aAAO;IAET,KAAK;AACH,aAAOZ,OAAO6C,OAAOJ,SAAShB,MAAM,EAAEqB,KAAKpB,kBAAkB;IAE/D,KAAK;AACH,aAAOA,mBAAmBe,SAAS5B,GAAG;IAExC,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IAET;AACE,aAAO;EACX;AACF;AAEA,SAASqB,mBACPa,YACAC,mBACA3C,aACQ;AACR,QAAMU,MAAMV,YAAYW,IAAIgC,iBAAiB;AAC7C,MAAI,CAACjC,OAAOA,IAAIH,SAAS,UAAU;AACjC,UAAM,IAAIL,MACR,0BAA0ByC,iBAAiB,EAC7C;EACF;AACA,SAAOC,oCACLlC,KACAgC,UACF;AACF;AAEO,SAAS7B,0BAGd6B,YACAJ,WACa;AACb,SAAO;IACLO,UAAUP,UAAUjE;IACpByE,QAAQtE;IACRuE,aAAaT,UAAUjE;IACvB2E,aAAaN;IACbO,kBAAkBL,oCAChBN,WACAI,UACF;EACF;AACF;;;AC3UA,IAAMQ,gBAAN,MAEA;EACEC,YACEC,WACAC,WACA;AAKA,SAAKC,cAAcA,YAAYC,KAAKC,QAAWJ,WAAWC,SAAS;AACnE,SAAKI,mBAAmBH,YAAYC,KAAKC,QAAWJ,WAAWC,SAAS;EAC1E;AAIF;AAEA,IAAMK,eAAN,MAEA;EACEP,YACEC,WACAO,UACA;AACA,SAAKC,kBAAkBC,WAAWN,KAAKC,QAAWJ,WAAWO,QAAQ;EACvE;AAGF;AAGO,SAASG,qBACdC,kBACAC,SACAC,aACAC,eACAC,UAA2CX,QAC3CY,UAAmCC,OAC3B;AACR,MAAI,OAAOJ,gBAAgB,UAAU;AACnC,QAAI,CAACA,YAAYK,WAAW,KAAK,GAAG;AAClC,YAAM,IAAIC,MAAM,sBAAsB;IACxC;EACF,OAAO;AAELN,gBAAYO,KAAMP,CAAAA,iBAAgB;AAChC,UAAI,CAACA,aAAYK,WAAW,KAAK,GAAG;AAElC,cAAM,IAAIC,MAAM,sBAAsB;MACxC;IACF,CAAC;EACH;AAEA,QAAMnB,YAA2BqB,oBAC/B;IAAER;EAAY,GACdD,SACAE,eACA;IAAE,GAAGC;IAASO,SAAQP,mCAASO,WAAU,IAAIC,cAAc;EAAE,GAC7DP,SACAL,gBACF;AAEA,SAAOa,wBAAwBxB,SAAS;AAC1C;AAKO,SAASwB,wBAAwBxB,WAA0B;AAoHhE,QAAMyB,gBAAgBC,sBAAsBvB,KAC1CC,QACAJ,SACF;AAIA,QAAM2B,SAAiBC,OAAOC,iBA1H9B,SAOEC,GAOF;AACE,QAAIA,EAAEC,SAAS,YAAYD,EAAEC,SAAS,aAAa;AACjD,aAAO/B,UAAUW,iBAAiBmB,GAAG9B,SAAS;IAChD,WAAW8B,EAAEC,SAAS,UAAU;AAC9B,aAAO,IAAIjC,cACTE,WACA8B,CACF;IAIF,WAAWA,EAAEC,SAAS,SAAS;AAC7B,aAAO,IAAIzB,aACTN,WACA8B,CACF;IAEF,WAAWA,EAAEC,SAAS,cAAc;AAClC,cAAQD,EAAEE,MAAI;QACZ,KAAKC,gDAAgDD;AACnD,iBAAO;YACLE,cAAcC,gCACZnC,SACF;UACF;QACF,KAAKoC,iDAAiDJ;AACpD,iBAAO;YACLK,eAAe,OAMbC,YACAC,KACAxB,YACG;AACH,qBAAO,MAAMyB,YACXxC,WACAsC,YACAvB,SACA0B,cACE,CAACF,GAAG,CACN,CACF;YACF;UACF;QACF,KAAKG,wDAAwDV;AAC3D,iBAAO;YACLW,sBAAsB,OAGpBC,SAKI;AACJ,oBAAM;gBAAEC;gBAAMC;gBAAUR;gBAAYS;cAAa,IAAIH;AACrD,qBAAO,MAAmBI,+BAAyBC,OACjDjD,WACA,MAAMA,UAAUa,aAChByB,WAAWY,SACXH,cACAF,MACA;gBACEM,eAAeL;gBACfM,SAAS;cACX,CACF;YACF;UACF;QAEF,KAAKC,kDAAkDrB;AACrD,iBAAO;YACLsB,gBAAgB,OAMdC,uBACAC,MACAzC,UAA0C,CAAC,MACxC;AACH,qBAAO,MAAM0C,UACXzD,WACAuD,uBACAxC,SACA0B,cAAce,IAAI,CACpB;YACF;UACF;MACJ;AAEA,YAAM,IAAIrC,MAAM,iBAAiB;IACnC,OAAO;AACL,YAAM,IAAIA,MAAM,iBAAiB;IACnC;EACF,GAWE;IACE,CAACuC,mBAAsB,GAAG;MACxBC,OAAO3D;IACT;IACA,CARgD,qBAAqB,GAQ9C;MACrB2D,OAAO3D;IACT;IACA,CAAC4D,iBAAiB,GAAG;MACnBD,OAAO3D;IACT;IACAyB,eAAe;MACbkC,OAAOlC;IACT;EACF,CACF;AAEA,SAAOE;AACT;AAEO,IAAMkC,eAQCnD,qBAAqBP,KACjCC,QACA0D,eACF;AAEA,SAASrB,cACPe,MACA;AAMA,SAL+B;IAC7BzB,MAAM;IACN,WAAWyB;EACb;AAGF;;;AC9QO,SAASO,qBACdC,SACAC,eACAC,UAAqBC,QACrBC,UAAmCC,OACnB;AAChB,SAAOC,0BACLN,SACAC,eACAM,YACAH,OACF;AACF;;;AC5BA,IAAMI,WACJ;AAQK,IAAMC,cAAeC,cAA6B;AACvD,IACEA,SAASC,SAAS,MAAEC,OADtBC,UAAS,OAEP,kDAAkD,IAFpDA,UAAS,KAAA,IAAA;AAIT,GACEL,SAASM,KAAKJ,QAAQ,IAACE,OADzBC,UAAS,OAEP,+DAA+DH,QAAQ,EAAE,IAF3EG,UAAS,KAAA,IAAA;AAIT,SAAOE,yBAAyBL,QAAQ;AAC1C;AAQO,IAAMM,mBAAoBC,UAAuB;AACtD,SAAOF,yBAAyBE,KAAKC,YAAY,CAAC;AACpD;AAQO,IAAMC,yBAA0BF,UAAuB;AAC5D,SAAOF,yBAAyBK,wBAAwBH,IAAI,CAAC;AAC/D;AAGO,IAAMG,0BAA2BH,UAAe;AACrD,QAAMI,WAAWJ,KAAKK,kBAAkB,IAAI,KAAK;AACjD,SAAO,IAAIC,KAAKN,KAAKO,QAAQ,IAAIH,QAAQ,EAAEH,YAAY;AACzD;AAEA,IAAMH,2BAA4BL,cAAqB;AACrD,SAAOA,SAASe,MAAM,GAAG,EAAE,CAAC;AAC9B;",
  "names": ["global", "fetchRetry", "fetch", "error", "DistanceUnitMapping", "TimeDurationMapping", "DurationMapping", "TimeDurationMapping", "isOk", "a", "TimeseriesDurationMapping", "TimeDurationMapping", "PalantirApiError", "Error", "constructor", "message", "errorName", "errorCode", "statusCode", "errorInstanceId", "parameters", "UnknownError", "PalantirApiError", "constructor", "message", "errorName", "originalError", "statusCode", "undefined", "ActionValidationError", "Error", "constructor", "validation", "JSON", "stringify", "__EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference", "name", "type", "version", "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid", "name", "type", "version", "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid", "name", "type", "version", "__EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks", "name", "type", "version", "_apply", "apply", "$ctx", "args", "$foundryPlatformFetch", "_applyAsync", "applyAsync", "_applyBatch", "applyBatch", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_getByRid", "getByRid", "get", "_upload", "upload", "$ctx", "args", "headerParams", "type", "size", "toString", "$foundryPlatformFetch", "_read", "read", "_get", "get", "_getAttachment", "getAttachment", "$ctx", "args", "$foundryPlatformFetch", "_getAttachmentByRid", "getAttachmentByRid", "_readAttachment", "readAttachment", "_readAttachmentByRid", "readAttachmentByRid", "_decrypt", "decrypt", "$ctx", "args", "$foundryPlatformFetch", "_listLinkedObjects", "listLinkedObjects", "$ctx", "args", "$foundryPlatformFetch", "_getLinkedObject", "getLinkedObject", "upload", "_getMediaContent", "getMediaContent", "$ctx", "args", "$foundryPlatformFetch", "_getMediaMetadata", "getMediaMetadata", "_upload", "upload", "_uploadMedia", "uploadMedia", "get", "list", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_getFullMetadata", "getFullMetadata", "_listOutgoingLinkTypes", "listOutgoingLinkTypes", "_getOutgoingLinkType", "getOutgoingLinkType", "get", "list", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_search", "search", "_aggregate", "aggregate", "aggregate", "get", "_createTemporary", "createTemporary", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_load", "load", "_loadMultipleObjectTypes", "loadMultipleObjectTypes", "_loadObjectsOrInterfaces", "loadObjectsOrInterfaces", "_aggregate", "aggregate", "aggregate", "get", "list", "search", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_count", "count", "_search", "search", "_aggregate", "aggregate", "get", "getFullMetadata", "list", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_getFullMetadata", "getFullMetadata", "_loadMetadata", "loadMetadata", "_execute", "execute", "$ctx", "args", "$foundryPlatformFetch", "get", "list", "_list", "list", "$ctx", "args", "$foundryPlatformFetch", "_get", "get", "_getFirstPoint", "getFirstPoint", "$ctx", "args", "$foundryPlatformFetch", "_getLastPoint", "getLastPoint", "_streamPoints", "streamPoints", "_getLatestValue", "getLatestValue", "$ctx", "args", "$foundryPlatformFetch", "_streamValues", "streamValues", "conjureFetch", "conjureUnionType", "type", "value", "makeConjureContext", "baseUrl", "fetch", "fetchFn", "tokenProvider", "servicePath", "getResults", "x", "results", "applyPageToken", "payload", "pageToken", "undefined", "pageRequestAsAsyncIter", "call", "values", "nextArgs", "initialPayload", "r", "q", "createSimpleCache", "map", "Map", "fn", "set", "key", "value", "get", "r", "undefined", "remove", "delete", "createSimpleAsyncCache", "type", "createCacheLocal", "cache", "WeakMap", "inProgress", "ret", "getOrUndefined", "k", "v", "e", "cachedAllOntologies", "getOntologyVersionForRid", "ctx", "ontologyRid", "loadAllOntologies", "ontologies", "process", "invariant", "currentOntologyVersion", "strongMemoAsync", "fn", "createSimpleAsyncCache", "get", "weakMemoAsync", "MetadataClient", "constructor", "client", "forObjectByRid", "rid", "Promise", "resolve", "getPropertyMapping", "bind", "getLinkMapping", "getRid", "getApiName", "apiName", "forObjectByApiName", "objectApiName", "objectDef", "ontologyProvider", "getObjectDefinition", "objectTypeRid", "conjureObjectType", "createObjectPropertyMapping", "linkTypes", "getLinkTypesForObjectTypes", "includeObjectTypesWithoutSearchableDatasources", "loadRedacted", "objectTypeBranches", "objectTypeVersions", "ontologyVersion", "process", "invariant", "ret", "l", "helper", "linkSide", "otherObjectType", "directedLinkTypeRid", "linkTypeRid", "definition", "type", "oneToMany", "objectTypeRidManySide", "manyToOneLinkMetadata", "objectTypeRidOneSide", "oneToManyLinkMetadata", "manyToMany", "objectTypeRidA", "objectTypeAToBLinkMetadata", "objectTypeRidB", "objectTypeBToALinkMetadata", "debug", "body", "datasourceTypes", "objectTypes", "identifier", "versionReference", "sharedPropertyTypes", "interfaceTypes", "typeGroups", "includeObjectTypeCount", "undefined", "includeEntityMetadata", "actionTypes", "includeTypeGroupEntitiesCount", "entityMetadata", "entities", "bulkLoadOntologyEntities", "objectType", "getOntologyVersionForRid", "ontologyRid", "makeConjureContext", "logger", "child", "mcc", "metadataCacheClient", "conjureOT", "primaryKeys", "length", "pkRid", "pkProperty", "Object", "values", "propertyTypes", "find", "a", "Error", "propertyIdToApiNameMapping", "fromEntries", "map", "property", "id", "propertyApiNameToIdMapping", "pk", "createBulkLinksAsyncIterFactory", "ctx", "objs", "linkTypes", "length", "logger", "debug", "every", "a", "$objectType", "process", "invariant", "mcc", "metadataCacheClient", "helper", "forObjectByApiName", "objectTypeRid", "propertyMapping", "fullLinkMapping", "Promise", "all", "getRid", "getPropertyMapping", "getLinkMapping", "linkMapping", "Object", "fromEntries", "entries", "filter", "apiName", "includes", "linkType", "req", "objectSetContext", "forkRid", "undefined", "objectSetFilterContext", "parameterOverrides", "ontologyBranchRid", "owningRid", "reportUsage", "workstateRid", "responseOptions", "includeObjectSetEntities", "includeUsageCost", "pageSize", "pageToken", "linksRequests", "directedLinkTypes", "values", "map", "directedLinkTypeRid", "objects", "conjureUnionType", "o", "objectPrimaryKey", "pk", "rid", "type", "$primaryKey", "bulkLinksIter", "pageRequestAsAsyncIter", "getBulkLinksPage", "bind", "makeConjureContext", "getResults", "prevReq", "prevResult", "applyPageToken", "item", "objectIdentifier", "obj", "findObject", "link", "links", "ref", "linkSide", "getPrimaryKeyOrThrow", "otherObjectApiName", "forObjectByRid", "getApiName", "mappedLink", "find", "linkTypeRid", "Error", "object", "linkApiName", "otherObjectPk", "pkValue", "pks", "objectLocatorV2", "createFetchHeaderMutator", "fetchFn", "fetch", "mutator", "url", "requestInit", "headers", "Headers", "createFetchOrThrow", "fetchFn", "fetch", "url", "requestInit", "response", "e", "convertError", "ok", "fallbackMessage", "status", "statusText", "headers", "get", "unknownError", "text", "Error", "body", "json", "undefined", "PalantirApiError", "message", "errorName", "errorCode", "errorInstanceId", "parameters", "msgIfNotError", "statusCode", "originalError", "UnknownError", "INITIAL_DELAY", "JITTER_FACTOR", "MAX_RETRIES", "createRetryingFetch", "fetch", "fetchRetry", "retryDelay", "attempt", "delay", "jitter", "Math", "random", "retryOn", "error", "response", "status", "isRetryable", "e", "PalantirApiError", "statusCode", "SERVICE_UNAVAILABLE", "TOO_MANY_REQUESTS", "addUserAgentAndRequestContextHeaders", "client", "withMetadata", "fetch", "createFetchHeaderMutator", "headers", "set", "JSON", "stringify", "requestContext", "osdkMetadata", "extraUserAgent", "augmentRequestContext", "client", "augment", "requestContext", "isAttachmentUpload", "o", "data", "Blob", "isAttachmentFile", "createAttachmentUpload", "name", "isMediaReference", "o", "mimeType", "reference", "type", "mediaSetViewItem", "mediaSetRid", "mediaSetViewRid", "mediaItemRid", "isMediaUpload", "path", "data", "Blob", "extractNamespace", "fqApiName", "last", "lastIndexOf", "undefined", "slice", "modernToLegacyWhereClause", "whereClause", "objectOrInterface", "type", "value", "$and", "map", "clause", "$or", "$not", "parts", "Object", "entries", "length", "handleWherePair", "v", "makeGeoFilterBbox", "bbox", "filterType", "propertyIdentifier", "field", "topLeft", "coordinates", "bottomRight", "makeGeoFilterPolygon", "fieldName", "filter", "structFieldSelector", "process", "invariant", "propertyApiName", "fullyQualifyPropName", "keysOfFilter", "keys", "hasDollarSign", "some", "key", "startsWith", "structFilter", "structFieldApiName", "firstKey", "withinBody", "Array", "isArray", "$bbox", "$distance", "$of", "center", "distance", "unit", "DistanceUnitMapping", "$polygon", "intersectsBody", "substring", "fuzzy", "objApiNamespace", "apiName", "fieldApiNamespace", "fieldShortName", "derivedPropertyDefinitionFactory", "wireDefinition", "definitionMap", "definition", "abs", "type", "property", "negate", "max", "value", "properties", "getDefinitionFromMap", "min", "add", "subtract", "multiply", "divide", "extractPart", "part", "set", "arg", "get", "process", "invariant", "createWithPropertiesObjectSet", "objectType", "objectSet", "definitionMap", "fromBaseObjectSet", "pivotTo", "link", "type", "where", "clause", "modernToLegacyWhereClause", "aggregate", "aggregation", "opt", "splitAggregation", "split", "length", "process", "invariant", "aggregationPropertyName", "aggregationOperation", "aggregationOperationDefinition", "selectedPropertyApiName", "approximatePercentile", "percentile", "limit", "undefined", "wrappedObjectSet", "operation", "selectorResult", "derivedPropertyDefinitionFactory", "set", "selectProperty", "name", "apiName", "constant", "double", "integer", "long", "datetime", "timestamp", "legacyToModernSingleAggregationResult", "entry", "metrics", "reduce", "accumulator", "curValue", "parts", "name", "split", "length", "process", "invariant", "property", "metricType", "value", "directionFieldMap", "dir", "undefined", "modernToLegacyAggregationClause", "select", "Object", "entries", "flatMap", "propAndMetric", "aggregationType", "type", "name", "direction", "colonPos", "lastIndexOf", "property", "slice", "metric", "field", "modernToLegacyGroupByClause", "groupByClause", "Object", "entries", "flatMap", "field", "type", "maxGroupCount", "$exactWithLimit", "$exact", "$limit", "undefined", "defaultValue", "$defaultValue", "fixedWidth", "$fixedWidth", "ranges", "$ranges", "map", "range", "convertRange", "value", "$duration", "unit", "DurationMapping", "startValue", "endValue", "resolveBaseObjectSetType", "objectType", "type", "interfaceType", "aggregate", "clientCtx", "objectType", "objectSet", "resolveBaseObjectSetType", "req", "body", "aggregation", "modernToLegacyAggregationClause", "$select", "groupBy", "where", "undefined", "$groupBy", "modernToLegacyGroupByClause", "result", "OntologyObjectSets", "addUserAgentAndRequestContextHeaders", "ontologyRid", "data", "length", "process", "invariant", "aggregationToCountResult", "legacyToModernSingleAggregationResult", "ret", "map", "entry", "$group", "group", "aggregateResult", "metrics", "name", "$count", "value", "extractRdpDefinition", "clientCtx", "objectSet", "extractRdpDefinitionInternal", "undefined", "definitions", "methodInputObjectType", "type", "childObjectType", "objDef", "ontologyProvider", "getObjectDefinition", "linkDef", "links", "link", "process", "invariant", "targetType", "name", "definition", "Object", "entries", "derivedProperties", "selectedOrCollectedPropertyType", "operation", "operationLevelObjectType", "properties", "selectedPropertyApiName", "objectType", "interfaceType", "objectSets", "objectSetTypes", "Promise", "all", "map", "os", "reduce", "acc", "keys", "length", "firstValidChildObjectType", "find", "every", "objectSetToSearchJsonV2", "objectSet", "expectedApiName", "existingWhere", "undefined", "type", "objectType", "Error", "interfaceType", "where", "value", "resolveInterfaceObjectSet", "interfaceTypeApiName", "args", "$includeAllBaseObjectProperties", "objectSets", "includeAllBaseObjectProperties", "fetchInterfacePage", "client", "$__UNSTABLE_useOldInterfaceApis", "result", "OntologyInterfaces", "search", "addUserAgentAndRequestContextHeaders", "ontologyRid", "apiName", "applyFetchArgs", "augmentedProperties", "augmentedSharedPropertyTypes", "otherInterfaceTypes", "selectedObjectTypes", "selectedSharedPropertyTypes", "$select", "preview", "data", "objectFactory", "$includeRid", "extractRdpDefinition", "OntologyObjectSets", "loadMultipleObjectTypes", "select", "excludeRid", "Promise", "resolve", "objectFactory2", "interfaceToObjectTypeMappings", "nextPageToken", "totalCount", "fetchPageInternal", "fetchObjectPage", "fetchPageWithErrorsInternal", "e", "error", "fetchPage", "resolveBaseObjectSetType", "applyFetchArgs", "args", "body", "$nextPageToken", "pageToken", "$pageSize", "pageSize", "$orderBy", "orderBy", "fields", "Object", "entries", "map", "field", "direction", "fetchObjectPage", "client", "objectType", "objectSet", "r", "OntologyObjectSets", "load", "addUserAgentAndRequestContextHeaders", "ontologyRid", "select", "$select", "excludeRid", "$includeRid", "Promise", "resolve", "data", "objectFactory", "undefined", "extractRdpDefinition", "nextPageToken", "totalCount", "fetchSingle", "client", "objectType", "args", "objectSet", "result", "fetchPage", "$pageSize", "data", "length", "nextPageToken", "PalantirApiError", "fetchSingleWithErrors", "value", "e", "Error", "error", "WIRE_OBJECT_SET_TYPES", "Set", "isWireObjectSet", "o", "has", "type", "MINIMUM_RECONNECT_DELAY_MS", "doNothing", "fillOutListener", "onChange", "onError", "onOutOfDate", "onSuccessfulSubscription", "isReady", "sub", "subscriptionIsDone", "status", "_client", "_logger", "ObjectSetListenerWebsocket", "constructor", "client", "minimumReconnectDelayMs", "Map", "Set", "#onOpen", "message", "data", "JSON", "parse", "toString", "process", "debug", "payload", "type", "invariant", "get", "id", "objectUpdates", "updates", "filter", "update", "referenceUpdates", "osdkObjectsWithReferenceUpdates", "Promise", "all", "map", "o", "osdkObjectArray", "objectFactory2", "__apiName", "objectType", "__primaryKey", "primaryKeyPropertyName", "primaryKey", "undefined", "property", "value", "interfaceApiName", "singleOsdkObject", "object", "state", "listener", "error", "osdkObjects", "keysToDelete", "Object", "keys", "key", "requestedReferenceProperties", "includes", "osdkObject", "responses", "subs", "delete", "i", "length", "response", "errors", "shouldFireOutOfDate", "subscriptionId", "set", "event", "#cycleWebsocket", "removeEventListener", "readyState", "WebSocket", "CLOSING", "CLOSED", "close", "size", "s", "values", "#tryCatchOnError", "subscriptionClosed", "onErrorError", "console", "logger", "child", "msgPrefix", "baseUrl", "startsWith", "getInstance", "instance", "clientCacheKey", "subscribe", "objectSet", "properties", "objOrInterfaceDef", "ontologyProvider", "getObjectDefinition", "apiName", "getInterfaceDefinition", "objectProperties", "referenceProperties", "p", "primaryKeyApiName", "requestedProperties", "nextUuid", "#initiateSubscribe", "OPEN", "#sendSubscribeMessage", "readySubs", "requests", "propertySet", "referenceSet", "send", "stringify", "#unsubscribe", "newStatus", "add", "clearTimeout", "setTimeout", "#ensureWebsocket", "tokenProvider", "url", "constructWebsocketUrl", "ontologyRid", "token", "nextConnectTime", "Date", "now", "resolve", "addEventListener", "CONNECTING", "ws", "reject", "cleanup", "open", "evt", "#fetchInterfaceMapping", "objectTypeApiName", "interfaceMap", "#handleMessage_subscriptionClosed", "has", "cause", "WeakMap", "base", "URL", "protocol", "replace", "uuidCounter", "padStart", "isObjectTypeDefinition", "def", "type", "isObjectSet", "o", "isWireObjectSet", "objectSetDefinitions", "get", "getWireObjectSet", "objectSet", "WeakMap", "createObjectSet", "objectType", "clientCtx", "resolveBaseObjectSetType", "base", "aggregate", "bind", "globalThis", "augmentRequestContext", "finalMethodCall", "fetchPage", "fetchPageInternal", "fetchPageWithErrors", "fetchPageWithErrorsInternal", "where", "clause", "objectSetFactory", "modernToLegacyWhereClause", "pivotTo", "createSearchAround", "union", "objectSets", "map", "os", "intersect", "subtract", "asyncIter", "args", "$nextPageToken", "undefined", "result", "$pageSize", "nextPageToken", "obj", "data", "fetchOne", "primaryKey", "options", "fetchSingle", "createWithPk", "fetchOneWithErrors", "fetchSingleWithErrors", "subscribe", "listener", "opts", "pendingSubscribe", "ObjectSetListenerWebsocket", "getInstance", "properties", "unsubscribe", "withProperties", "definitionMap", "Map", "derivedProperties", "key", "Object", "keys", "derivedPropertyDefinition", "createWithPropertiesObjectSet", "$objectSetInternals", "link", "set", "objDef", "ontologyProvider", "getObjectDefinition", "apiName", "withPk", "field", "primaryKeyApiName", "value", "isInterfaceActionParam", "o", "isObjectSpecifiersObject", "o", "$apiName", "$primaryKey", "isOntologyObjectV2", "o", "__apiName", "__primaryKey", "isPoint", "o", "type", "coordinates", "length", "toDataValue", "value", "client", "actionMetadata", "Array", "isArray", "Set", "values", "from", "some", "dataValue", "isAttachmentUpload", "isAttachmentFile", "converted", "push", "promiseArray", "innerValue", "Promise", "all", "attachment", "Attachments", "upload", "data", "filename", "name", "rid", "isMediaUpload", "mediaRef", "MediaReferenceProperties", "uploadMedia", "ontologyRid", "apiName", "mediaItemPath", "path", "preview", "isOntologyObjectV2", "__primaryKey", "isObjectSpecifiersObject", "$primaryKey", "isPoint", "coordinates", "isWireObjectSet", "isObjectSet", "getWireObjectSet", "isMediaReference", "isInterfaceActionParam", "objectTypeApiName", "$objectType", "primaryKeyValue", "Object", "entries", "reduce", "promisedAcc", "key", "structValue", "acc", "resolve", "applyAction", "client", "action", "parameters", "options", "clientWithHeaders", "addUserAgentAndRequestContextHeaders", "augmentRequestContext", "finalMethodCall", "Array", "isArray", "response", "Actions", "applyBatch", "ontologyRid", "apiName", "requests", "remapBatchActionParams", "ontologyProvider", "getActionDefinition", "returnEdits", "$returnEdits", "edits", "type", "remapActionResponse", "undefined", "apply", "remapActionParams", "mode", "$validateOnly", "validation", "result", "ActionValidationError", "params", "actionMetadata", "parameterMap", "key", "value", "Object", "entries", "toDataValue", "remappedParams", "Promise", "all", "map", "param", "editResponses", "remappedActionResponse", "deletedLinksCount", "deletedObjectsCount", "addedLinks", "deletedLinks", "addedObjects", "deletedObjects", "modifiedObjects", "editedObjectTypes", "editedObjectTypesSet", "Set", "edit", "osdkEdit", "linkTypeApiNameAtoB", "linkTypeApiNameBtoA", "aSideObject", "bSideObject", "push", "add", "objectType", "primaryKey", "process", "console", "warn", "JSON", "stringify", "additionalContext", "Symbol", "ErrorMessage", "Symbol", "createSharedClientContext", "baseUrl", "tokenProvider", "userAgent", "fetchFn", "fetch", "length", "Error", "retryingFetchWithAuthOrThrow", "createFetchHeaderMutator", "createRetryingFetch", "createFetchOrThrow", "headers", "token", "set", "get", "filter", "x", "join", "input", "init", "e", "betterError", "PalantirApiError", "message", "errorName", "errorCode", "statusCode", "errorInstanceId", "parameters", "cause", "START_TOKEN", "Uint8Array", "OBJECT_OPEN_CHAR_CODE", "OBJECT_CLOSE_CHAR_CODE", "parseStreamedResponse", "asyncIterable", "utf8decoder", "TextDecoder", "parsedStart", "prevChunks", "openBracesCount", "chunk", "i", "startsWith", "length", "j", "c", "combineAndParse", "subarray", "push", "a", "b", "prev", "curr", "str", "decode", "stream", "JSON", "parse", "iterateReadableStream", "readableStream", "res", "read", "done", "value", "getTimeRange", "body", "type", "startTime", "$startTime", "endTime", "$endTime", "$before", "when", "value", "unit", "TimeseriesDurationMapping", "$unit", "$after", "asyncIterPointsHelper", "iterator", "reader", "getReader", "point", "parseStreamedResponse", "iterateReadableStream", "time", "_client", "GeotimeSeriesPropertyImpl", "constructor", "client", "objectApiName", "primaryKey", "propertyName", "initialValue", "lastFetchedValue", "getLatestValue", "latestPointPromise", "TimeSeriesValueBankProperties", "ontologyRid", "then", "latestPoint", "err", "console", "error", "getAllValues", "query", "allPoints", "point", "asyncIterValues", "push", "streamPointsIterator", "streamValues", "range", "getTimeRange", "timeseriesPoint", "asyncIterPointsHelper", "_triplet", "_client", "MediaReferencePropertyImpl", "constructor", "args", "client", "objectApiName", "primaryKey", "propertyName", "mediaReference", "fetchContents", "MediaReferenceProperties", "getMediaContent", "ontologyRid", "preview", "fetchMetadata", "r", "getMediaMetadata", "path", "sizeBytes", "Number", "mediaType", "getMediaReference", "_triplet", "_client", "TimeSeriesPropertyImpl", "constructor", "client", "objectApiName", "primaryKey", "propertyName", "getFirstPoint", "TimeSeriesPropertiesV2", "ontologyRid", "getLastPoint", "getAllPoints", "query", "allPoints", "point", "asyncIterPoints", "push", "streamPointsIterator", "streamPoints", "range", "getTimeRange", "timeseriesPoint", "asyncIterPointsHelper", "hydrateAttachmentFromRidInternal", "client", "rid", "fetchContents", "Attachments", "read", "fetchMetadata", "r", "get", "sizeBytes", "Number", "createObjectSpecifierFromPrimaryKey", "objectDef", "primaryKey", "apiName", "extractPrimaryKeyFromObjectSpecifier", "ObjectSpecifier", "split", "InterfaceDefinitions", "Symbol", "UnderlyingOsdkObject", "Symbol", "ObjectDefRef", "InterfaceDefRef", "ClientRef", "createOsdkInterface", "underlying", "interfaceDef", "objApiNamespace", "extractNamespace", "apiName", "Object", "freeze", "defineProperties", "UnderlyingOsdkObject", "value", "enumerable", "$as", "$objectType", "$primaryKey", "$objectSpecifier", "$title", "$rid", "clone", "InterfaceDefRef", "fromEntries", "keys", "properties", "map", "p", "objDef", "ObjectDefRef", "apiNamespace", "targetPropName", "interfaceMap", "update", "$clone", "key", "Error", "remappedProps", "mapProperty", "filter", "x", "propertyName", "get$as", "createSimpleCache", "WeakMap", "$asFactory", "get", "osdkObjectToInterfaceView", "Map", "objDef", "targetMinDef", "targetInterfaceApiName", "apiName", "UnderlyingOsdkObject", "interfaceMap", "Error", "type", "def", "InterfaceDefinitions", "underlying", "existing", "deref", "osdkInterface", "createOsdkInterface", "set", "WeakRef", "get$link", "holder", "client", "ClientRef", "objDef", "ObjectDefRef", "rawObj", "UnderlyingOsdkObject", "Object", "freeze", "fromEntries", "keys", "links", "map", "linkName", "linkDef", "objectSet", "objectSetFactory", "where", "primaryKeyApiName", "$primaryKey", "pivotTo", "value", "multiplicity", "fetchOne", "options", "fetchSingle", "getWireObjectSet", "fetchOneWithErrors", "fetchSingleWithErrors", "specialPropertyTypes", "Set", "basePropDefs", "get", "get$as", "ObjectDefRef", "get$link", "value", "update", "rawObj", "UnderlyingOsdkObject", "def", "createOsdkObject", "ClientRef", "primaryKeyApiName", "Error", "apiName", "titleProperty", "$title", "newObject", "createObjectSpecifierFromPrimaryKey", "$primaryKey", "enumerable", "client", "objectDef", "simpleOsdkProperties", "derivedPropertyTypeByName", "Object", "defineProperties", "propKey", "keys", "properties", "type", "has", "createSpecialProperty", "modifyRdpProperties", "freeze", "rawValue", "definition", "operation", "num", "Number", "isSafeInteger", "process", "invariant", "selectedOrCollectedPropertyType", "Array", "isArray", "map", "a", "hydrateAttachmentFromRidInternal", "rid", "rawObject", "p", "propDef", "TimeSeriesPropertyImpl", "GeotimeSeriesPropertyImpl", "time", "timestamp", "coordinates", "position", "undefined", "MediaReferencePropertyImpl", "objectApiName", "primaryKey", "propertyName", "mediaReference", "convertWireToOsdkObjects", "client", "objects", "interfaceApiName", "forceRemoveRid", "derivedPropertyTypesByName", "selectedProps", "strictNonNull", "fixObjectPropertiesInPlace", "ifaceDef", "ontologyProvider", "getInterfaceDefinition", "undefined", "ifaceSelected", "Object", "keys", "properties", "ret", "rawObj", "objectDef", "getObjectDefinition", "$apiName", "process", "invariant", "objProps", "conforming", "invariantInterfacesAsViews", "apiName", "isConforming", "reframeAsObjectInPlace", "convertInterfacePropNamesToObjectPropNames", "Error", "osdkObject", "createOsdkObject", "$as", "push", "convertWireToOsdkObjects2", "derivedPropertyTypeByName", "interfaceToObjectTypeMappings", "interfaceToObjMapping", "filter", "val", "includes", "values", "primaryKeyApiName", "ifacePropsToMap", "map", "ifaceProp", "interfaceMap", "newProps", "sptProp", "regularProp", "entries", "value", "assign", "$primaryKey", "def", "obj", "propsToCheck", "propName", "nullable", "logger", "debug", "$objectType", "warning", "warn", "console", "error", "objs", "__rid", "$rid", "__apiName", "__primaryKey", "$title", "__title", "createClientCache", "fn", "cache", "WeakMap", "set", "client", "key", "value", "get", "clientCacheKey", "Map", "r", "undefined", "remove", "delete", "createAsyncClientCache", "createCacheLocal", "inProgress", "ret", "getOrUndefined", "k", "v", "e", "wirePropertyV2ToSdkPropertyDefinition", "input", "isNullable", "log", "sdkPropDefinition", "objectPropertyTypeToSdkPropertyDefinition", "dataType", "undefined", "type", "displayName", "multiplicity", "description", "nullable", "info", "JSON", "stringify", "propertyType", "subType", "itemType", "structFieldTypes", "reduce", "structMap", "structField", "apiName", "__UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition", "interfaceType", "v2", "log", "type", "rid", "apiName", "displayName", "description", "implements", "allExtendsInterfaces", "extendsInterfaces", "properties", "Object", "fromEntries", "entries", "allProperties", "map", "key", "value", "wirePropertyV2ToSdkPropertyDefinition", "filter", "links", "implementedBy", "implementedByObjectTypes", "getModifiedEntityTypes", "action", "addedObjects", "Set", "modifiedObjects", "operation", "operations", "type", "add", "objectTypeApiName", "wirePropertyV2ToSdkPrimaryKeyTypeDefinition", "input", "dataType", "type", "Error", "wireObjectTypeFullMetadataToSdkObjectMetadata", "objectTypeWithLink", "v2", "log", "objectType", "properties", "primaryKey", "undefined", "Error", "apiName", "implementsInterfaces2", "implementsInterfaces", "interfaceMap", "Object", "fromEntries", "entries", "map", "interfaceApiName", "impl", "type", "description", "primaryKeyApiName", "primaryKeyType", "wirePropertyV2ToSdkPrimaryKeyTypeDefinition", "links", "linkTypes", "linkType", "multiplicity", "cardinality", "targetType", "objectTypeApiName", "key", "value", "wirePropertyV2ToSdkPropertyDefinition", "filter", "implements", "inverseInterfaceMap", "props", "invertProps", "icon", "supportedIconTypes", "includes", "titleProperty", "displayName", "pluralDisplayName", "status", "ensureStringEnumSupportedOrUndefined", "supportedReleaseStatus", "rid", "visibility", "supportedObjectTypeVisibility", "a", "k", "v", "supportedValues", "wireActionTypeV2ToSdkActionMetadata", "input", "modifiedEntityTypes", "getModifiedEntityTypes", "type", "apiName", "parameters", "Object", "fromEntries", "entries", "map", "key", "value", "wireActionParameterV2ToSdkParameterDefinition", "displayName", "description", "modifiedEntities", "createModifiedEntities", "addedObjects", "modifiedObjects", "rid", "status", "ensureStringEnumSupportedOrUndefined", "supportedReleaseStatus", "multiplicity", "dataType", "actionPropertyToSdkPropertyDefinition", "subType", "nullable", "required", "parameterType", "objectSet", "objectTypeApiName", "object", "interface", "interfaceTypeApiName", "struct", "fields", "reduce", "structMap", "structField", "name", "fieldType", "Error", "JSON", "stringify", "entities", "created", "modified", "isNullableQueryDataType", "input", "type", "unionTypes", "some", "t", "wireQueryDataTypeToQueryDataTypeDefinition", "input", "type", "nullable", "object", "objectTypeApiName", "objectSet", "subType", "multiplicity", "set", "allowNulls", "isNullableQueryDataType", "unionTypes", "length", "nonNull", "find", "t", "union", "reduce", "acc", "push", "struct", "Object", "fromEntries", "fields", "map", "f", "name", "fieldType", "twoDimensionalAggregation", "get2DQueryAggregationProps", "threeDimensionalAggregation", "get3DQueryAggregationProps", "keyType", "validMapKeyTypes", "includes", "Error", "toString", "valueType", "keySubtype", "guardInvalidKeyTypes", "key", "wireQueryTypeV2ToSdkQueryMetadata", "input", "type", "apiName", "description", "displayName", "version", "parameters", "Object", "fromEntries", "entries", "map", "name", "parameter", "wireQueryParameterV2ToQueryParameterDefinition", "output", "wireQueryDataTypeToQueryDataTypeDefinition", "rid", "wireQueryParameterV2ToQueryParameterDefinition", "parameter", "description", "wireQueryDataTypeToQueryDataTypeDefinition", "dataType", "loadActionMetadata", "client", "actionType", "r", "ActionTypesV2", "get", "ontologyRid", "wireActionTypeV2ToSdkActionMetadata", "loadFullObjectMetadata", "client", "objectType", "full", "ObjectTypesV2", "getFullMetadata", "ontologyRid", "preview", "ret", "wireObjectTypeFullMetadataToSdkObjectMetadata", "loadInterfaceMetadata", "client", "objectType", "r", "OntologyInterfaces", "get", "ontologyRid", "preview", "__UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition", "loadQueryMetadata", "client", "queryTypeApiNameAndVersion", "apiName", "version", "split", "r", "QueryTypes", "get", "ontologyRid", "wireQueryTypeV2ToSdkQueryMetadata", "createStandardOntologyProviderFactory", "client", "makeGetter", "fn", "cache", "createAsyncClientCache", "key", "apiName", "get", "ret", "getObjectDefinition", "objectDef", "loadFullObjectMetadata", "interfaceDefs", "Object", "fromEntries", "Promise", "all", "implements", "map", "i", "getInterfaceDefinition", "def", "handler", "undefined", "fullObjectDef", "InterfaceDefinitions", "loadInterfaceMetadata", "getActionDefinition", "r", "loadActionMetadata", "getQueryDefinition", "queryCache", "version", "loadQueryMetadata", "USER_AGENT", "createMinimalClient", "metadata", "baseUrl", "tokenProvider", "options", "fetchFn", "global", "fetch", "objectSetFactory", "createObjectSet", "createOntologyProviderFactory", "createStandardOntologyProviderFactory", "process", "URL", "e", "hint", "startsWith", "Error", "processedBaseUrl", "pathname", "endsWith", "minimalClient", "createSharedClientContext", "toString", "USER_AGENT", "objectFactory", "convertWireToOsdkObjects", "objectFactory2", "convertWireToOsdkObjects2", "ontologyRid", "logger", "clientCacheKey", "requestContext", "Object", "freeze", "assign", "ontologyProvider", "fetchMetadataInternal", "client", "definition", "type", "InterfaceDefinitions", "interfaceDefs", "objectTypeDef", "ontologyProvider", "getObjectDefinition", "apiName", "getInterfaceDefinition", "getActionDefinition", "getQueryDefinition", "isFixedVersion", "version", "undefined", "Error", "noop", "levels", "trace", "debug", "info", "warn", "error", "fatal", "BaseLogger", "constructor", "bindings", "options", "factory", "k", "level", "isLevelEnabled", "createLogMethod", "child", "msgPrefix", "filter", "x", "join", "ourLevel", "MinimalLogger", "BaseLogger", "constructor", "bindings", "options", "level", "createLogMethod", "name", "msgs", "msgPrefix", "push", "methodName", "args", "console", "join", "toDataValueQueries", "value", "client", "desiredType", "Array", "isArray", "multiplicity", "values", "from", "some", "dataValue", "isAttachmentUpload", "isAttachmentFile", "converted", "push", "promiseArray", "innerValue", "Promise", "all", "type", "attachment", "Attachments", "upload", "data", "filename", "name", "rid", "groups", "Set", "isObjectSpecifiersObject", "$primaryKey", "isWireObjectSet", "isObjectSet", "getWireObjectSet", "entrySet", "key", "mapValue", "Object", "entries", "keyType", "extractPrimaryKeyFromObjectSpecifier", "valueType", "structMap", "structValue", "applyQuery", "client", "query", "params", "qd", "ontologyProvider", "getQueryDefinition", "apiName", "isFixedVersion", "version", "undefined", "response", "Queries", "execute", "addUserAgentAndRequestContextHeaders", "augmentRequestContext", "finalMethodCall", "ontologyRid", "parameters", "remapQueryParams", "objectOutputDefs", "getRequiredDefinitions", "output", "remappedResponse", "remapQueryResponse", "value", "paramTypes", "parameterMap", "key", "Object", "entries", "toDataValueQueries", "responseDataType", "responseValue", "definitions", "nullable", "Error", "multiplicity", "withoutMultiplicity", "i", "length", "type", "set", "hydrateAttachmentFromRidInternal", "def", "get", "object", "createQueryObjectResponse", "objectSet", "createObjectSet", "objectSets", "objectType", "reference", "subtype", "struct", "requiresConversion", "map", "Array", "isArray", "process", "invariant", "entry", "keyType", "getObjectSpecifier", "valueType", "result", "groups", "push", "subResult", "subKey", "dataType", "Map", "objectDef", "getObjectDefinition", "values", "some", "primaryKey", "objectTypeApiName", "createObjectSpecifierFromPrimaryKey", "$apiName", "$title", "$objectType", "$primaryKey", "$objectSpecifier", "ActionInvoker", "constructor", "clientCtx", "actionDef", "applyAction", "bind", "undefined", "batchApplyAction", "QueryInvoker", "queryDef", "executeFunction", "applyQuery", "createClientInternal", "objectSetFactory", "baseUrl", "ontologyRid", "tokenProvider", "options", "fetchFn", "fetch", "startsWith", "Error", "then", "createMinimalClient", "logger", "MinimalLogger", "createClientFromContext", "fetchMetadata", "fetchMetadataInternal", "client", "Object", "defineProperties", "o", "type", "name", "__EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks", "getBulkLinks", "createBulkLinksAsyncIterFactory", "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid", "fetchOneByRid", "objectType", "rid", "fetchSingle", "createWithRid", "__EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference", "createMediaReference", "args", "data", "fileName", "propertyType", "MediaReferenceProperties", "upload", "apiName", "mediaItemPath", "preview", "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid", "fetchPageByRid", "objectOrInterfaceType", "rids", "fetchPage", "oldSymbolClientContext", "value", "additionalContext", "createClient", "createObjectSet", "createPlatformClient", "baseUrl", "tokenProvider", "options", "undefined", "fetchFn", "fetch", "createSharedClientContext", "USER_AGENT", "isoRegex", "extractDate", "dateTime", "length", "process", "invariant", "test", "extractDateFromIsoString", "extractDateInUTC", "date", "toISOString", "extractDateInLocalTime", "generateOffsetUtcString", "offsetMs", "getTimezoneOffset", "Date", "getTime", "split"]
}
