{
  "version": 3,
  "sources": ["../../oauth4webapi/build/index.js", "../../typescript-event-target/dist/index.mjs", "../../@osdk/oauth/build/browser/throwIfError.ts", "../../@osdk/oauth/build/browser/common.ts", "../../@osdk/oauth/build/browser/createConfidentialOauthClient.ts", "../../delay/index.js", "../../@osdk/oauth/build/browser/utils.ts", "../../@osdk/oauth/build/browser/createPublicOauthClient.ts"],
  "sourcesContent": ["let USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'oauth4webapi';\n    const VERSION = 'v2.17.0';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return (input instanceof expected ||\n            Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag]);\n    }\n    catch {\n        return false;\n    }\n}\nexport const clockSkew = Symbol();\nexport const clockTolerance = Symbol();\nexport const customFetch = Symbol();\nexport const modifyAssertion = Symbol();\nexport const jweDecrypt = Symbol();\nexport const jwksCache = Symbol();\nexport const useMtlsAlias = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === 'string') {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join('')).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, ''));\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    }\n    catch (cause) {\n        throw new OPE('The input to be decoded is not correctly encoded.', { cause });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === 'string') {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize) {\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if ((v = this._cache.get(key))) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        }\n        else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nexport class UnsupportedOperationError extends Error {\n    constructor(message) {\n        super(message ?? 'operation not supported');\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class OperationProcessingError extends Error {\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === 'private';\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === 'public';\n}\nconst SUPPORTED_JWS_ALGS = [\n    'PS256',\n    'ES256',\n    'RS256',\n    'PS384',\n    'ES384',\n    'RS384',\n    'PS512',\n    'ES512',\n    'RS512',\n    'EdDSA',\n];\nfunction processDpopNonce(response) {\n    try {\n        const nonce = response.headers.get('dpop-nonce');\n        if (nonce) {\n            dpopNonces.set(new URL(response.url).origin, nonce);\n        }\n    }\n    catch { }\n    return response;\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, '');\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== 'object' || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has('user-agent')) {\n        headers.set('user-agent', USER_AGENT);\n    }\n    if (headers.has('authorization')) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has('dpop')) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === 'function') {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nexport async function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== 'https:' && issuerIdentifier.protocol !== 'http:') {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch (options?.algorithm) {\n        case undefined:\n        case 'oidc':\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace('//', '/');\n            break;\n        case 'oauth2':\n            if (url.pathname === '/') {\n                url.pathname = '.well-known/oauth-authorization-server';\n            }\n            else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace('//', '/');\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === 'string' && input.length !== 0;\n}\nexport async function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nexport function generateRandomCodeVerifier() {\n    return randomBytes();\n}\nexport function generateRandomState() {\n    return randomBytes();\n}\nexport function generateRandomNonce() {\n    return randomBytes();\n}\nexport async function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest('SHA-256', buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return { key: input };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid,\n        modifyAssertion: input[modifyAssertion],\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, '+');\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'PS256';\n        case 'SHA-384':\n            return 'PS384';\n        case 'SHA-512':\n            return 'PS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n    }\n}\nfunction rsAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'RS256';\n        case 'SHA-384':\n            return 'RS384';\n        case 'SHA-512':\n            return 'RS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n    }\n}\nfunction esAlg(key) {\n    switch (key.algorithm.namedCurve) {\n        case 'P-256':\n            return 'ES256';\n        case 'P-384':\n            return 'ES384';\n        case 'P-521':\n            return 'ES512';\n        default:\n            throw new UnsupportedOperationError('unsupported EcKeyAlgorithm namedCurve');\n    }\n}\nfunction keyToJws(key) {\n    switch (key.algorithm.name) {\n        case 'RSA-PSS':\n            return psAlg(key);\n        case 'RSASSA-PKCS1-v1_5':\n            return rsAlg(key);\n        case 'ECDSA':\n            return esAlg(key);\n        case 'Ed25519':\n        case 'Ed448':\n            return 'EdDSA';\n        default:\n            throw new UnsupportedOperationError('unsupported CryptoKey algorithm name');\n    }\n}\nfunction getClockSkew(client) {\n    const skew = client?.[clockSkew];\n    return typeof skew === 'number' && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client?.[clockTolerance];\n    return typeof tolerance === 'number' && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1\n        ? tolerance\n        : 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [as.issuer, as.token_endpoint],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id,\n    };\n}\nasync function privateKeyJwt(as, client, key, kid, modifyAssertion) {\n    const header = { alg: keyToJws(key), kid };\n    const payload = clientAssertion(as, client);\n    modifyAssertion?.(header, payload);\n    return jwt(header, payload, key);\n}\nfunction assertAs(as) {\n    if (typeof as !== 'object' || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== 'object' || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete('client_secret');\n    body.delete('client_assertion_type');\n    body.delete('client_assertion');\n    switch (client.token_endpoint_auth_method) {\n        case undefined:\n        case 'client_secret_basic': {\n            assertNoClientPrivateKey('client_secret_basic', clientPrivateKey);\n            headers.set('authorization', clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n            break;\n        }\n        case 'client_secret_post': {\n            assertNoClientPrivateKey('client_secret_post', clientPrivateKey);\n            body.set('client_id', client.client_id);\n            body.set('client_secret', assertClientSecret(client.client_secret));\n            break;\n        }\n        case 'private_key_jwt': {\n            assertNoClientSecret('private_key_jwt', client.client_secret);\n            if (clientPrivateKey === undefined) {\n                throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n            }\n            const { key, kid, modifyAssertion } = getKeyAndKid(clientPrivateKey);\n            if (!isPrivateKey(key)) {\n                throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n            }\n            body.set('client_id', client.client_id);\n            body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');\n            body.set('client_assertion', await privateKeyJwt(as, client, key, kid, modifyAssertion));\n            break;\n        }\n        case 'tls_client_auth':\n        case 'self_signed_tls_client_auth':\n        case 'none': {\n            assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n            assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n            body.set('client_id', client.client_id);\n            break;\n        }\n        default:\n            throw new UnsupportedOperationError('unsupported client token_endpoint_auth_method');\n    }\n}\nasync function jwt(header, payload, key) {\n    if (!key.usages.includes('sign')) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nexport async function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid, modifyAssertion } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set('client_id', client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n    };\n    let resource;\n    if (parameters.has('resource') &&\n        (resource = parameters.getAll('resource')) &&\n        resource.length > 1) {\n        claims.resource = resource;\n    }\n    {\n        let value = parameters.get('max_age');\n        if (value !== null) {\n            claims.max_age = parseInt(value, 10);\n            if (!Number.isFinite(claims.max_age)) {\n                throw new OPE('\"max_age\" parameter must be a number');\n            }\n        }\n    }\n    {\n        let value = parameters.get('claims');\n        if (value !== null) {\n            try {\n                claims.claims = JSON.parse(value);\n            }\n            catch (cause) {\n                throw new OPE('failed to parse the \"claims\" parameter as JSON', { cause });\n            }\n            if (!isJsonObject(claims.claims)) {\n                throw new OPE('\"claims\" parameter must be a JSON with a top level object');\n            }\n        }\n    }\n    {\n        let value = parameters.get('authorization_details');\n        if (value !== null) {\n            try {\n                claims.authorization_details = JSON.parse(value);\n            }\n            catch (cause) {\n                throw new OPE('failed to parse the \"authorization_details\" parameter as JSON', { cause });\n            }\n            if (!Array.isArray(claims.authorization_details)) {\n                throw new OPE('\"authorization_details\" parameter must be a JSON with a top level array');\n            }\n        }\n    }\n    const header = {\n        alg: keyToJws(key),\n        typ: 'oauth-authz-req+jwt',\n        kid,\n    };\n    modifyAssertion?.(header, claims);\n    return jwt(header, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const header = {\n        alg: keyToJws(privateKey),\n        typ: 'dpop+jwt',\n        jwk: await publicJwk(publicKey),\n    };\n    const payload = {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest('SHA-256', buf(accessToken))) : undefined,\n    };\n    options[modifyAssertion]?.(header, payload);\n    headers.set('dpop', await jwt(header, payload, privateKey));\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key) {\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey('jwk', key);\n    const jwk = { kty, e, n, x, y, crv };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    return jwkCache.get(key) || getSetPublicJwkCache(key);\n}\nfunction validateEndpoint(value, endpoint, useMtlsAlias) {\n    if (typeof value !== 'string') {\n        if (useMtlsAlias) {\n            throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n        }\n        throw new TypeError(`\"as.${endpoint}\" must be a string`);\n    }\n    return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, useMtlsAlias = false) {\n    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias);\n    }\n    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias);\n}\nfunction alias(client, options) {\n    if (client.use_mtls_endpoint_aliases || options?.[useMtlsAlias]) {\n        return true;\n    }\n    return false;\n}\nexport async function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'pushed_authorization_request_endpoint', alias(client, options));\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport function isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return { scheme: scheme.toLowerCase(), parameters: {} };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, '');\n    const parameters = {};\n    for (let i = 1; i < arr.length; i += 2) {\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while (arr[idx].slice(-1) !== '\"' && ++i < arr.length) {\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, '').toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters,\n    };\n}\nexport function parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    const header = response.headers.get('www-authenticate');\n    if (header === null) {\n        return undefined;\n    }\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)) {\n        result.push([scheme, index]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others) => {\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        }\n        else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nexport async function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nexport async function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set('authorization', `Bearer ${accessToken}`);\n    }\n    else {\n        await dpopProofJwt(headers, options.DPoP, url, method.toUpperCase(), getClockSkew({ [clockSkew]: options?.[clockSkew] }), accessToken);\n        headers.set('authorization', `DPoP ${accessToken}`);\n    }\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nexport async function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'userinfo_endpoint', alias(client, options));\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set('accept', 'application/jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n        headers.append('accept', 'application/jwt');\n    }\n    return protectedResourceRequest(accessToken, 'GET', url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client),\n    });\n}\nlet jwksMap;\nfunction setJwksCache(as, jwks, uat, cache) {\n    jwksMap || (jwksMap = new WeakMap());\n    jwksMap.set(as, {\n        jwks,\n        uat,\n        get age() {\n            return epochTime() - this.uat;\n        },\n    });\n    if (cache) {\n        Object.assign(cache, { jwks: structuredClone(jwks), uat });\n    }\n}\nfunction isFreshJwksCache(input) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || epochTime() - input.uat >= 300) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isJsonObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {\n        return false;\n    }\n    return true;\n}\nfunction clearJwksCache(as, cache) {\n    jwksMap?.delete(as);\n    delete cache?.jwks;\n    delete cache?.uat;\n}\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {\n        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);\n    }\n    let jwks;\n    let age;\n    if (jwksMap?.has(as)) {\n        ;\n        ({ jwks, age } = jwksMap.get(as));\n        if (age >= 300) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    }\n    else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);\n    }\n    let kty;\n    switch (alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            kty = 'RSA';\n            break;\n        case 'ES':\n            kty = 'EC';\n            break;\n        case 'Ed':\n            kty = 'OKP';\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk) => {\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== 'sig') {\n            return false;\n        }\n        if (jwk.key_ops?.includes('verify') === false) {\n            return false;\n        }\n        switch (true) {\n            case alg === 'ES256' && jwk.crv !== 'P-256':\n            case alg === 'ES384' && jwk.crv !== 'P-384':\n            case alg === 'ES512' && jwk.crv !== 'P-521':\n            case alg === 'EdDSA' && !(jwk.crv === 'Ed25519' || jwk.crv === 'Ed448'):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE('error when selecting a JWT verification key, no applicable keys found');\n    }\n    if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== 'public') {\n        throw new OPE('jwks_uri must only contain public keys');\n    }\n    return key;\n}\nexport const skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get('content-type')?.split(';')[0];\n}\nexport async function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === 'application/jwt') {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n            .then(validateOptionalAudience.bind(undefined, client.client_id))\n            .then(validateOptionalIssuer.bind(undefined, as.issuer));\n        jwtResponseBodies.set(response, jwt);\n        json = claims;\n    }\n    else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE('JWT UserInfo Response expected');\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        }\n        catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', { cause });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch (expectedSubject) {\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    const url = resolveEndpoint(as, 'token_endpoint', alias(client, options));\n    parameters.set('grant_type', grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, 'POST', url, parameters, headers, options);\n}\nexport async function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('refresh_token', refreshToken);\n    return tokenEndpointRequest(as, client, 'refresh_token', parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nconst jwtResponseBodies = new WeakMap();\nexport function getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims[0];\n}\nexport async function validateIdTokenSignature(as, ref, options) {\n    assertAs(as);\n    if (!idTokenClaims.has(ref)) {\n        throw new OPE('\"ref\" does not contain an ID Token to verify the signature of');\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, } = idTokenClaims.get(ref)[1].split('.');\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith('HS')) {\n        throw new UnsupportedOperationError();\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nasync function validateJwtResponseSignature(as, ref, options) {\n    assertAs(as);\n    if (!jwtResponseBodies.has(ref)) {\n        throw new OPE('\"ref\" does not contain a processed JWT Response to verify the signature of');\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, } = jwtResponseBodies.get(ref).split('.');\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith('HS')) {\n        throw new UnsupportedOperationError();\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nexport function validateJwtUserInfoSignature(as, ref, options) {\n    return validateJwtResponseSignature(as, ref, options);\n}\nexport function validateJwtIntrospectionSignature(as, ref, options) {\n    return validateJwtResponseSignature(as, ref, options);\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== 'dpop' && json.token_type !== 'bearer') {\n        throw new UnsupportedOperationError('unsupported `token_type` value');\n    }\n    if (json.expires_in !== undefined &&\n        (typeof json.expires_in !== 'number' || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken &&\n        json.refresh_token !== undefined &&\n        !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== 'string') {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n                .then(validatePresence.bind(undefined, ['aud', 'exp', 'iat', 'iss', 'sub']))\n                .then(validateIssuer.bind(undefined, as.issuer))\n                .then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n                if (claims.azp === undefined) {\n                    throw new OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences');\n                }\n                if (claims.azp !== client.client_id) {\n                    throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n                }\n            }\n            if (claims.auth_time !== undefined &&\n                (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {\n                throw new OPE('ID Token \"auth_time\" (authentication time) must be a positive number');\n            }\n            idTokenClaims.set(json, [claims, jwt]);\n        }\n    }\n    return json;\n}\nexport async function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    }\n    else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nexport async function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, 'code');\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('redirect_uri', redirectUri);\n    parameters.set('code_verifier', codeVerifier);\n    parameters.set('code', code);\n    return tokenEndpointRequest(as, client, 'authorization_code', parameters, options);\n}\nconst jwtClaimNames = {\n    aud: 'audience',\n    c_hash: 'code hash',\n    client_id: 'client id',\n    exp: 'expiration time',\n    iat: 'issued at',\n    iss: 'issuer',\n    jti: 'jwt id',\n    nonce: 'nonce',\n    s_hash: 'state hash',\n    sub: 'subject',\n    ath: 'access token hash',\n    htm: 'http method',\n    htu: 'http uri',\n    cnf: 'confirmation',\n};\nfunction validatePresence(required, result) {\n    for (const claim of required) {\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nexport const expectNoNonce = Symbol();\nexport const skipAuthTimeCheck = Symbol();\nexport async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) &&\n        claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== 'number' || maxAge < 0) {\n            throw new TypeError('\"maxAge\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE('too much time has elapsed since the last End-User authentication');\n        }\n    }\n    switch (expectedNonce) {\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nexport async function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === 'string' && result.id_token.length) {\n            throw new OPE('Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing');\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== 'string' || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nexport async function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, 'client_credentials', new URLSearchParams(parameters), options);\n}\nexport async function genericTokenEndpointRequest(as, client, grantType, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(grantType)) {\n        throw new TypeError('\"grantType\" must be a non-empty string');\n    }\n    return tokenEndpointRequest(as, client, grantType, new URLSearchParams(parameters), options);\n}\nexport async function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nexport async function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, 'revocation_endpoint', alias(client, options));\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete('accept');\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nexport async function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, 'introspection_endpoint', alias(client, options));\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set('accept', 'application/token-introspection+jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n    }\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === 'application/token-introspection+jwt') {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n            .then(checkJwtType.bind(undefined, 'token-introspection+jwt'))\n            .then(validatePresence.bind(undefined, ['aud', 'iat', 'iss']))\n            .then(validateIssuer.bind(undefined, as.issuer))\n            .then(validateAudience.bind(undefined, client.client_id));\n        jwtResponseBodies.set(response, jwt);\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    }\n    else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        }\n        catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', { cause });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== 'boolean') {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, 'jwks_uri');\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    headers.append('accept', 'application/jwk-set+json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === 'string' && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== 'string') {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== 'string') {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== 'string') {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== 'string') {\n                    delete json.scope;\n                }\n                return json;\n            }\n        }\n        catch { }\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== 'number' || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch (namedCurve) {\n        case 'P-256':\n            return 'SHA-256';\n        case 'P-384':\n            return 'SHA-384';\n        case 'P-521':\n            return 'SHA-512';\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch (key.algorithm.name) {\n        case 'ECDSA':\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve),\n            };\n        case 'RSA-PSS': {\n            checkRsaKeyAlgorithm(key.algorithm);\n            switch (key.algorithm.hash.name) {\n                case 'SHA-256':\n                case 'SHA-384':\n                case 'SHA-512':\n                    return {\n                        name: key.algorithm.name,\n                        saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3,\n                    };\n                default:\n                    throw new UnsupportedOperationError();\n            }\n        }\n        case 'RSASSA-PKCS1-v1_5':\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case 'Ed448':\n        case 'Ed25519':\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n    const input = `${protectedHeader}.${payload}`;\n    const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n    if (!verified) {\n        throw new OPE('JWT signature verification failed');\n    }\n}\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance, decryptJwt) {\n    let { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split('.');\n    if (length === 5) {\n        if (decryptJwt !== undefined) {\n            jws = await decryptJwt(jws);\n            ({ 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split('.'));\n        }\n        else {\n            throw new UnsupportedOperationError('JWE structure JWTs are not supported');\n        }\n    }\n    if (length !== 3) {\n        throw new OPE('Invalid JWT');\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    }\n    catch (cause) {\n        throw new OPE('failed to parse JWT Header body as base64url encoded JSON', { cause });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE('JWT Header must be a top level object');\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    let key;\n    if (getKey !== noSignatureCheck) {\n        key = await getKey(header);\n        await validateJwsSignature(protectedHeader, payload, key, signature);\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    }\n    catch (cause) {\n        throw new OPE('failed to parse JWT Payload body as base64url encoded JSON', { cause });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE('JWT Payload must be a top level object');\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== 'number') {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== 'number') {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== 'string') {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== 'number') {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== 'string' && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return { header, claims, signature, key, jwt: jws };\n}\nexport async function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, 'response');\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n        .then(validatePresence.bind(undefined, ['aud', 'exp', 'iss']))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)) {\n        if (typeof value === 'string' && key !== 'aud') {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n    let algorithm;\n    switch (alg) {\n        case 'RS256':\n        case 'PS256':\n        case 'ES256':\n            algorithm = 'SHA-256';\n            break;\n        case 'RS384':\n        case 'PS384':\n        case 'ES384':\n            algorithm = 'SHA-384';\n            break;\n        case 'RS512':\n        case 'PS512':\n        case 'ES512':\n            algorithm = 'SHA-512';\n            break;\n        case 'EdDSA':\n            if (key.algorithm.name === 'Ed25519') {\n                algorithm = 'SHA-512';\n                break;\n            }\n            throw new UnsupportedOperationError();\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n    const expected = await idTokenHash(alg, data, key);\n    return actual === expected;\n}\nexport async function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n    }\n    parameters = new URLSearchParams(parameters);\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    parameters.delete('id_token');\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new TypeError('\"expectedState\" must be a non-empty string');\n            }\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false,\n    }, client, parameters, expectedState);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!id_token) {\n        throw new OPE('\"parameters\" does not contain an ID Token');\n    }\n    const code = getURLSearchParameter(parameters, 'code');\n    if (!code) {\n        throw new OPE('\"parameters\" does not contain an Authorization Code');\n    }\n    const requiredClaims = [\n        'aud',\n        'exp',\n        'iat',\n        'iss',\n        'sub',\n        'nonce',\n        'c_hash',\n    ];\n    if (typeof expectedState === 'string') {\n        requiredClaims.push('s_hash');\n    }\n    const { claims, header, key } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n    }\n    if (typeof claims.c_hash !== 'string' ||\n        (await idTokenHashMatches(code, claims.c_hash, header.alg, key)) !== true) {\n        throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n    }\n    if (claims.s_hash !== undefined && typeof expectedState !== 'string') {\n        throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (typeof expectedState === 'string' &&\n        (typeof claims.s_hash !== 'string' ||\n            (await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key)) !== true)) {\n        throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (claims.auth_time !== undefined &&\n        (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) must be a positive number');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) &&\n        claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== 'number' || maxAge < 0) {\n            throw new TypeError('\"maxAge\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE('too much time has elapsed since the last End-User authentication');\n        }\n    }\n    if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n    }\n    if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === undefined) {\n            throw new OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences');\n        }\n        if (claims.azp !== client.client_id) {\n            throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n        }\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== 'RS256') {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nexport const skipStateCheck = Symbol();\nexport const expectNoState = Symbol();\nexport function validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, 'response')) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, 'iss');\n    const state = getURLSearchParameter(parameters, 'state');\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, 'error');\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, 'error_description'),\n            error_uri: getURLSearchParameter(parameters, 'error_uri'),\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    const token = getURLSearchParameter(parameters, 'token');\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError('implicit and hybrid flows are not supported');\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n        case 'ES256':\n        case 'ES384':\n            return { name: 'ECDSA', namedCurve: `P-${alg.slice(-3)}` };\n        case 'ES512':\n            return { name: 'ECDSA', namedCurve: 'P-521' };\n        case 'EdDSA': {\n            switch (crv) {\n                case 'Ed25519':\n                case 'Ed448':\n                    return crv;\n                default:\n                    throw new UnsupportedOperationError();\n            }\n        }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey('jwk', key, algToSubtle(alg, jwk.crv), true, ['verify']);\n}\nexport async function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'device_authorization_endpoint', alias(client, options));\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined &&\n        !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== 'number' || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nexport async function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('device_code', deviceCode);\n    return tokenEndpointRequest(as, client, 'urn:ietf:params:oauth:grant-type:device_code', parameters, options);\n}\nexport async function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nexport async function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === 'EdDSA' ? (options?.crv ?? 'Ed25519') : undefined);\n    if (alg.startsWith('PS') || alg.startsWith('RS')) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        'sign',\n        'verify',\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = '';\n    url.hash = '';\n    return url.href;\n}\nasync function validateDPoP(as, request, accessToken, accessTokenClaims, options) {\n    const header = request.headers.get('dpop');\n    if (header === null) {\n        throw new OPE('operation indicated DPoP use but the request has no DPoP HTTP Header');\n    }\n    if (request.headers.get('authorization')?.toLowerCase().startsWith('dpop ') === false) {\n        throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== 'string') {\n        throw new OPE('operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim');\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(header, checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({ jwk, alg }) => {\n        if (!jwk) {\n            throw new OPE('DPoP Proof is missing the jwk header parameter');\n        }\n        const key = await importJwk(alg, jwk);\n        if (key.type !== 'public') {\n            throw new OPE('DPoP Proof jwk header parameter must contain a public key');\n        }\n        return key;\n    }, clockSkew, getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'dpop+jwt'))\n        .then(validatePresence.bind(undefined, ['iat', 'jti', 'ath', 'htm', 'htu']));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw new OPE('DPoP Proof iat is not recent enough');\n    }\n    if (proof.claims.htm !== request.method) {\n        throw new OPE('DPoP Proof htm mismatch');\n    }\n    if (typeof proof.claims.htu !== 'string' ||\n        normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw new OPE('DPoP Proof htu mismatch');\n    }\n    {\n        const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw new OPE('DPoP Proof ath mismatch');\n        }\n    }\n    {\n        let components;\n        switch (proof.header.jwk.kty) {\n            case 'EC':\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                    y: proof.header.jwk.y,\n                };\n                break;\n            case 'OKP':\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                };\n                break;\n            case 'RSA':\n                components = {\n                    e: proof.header.jwk.e,\n                    kty: proof.header.jwk.kty,\n                    n: proof.header.jwk.n,\n                };\n                break;\n            default:\n                throw new UnsupportedOperationError();\n        }\n        const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(JSON.stringify(components))));\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw new OPE('JWT Access Token confirmation mismatch');\n        }\n    }\n}\nexport async function validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw new TypeError('\"request\" must be an instance of Request');\n    }\n    if (!validateString(expectedAudience)) {\n        throw new OPE('\"expectedAudience\" must be a non-empty string');\n    }\n    const authorization = request.headers.get('authorization');\n    if (authorization === null) {\n        throw new OPE('\"request\" is missing an Authorization HTTP Header');\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(' ');\n    scheme = scheme.toLowerCase();\n    switch (scheme) {\n        case 'dpop':\n        case 'bearer':\n            break;\n        default:\n            throw new UnsupportedOperationError('unsupported Authorization HTTP Header scheme');\n    }\n    if (length !== 2) {\n        throw new OPE('invalid Authorization HTTP Header format');\n    }\n    const requiredClaims = [\n        'iss',\n        'exp',\n        'aud',\n        'sub',\n        'iat',\n        'jti',\n        'client_id',\n    ];\n    if (options?.requireDPoP || scheme === 'dpop' || request.headers.has('dpop')) {\n        requiredClaims.push('cnf');\n    }\n    const { claims } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'at+jwt'))\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, expectedAudience));\n    for (const claim of ['client_id', 'jti', 'sub']) {\n        if (typeof claims[claim] !== 'string') {\n            throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n        }\n    }\n    if ('cnf' in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError('multiple confirmation claims are not supported');\n            }\n            if (cnf !== 'jkt') {\n                throw new UnsupportedOperationError('unsupported JWT Confirmation method');\n            }\n        }\n    }\n    if (options?.requireDPoP ||\n        scheme === 'dpop' ||\n        claims.cnf?.jkt !== undefined ||\n        request.headers.has('dpop')) {\n        await validateDPoP(as, request, accessToken, claims, options);\n    }\n    return claims;\n}\nexport const experimentalCustomFetch = customFetch;\nexport const experimental_customFetch = customFetch;\nexport const experimentalUseMtlsAlias = useMtlsAlias;\nexport const experimental_useMtlsAlias = useMtlsAlias;\nexport const experimental_validateDetachedSignatureResponse = (...args) => validateDetachedSignatureResponse(...args);\nexport const experimental_validateJwtAccessToken = (...args) => validateJwtAccessToken(...args);\nexport const validateJwtUserinfoSignature = (...args) => validateJwtUserInfoSignature(...args);\nexport const experimental_jwksCache = jwksCache;\n", "var e=class extends EventTarget{dispatchTypedEvent(s,t){return super.dispatchEvent(t)}};export{e as TypedEventTarget};\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OAuth2Error } from \"oauth4webapi\";\nimport { isOAuth2Error } from \"oauth4webapi\";\n\ntype IsErrorInputs = Parameters<typeof isOAuth2Error>[0];\nexport function throwIfError<T extends IsErrorInputs>(\n  result: T | OAuth2Error,\n): Exclude<T, OAuth2Error> {\n  if (isOAuth2Error(result)) {\n    throw new Error(`Failed to get token: ${result.error}`);\n  }\n  return result as any;\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AuthorizationServer,\n  Client,\n  HttpRequestOptions,\n  OAuth2TokenEndpointResponse,\n} from \"oauth4webapi\";\nimport { processRevocationResponse, revocationRequest } from \"oauth4webapi\";\nimport invariant from \"tiny-invariant\";\nimport { TypedEventTarget } from \"typescript-event-target\";\nimport type { BaseOauthClient, Events } from \"./BaseOauthClient.js\";\nimport { throwIfError } from \"./throwIfError.js\";\nimport type { Token } from \"./Token.js\";\n\n// Node 18 is supposed to have a `CustomEvent` but it is not exposed on `globalThis`\n// which creates a problem for making a single codebase for node and browser. This polyfill works around it\nconst CustomEvent = process.env.TARGET === \"browser\"\n  ? globalThis.CustomEvent\n  : globalThis.CustomEvent\n    ?? class CustomEvent<T> extends Event {\n      #detail: T | null;\n\n      constructor(type: string, options: EventInit & { detail: T }) {\n        super(type, options);\n        this.#detail = options?.detail ?? null;\n      }\n\n      get detail() {\n        return this.#detail;\n      }\n    };\n\ndeclare const process: {\n  env: Record<string, string | undefined>;\n};\n\nexport interface LocalStorageState {\n  refresh_token?: string;\n  refreshTokenMarker?: string;\n  // The stringified space-separated list of scopes requested during the initial auth grant, which our refresh token is still valid for\n  // Note any or none of these scopes may have actually been granted when we received our last access token\n  requestedScopes?: string;\n}\n\nexport type SessionStorageState =\n  // when we are going to the login page\n  | {\n    codeVerifier?: never;\n    state?: never;\n    oldUrl: string;\n  }\n  // when we are redirecting to oauth login\n  | {\n    codeVerifier: string;\n    state: string;\n    oldUrl: string;\n  }\n  // when we have the refresh token\n  | {\n    codeVerifier?: never;\n    state?: never;\n    oldUrl?: never;\n  };\n\nfunction localStorageKey(client: Client) {\n  return `@osdk/oauth : refresh : ${client.client_id}`;\n}\n\nexport function saveLocal(client: Client, x: LocalStorageState): void {\n  // MUST `localStorage?` as nodejs does not have localStorage\n  globalThis.localStorage?.setItem(\n    localStorageKey(client),\n    JSON.stringify(x),\n  );\n}\n\nexport function removeLocal(client: Client): void {\n  // MUST `localStorage?` as nodejs does not have localStorage\n  globalThis.localStorage?.removeItem(\n    localStorageKey(client),\n  );\n}\n\nexport function readLocal(client: Client): LocalStorageState {\n  return JSON.parse(\n    // MUST `localStorage?` as nodejs does not have localStorage\n    globalThis.localStorage?.getItem(\n      localStorageKey(client),\n    )\n      ?? \"{}\",\n  );\n}\n\nexport function saveSession(client: Client, x: SessionStorageState): void {\n  // MUST `sessionStorage?` as nodejs does not have sessionStorage\n  globalThis.sessionStorage?.setItem(\n    localStorageKey(client),\n    JSON.stringify(x),\n  );\n}\n\nexport function removeSession(client: Client): void {\n  // MUST `sessionStorage?` as nodejs does not have sessionStorage\n  globalThis.sessionStorage?.removeItem(\n    localStorageKey(client),\n  );\n}\n\nexport function readSession(client: Client): SessionStorageState {\n  return JSON.parse(\n    // MUST `sessionStorage?` as nodejs does not have sessionStorage\n    globalThis.sessionStorage?.getItem(\n      localStorageKey(client),\n    )\n      ?? \"{}\",\n  );\n}\n\nexport function common<\n  R extends undefined | (() => Promise<Token | undefined>),\n>(\n  client: Client,\n  as: AuthorizationServer,\n  _signIn: () => Promise<Token>,\n  oauthHttpOptions: HttpRequestOptions,\n  refresh: R,\n  refreshTokenMarker: string | undefined,\n  scopes: string,\n): {\n  getToken: BaseOauthClient<keyof Events & string> & { refresh: R };\n  makeTokenAndSaveRefresh: (\n    resp: OAuth2TokenEndpointResponse,\n    type: \"signIn\" | \"refresh\",\n  ) => Token;\n} {\n  let token: Token | undefined;\n  const eventTarget = new TypedEventTarget<Events>();\n\n  function makeTokenAndSaveRefresh(\n    resp: OAuth2TokenEndpointResponse,\n    type: \"signIn\" | \"refresh\",\n  ): Token {\n    const { refresh_token, expires_in, access_token } = resp;\n    invariant(expires_in != null);\n    saveLocal(client, {\n      refresh_token,\n      refreshTokenMarker,\n      requestedScopes: scopes,\n    });\n    token = {\n      refresh_token,\n      expires_in,\n      access_token,\n      expires_at: Date.now() + expires_in * 1000,\n    };\n\n    eventTarget.dispatchTypedEvent(\n      type,\n      new CustomEvent(\n        type,\n        { detail: token },\n      ),\n    );\n    return token;\n  }\n\n  let refreshTimeout: ReturnType<typeof setTimeout>;\n  function rmTimeout() {\n    if (refreshTimeout) clearTimeout(refreshTimeout);\n  }\n  function restartRefreshTimer(evt: CustomEvent<Token>) {\n    if (refresh) {\n      rmTimeout();\n      refreshTimeout = setTimeout(\n        refresh,\n        evt.detail.expires_in * 1000 - 60 * 1000,\n      );\n    }\n  }\n\n  async function signOut() {\n    invariant(token, \"not signed in\");\n\n    const result = await processRevocationResponse(\n      await revocationRequest(\n        as,\n        client,\n        token.access_token,\n        oauthHttpOptions,\n      ),\n    );\n\n    rmTimeout();\n\n    // Clean up\n    removeLocal(client);\n    token = undefined;\n    throwIfError(result);\n    eventTarget.dispatchTypedEvent(\"signOut\", new Event(\"signOut\"));\n  }\n\n  let pendingSignIn: Promise<Token> | undefined;\n  async function signIn() {\n    if (pendingSignIn) {\n      return pendingSignIn;\n    }\n    try {\n      pendingSignIn = _signIn();\n      return await pendingSignIn;\n    } finally {\n      pendingSignIn = undefined;\n    }\n  }\n\n  eventTarget.addEventListener(\"signIn\", restartRefreshTimer);\n  eventTarget.addEventListener(\"refresh\", restartRefreshTimer);\n\n  function getTokenOrUndefined() {\n    if (!token || Date.now() >= token.expires_at) {\n      return undefined;\n    }\n    return token?.access_token;\n  }\n\n  const getToken = Object.assign(async function getToken() {\n    if (!token || Date.now() >= token.expires_at) {\n      token = await signIn();\n    }\n    return token?.access_token;\n  }, {\n    signIn,\n    refresh,\n    signOut,\n    rmTimeout,\n    getTokenOrUndefined,\n    addEventListener: eventTarget.addEventListener.bind(\n      eventTarget,\n    ) as typeof eventTarget.addEventListener,\n    removeEventListener: eventTarget.removeEventListener.bind(\n      eventTarget,\n    ) as typeof eventTarget.removeEventListener,\n  });\n\n  return { getToken, makeTokenAndSaveRefresh };\n}\n\nexport function createAuthorizationServer(\n  ctxPath: string,\n  url: string,\n): Required<\n  Pick<\n    AuthorizationServer,\n    | \"issuer\"\n    | \"token_endpoint\"\n    | \"authorization_endpoint\"\n    | \"revocation_endpoint\"\n  >\n> {\n  const issuer = `${new URL(ctxPath, url.endsWith(\"/\") ? url : url + \"/\")}`;\n  return {\n    token_endpoint: `${issuer}/api/oauth2/token`,\n    authorization_endpoint: `${issuer}/api/oauth2/authorize`,\n    revocation_endpoint: `${issuer}/api/oauth2/revoke_token`,\n    issuer,\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Client, HttpRequestOptions } from \"oauth4webapi\";\nimport {\n  clientCredentialsGrantRequest,\n  customFetch,\n  processClientCredentialsResponse,\n} from \"oauth4webapi\";\nimport { common, createAuthorizationServer } from \"./common.js\";\nimport type { ConfidentialOauthClient } from \"./ConfidentialOauthClient.js\";\nimport { throwIfError } from \"./throwIfError.js\";\n\n/**\n * @param client_id\n * @param client_secret\n * @param url the base url of your foundry server\n * @param scopes\n * @param fetchFn\n * @param ctxPath\n * @returns which can be used as a token provider\n */\nexport function createConfidentialOauthClient(\n  client_id: string,\n  client_secret: string,\n  url: string,\n  scopes: string[] = [\"api:read-data\", \"api:write-data\"],\n  fetchFn: typeof globalThis.fetch = globalThis.fetch,\n  ctxPath: string = \"multipass\",\n): ConfidentialOauthClient {\n  const client: Client = { client_id, client_secret };\n  const authServer = createAuthorizationServer(ctxPath, url);\n  const oauthHttpOptions: HttpRequestOptions = { [customFetch]: fetchFn };\n  const joinedScopes = scopes.join(\" \");\n\n  const { getToken, makeTokenAndSaveRefresh } = common(\n    client,\n    authServer,\n    _signIn,\n    oauthHttpOptions,\n    undefined,\n    undefined,\n    joinedScopes,\n  );\n\n  async function _signIn() {\n    return makeTokenAndSaveRefresh(\n      throwIfError(\n        await processClientCredentialsResponse(\n          authServer,\n          client,\n          await clientCredentialsGrantRequest(\n            authServer,\n            client,\n            new URLSearchParams({ scope: joinedScopes }),\n            oauthHttpOptions,\n          ),\n        ),\n      ),\n      \"signIn\",\n    );\n  }\n\n  return getToken;\n}\n", "// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\t// TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(createAbortError());\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(createAbortError());\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay();\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options = {}) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport invariant from \"tiny-invariant\";\nimport type { PublicOauthClientOptions } from \"./createPublicOauthClient.js\";\n\ninterface ProcessedPublicOauthClientOptions extends\n  Omit<\n    Required<PublicOauthClientOptions>,\n    \"loginPage\" | \"refreshTokenMarker\" | \"scopes\"\n  >\n{\n  loginPage?: string;\n  refreshTokenMarker?: string;\n  joinedScopes: string;\n}\n\nexport function processOptionsAndAssignDefaults(\n  url: string,\n  redirect_uri: string,\n  useHistory?: boolean | PublicOauthClientOptions,\n  loginPage?: string,\n  postLoginPage?: string,\n  scopes?: string[],\n  fetchFn?: typeof globalThis.fetch,\n  ctxPath?: string,\n): ProcessedPublicOauthClientOptions {\n  let options: PublicOauthClientOptions = {};\n\n  if (typeof useHistory === \"object\") {\n    invariant(\n      !loginPage && !postLoginPage && !scopes && !fetchFn && !ctxPath,\n      \"If useHistory is an object, other options should not be provided\",\n    );\n    options = useHistory;\n  } else {\n    options = {\n      useHistory,\n      loginPage,\n      postLoginPage,\n      scopes,\n      fetchFn,\n      ctxPath,\n    };\n  }\n\n  invariant(url, \"url is required\");\n  invariant(redirect_uri, \"redirectUrl is required\");\n\n  // Assign defaults\n  return {\n    useHistory: options.useHistory ?? true,\n    loginPage: options.loginPage,\n    postLoginPage: options.postLoginPage || window.location.toString(),\n    joinedScopes: [...options.scopes ?? [\"api:read-data\", \"api:write-data\"]]\n      .sort().join(\" \"),\n    fetchFn: options.fetchFn ?? globalThis.fetch,\n    ctxPath: options.ctxPath ?? \"multipass\",\n    refreshTokenMarker: options.refreshTokenMarker,\n  };\n}\n", "/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport delay from \"delay\";\nimport type { Client, HttpRequestOptions } from \"oauth4webapi\";\nimport {\n  authorizationCodeGrantRequest,\n  calculatePKCECodeChallenge,\n  customFetch,\n  generateRandomCodeVerifier,\n  generateRandomState,\n  processAuthorizationCodeOAuth2Response,\n  refreshTokenGrantRequest,\n  validateAuthResponse,\n} from \"oauth4webapi\";\nimport {\n  common,\n  createAuthorizationServer,\n  readLocal,\n  readSession,\n  removeLocal,\n  removeSession,\n  saveLocal,\n  saveSession,\n} from \"./common.js\";\nimport type { PublicOauthClient } from \"./PublicOauthClient.js\";\nimport { throwIfError } from \"./throwIfError.js\";\nimport type { Token } from \"./Token.js\";\nimport { processOptionsAndAssignDefaults } from \"./utils.js\";\n\ndeclare const process: {\n  env: {\n    NODE_ENV: \"production\" | \"development\";\n    TARGET: \"browser\" | \"node\";\n  };\n};\n\nexport interface PublicOauthClientOptions {\n  /**\n   * If true, uses `history.replaceState()`, otherwise uses `window.location.assign()` (defaults to true)\n   */\n  useHistory?: boolean;\n\n  /**\n   * Custom landing page URL prior to logging in\n   */\n  loginPage?: string;\n\n  /**\n   * URL to return to after completed authentication cycle (defaults to `window.location.toString()`)\n   */\n  postLoginPage?: string;\n\n  /**\n   * * @param {string[]} [scopes=[]] - OAuth scopes to request. If not provided, defaults to `[\"api:read-data\", \"api:write-data\"]`\n   */\n  scopes?: string[];\n\n  /**\n   * Custom fetch function to use for requests (defaults to `globalThis.fetch`)\n   */\n  fetchFn?: typeof globalThis.fetch;\n\n  /**\n   * Context path for the authorization server (defaults to \"multipass\")\n   */\n  ctxPath?: string;\n\n  /**\n   * Allows for an additional value to be appended to the local storage key for the refresh token.\n   */\n  refreshTokenMarker?: string;\n}\n\n/**\n * Creates a PublicOauthClient for authentication.\n *\n * @param {string} clientId - The client_id from the OAuth configuration on the server\n * @param {string} url - The base URL of your Foundry server\n * @param {string} redirectUrl - The URL configured for redirect in the OAuth configuration on the server\n * @param {PublicOauthClientOptions} options - Additional options for the client\n * @returns {PublicOauthClient} A client that can be used as a token provider\n */\nexport function createPublicOauthClient(\n  clientId: string,\n  url: string,\n  redirectUrl: string,\n  options?: PublicOauthClientOptions,\n): PublicOauthClient;\n\n/**\n * Creates a PublicOauthClient for authentication.\n *\n * @param {string} clientId - The client_id from the OAuth configuration on the server\n * @param {string} url - The base URL of your Foundry server\n * @param {string} redirectUrl - The URL configured for redirect in the OAuth configuration on the server\n * @param {boolean} useHistory - If true, uses `history.replaceState()`, otherwise uses `window.location.assign()` (defaults to true)\n * @param {string} loginPage - Custom landing page URL prior to logging in\n * @param {string} postLoginPage - URL to return to after completed authentication cycle (defaults to `window.location.toString()`)\n * @param {string[]} scopes - OAuth scopes to request. If not provided, defaults to `[\"api:read-data\", \"api:write-data\"]`\n * @param {typeof globalThis.fetch} fetchFn - Custom fetch function to use for requests (defaults to `globalThis.fetch`)\n * @param {string} ctxPath - Context path for the authorization server (defaults to \"multipass\")\n * @returns {PublicOauthClient} A client that can be used as a token provider\n */\nexport function createPublicOauthClient(\n  client_id: string,\n  url: string,\n  redirectUrl: string,\n  useHistory?: boolean,\n  loginPage?: string,\n  postLoginPage?: string,\n  scopes?: string[],\n  fetchFn?: typeof globalThis.fetch,\n  ctxPath?: string,\n): PublicOauthClient;\nexport function createPublicOauthClient(\n  client_id: string,\n  url: string,\n  redirect_uri: string,\n  useHistory?: boolean | PublicOauthClientOptions,\n  loginPage?: string,\n  postLoginPage?: string,\n  scopes?: string[],\n  fetchFn?: typeof globalThis.fetch,\n  ctxPath?: string,\n): PublicOauthClient {\n  let refreshTokenMarker: string | undefined;\n  let joinedScopes: string;\n  ({\n    useHistory,\n    loginPage,\n    postLoginPage,\n    joinedScopes,\n    fetchFn,\n    ctxPath,\n    refreshTokenMarker,\n  } = processOptionsAndAssignDefaults(\n    url,\n    redirect_uri,\n    useHistory,\n    loginPage,\n    postLoginPage,\n    scopes,\n    fetchFn,\n    ctxPath,\n  ));\n\n  const client: Client = {\n    client_id,\n    token_endpoint_auth_method: \"none\",\n  };\n  const authServer = createAuthorizationServer(ctxPath, url);\n  const oauthHttpOptions: HttpRequestOptions = { [customFetch]: fetchFn };\n\n  const { makeTokenAndSaveRefresh, getToken } = common(\n    client,\n    authServer,\n    _signIn,\n    oauthHttpOptions,\n    maybeRefresh.bind(globalThis, true),\n    refreshTokenMarker,\n    joinedScopes,\n  );\n\n  // as an arrow function, `useHistory` is known to be a boolean\n  const go = async (x: string) => {\n    if (useHistory) {\n      window.history.replaceState({}, \"\", x);\n      return;\n    } else window.location.assign(x);\n\n    await delay(1000);\n    throw new Error(\"Unable to redirect\");\n  };\n\n  async function maybeRefresh(\n    expectRefreshToken?: boolean,\n  ): Promise<Token | undefined> {\n    const {\n      refresh_token,\n      refreshTokenMarker: lastRefreshTokenMarker,\n      requestedScopes: initialRequestedScopes,\n    } = readLocal(client);\n\n    const areScopesEqual = initialRequestedScopes != null\n      && joinedScopes === initialRequestedScopes;\n\n    if (\n      !refresh_token || lastRefreshTokenMarker !== refreshTokenMarker\n      || !areScopesEqual\n    ) {\n      if (expectRefreshToken) throw new Error(\"No refresh token found\");\n      return;\n    }\n\n    try {\n      // note, we don't use processRefreshTokenResponse because the mp oauth implementation\n      // doesn't do refresh tokens quite right and this lets us skip the id check\n      const result = makeTokenAndSaveRefresh(\n        throwIfError(\n          await processAuthorizationCodeOAuth2Response(\n            authServer,\n            client,\n            await refreshTokenGrantRequest(\n              authServer,\n              client,\n              refresh_token,\n              oauthHttpOptions,\n            ),\n          ),\n        ),\n        \"refresh\",\n      );\n\n      if (\n        result && window.location.pathname === new URL(redirect_uri).pathname\n      ) {\n        const { oldUrl } = readSession(client);\n        // don't block on the redirect\n        void go(oldUrl ?? \"/\");\n      }\n      return result;\n    } catch (e) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"Failed to get OAuth2 refresh token. Removing refresh token\",\n          e,\n        );\n      }\n      removeLocal(client);\n      if (expectRefreshToken) {\n        throw new Error(\"Could not refresh token\");\n      }\n    }\n  }\n\n  async function maybeHandleAuthReturn() {\n    const { state, oldUrl, codeVerifier } = readSession(client);\n    if (!codeVerifier) return;\n\n    try {\n      const ret = makeTokenAndSaveRefresh(\n        throwIfError(\n          await processAuthorizationCodeOAuth2Response(\n            authServer,\n            client,\n            await authorizationCodeGrantRequest(\n              authServer,\n              client,\n              throwIfError(\n                validateAuthResponse(\n                  authServer,\n                  client,\n                  new URL(window.location.href),\n                  state,\n                ),\n              ),\n              redirect_uri,\n              codeVerifier,\n              oauthHttpOptions,\n            ),\n          ),\n        ),\n        \"signIn\",\n      );\n\n      void go(oldUrl);\n      return ret;\n    } catch (e) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(\n          \"Failed to get OAuth2 token using PKCE, removing PKCE and starting a new auth flow\",\n          e,\n        );\n      }\n      removeLocal(client);\n      removeSession(client);\n      throw e;\n    }\n  }\n\n  // As an arrow function, `scopes` and `postLoginPage` are known at compile time\n  const initiateLoginRedirect = async (): Promise<void> => {\n    if (\n      loginPage\n      && window.location.href !== loginPage\n      && window.location.pathname !== loginPage\n    ) {\n      saveLocal(client, {});\n      saveSession(client, { oldUrl: postLoginPage });\n      await go(loginPage);\n      return;\n    }\n\n    const state = generateRandomState()!;\n    const codeVerifier = generateRandomCodeVerifier();\n    const oldUrl = readSession(client).oldUrl ?? window.location.toString();\n    saveLocal(client, {});\n    saveSession(client, { codeVerifier, state, oldUrl });\n\n    window.location.assign(`${authServer\n      .authorization_endpoint!}?${new URLSearchParams({\n      client_id,\n      response_type: \"code\",\n      state,\n      redirect_uri,\n      code_challenge: await calculatePKCECodeChallenge(codeVerifier),\n      code_challenge_method: \"S256\",\n      scope: `offline_access ${joinedScopes}`,\n    })}`);\n\n    // Give time for redirect to happen\n    await delay(1000);\n    throw new Error(\"Unable to redirect\");\n  };\n\n  /** Will throw if there is no token! */\n  async function _signIn() {\n    // 1. Check if we have a refresh token in local storage\n    return await maybeRefresh()\n      // 2. If there is no refresh token we are likely trying to perform the callback\n      ?? await maybeHandleAuthReturn()\n      // 3. If we haven't been able to load the token from one of the two above ways, we need to make the initial auth request\n      ?? await initiateLoginRedirect() as unknown as Token;\n  }\n\n  return getToken;\n}\n"],
  "mappings": "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",
  "names": ["_a", "modifyAssertion", "clockSkew", "_a", "e", "useMtlsAlias", "jwt", "clockSkew", "clockTolerance", "throwIfError", "result", "isOAuth2Error", "Error", "error", "CustomEvent", "globalThis", "localStorageKey", "client", "client_id", "saveLocal", "x", "_a", "localStorage", "setItem", "JSON", "stringify", "removeLocal", "removeItem", "readLocal", "parse", "getItem", "saveSession", "sessionStorage", "removeSession", "readSession", "common", "as", "_signIn", "oauthHttpOptions", "refresh", "refreshTokenMarker", "scopes", "token", "eventTarget", "TypedEventTarget", "makeTokenAndSaveRefresh", "resp", "type", "refresh_token", "expires_in", "access_token", "process", "invariant", "requestedScopes", "expires_at", "Date", "now", "dispatchTypedEvent", "detail", "refreshTimeout", "rmTimeout", "clearTimeout", "restartRefreshTimer", "evt", "setTimeout", "pendingSignIn", "signIn", "undefined", "addEventListener", "getTokenOrUndefined", "getToken", "Object", "assign", "signOut", "result", "processRevocationResponse", "revocationRequest", "throwIfError", "Event", "bind", "removeEventListener", "createAuthorizationServer", "ctxPath", "url", "issuer", "URL", "endsWith", "token_endpoint", "authorization_endpoint", "revocation_endpoint", "createConfidentialOauthClient", "client_id", "client_secret", "url", "scopes", "fetchFn", "globalThis", "fetch", "ctxPath", "client", "authServer", "createAuthorizationServer", "oauthHttpOptions", "customFetch", "joinedScopes", "join", "getToken", "makeTokenAndSaveRefresh", "common", "throwIfError", "processClientCredentialsResponse", "clientCredentialsGrantRequest", "URLSearchParams", "scope", "undefined", "signal", "processOptionsAndAssignDefaults", "url", "redirect_uri", "useHistory", "loginPage", "postLoginPage", "scopes", "fetchFn", "ctxPath", "options", "process", "invariant", "window", "location", "toString", "joinedScopes", "sort", "join", "globalThis", "fetch", "refreshTokenMarker", "createPublicOauthClient", "client_id", "url", "redirect_uri", "useHistory", "loginPage", "postLoginPage", "scopes", "fetchFn", "ctxPath", "refreshTokenMarker", "joinedScopes", "processOptionsAndAssignDefaults", "client", "token_endpoint_auth_method", "authServer", "createAuthorizationServer", "oauthHttpOptions", "customFetch", "makeTokenAndSaveRefresh", "getToken", "common", "_signIn", "maybeRefresh", "maybeHandleAuthReturn", "initiateLoginRedirect", "bind", "globalThis", "go", "x", "window", "history", "replaceState", "location", "assign", "delay", "Error", "expectRefreshToken", "refresh_token", "lastRefreshTokenMarker", "requestedScopes", "initialRequestedScopes", "readLocal", "areScopesEqual", "result", "throwIfError", "processAuthorizationCodeOAuth2Response", "refreshTokenGrantRequest", "pathname", "URL", "oldUrl", "readSession", "e", "process", "console", "warn", "removeLocal", "state", "codeVerifier", "ret", "authorizationCodeGrantRequest", "validateAuthResponse", "href", "removeSession", "saveLocal", "saveSession", "generateRandomState", "generateRandomCodeVerifier", "toString", "authorization_endpoint", "URLSearchParams", "response_type", "code_challenge", "calculatePKCECodeChallenge", "code_challenge_method", "scope"]
}
