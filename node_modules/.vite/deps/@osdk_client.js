import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  foundryPlatformFetch,
  symbolClientContext
} from "./chunk-3UWMVGII.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-DWA4UIM3.js";

// node_modules/fetch-retry/dist/fetch-retry.umd.js
var require_fetch_retry_umd = __commonJS({
  "node_modules/fetch-retry/dist/fetch-retry.umd.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.fetchRetry = factory());
    })(exports, function() {
      "use strict";
      var fetchRetry2 = function(fetch2, defaults) {
        defaults = defaults || {};
        if (typeof fetch2 !== "function") {
          throw new ArgumentError("fetch must be a function");
        }
        if (typeof defaults !== "object") {
          throw new ArgumentError("defaults must be an object");
        }
        if (defaults.retries !== void 0 && !isPositiveInteger(defaults.retries)) {
          throw new ArgumentError("retries must be a positive integer");
        }
        if (defaults.retryDelay !== void 0 && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== "function") {
          throw new ArgumentError("retryDelay must be a positive integer or a function returning a positive integer");
        }
        if (defaults.retryOn !== void 0 && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== "function") {
          throw new ArgumentError("retryOn property expects an array or function");
        }
        var baseDefaults = {
          retries: 3,
          retryDelay: 1e3,
          retryOn: []
        };
        defaults = Object.assign(baseDefaults, defaults);
        return function fetchRetry3(input, init) {
          var retries = defaults.retries;
          var retryDelay = defaults.retryDelay;
          var retryOn = defaults.retryOn;
          if (init && init.retries !== void 0) {
            if (isPositiveInteger(init.retries)) {
              retries = init.retries;
            } else {
              throw new ArgumentError("retries must be a positive integer");
            }
          }
          if (init && init.retryDelay !== void 0) {
            if (isPositiveInteger(init.retryDelay) || typeof init.retryDelay === "function") {
              retryDelay = init.retryDelay;
            } else {
              throw new ArgumentError("retryDelay must be a positive integer or a function returning a positive integer");
            }
          }
          if (init && init.retryOn) {
            if (Array.isArray(init.retryOn) || typeof init.retryOn === "function") {
              retryOn = init.retryOn;
            } else {
              throw new ArgumentError("retryOn property expects an array or function");
            }
          }
          return new Promise(function(resolve, reject) {
            var wrappedFetch = function(attempt) {
              var _input = typeof Request !== "undefined" && input instanceof Request ? input.clone() : input;
              fetch2(_input, init).then(function(response) {
                if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {
                  resolve(response);
                } else if (typeof retryOn === "function") {
                  try {
                    return Promise.resolve(retryOn(attempt, null, response)).then(function(retryOnResponse) {
                      if (retryOnResponse) {
                        retry(attempt, null, response);
                      } else {
                        resolve(response);
                      }
                    }).catch(reject);
                  } catch (error) {
                    reject(error);
                  }
                } else {
                  if (attempt < retries) {
                    retry(attempt, null, response);
                  } else {
                    resolve(response);
                  }
                }
              }).catch(function(error) {
                if (typeof retryOn === "function") {
                  try {
                    Promise.resolve(retryOn(attempt, error, null)).then(function(retryOnResponse) {
                      if (retryOnResponse) {
                        retry(attempt, error, null);
                      } else {
                        reject(error);
                      }
                    }).catch(function(error2) {
                      reject(error2);
                    });
                  } catch (error2) {
                    reject(error2);
                  }
                } else if (attempt < retries) {
                  retry(attempt, error, null);
                } else {
                  reject(error);
                }
              });
            };
            function retry(attempt, error, response) {
              var delay = typeof retryDelay === "function" ? retryDelay(attempt, error, response) : retryDelay;
              setTimeout(function() {
                wrappedFetch(++attempt);
              }, delay);
            }
            wrappedFetch(0);
          });
        };
      };
      function isPositiveInteger(value) {
        return Number.isInteger(value) && value >= 0;
      }
      function ArgumentError(message) {
        this.name = "ArgumentError";
        this.message = message;
      }
      return fetchRetry2;
    });
  }
});

// node_modules/@osdk/api/build/browser/aggregate/WhereClause.js
var DistanceUnitMapping = {
  "centimeter": "CENTIMETERS",
  "centimeters": "CENTIMETERS",
  "cm": "CENTIMETERS",
  "meter": "METERS",
  "meters": "METERS",
  "m": "METERS",
  "kilometer": "KILOMETERS",
  "kilometers": "KILOMETERS",
  "km": "KILOMETERS",
  "inch": "INCHES",
  "inches": "INCHES",
  "foot": "FEET",
  "feet": "FEET",
  "yard": "YARDS",
  "yards": "YARDS",
  "mile": "MILES",
  "miles": "MILES",
  "nautical_mile": "NAUTICAL_MILES",
  "nauticalMile": "NAUTICAL_MILES",
  "nautical miles": "NAUTICAL_MILES"
};

// node_modules/@osdk/api/build/browser/mapping/DurationMapping.js
var TimeDurationMapping = {
  "sec": "SECONDS",
  "seconds": "SECONDS",
  "min": "MINUTES",
  "minute": "MINUTES",
  "minutes": "MINUTES",
  "hr": "HOURS",
  "hrs": "HOURS",
  "hour": "HOURS",
  "hours": "HOURS",
  "day": "DAYS",
  "days": "DAYS",
  "wk": "WEEKS",
  "week": "WEEKS",
  "weeks": "WEEKS",
  "mos": "MONTHS",
  "month": "MONTHS",
  "months": "MONTHS",
  "yr": "YEARS",
  "year": "YEARS",
  "years": "YEARS"
};

// node_modules/@osdk/api/build/browser/groupby/GroupByClause.js
var DurationMapping = {
  ...TimeDurationMapping,
  "quarter": "QUARTERS",
  "quarters": "QUARTERS"
};

// node_modules/@osdk/api/build/browser/object/Result.js
function isOk(a) {
  return "value" in a;
}

// node_modules/@osdk/api/build/browser/timeseries/timeseries.js
var TimeseriesDurationMapping = {
  "ms": "MILLISECONDS",
  "milliseconds": "MILLISECONDS",
  ...TimeDurationMapping
};

// node_modules/@osdk/shared.net.errors/build/browser/PalantirApiError.js
var PalantirApiError = class extends Error {
  constructor(message, errorName, errorCode, statusCode, errorInstanceId, parameters) {
    super(message);
    this.message = message;
    this.errorName = errorName;
    this.errorCode = errorCode;
    this.statusCode = statusCode;
    this.errorInstanceId = errorInstanceId;
    this.parameters = parameters;
  }
};

// node_modules/@osdk/shared.net.errors/build/browser/UnknownError.js
var UnknownError = class extends PalantirApiError {
  constructor(message, errorName, originalError, statusCode) {
    super(message, errorName, void 0, statusCode);
    this.originalError = originalError;
  }
};

// node_modules/@osdk/client/build/browser/actions/ActionValidationError.js
var ActionValidationError = class extends Error {
  constructor(validation) {
    super("Validation Error: " + JSON.stringify(validation, null, 2));
    this.validation = validation;
  }
};

// node_modules/@osdk/api/build/browser/experimental/createMediaReference.js
var __EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference = {
  name: "__EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference",
  type: "experiment",
  version: "2.1.0"
};

// node_modules/@osdk/api/build/browser/experimental/fetchOneByRid.js
var __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid = {
  name: "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid",
  type: "experiment",
  version: "2.1.0"
};

// node_modules/@osdk/api/build/browser/experimental/fetchPageByRid.js
var __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid = {
  name: "__EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid",
  type: "experiment",
  version: "2.2.0"
};

// node_modules/@osdk/api/build/browser/experimental/getBulkLinks.js
var __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks = {
  name: "__EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks",
  type: "experiment",
  version: "2.0.8"
};

// node_modules/@osdk/foundry.ontologies/build/browser/public/Action.js
var Action_exports = {};
__export(Action_exports, {
  apply: () => apply,
  applyAsync: () => applyAsync,
  applyBatch: () => applyBatch
});
var _apply = [1, "/v2/ontologies/{0}/actions/{1}/apply", 3];
function apply($ctx, ...args) {
  return foundryPlatformFetch($ctx, _apply, ...args);
}
var _applyAsync = [1, "/v2/ontologies/{0}/actions/{1}/applyAsync", 3];
function applyAsync($ctx, ...args) {
  return foundryPlatformFetch($ctx, _applyAsync, ...args);
}
var _applyBatch = [1, "/v2/ontologies/{0}/actions/{1}/applyBatch", 3];
function applyBatch($ctx, ...args) {
  return foundryPlatformFetch($ctx, _applyBatch, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/ActionTypeV2.js
var ActionTypeV2_exports = {};
__export(ActionTypeV2_exports, {
  get: () => get,
  getByRid: () => getByRid,
  list: () => list
});
var _list = [0, "/v2/ontologies/{0}/actionTypes", 2];
function list($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list, ...args);
}
var _get = [0, "/v2/ontologies/{0}/actionTypes/{1}"];
function get($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get, ...args);
}
var _getByRid = [0, "/v2/ontologies/{0}/actionTypes/byRid/{1}"];
function getByRid($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getByRid, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/Attachment.js
var Attachment_exports = {};
__export(Attachment_exports, {
  get: () => get2,
  read: () => read,
  upload: () => upload
});
var _upload = [1, "/v2/ontologies/attachments/upload", 7, "*/*"];
function upload($ctx, ...args) {
  var _a;
  const headerParams = {
    ...args[2],
    "Content-Type": ((_a = args[2]) == null ? void 0 : _a["Content-Type"]) ?? args[0].type,
    "Content-Length": args[0].size.toString()
  };
  return foundryPlatformFetch($ctx, _upload, args[0], args[1], headerParams);
}
var _read = [0, "/v2/ontologies/attachments/{0}/content", , , "*/*"];
function read($ctx, ...args) {
  return foundryPlatformFetch($ctx, _read, ...args);
}
var _get2 = [0, "/v2/ontologies/attachments/{0}"];
function get2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get2, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/AttachmentPropertyV2.js
var AttachmentPropertyV2_exports = {};
__export(AttachmentPropertyV2_exports, {
  getAttachment: () => getAttachment,
  getAttachmentByRid: () => getAttachmentByRid,
  readAttachment: () => readAttachment,
  readAttachmentByRid: () => readAttachmentByRid
});
var _getAttachment = [0, "/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}", 2];
function getAttachment($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getAttachment, ...args);
}
var _getAttachmentByRid = [0, "/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/{4}", 2];
function getAttachmentByRid($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getAttachmentByRid, ...args);
}
var _readAttachment = [0, "/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/content", 2, , "*/*"];
function readAttachment($ctx, ...args) {
  return foundryPlatformFetch($ctx, _readAttachment, ...args);
}
var _readAttachmentByRid = [0, "/v2/ontologies/{0}/objects/{1}/{2}/attachments/{3}/{4}/content", 2, , "*/*"];
function readAttachmentByRid($ctx, ...args) {
  return foundryPlatformFetch($ctx, _readAttachmentByRid, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/LinkedObjectV2.js
var LinkedObjectV2_exports = {};
__export(LinkedObjectV2_exports, {
  getLinkedObject: () => getLinkedObject,
  listLinkedObjects: () => listLinkedObjects
});
var _listLinkedObjects = [0, "/v2/ontologies/{0}/objects/{1}/{2}/links/{3}", 2];
function listLinkedObjects($ctx, ...args) {
  return foundryPlatformFetch($ctx, _listLinkedObjects, ...args);
}
var _getLinkedObject = [0, "/v2/ontologies/{0}/objects/{1}/{2}/links/{3}/{4}", 2];
function getLinkedObject($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getLinkedObject, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/MediaReferenceProperty.js
var MediaReferenceProperty_exports = {};
__export(MediaReferenceProperty_exports, {
  getMediaContent: () => getMediaContent,
  getMediaMetadata: () => getMediaMetadata,
  upload: () => upload2
});
var _getMediaContent = [0, "/v2/ontologies/{0}/objects/{1}/{2}/media/{3}/content", 2, , "*/*"];
function getMediaContent($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getMediaContent, ...args);
}
var _getMediaMetadata = [0, "/v2/ontologies/{0}/objects/{1}/{2}/media/{3}/metadata", 2];
function getMediaMetadata($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getMediaMetadata, ...args);
}
var _upload2 = [1, "/v2/ontologies/{0}/objectTypes/{1}/media/{2}/upload", 3, "*/*"];
function upload2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _upload2, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/ObjectTypeV2.js
var ObjectTypeV2_exports = {};
__export(ObjectTypeV2_exports, {
  get: () => get3,
  getFullMetadata: () => getFullMetadata,
  getOutgoingLinkType: () => getOutgoingLinkType,
  list: () => list2,
  listOutgoingLinkTypes: () => listOutgoingLinkTypes
});
var _list2 = [0, "/v2/ontologies/{0}/objectTypes", 2];
function list2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list2, ...args);
}
var _get3 = [0, "/v2/ontologies/{0}/objectTypes/{1}"];
function get3($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get3, ...args);
}
var _getFullMetadata = [0, "/v2/ontologies/{0}/objectTypes/{1}/fullMetadata", 2];
function getFullMetadata($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getFullMetadata, ...args);
}
var _listOutgoingLinkTypes = [0, "/v2/ontologies/{0}/objectTypes/{1}/outgoingLinkTypes", 2];
function listOutgoingLinkTypes($ctx, ...args) {
  return foundryPlatformFetch($ctx, _listOutgoingLinkTypes, ...args);
}
var _getOutgoingLinkType = [0, "/v2/ontologies/{0}/objectTypes/{1}/outgoingLinkTypes/{2}"];
function getOutgoingLinkType($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getOutgoingLinkType, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/OntologyInterface.js
var OntologyInterface_exports = {};
__export(OntologyInterface_exports, {
  aggregate: () => aggregate,
  get: () => get4,
  list: () => list3,
  search: () => search
});
var _list3 = [0, "/v2/ontologies/{0}/interfaceTypes", 2];
function list3($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list3, ...args);
}
var _get4 = [0, "/v2/ontologies/{0}/interfaceTypes/{1}", 2];
function get4($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get4, ...args);
}
var _search = [1, "/v2/ontologies/{0}/interfaces/{1}/search", 3];
function search($ctx, ...args) {
  return foundryPlatformFetch($ctx, _search, ...args);
}
var _aggregate = [1, "/v2/ontologies/{0}/interfaces/{1}/aggregate", 3];
function aggregate($ctx, ...args) {
  return foundryPlatformFetch($ctx, _aggregate, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/OntologyObjectSet.js
var OntologyObjectSet_exports = {};
__export(OntologyObjectSet_exports, {
  aggregate: () => aggregate2,
  createTemporary: () => createTemporary,
  get: () => get5,
  load: () => load,
  loadMultipleObjectTypes: () => loadMultipleObjectTypes,
  loadObjectsOrInterfaces: () => loadObjectsOrInterfaces
});
var _createTemporary = [1, "/v2/ontologies/{0}/objectSets/createTemporary", 1];
function createTemporary($ctx, ...args) {
  return foundryPlatformFetch($ctx, _createTemporary, ...args);
}
var _get5 = [0, "/v2/ontologies/{0}/objectSets/{1}"];
function get5($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get5, ...args);
}
var _load = [1, "/v2/ontologies/{0}/objectSets/loadObjects", 3];
function load($ctx, ...args) {
  return foundryPlatformFetch($ctx, _load, ...args);
}
var _loadMultipleObjectTypes = [1, "/v2/ontologies/{0}/objectSets/loadObjectsMultipleObjectTypes", 3];
function loadMultipleObjectTypes($ctx, ...args) {
  return foundryPlatformFetch($ctx, _loadMultipleObjectTypes, ...args);
}
var _loadObjectsOrInterfaces = [1, "/v2/ontologies/{0}/objectSets/loadObjectsOrInterfaces", 3];
function loadObjectsOrInterfaces($ctx, ...args) {
  return foundryPlatformFetch($ctx, _loadObjectsOrInterfaces, ...args);
}
var _aggregate2 = [1, "/v2/ontologies/{0}/objectSets/aggregate", 3];
function aggregate2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _aggregate2, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/OntologyObjectV2.js
var OntologyObjectV2_exports = {};
__export(OntologyObjectV2_exports, {
  aggregate: () => aggregate3,
  count: () => count,
  get: () => get6,
  list: () => list4,
  search: () => search2
});
var _list4 = [0, "/v2/ontologies/{0}/objects/{1}", 2];
function list4($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list4, ...args);
}
var _get6 = [0, "/v2/ontologies/{0}/objects/{1}/{2}", 2];
function get6($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get6, ...args);
}
var _count = [1, "/v2/ontologies/{0}/objects/{1}/count", 2];
function count($ctx, ...args) {
  return foundryPlatformFetch($ctx, _count, ...args);
}
var _search2 = [1, "/v2/ontologies/{0}/objects/{1}/search", 3];
function search2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _search2, ...args);
}
var _aggregate3 = [1, "/v2/ontologies/{0}/objects/{1}/aggregate", 3];
function aggregate3($ctx, ...args) {
  return foundryPlatformFetch($ctx, _aggregate3, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/OntologyV2.js
var OntologyV2_exports = {};
__export(OntologyV2_exports, {
  get: () => get7,
  getFullMetadata: () => getFullMetadata2,
  list: () => list5
});
var _list5 = [0, "/v2/ontologies"];
function list5($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list5, ...args);
}
var _get7 = [0, "/v2/ontologies/{0}"];
function get7($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get7, ...args);
}
var _getFullMetadata2 = [0, "/v2/ontologies/{0}/fullMetadata"];
function getFullMetadata2($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getFullMetadata2, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/Query.js
var Query_exports = {};
__export(Query_exports, {
  execute: () => execute
});
var _execute = [1, "/v2/ontologies/{0}/queries/{1}/execute", 3];
function execute($ctx, ...args) {
  return foundryPlatformFetch($ctx, _execute, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/QueryType.js
var QueryType_exports = {};
__export(QueryType_exports, {
  get: () => get8,
  list: () => list6
});
var _list6 = [0, "/v2/ontologies/{0}/queryTypes", 2];
function list6($ctx, ...args) {
  return foundryPlatformFetch($ctx, _list6, ...args);
}
var _get8 = [0, "/v2/ontologies/{0}/queryTypes/{1}"];
function get8($ctx, ...args) {
  return foundryPlatformFetch($ctx, _get8, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/TimeSeriesPropertyV2.js
var TimeSeriesPropertyV2_exports = {};
__export(TimeSeriesPropertyV2_exports, {
  getFirstPoint: () => getFirstPoint,
  getLastPoint: () => getLastPoint,
  streamPoints: () => streamPoints
});
var _getFirstPoint = [0, "/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/firstPoint", 2];
function getFirstPoint($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getFirstPoint, ...args);
}
var _getLastPoint = [0, "/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/lastPoint", 2];
function getLastPoint($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getLastPoint, ...args);
}
var _streamPoints = [1, "/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/streamPoints", 3, , "*/*"];
function streamPoints($ctx, ...args) {
  return foundryPlatformFetch($ctx, _streamPoints, ...args);
}

// node_modules/@osdk/foundry.ontologies/build/browser/public/TimeSeriesValueBankProperty.js
var TimeSeriesValueBankProperty_exports = {};
__export(TimeSeriesValueBankProperty_exports, {
  getLatestValue: () => getLatestValue,
  streamValues: () => streamValues
});
var _getLatestValue = [0, "/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/latestValue", 2];
function getLatestValue($ctx, ...args) {
  return foundryPlatformFetch($ctx, _getLatestValue, ...args);
}
var _streamValues = [1, "/v2/ontologies/{0}/objects/{1}/{2}/timeseries/{3}/streamValues", 3, , "*/*"];
function streamValues($ctx, ...args) {
  return foundryPlatformFetch($ctx, _streamValues, ...args);
}

// node_modules/@osdk/client.unstable/node_modules/conjure-lite/dist/index.mjs
async function conjureFetch({ fetchFn, baseUrl, servicePath, tokenProvider }, url, method, body, params, contentType, accept) {
  if (body) {
    if (body instanceof URLSearchParams || body instanceof Blob || body instanceof FormData || typeof body === "string" || body instanceof ArrayBuffer) ;
    else {
      body = JSON.stringify(body);
    }
  }
  const queryParams = Object.entries(params ?? {}).flatMap(
    ([key, value]) => {
      if (value == null) {
        return [];
      }
      if (Array.isArray(value)) {
        return value.map((item) => [key, item]);
      }
      const stringValue = "" + value;
      return stringValue.length === 0 ? [] : [[key, stringValue]];
    }
  );
  const query = Object.keys(queryParams).length === 0 ? "" : `?${new URLSearchParams(queryParams).toString()}`;
  const response = await (fetchFn ?? fetch)(`${baseUrl}${servicePath}${url}${query}`, {
    method,
    credentials: "same-origin",
    headers: {
      "Fetch-User-Agent": "conjure-lite",
      "Content-Type": contentType ?? "application/json",
      accept: accept ?? "application/json",
      ...tokenProvider ? { "Authorization": `Bearer ${await tokenProvider()}` } : {}
    },
    ...body ? { body } : {}
  });
  try {
    if (response.status === 204) {
      return void 0;
    }
    const body2 = await readBody(response);
    if (!response.ok) {
      throw new ConjureError("STATUS", void 0, response.status, body2);
    }
    return body2;
  } catch (error) {
    if (error instanceof ConjureError) {
      throw error;
    } else if (error instanceof TypeError) {
      throw new ConjureError("NETWORK", error);
    } else {
      throw new ConjureError("OTHER", error);
    }
  }
}
async function readBody(response) {
  const contentType = response.headers.get("Content-Type") != null ? response.headers.get("Content-Type") : "";
  try {
    if (contentType.includes("application/json")) {
      return await response.json();
    } else if (contentType.includes("application/octet-stream")) {
      return await response.blob();
    } else {
      return await response.text();
    }
  } catch (error) {
    throw new ConjureError("PARSE", error, response.status);
  }
}
var ConjureError = class {
  constructor(errorType, originalError, status, body) {
    __publicField(this, "type");
    __publicField(this, "originalError");
    __publicField(this, "status");
    __publicField(this, "body");
    this.type = errorType;
    this.originalError = originalError;
    this.status = status;
    this.body = body;
  }
  toString() {
    return JSON.stringify(
      {
        body: this.body,
        originalError: this.originalError && this.originalError.toString(),
        status: this.status,
        type: this.type
      },
      null,
      "  "
    );
  }
};

// node_modules/@osdk/client.unstable/build/browser/index.js
async function getBulkLinksPage(ctx, request) {
  return conjureFetch(ctx, `/bulk-links`, "PUT", request);
}
async function bulkLoadOntologyEntities(ctx, onBehalfOf, request) {
  return conjureFetch(ctx, `/ontology/ontology/bulkLoadEntities`, "POST", request);
}
async function getLinkTypesForObjectTypes(ctx, request) {
  return conjureFetch(ctx, `/ontology/linkTypesForObjectTypes`, "POST", request);
}
async function loadAllOntologies(ctx, request) {
  return conjureFetch(ctx, `/ontology/ontology/ontologies/load/all`, "POST", request);
}

// node_modules/@osdk/client/build/browser/objectSet/conjureUnionType.js
function conjureUnionType(type, value) {
  return {
    type,
    [type]: value
  };
}

// node_modules/@osdk/client/build/browser/ontology/makeConjureContext.js
function makeConjureContext({
  baseUrl,
  fetch: fetchFn,
  tokenProvider
}, servicePath) {
  return {
    baseUrl,
    servicePath,
    fetchFn,
    tokenProvider
  };
}

// node_modules/@osdk/client/build/browser/pageRequestAsAsyncIter.js
function getResults(x) {
  return x.results;
}
function applyPageToken(payload, {
  pageToken
}) {
  return pageToken ? {
    ...payload,
    pageToken
  } : void 0;
}
async function* pageRequestAsAsyncIter(call, values, nextArgs, initialPayload) {
  let payload = initialPayload;
  while (payload) {
    const r = await call(payload);
    for (const q of values(r)) {
      yield q;
    }
    payload = nextArgs(payload, r);
  }
}

// node_modules/@osdk/client/build/browser/object/SimpleCache.js
function createSimpleCache(map = /* @__PURE__ */ new Map(), fn) {
  function set(key, value) {
    map.set(key, value);
    return value;
  }
  return {
    get: function(key) {
      let r = map.get(key);
      if (r === void 0 && fn !== void 0) {
        return set(key, fn(key));
      } else {
        return r;
      }
    },
    set,
    remove: function(key) {
      return map.delete(key);
    }
  };
}
function createSimpleAsyncCache(type, fn, createCacheLocal = createSimpleCache) {
  const cache = createCacheLocal(type === "weak" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
  const inProgress = createCacheLocal(type === "weak" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
  const ret = {
    getOrUndefined: function(key) {
      return cache.get(key);
    },
    get: async function(key) {
      return cache.get(key) ?? inProgress.get(key) ?? ret.set(key, fn(key));
    },
    set: async function(k, v) {
      try {
        const r = await inProgress.set(k, v);
        cache.set(k, r);
        inProgress.remove(k);
        return r;
      } catch (e) {
        inProgress.remove(k);
        throw e;
      }
    }
  };
  return ret;
}

// node_modules/@osdk/client/build/browser/__unstable/ConjureSupport.js
var cachedAllOntologies;
async function getOntologyVersionForRid(ctx, ontologyRid) {
  cachedAllOntologies ?? (cachedAllOntologies = await loadAllOntologies(ctx, {}));
  !cachedAllOntologies.ontologies[ontologyRid] ? true ? invariant(false, "ontology should be loaded") : invariant(false) : void 0;
  return cachedAllOntologies.ontologies[ontologyRid].currentOntologyVersion;
}
var strongMemoAsync = (fn) => createSimpleAsyncCache("strong", fn).get;
var weakMemoAsync = (fn) => createSimpleAsyncCache("weak", fn).get;
var _client, _ctx, _logger, _objectPropertyMapping, _objectLinkMapping, _getConjureObjectType;
var MetadataClient = class {
  constructor(client) {
    __privateAdd(this, _client);
    __privateAdd(this, _ctx);
    __privateAdd(this, _logger);
    __publicField(this, "forObjectByRid", strongMemoAsync(async (rid) => {
      return Promise.resolve({
        getPropertyMapping: __privateGet(this, _objectPropertyMapping).bind(this, rid),
        getLinkMapping: __privateGet(this, _objectLinkMapping).bind(this, rid),
        getRid: () => rid,
        getApiName: async () => (await __privateGet(this, _getConjureObjectType).call(this, rid)).apiName
      });
    }));
    __publicField(this, "forObjectByApiName", strongMemoAsync(async (objectApiName) => {
      const objectDef = await __privateGet(this, _client).ontologyProvider.getObjectDefinition(objectApiName);
      return this.forObjectByRid(objectDef.rid);
    }));
    __privateAdd(this, _objectPropertyMapping, strongMemoAsync(async (objectTypeRid) => {
      const conjureObjectType = await __privateGet(this, _getConjureObjectType).call(this, objectTypeRid);
      return createObjectPropertyMapping(conjureObjectType);
    }));
    __privateAdd(this, _objectLinkMapping, strongMemoAsync(async (objectTypeRid) => {
      const linkTypes = await getLinkTypesForObjectTypes(__privateGet(this, _ctx), {
        includeObjectTypesWithoutSearchableDatasources: true,
        loadRedacted: false,
        objectTypeBranches: {},
        objectTypeVersions: {
          [objectTypeRid]: await this.ontologyVersion("")
        }
      });
      !linkTypes.linkTypes[objectTypeRid] ? true ? invariant(false, "link type should be loaded") : invariant(false) : void 0;
      const ret = {};
      for (const l of linkTypes.linkTypes[objectTypeRid]) {
        const helper = ({
          apiName
        }, linkSide, otherObjectType) => {
          if (apiName) {
            ret[apiName] = {
              apiName,
              directedLinkTypeRid: {
                linkTypeRid: l.rid,
                linkSide
              },
              otherObjectType
            };
          }
        };
        if (l.definition.type === "oneToMany") {
          const {
            oneToMany: {
              objectTypeRidManySide,
              manyToOneLinkMetadata,
              objectTypeRidOneSide,
              oneToManyLinkMetadata
            }
          } = l.definition;
          if (objectTypeRidManySide === objectTypeRid) {
            helper(manyToOneLinkMetadata, "TARGET", objectTypeRidOneSide);
          }
          if (objectTypeRidOneSide === objectTypeRid) {
            helper(oneToManyLinkMetadata, "SOURCE", objectTypeRidManySide);
          }
        } else if (l.definition.type === "manyToMany") {
          const {
            manyToMany: {
              objectTypeRidA,
              objectTypeAToBLinkMetadata,
              objectTypeRidB,
              objectTypeBToALinkMetadata
            }
          } = l.definition;
          if (objectTypeRidA === objectTypeRid) {
            helper(objectTypeAToBLinkMetadata, "SOURCE", objectTypeRidB);
          }
          if (objectTypeRidB === objectTypeRid) {
            helper(objectTypeBToALinkMetadata, "TARGET", objectTypeRidA);
          }
        }
      }
      return ret;
    }));
    __privateAdd(this, _getConjureObjectType, strongMemoAsync(async (objectTypeRid) => {
      var _a, _b;
      (_a = __privateGet(this, _logger)) == null ? void 0 : _a.debug(`getConjureObjectType(${objectTypeRid})`);
      const body = {
        datasourceTypes: [],
        objectTypes: [{
          identifier: {
            type: "objectTypeRid",
            objectTypeRid
          },
          versionReference: {
            type: "ontologyVersion",
            ontologyVersion: await this.ontologyVersion("")
          }
        }],
        linkTypes: [],
        sharedPropertyTypes: [],
        interfaceTypes: [],
        typeGroups: [],
        loadRedacted: false,
        includeObjectTypeCount: void 0,
        includeObjectTypesWithoutSearchableDatasources: true,
        includeEntityMetadata: void 0,
        actionTypes: [],
        includeTypeGroupEntitiesCount: void 0,
        entityMetadata: void 0
      };
      const entities = await bulkLoadOntologyEntities(__privateGet(this, _ctx), void 0, body);
      !((_b = entities.objectTypes[0]) == null ? void 0 : _b.objectType) ? true ? invariant(false, "object type should be loaded") : invariant(false) : void 0;
      return entities.objectTypes[0].objectType;
    }));
    __publicField(this, "ontologyVersion", strongMemoAsync(async () => getOntologyVersionForRid(__privateGet(this, _ctx), await __privateGet(this, _client).ontologyRid)));
    var _a;
    __privateSet(this, _client, client);
    __privateSet(this, _ctx, makeConjureContext(client, "ontology-metadata/api"));
    __privateGet(this, _client).ontologyProvider.getObjectDefinition;
    __privateSet(this, _logger, (_a = __privateGet(this, _client).logger) == null ? void 0 : _a.child({
      mcc: true
    }));
  }
};
_client = new WeakMap();
_ctx = new WeakMap();
_logger = new WeakMap();
_objectPropertyMapping = new WeakMap();
_objectLinkMapping = new WeakMap();
_getConjureObjectType = new WeakMap();
var metadataCacheClient = weakMemoAsync((client) => Promise.resolve(new MetadataClient(client)));
function createObjectPropertyMapping(conjureOT) {
  !(conjureOT.primaryKeys.length === 1) ? true ? invariant(false, `only one primary key supported, got ${conjureOT.primaryKeys.length}`) : invariant(false) : void 0;
  const pkRid = conjureOT.primaryKeys[0];
  const pkProperty = Object.values(conjureOT.propertyTypes).find((a) => a.rid === pkRid);
  if (!pkProperty) {
    throw new Error(`Could not find PK property by rid: ${pkRid}`);
  }
  const propertyIdToApiNameMapping = Object.fromEntries(Object.values(conjureOT.propertyTypes).map((property) => {
    return [property.id, property.apiName];
  }));
  const propertyApiNameToIdMapping = Object.fromEntries(Object.values(conjureOT.propertyTypes).map((property) => {
    return [property.apiName, property.id];
  }));
  return {
    apiName: conjureOT.apiName,
    id: conjureOT.id,
    propertyIdToApiNameMapping,
    propertyApiNameToIdMapping,
    pk: {
      rid: pkRid,
      apiName: pkProperty.apiName,
      type: pkProperty.type
    }
  };
}

// node_modules/@osdk/client/build/browser/__unstable/createBulkLinksAsyncIterFactory.js
function createBulkLinksAsyncIterFactory(ctx) {
  return async function* (objs, linkTypes) {
    var _a;
    if (objs.length === 0) {
      return;
    }
    (_a = ctx.logger) == null ? void 0 : _a.debug("Preparing to fetch bulk links");
    !objs.every((a) => a.$objectType === objs[0].$objectType) ? true ? invariant(false) : invariant(false) : void 0;
    const mcc = await metadataCacheClient(ctx);
    const helper = await mcc.forObjectByApiName(objs[0].$objectType);
    const [objectTypeRid, propertyMapping, fullLinkMapping] = await Promise.all([helper.getRid(), helper.getPropertyMapping(), helper.getLinkMapping()]);
    const linkMapping = Object.fromEntries(Object.entries(fullLinkMapping).filter(([apiName]) => linkTypes.includes(apiName)));
    for (const linkType of linkTypes) {
      if (linkMapping[linkType] == null) {
        throw "Unable to find link type: " + linkType;
      }
    }
    const req = {
      objectSetContext: {
        forkRid: void 0,
        objectSetFilterContext: {
          parameterOverrides: {}
        },
        ontologyBranchRid: void 0,
        owningRid: void 0,
        reportUsage: void 0,
        workstateRid: void 0
      },
      responseOptions: {
        includeObjectSetEntities: true,
        includeUsageCost: false
      },
      pageSize: 1e3,
      pageToken: void 0,
      linksRequests: [{
        directedLinkTypes: Object.values(linkMapping).map(({
          directedLinkTypeRid
        }) => directedLinkTypeRid),
        objects: conjureUnionType("objects", objs.map((o) => conjureUnionType("objectLocatorV2", {
          objectTypeRid,
          objectPrimaryKey: {
            [propertyMapping.pk.rid]: conjureUnionType(propertyMapping.pk.type.type, o.$primaryKey)
          }
        })))
      }]
    };
    const bulkLinksIter = pageRequestAsAsyncIter(getBulkLinksPage.bind(void 0, makeConjureContext(ctx, "object-set-service/api")), getResults, applyPageToken, req);
    for await (const item of bulkLinksIter) {
      const {
        objectIdentifier
      } = item;
      const obj = findObject(objectIdentifier, objs);
      for (const link of item.links) {
        const ref = link.link[link.linkSide === "SOURCE" ? "objectSideB" : "objectSideA"];
        const pk = getPrimaryKeyOrThrow(ref);
        const otherObjectApiName = await (await mcc.forObjectByRid(pk.objectTypeRid)).getApiName();
        const mappedLink = Object.values(linkMapping).find((a) => a.directedLinkTypeRid.linkTypeRid === link.link.linkTypeRid && a.directedLinkTypeRid.linkSide === link.linkSide);
        if (!mappedLink) throw new Error("Could not find link type");
        yield {
          object: obj,
          linkApiName: mappedLink.apiName,
          otherObjectApiName,
          otherObjectPk: pk.pkValue
        };
      }
    }
  };
}
function findObject(objectIdentifier, objs) {
  const {
    pkValue
  } = getPrimaryKeyOrThrow(objectIdentifier);
  const obj = objs.find((o) => o.$primaryKey === pkValue);
  if (obj == null) {
    throw new Error(`Needed to find object with pk ${pkValue}} and could not`);
  }
  return obj;
}
function getPrimaryKeyOrThrow(ref) {
  if ("type" in ref && ref.type !== "objectLocatorV2") {
    throw new Error("We do not support looking up object by rid");
  }
  const pks = Object.entries(ref.objectLocatorV2.objectPrimaryKey);
  if (pks.length !== 1) {
    throw new Error("Unable to support this request due to multiple pks");
  }
  return {
    objectTypeRid: ref.objectLocatorV2.objectTypeRid,
    pkValue: pks[0][1][pks[0][1].type]
  };
}

// node_modules/@osdk/shared.net.fetch/build/browser/createFetchHeaderMutator.js
function createFetchHeaderMutator(fetchFn = fetch, mutator) {
  return async function(url, requestInit) {
    if (!requestInit) {
      return fetchFn(url, {
        headers: await mutator(new Headers())
      });
    }
    return fetchFn(url, {
      ...requestInit,
      headers: await mutator(new Headers(requestInit.headers))
    });
  };
}

// node_modules/@osdk/shared.net.fetch/build/browser/createFetchOrThrow.js
function createFetchOrThrow(fetchFn = fetch) {
  return async function(url, requestInit) {
    let response;
    try {
      response = await fetchFn(url, requestInit);
    } catch (e) {
      throw convertError(e, "A network error occurred");
    }
    if (!response.ok) {
      const fallbackMessage = `Failed to fetch ${response.status} ${response.statusText}`;
      if (response.headers.get("Content-Type") === "text/plain") {
        throw unknownError(await response.text(), response.status);
      }
      if (response.headers.get("Content-Type") === "text/html") {
        throw unknownError(fallbackMessage, response.status, new Error("Received HTML error page: " + await response.text()));
      }
      let body;
      try {
        body = await response.json();
      } catch (e) {
        throw unknownError(fallbackMessage, response.status, e instanceof Error ? e : void 0);
      }
      throw new PalantirApiError((body == null ? void 0 : body.message) ?? fallbackMessage, body == null ? void 0 : body.errorName, body == null ? void 0 : body.errorCode, response.status, body == null ? void 0 : body.errorInstanceId, body == null ? void 0 : body.parameters);
    }
    return response;
  };
}
function convertError(e, msgIfNotError = "An unknown error occurred") {
  if (e instanceof Error) {
    return unknownError(e.message, void 0, e);
  }
  return unknownError(msgIfNotError, void 0);
}
function unknownError(message, statusCode, originalError) {
  return new UnknownError(message, void 0, originalError, statusCode);
}

// node_modules/@osdk/shared.net.fetch/build/browser/createRetryingFetch.js
var import_fetch_retry = __toESM(require_fetch_retry_umd(), 1);
var INITIAL_DELAY = 1e3;
var JITTER_FACTOR = 0.5;
var MAX_RETRIES = 3;
function createRetryingFetch(fetch2) {
  return (0, import_fetch_retry.default)(fetch2, {
    retryDelay(attempt) {
      const delay = INITIAL_DELAY * 2 ** attempt;
      const jitter = delay * JITTER_FACTOR * (Math.random() * 2 - 1);
      return delay + jitter;
    },
    retryOn(attempt, error, response) {
      const status = (response == null ? void 0 : response.status) ?? 0;
      return !(status >= 200 && status < 300) && isRetryable(error) && attempt < MAX_RETRIES;
    }
  });
}
function isRetryable(e) {
  if (e instanceof PalantirApiError) {
    if (e.statusCode !== SERVICE_UNAVAILABLE && e.statusCode !== TOO_MANY_REQUESTS) {
      return false;
    }
  }
  return true;
}
var SERVICE_UNAVAILABLE = 503;
var TOO_MANY_REQUESTS = 429;

// node_modules/@osdk/client/build/browser/util/addUserAgentAndRequestContextHeaders.js
var addUserAgentAndRequestContextHeaders = (client, withMetadata) => ({
  ...client,
  fetch: createFetchHeaderMutator(client.fetch, (headers) => {
    headers.set("X-OSDK-Request-Context", JSON.stringify(client.requestContext));
    if (withMetadata.osdkMetadata) {
      headers.set("Fetch-User-Agent", withMetadata.osdkMetadata.extraUserAgent);
    }
    return headers;
  })
});

// node_modules/@osdk/client/build/browser/util/augmentRequestContext.js
var augmentRequestContext = (client, augment) => ({
  ...client,
  requestContext: {
    ...client.requestContext,
    ...augment(client.requestContext)
  }
});

// node_modules/@osdk/client/build/browser/object/AttachmentUpload.js
function isAttachmentUpload(o) {
  return typeof o === `object` && "name" in o && "data" in o && o.data instanceof Blob;
}
function isAttachmentFile(o) {
  return typeof o === "object" && o instanceof Blob && "name" in o;
}
function createAttachmentUpload(data, name) {
  return {
    data,
    name
  };
}

// node_modules/@osdk/client/build/browser/object/mediaUpload.js
function isMediaReference(o) {
  return typeof o === `object` && typeof o.mimeType === "string" && "reference" in o && typeof o.reference === "object" && o.reference.type === "mediaSetViewItem" && "mediaSetViewItem" in o.reference && typeof o.reference.mediaSetViewItem === "object" && typeof o.reference.mediaSetViewItem.mediaSetRid === "string" && typeof o.reference.mediaSetViewItem.mediaSetViewRid === "string" && typeof o.reference.mediaSetViewItem.mediaItemRid === "string";
}

// node_modules/@osdk/client/build/browser/internal/conversions/modernToLegacyWhereClause.js
function extractNamespace(fqApiName) {
  const last = fqApiName.lastIndexOf(".");
  if (last === -1) return [void 0, fqApiName];
  return [fqApiName.slice(0, last), fqApiName.slice(last + 1)];
}
function modernToLegacyWhereClause(whereClause, objectOrInterface) {
  if ("$and" in whereClause) {
    return {
      type: "and",
      value: whereClause.$and.map((clause) => modernToLegacyWhereClause(clause, objectOrInterface))
    };
  } else if ("$or" in whereClause) {
    return {
      type: "or",
      value: whereClause.$or.map((clause) => modernToLegacyWhereClause(clause, objectOrInterface))
    };
  } else if ("$not" in whereClause) {
    return {
      type: "not",
      value: modernToLegacyWhereClause(whereClause.$not, objectOrInterface)
    };
  }
  const parts = Object.entries(whereClause);
  if (parts.length === 1) {
    return handleWherePair(parts[0], objectOrInterface);
  }
  return {
    type: "and",
    value: parts.map((v) => handleWherePair(v, objectOrInterface))
  };
}
function makeGeoFilterBbox(bbox, filterType, propertyIdentifier, field) {
  return {
    type: filterType === "$within" ? "withinBoundingBox" : "intersectsBoundingBox",
    /**
     * This is a bit ugly, but did this so that propertyIdentifier only shows up in the return object if its defined,
     * this makes it so we don't need to go update our entire test bed either to include a field which may change in near future.
     * Once we solidify that this is the way forward, I can remove field and clean this up
     */
    ...propertyIdentifier != null && {
      propertyIdentifier
    },
    field,
    value: {
      topLeft: {
        type: "Point",
        coordinates: [bbox[0], bbox[3]]
      },
      bottomRight: {
        type: "Point",
        coordinates: [bbox[2], bbox[1]]
      }
    }
  };
}
function makeGeoFilterPolygon(coordinates, filterType, propertyIdentifier, field) {
  return {
    type: filterType,
    ...propertyIdentifier != null && {
      propertyIdentifier
    },
    field,
    value: {
      type: "Polygon",
      coordinates
    }
  };
}
function handleWherePair([fieldName, filter], objectOrInterface, structFieldSelector) {
  !(filter != null) ? true ? invariant(false, "Defined key values are only allowed when they are not undefined.") : invariant(false) : void 0;
  const propertyIdentifier = structFieldSelector != null ? {
    type: "structField",
    ...structFieldSelector,
    propertyApiName: fullyQualifyPropName(structFieldSelector.propertyApiName, objectOrInterface)
  } : void 0;
  const field = structFieldSelector == null ? fullyQualifyPropName(fieldName, objectOrInterface) : void 0;
  if (typeof filter === "string" || typeof filter === "number" || typeof filter === "boolean") {
    return {
      type: "eq",
      ...propertyIdentifier != null && {
        propertyIdentifier
      },
      field,
      value: filter
    };
  }
  const keysOfFilter = Object.keys(filter);
  const hasDollarSign = keysOfFilter.some((key) => key.startsWith("$"));
  !(!hasDollarSign || keysOfFilter.length === 1) ? true ? invariant(false, "A WhereClause Filter with multiple clauses/fields is not allowed. Instead, use an 'or'/'and' clause to combine multiple filters.") : invariant(false) : void 0;
  if (!hasDollarSign) {
    const structFilter = Object.entries(filter);
    !(structFilter.length === 1) ? true ? invariant(false, "Cannot filter on more than one struct field in the same clause, need to use an and clause") : invariant(false) : void 0;
    const structFieldApiName = keysOfFilter[0];
    return handleWherePair(Object.entries(filter)[0], objectOrInterface, {
      propertyApiName: fieldName,
      structFieldApiName
    });
  }
  const firstKey = keysOfFilter[0];
  !(filter[firstKey] != null) ? true ? invariant(false) : invariant(false) : void 0;
  if (firstKey === "$ne") {
    return {
      type: "not",
      value: {
        type: "eq",
        ...propertyIdentifier != null && {
          propertyIdentifier
        },
        field,
        value: filter[firstKey]
      }
    };
  }
  if (firstKey === "$within") {
    const withinBody = filter[firstKey];
    if (Array.isArray(withinBody)) {
      return makeGeoFilterBbox(withinBody, firstKey, propertyIdentifier, field);
    } else if ("$bbox" in withinBody && withinBody.$bbox != null) {
      return makeGeoFilterBbox(withinBody.$bbox, firstKey, propertyIdentifier, field);
    } else if ("$distance" in withinBody && "$of" in withinBody && withinBody.$distance != null && withinBody.$of != null) {
      return {
        type: "withinDistanceOf",
        ...propertyIdentifier != null && {
          propertyIdentifier
        },
        field,
        value: {
          center: Array.isArray(withinBody.$of) ? {
            type: "Point",
            coordinates: withinBody.$of
          } : withinBody.$of,
          distance: {
            value: withinBody.$distance[0],
            unit: DistanceUnitMapping[withinBody.$distance[1]]
          }
        }
      };
    } else {
      const coordinates = "$polygon" in withinBody ? withinBody.$polygon : withinBody.coordinates;
      return makeGeoFilterPolygon(coordinates, "withinPolygon", propertyIdentifier, fieldName);
    }
  }
  if (firstKey === "$intersects") {
    const intersectsBody = filter[firstKey];
    if (Array.isArray(intersectsBody)) {
      return makeGeoFilterBbox(intersectsBody, firstKey, propertyIdentifier, field);
    } else if ("$bbox" in intersectsBody && intersectsBody.$bbox != null) {
      return makeGeoFilterBbox(intersectsBody.$bbox, firstKey, propertyIdentifier, field);
    } else {
      const coordinates = "$polygon" in intersectsBody ? intersectsBody.$polygon : intersectsBody.coordinates;
      return makeGeoFilterPolygon(coordinates, "intersectsPolygon", propertyIdentifier, field);
    }
  }
  if (firstKey === "$containsAllTerms" || firstKey === "$containsAnyTerm") {
    return {
      type: firstKey.substring(1),
      ...propertyIdentifier != null && {
        propertyIdentifier
      },
      field,
      value: typeof filter[firstKey] === "string" ? filter[firstKey] : filter[firstKey]["term"],
      fuzzy: typeof filter[firstKey] === "string" ? false : filter[firstKey]["fuzzySearch"] ?? false
    };
  }
  return {
    type: firstKey.substring(1),
    ...propertyIdentifier != null && {
      propertyIdentifier
    },
    field,
    value: filter[firstKey]
  };
}
function fullyQualifyPropName(fieldName, objectOrInterface) {
  if (objectOrInterface.type === "interface") {
    const [objApiNamespace] = extractNamespace(objectOrInterface.apiName);
    const [fieldApiNamespace, fieldShortName] = extractNamespace(fieldName);
    return fieldApiNamespace == null && objApiNamespace != null ? `${objApiNamespace}.${fieldShortName}` : fieldName;
  }
  return fieldName;
}

// node_modules/@osdk/client/build/browser/derivedProperties/createWithPropertiesObjectSet.js
function createWithPropertiesObjectSet(objectType, objectSet, definitionMap) {
  return {
    pivotTo: (link) => {
      return createWithPropertiesObjectSet(objectType, {
        type: "searchAround",
        objectSet,
        link
      }, definitionMap);
    },
    where: (clause) => {
      return createWithPropertiesObjectSet(objectType, {
        type: "filter",
        objectSet,
        where: modernToLegacyWhereClause(clause, objectType)
      }, definitionMap);
    },
    aggregate: (aggregation, opt) => {
      const splitAggregation = aggregation.split(":");
      !(splitAggregation.length === 2 || splitAggregation[0] === "$count") ? true ? invariant(false, "Invalid aggregation format") : invariant(false) : void 0;
      const [aggregationPropertyName, aggregationOperation] = splitAggregation;
      let aggregationOperationDefinition;
      switch (aggregationOperation) {
        case "sum":
        case "avg":
        case "min":
        case "max":
        case "exactDistinct":
        case "approximateDistinct":
          aggregationOperationDefinition = {
            type: aggregationOperation,
            selectedPropertyApiName: aggregationPropertyName
          };
          break;
        case "approximatePercentile":
          aggregationOperationDefinition = {
            type: "approximatePercentile",
            selectedPropertyApiName: aggregationPropertyName,
            approximatePercentile: (opt == null ? void 0 : opt.percentile) ?? 0.5
          };
          break;
        case "collectSet":
        case "collectList":
          aggregationOperationDefinition = {
            type: aggregationOperation,
            selectedPropertyApiName: aggregationPropertyName,
            limit: (opt == null ? void 0 : opt.limit) ?? 100
          };
          break;
        case void 0:
          if (aggregationPropertyName === "$count") {
            aggregationOperationDefinition = {
              type: "count"
            };
            break;
          }
        default:
          true ? invariant(false, "Invalid aggregation operation " + aggregationOperation) : invariant(false);
      }
      const selectorResult = {
        type: {}
      };
      definitionMap.set(selectorResult, {
        type: "selection",
        objectSet,
        operation: aggregationOperationDefinition
      });
      return selectorResult;
    },
    selectProperty: (name) => {
      const selectorResult = {
        type: {}
      };
      definitionMap.set(selectorResult, {
        type: "selection",
        objectSet,
        operation: {
          type: "get",
          selectedPropertyApiName: name
        }
      });
      return selectorResult;
    }
  };
}

// node_modules/@osdk/client/build/browser/internal/conversions/legacyToModernSingleAggregationResult.js
function legacyToModernSingleAggregationResult(entry) {
  return entry.metrics.reduce((accumulator, curValue) => {
    const parts = curValue.name.split(".");
    if (parts[0] === "count") {
      return accumulator;
    }
    !(parts.length === 2) ? true ? invariant(false, "assumed we were getting a `${key}.${type}`") : invariant(false) : void 0;
    const property = parts[0];
    const metricType = parts[1];
    if (!(property in accumulator)) {
      accumulator[property] = {};
    }
    accumulator[property][metricType] = curValue.value;
    return accumulator;
  }, {});
}

// node_modules/@osdk/client/build/browser/internal/conversions/modernToLegacyAggregationClause.js
var directionFieldMap = (dir) => dir === "asc" ? "ASC" : dir === "desc" ? "DESC" : void 0;
function modernToLegacyAggregationClause(select) {
  return Object.entries(select).flatMap(([propAndMetric, aggregationType]) => {
    if (propAndMetric === "$count") {
      return {
        type: "count",
        name: "count",
        direction: directionFieldMap(aggregationType)
      };
    }
    const colonPos = propAndMetric.lastIndexOf(":");
    const property = propAndMetric.slice(0, colonPos);
    const metric = propAndMetric.slice(colonPos + 1);
    return [{
      type: metric,
      name: `${property}.${metric}`,
      direction: directionFieldMap(aggregationType),
      field: property
    }];
  });
}

// node_modules/@osdk/client/build/browser/internal/conversions/modernToLegacyGroupByClause.js
function modernToLegacyGroupByClause(groupByClause) {
  if (!groupByClause) return [];
  return Object.entries(groupByClause).flatMap(([field, type]) => {
    var _a;
    if (type === "exact") {
      return [{
        type,
        field
      }];
    } else if ("$exactWithLimit" in type) {
      {
        return [{
          type: "exact",
          field,
          maxGroupCount: type.$exactWithLimit
        }];
      }
    } else if ("$exact" in type) {
      return [{
        type: "exact",
        field,
        maxGroupCount: ((_a = type.$exact) == null ? void 0 : _a.$limit) ?? void 0,
        defaultValue: type.$exact.$defaultValue ?? void 0
      }];
    } else if ("$fixedWidth" in type) {
      return [{
        type: "fixedWidth",
        field,
        fixedWidth: type.$fixedWidth
      }];
    } else if ("$ranges" in type) {
      return [{
        type: "ranges",
        field,
        ranges: type.$ranges.map((range) => convertRange(range))
      }];
    } else if ("$duration" in type) {
      return [{
        type: "duration",
        field,
        value: type.$duration[0],
        unit: DurationMapping[type.$duration[1]]
      }];
    } else return [];
  });
}
function convertRange(range) {
  return {
    startValue: range[0],
    endValue: range[1]
  };
}

// node_modules/@osdk/client/build/browser/util/objectSetUtils.js
function resolveBaseObjectSetType(objectType) {
  return objectType.type === "interface" ? {
    type: "interfaceBase",
    interfaceType: objectType["apiName"]
  } : {
    type: "base",
    objectType: objectType["apiName"]
  };
}

// node_modules/@osdk/client/build/browser/object/aggregate.js
async function aggregate4(clientCtx, objectType, objectSet = resolveBaseObjectSetType(objectType), req) {
  resolveBaseObjectSetType(objectType);
  const body = {
    aggregation: modernToLegacyAggregationClause(req.$select),
    groupBy: [],
    where: void 0
  };
  if (req.$groupBy) {
    body.groupBy = modernToLegacyGroupByClause(req.$groupBy);
  }
  const result = await OntologyObjectSet_exports.aggregate(addUserAgentAndRequestContextHeaders(clientCtx, objectType), await clientCtx.ontologyRid, {
    objectSet,
    groupBy: body.groupBy,
    aggregation: body.aggregation
  });
  if (!req.$groupBy) {
    !(result.data.length === 1) ? true ? invariant(false, "no group by clause should mean only one data result") : invariant(false) : void 0;
    return {
      ...aggregationToCountResult(result.data[0]),
      ...legacyToModernSingleAggregationResult(result.data[0])
    };
  }
  const ret = result.data.map((entry) => {
    return {
      $group: entry.group,
      ...aggregationToCountResult(entry),
      ...legacyToModernSingleAggregationResult(entry)
    };
  });
  return ret;
}
function aggregationToCountResult(entry) {
  for (const aggregateResult of entry.metrics) {
    if (aggregateResult.name === "count") {
      return {
        $count: aggregateResult.value
      };
    }
  }
}

// node_modules/@osdk/client/build/browser/util/extractRdpDefinition.js
async function extractRdpDefinition(clientCtx, objectSet) {
  return (await extractRdpDefinitionInternal(clientCtx, objectSet, void 0)).definitions;
}
async function extractRdpDefinitionInternal(clientCtx, objectSet, methodInputObjectType) {
  var _a;
  switch (objectSet.type) {
    case "searchAround": {
      const {
        definitions: definitions2,
        childObjectType
      } = await extractRdpDefinitionInternal(clientCtx, objectSet.objectSet, methodInputObjectType);
      if (childObjectType === void 0 || childObjectType === "") {
        return {
          definitions: {}
        };
      }
      const objDef = await clientCtx.ontologyProvider.getObjectDefinition(childObjectType);
      const linkDef = objDef.links[objectSet.link];
      !linkDef ? true ? invariant(false, `Missing link definition for '${objectSet.link}'`) : invariant(false) : void 0;
      return {
        definitions: definitions2,
        childObjectType: objDef.links[objectSet.link].targetType
      };
    }
    case "withProperties": {
      const {
        definitions: definitions2,
        childObjectType
      } = await extractRdpDefinitionInternal(clientCtx, objectSet.objectSet, methodInputObjectType);
      if (childObjectType === void 0 || childObjectType === "") {
        return {
          definitions: {}
        };
      }
      for (const [name, definition] of Object.entries(objectSet.derivedProperties)) {
        if (definition.type !== "selection") {
          continue;
        }
        switch (definition.operation.type) {
          case "collectList":
          case "collectSet":
          case "get":
            const {
              childObjectType: operationLevelObjectType
            } = await extractRdpDefinitionInternal(clientCtx, definition.objectSet, childObjectType);
            if (operationLevelObjectType === void 0 || operationLevelObjectType === "") {
              return {
                definitions: {}
              };
            }
            const objDef = await clientCtx.ontologyProvider.getObjectDefinition(operationLevelObjectType);
            definitions2[name] = objDef.properties[definition.operation.selectedPropertyApiName];
          default:
            continue;
        }
      }
      return {
        definitions: definitions2,
        childObjectType
      };
    }
    case "methodInput":
      return {
        definitions: {},
        childObjectType: methodInputObjectType
      };
    case "base":
      return {
        definitions: {},
        childObjectType: objectSet.objectType
      };
    case "interfaceBase":
      return {
        definitions: {},
        childObjectType: objectSet.interfaceType
      };
    case "filter":
    case "asBaseObjectTypes":
    case "asType":
    case "nearestNeighbors":
      return extractRdpDefinitionInternal(clientCtx, objectSet.objectSet, methodInputObjectType);
    // These will throw in OSS so we should throw here so no request is made
    case "intersect":
    case "subtract":
    case "union":
      const objectSets = objectSet.objectSets;
      const objectSetTypes = await Promise.all(objectSets.map((os) => extractRdpDefinitionInternal(clientCtx, os, methodInputObjectType)));
      const definitions = objectSetTypes.reduce((acc, {
        definitions: definitions2
      }) => ({
        ...acc,
        ...definitions2
      }), {});
      !(Object.keys(definitions).length === 0) ? true ? invariant(false, "Object sets combined using intersect, subtract, or union must not contain any derived property definitions") : invariant(false) : void 0;
      const firstValidChildObjectType = (_a = objectSetTypes.find(({
        childObjectType
      }) => childObjectType != null)) == null ? void 0 : _a.childObjectType;
      !objectSetTypes.every(({
        childObjectType
      }) => childObjectType === firstValidChildObjectType || childObjectType == null) ? true ? invariant(false, "All object sets in an intersect, subtract, or union must have the same child object type") : invariant(false) : void 0;
      return {
        definitions: {},
        childObjectType: firstValidChildObjectType
      };
    case "static":
    case "reference":
      return {
        definitions: {}
      };
    // We don't have to worry about new object sets being added and doing a runtime break and breaking people since the OSDK is always constructing these.
    default:
      true ? invariant(false, `Unsupported object set type for Runtime Derived Properties`) : invariant(false);
  }
}

// node_modules/@osdk/client/build/browser/object/fetchPage.js
function objectSetToSearchJsonV2(objectSet, expectedApiName, existingWhere = void 0) {
  if (objectSet.type === "base" || objectSet.type === "interfaceBase") {
    if (objectSet.type === "base" && objectSet.objectType !== expectedApiName) {
      throw new Error(`Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.objectType}`);
    }
    if (objectSet.type === "interfaceBase" && objectSet.interfaceType !== expectedApiName) {
      throw new Error(`Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.interfaceType}`);
    }
    return existingWhere;
  }
  if (objectSet.type === "filter") {
    return objectSetToSearchJsonV2(objectSet.objectSet, expectedApiName, existingWhere == null ? objectSet.where : {
      type: "and",
      value: [existingWhere, objectSet.where]
    });
  }
  throw new Error(`Unsupported objectSet type: ${objectSet.type}`);
}
function resolveInterfaceObjectSet(objectSet, interfaceTypeApiName, args) {
  return (args == null ? void 0 : args.$includeAllBaseObjectProperties) ? {
    type: "intersect",
    objectSets: [objectSet, {
      type: "interfaceBase",
      interfaceType: interfaceTypeApiName,
      includeAllBaseObjectProperties: true
    }]
  } : objectSet;
}
async function fetchInterfacePage(client, interfaceType, args, objectSet) {
  if (args.$__UNSTABLE_useOldInterfaceApis) {
    const result2 = await OntologyInterface_exports.search(addUserAgentAndRequestContextHeaders(client, interfaceType), await client.ontologyRid, interfaceType.apiName, applyFetchArgs(args, {
      augmentedProperties: {},
      augmentedSharedPropertyTypes: {},
      otherInterfaceTypes: [],
      selectedObjectTypes: [],
      selectedSharedPropertyTypes: args.$select ?? [],
      where: objectSetToSearchJsonV2(objectSet, interfaceType.apiName)
    }), {
      preview: true
    });
    result2.data = await client.objectFactory(
      client,
      result2.data,
      // drop readonly
      interfaceType.apiName,
      !args.$includeRid,
      await extractRdpDefinition(client, objectSet)
    );
    return result2;
  }
  const result = await OntologyObjectSet_exports.loadMultipleObjectTypes(addUserAgentAndRequestContextHeaders(client, interfaceType), await client.ontologyRid, applyFetchArgs(args, {
    objectSet: resolveInterfaceObjectSet(objectSet, interfaceType.apiName, args),
    select: (args == null ? void 0 : args.$select) ?? [],
    excludeRid: !(args == null ? void 0 : args.$includeRid)
  }), {
    preview: true
  });
  return Promise.resolve({
    data: await client.objectFactory2(client, result.data, interfaceType.apiName, {}, !args.$includeRid, args.$select, false, result.interfaceToObjectTypeMappings),
    nextPageToken: result.nextPageToken,
    totalCount: result.totalCount
  });
}
async function fetchPageInternal(client, objectType, objectSet, args = {}) {
  if (objectType.type === "interface") {
    return await fetchInterfacePage(client, objectType, args, objectSet);
  } else {
    return await fetchObjectPage(client, objectType, args, objectSet);
  }
}
async function fetchPageWithErrorsInternal(client, objectType, objectSet, args = {}) {
  try {
    const result = await fetchPageInternal(client, objectType, objectSet, args);
    return {
      value: result
    };
  } catch (e) {
    if (e instanceof Error) {
      return {
        error: e
      };
    }
    return {
      error: e
    };
  }
}
async function fetchPage(client, objectType, args, objectSet = resolveBaseObjectSetType(objectType)) {
  return fetchPageInternal(client, objectType, objectSet, args);
}
function applyFetchArgs(args, body) {
  if (args == null ? void 0 : args.$nextPageToken) {
    body.pageToken = args.$nextPageToken;
  }
  if ((args == null ? void 0 : args.$pageSize) != null) {
    body.pageSize = args.$pageSize;
  }
  if ((args == null ? void 0 : args.$orderBy) != null) {
    body.orderBy = {
      fields: Object.entries(args.$orderBy).map(([field, direction]) => ({
        field,
        direction
      }))
    };
  }
  return body;
}
async function fetchObjectPage(client, objectType, args, objectSet) {
  const r = await OntologyObjectSet_exports.load(addUserAgentAndRequestContextHeaders(client, objectType), await client.ontologyRid, applyFetchArgs(args, {
    objectSet,
    // We have to do the following case because LoadObjectSetRequestV2 isn't readonly
    select: (args == null ? void 0 : args.$select) ?? [],
    // FIXME?
    excludeRid: !(args == null ? void 0 : args.$includeRid)
  }));
  return Promise.resolve({
    data: await client.objectFactory(client, r.data, void 0, void 0, await extractRdpDefinition(client, objectSet), args.$select),
    nextPageToken: r.nextPageToken,
    totalCount: r.totalCount
  });
}

// node_modules/@osdk/client/build/browser/object/fetchSingle.js
async function fetchSingle(client, objectType, args, objectSet) {
  const result = await fetchPage(client, objectType, {
    ...args,
    $pageSize: 1
  }, objectSet);
  if (result.data.length !== 1 || result.nextPageToken != null) {
    throw new PalantirApiError(`Expected a single result but got ${result.data.length} instead${result.nextPageToken != null ? " with nextPageToken set" : ""}`);
  }
  return result.data[0];
}
async function fetchSingleWithErrors(client, objectType, args, objectSet) {
  try {
    const result = await fetchSingle(client, objectType, args, objectSet);
    return {
      value: result
    };
  } catch (e) {
    if (e instanceof Error) {
      return {
        error: e
      };
    }
    return {
      error: e
    };
  }
}

// node_modules/@osdk/client/build/browser/util/WireObjectSet.js
var WIRE_OBJECT_SET_TYPES = /* @__PURE__ */ new Set(["base", "filter", "intersect", "reference", "searchAround", "static", "subtract", "union"]);
function isWireObjectSet(o) {
  return o != null && typeof o === "object" && WIRE_OBJECT_SET_TYPES.has(o.type);
}

// node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@osdk/client/build/browser/objectSet/ObjectSetListenerWebsocket.js
var MINIMUM_RECONNECT_DELAY_MS = 5 * 1e3;
function doNothing() {
}
function fillOutListener({
  onChange = doNothing,
  onError = doNothing,
  onOutOfDate = doNothing,
  onSuccessfulSubscription = doNothing
}) {
  return {
    onChange,
    onError,
    onOutOfDate,
    onSuccessfulSubscription
  };
}
function isReady(sub) {
  return sub.isReady != null;
}
function subscriptionIsDone(sub) {
  return sub.status === "done" || sub.status === "error";
}
var _instances, _ws, _lastWsConnect, _client2, _logger2, _pendingSubscriptions, _subscriptions, _endedSubscriptions, _maybeDisconnectTimeout, _ObjectSetListenerWebsocket_instances, initiateSubscribe_fn, sendSubscribeMessage_fn, unsubscribe_fn, ensureWebsocket_fn, _onOpen, _onMessage, _handleMessage_objectSetChanged, fetchInterfaceMapping_fn, _handleMessage_refreshObjectSet, _handleMessage_subscribeResponses, handleMessage_subscriptionClosed_fn, _onClose, _cycleWebsocket, _tryCatchOnError;
var _ObjectSetListenerWebsocket = class _ObjectSetListenerWebsocket {
  // DO NOT CONSTRUCT DIRECTLY. ONLY EXPOSED AS A TESTING SEAM
  constructor(client, {
    minimumReconnectDelayMs = MINIMUM_RECONNECT_DELAY_MS
  } = {}) {
    __privateAdd(this, _ObjectSetListenerWebsocket_instances);
    __privateAdd(this, _ws);
    __privateAdd(this, _lastWsConnect, 0);
    __privateAdd(this, _client2);
    __privateAdd(this, _logger2);
    /**
     * map of requestId to all active subscriptions at the time of the request
     */
    __privateAdd(this, _pendingSubscriptions, /* @__PURE__ */ new Map());
    /**
     * Map of subscriptionId to Subscription. Note: the subscriptionId may be
     * temporary and not the actual subscriptionId from the server.
     */
    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Map());
    __privateAdd(this, _endedSubscriptions, /* @__PURE__ */ new Set());
    __privateAdd(this, _maybeDisconnectTimeout);
    __privateAdd(this, _onOpen, () => {
      __privateMethod(this, _ObjectSetListenerWebsocket_instances, sendSubscribeMessage_fn).call(this);
    });
    __privateAdd(this, _onMessage, async (message) => {
      var _a;
      const data = JSON.parse(message.data.toString());
      if (true) {
        (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug({
          payload: data
        }, "received message from ws");
      }
      switch (data.type) {
        case "objectSetChanged":
          await __privateGet(this, _handleMessage_objectSetChanged).call(this, data);
          return;
        case "refreshObjectSet":
          __privateGet(this, _handleMessage_refreshObjectSet).call(this, data);
          return;
        case "subscribeResponses":
          __privateGet(this, _handleMessage_subscribeResponses).call(this, data);
          return;
        case "subscriptionClosed": {
          __privateMethod(this, _ObjectSetListenerWebsocket_instances, handleMessage_subscriptionClosed_fn).call(this, data);
          return;
        }
        default:
          true ? invariant(false, "Unexpected message type") : invariant(false);
      }
    });
    __privateAdd(this, _handleMessage_objectSetChanged, async (payload) => {
      var _a, _b, _c, _d, _e, _f;
      const sub = __privateGet(this, _subscriptions).get(payload.id);
      if (sub == null) return;
      const objectUpdates = payload.updates.filter((update) => update.type === "object");
      const referenceUpdates = payload.updates.filter((update) => update.type === "reference");
      const osdkObjectsWithReferenceUpdates = await Promise.all(referenceUpdates.map(async (o) => {
        const osdkObjectArray = await __privateGet(this, _client2).objectFactory2(__privateGet(this, _client2), [{
          __apiName: o.objectType,
          __primaryKey: sub.primaryKeyPropertyName != null ? o.primaryKey[sub.primaryKeyPropertyName] : void 0,
          ...o.primaryKey,
          [o.property]: o.value
        }], sub.interfaceApiName, {}, false, void 0, false, await __privateMethod(this, _ObjectSetListenerWebsocket_instances, fetchInterfaceMapping_fn).call(this, o.objectType, sub.interfaceApiName));
        const singleOsdkObject = osdkObjectArray[0] ?? void 0;
        return singleOsdkObject != null ? {
          object: singleOsdkObject,
          state: "ADDED_OR_UPDATED"
        } : void 0;
      }));
      for (const update of osdkObjectsWithReferenceUpdates) {
        if (update != null) {
          try {
            (_b = (_a = sub.listener).onChange) == null ? void 0 : _b.call(_a, update);
          } catch (error) {
            (_c = __privateGet(this, _logger2)) == null ? void 0 : _c.error(error, "Error in onChange callback");
            __privateGet(this, _tryCatchOnError).call(this, sub, false, error);
          }
        }
      }
      const osdkObjects = await Promise.all(objectUpdates.map(async (o) => {
        const keysToDelete = Object.keys(o.object).filter((key) => sub.requestedReferenceProperties.includes(key));
        for (const key of keysToDelete) {
          delete o.object[key];
        }
        const osdkObjectArray = await __privateGet(this, _client2).objectFactory2(__privateGet(this, _client2), [o.object], sub.interfaceApiName, {}, false, void 0, false, await __privateMethod(this, _ObjectSetListenerWebsocket_instances, fetchInterfaceMapping_fn).call(this, o.object.__apiName, sub.interfaceApiName));
        const singleOsdkObject = osdkObjectArray[0] ?? void 0;
        return singleOsdkObject != null ? {
          object: singleOsdkObject,
          state: o.state
        } : void 0;
      }));
      for (const osdkObject of osdkObjects) {
        if (osdkObject != null) {
          try {
            (_e = (_d = sub.listener).onChange) == null ? void 0 : _e.call(_d, osdkObject);
          } catch (error) {
            (_f = __privateGet(this, _logger2)) == null ? void 0 : _f.error(error, "Error in onChange callback");
            __privateGet(this, _tryCatchOnError).call(this, sub, false, error);
          }
        }
      }
    });
    __privateAdd(this, _handleMessage_refreshObjectSet, (payload) => {
      var _a;
      const sub = __privateGet(this, _subscriptions).get(payload.id);
      !sub ? true ? invariant(false, `Expected subscription id ${payload.id}`) : invariant(false) : void 0;
      try {
        sub.listener.onOutOfDate();
      } catch (error) {
        (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.error(error, "Error in onOutOfDate callback");
        __privateGet(this, _tryCatchOnError).call(this, sub, false, error);
      }
    });
    __privateAdd(this, _handleMessage_subscribeResponses, (payload) => {
      var _a, _b;
      const {
        id,
        responses
      } = payload;
      const subs = __privateGet(this, _pendingSubscriptions).get(id);
      !subs ? true ? invariant(false, `should have a pending subscription for ${id}`) : invariant(false) : void 0;
      __privateGet(this, _pendingSubscriptions).delete(id);
      for (let i = 0; i < responses.length; i++) {
        const sub = subs[i];
        const response = responses[i];
        switch (response.type) {
          case "error":
            __privateGet(this, _tryCatchOnError).call(this, sub, true, response.errors);
            __privateMethod(this, _ObjectSetListenerWebsocket_instances, unsubscribe_fn).call(this, sub, "error");
            break;
          case "qos":
            __privateGet(this, _cycleWebsocket).call(this);
            break;
          case "success":
            const shouldFireOutOfDate = sub.status === "expired" || sub.status === "reconnecting";
            if (true) {
              (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug({
                shouldFireOutOfDate
              }, "success");
            }
            sub.status = "subscribed";
            if (sub.subscriptionId !== response.id) {
              __privateGet(this, _subscriptions).delete(sub.subscriptionId);
              sub.subscriptionId = response.id;
              __privateGet(this, _subscriptions).set(sub.subscriptionId, sub);
            }
            try {
              if (shouldFireOutOfDate) sub.listener.onOutOfDate();
              else sub.listener.onSuccessfulSubscription();
            } catch (error) {
              (_b = __privateGet(this, _logger2)) == null ? void 0 : _b.error(error, "Error in onOutOfDate or onSuccessfulSubscription callback");
              __privateGet(this, _tryCatchOnError).call(this, sub, false, error);
            }
            break;
          default:
            __privateGet(this, _tryCatchOnError).call(this, sub, true, response);
        }
      }
    });
    __privateAdd(this, _onClose, (event) => {
      var _a;
      if (true) {
        (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug({
          event
        }, "Received close event from ws", event);
      }
      __privateGet(this, _cycleWebsocket).call(this);
    });
    __privateAdd(this, _cycleWebsocket, () => {
      if (__privateGet(this, _ws)) {
        __privateGet(this, _ws).removeEventListener("open", __privateGet(this, _onOpen));
        __privateGet(this, _ws).removeEventListener("message", __privateGet(this, _onMessage));
        __privateGet(this, _ws).removeEventListener("close", __privateGet(this, _onClose));
        if (__privateGet(this, _ws).readyState !== browser_default.CLOSING && __privateGet(this, _ws).readyState !== browser_default.CLOSED) {
          __privateGet(this, _ws).close();
        }
        __privateSet(this, _ws, void 0);
      }
      if (__privateGet(this, _subscriptions).size > 0) {
        if (true) {
          for (const s of __privateGet(this, _subscriptions).values()) {
            !(s.status !== "done" && s.status !== "error") ? true ? invariant(false, "should not have done/error subscriptions still") : invariant(false) : void 0;
          }
        }
        for (const s of __privateGet(this, _subscriptions).values()) {
          if (s.status === "subscribed") s.status = "reconnecting";
        }
        void __privateMethod(this, _ObjectSetListenerWebsocket_instances, ensureWebsocket_fn).call(this);
      }
    });
    __privateAdd(this, _tryCatchOnError, (sub, subscriptionClosed, error) => {
      var _a;
      try {
        sub.listener.onError({
          subscriptionClosed,
          error
        });
      } catch (onErrorError) {
        console.error(`Error encountered in an onError callback for an OSDK subscription`, onErrorError);
        console.error(`This onError call was triggered by an error in another callback`, error);
        console.error(`The subscription has been closed.`, error);
        if (!subscriptionClosed) {
          (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.error(error, "Error in onError callback");
          __privateMethod(this, _ObjectSetListenerWebsocket_instances, unsubscribe_fn).call(this, sub, "error");
          __privateGet(this, _tryCatchOnError).call(this, sub, true, onErrorError);
        }
      }
    });
    var _a;
    this.MINIMUM_RECONNECT_DELAY_MS = minimumReconnectDelayMs;
    __privateSet(this, _client2, client);
    __privateSet(this, _logger2, (_a = client.logger) == null ? void 0 : _a.child({}, {
      msgPrefix: "<OSW> "
    }));
    !(client.baseUrl.startsWith("https://") || client.baseUrl.startsWith("http://")) ? true ? invariant(false, "Stack must be a URL") : invariant(false) : void 0;
  }
  // FIXME
  static getInstance(client) {
    let instance = __privateGet(_ObjectSetListenerWebsocket, _instances).get(client.clientCacheKey);
    if (instance == null) {
      instance = new _ObjectSetListenerWebsocket(client);
      __privateGet(_ObjectSetListenerWebsocket, _instances).set(client.clientCacheKey, instance);
    }
    return instance;
  }
  async subscribe(objectType, objectSet, listener, properties = []) {
    const objOrInterfaceDef = objectType.type === "object" ? await __privateGet(this, _client2).ontologyProvider.getObjectDefinition(objectType.apiName) : await __privateGet(this, _client2).ontologyProvider.getInterfaceDefinition(objectType.apiName);
    let objectProperties = [];
    let referenceProperties = [];
    if (properties.length === 0) {
      properties = Object.keys(objOrInterfaceDef.properties);
    }
    objectProperties = properties.filter((p) => objOrInterfaceDef.properties[p].type !== "geotimeSeriesReference");
    referenceProperties = properties.filter((p) => objOrInterfaceDef.properties[p].type === "geotimeSeriesReference");
    const sub = {
      listener: fillOutListener(listener),
      objectSet,
      primaryKeyPropertyName: objOrInterfaceDef.type === "interface" ? void 0 : objOrInterfaceDef.primaryKeyApiName,
      requestedProperties: objectProperties,
      requestedReferenceProperties: referenceProperties,
      status: "preparing",
      // Since we don't have a real subscription id yet but we need to keep
      // track of this reference, we can just use a random uuid.
      subscriptionId: `TMP-${nextUuid()}}`,
      interfaceApiName: objOrInterfaceDef.type === "object" ? void 0 : objOrInterfaceDef.apiName
    };
    __privateGet(this, _subscriptions).set(sub.subscriptionId, sub);
    void __privateMethod(this, _ObjectSetListenerWebsocket_instances, initiateSubscribe_fn).call(this, sub);
    return () => {
      __privateMethod(this, _ObjectSetListenerWebsocket_instances, unsubscribe_fn).call(this, sub);
    };
  }
};
_instances = new WeakMap();
_ws = new WeakMap();
_lastWsConnect = new WeakMap();
_client2 = new WeakMap();
_logger2 = new WeakMap();
_pendingSubscriptions = new WeakMap();
_subscriptions = new WeakMap();
_endedSubscriptions = new WeakMap();
_maybeDisconnectTimeout = new WeakMap();
_ObjectSetListenerWebsocket_instances = new WeakSet();
initiateSubscribe_fn = async function(sub) {
  var _a, _b, _c;
  if (true) {
    (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug("#initiateSubscribe()");
  }
  try {
    await __privateMethod(this, _ObjectSetListenerWebsocket_instances, ensureWebsocket_fn).call(this);
    if (subscriptionIsDone(sub)) {
      return;
    }
    sub.isReady = true;
    if (((_b = __privateGet(this, _ws)) == null ? void 0 : _b.readyState) === browser_default.OPEN) {
      __privateMethod(this, _ObjectSetListenerWebsocket_instances, sendSubscribeMessage_fn).call(this);
    }
  } catch (error) {
    (_c = __privateGet(this, _logger2)) == null ? void 0 : _c.error(error, "Error in #initiateSubscribe");
    __privateGet(this, _tryCatchOnError).call(this, sub, true, error);
  }
};
sendSubscribeMessage_fn = function() {
  var _a, _b, _c;
  if (true) {
    (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug("#sendSubscribeMessage()");
  }
  const readySubs = [...__privateGet(this, _subscriptions).values()].filter(isReady);
  const id = nextUuid();
  __privateGet(this, _pendingSubscriptions).set(id, readySubs);
  const subscribe = {
    id,
    requests: readySubs.map(({
      objectSet,
      requestedProperties,
      requestedReferenceProperties,
      interfaceApiName
    }) => {
      return {
        objectSet,
        propertySet: requestedProperties,
        referenceSet: requestedReferenceProperties
      };
    })
  };
  if (true) {
    (_b = __privateGet(this, _logger2)) == null ? void 0 : _b.debug({
      payload: subscribe
    }, "sending subscribe message");
  }
  (_c = __privateGet(this, _ws)) == null ? void 0 : _c.send(JSON.stringify(subscribe));
};
unsubscribe_fn = function(sub, newStatus = "done") {
  if (subscriptionIsDone(sub)) {
    return;
  }
  sub.status = newStatus;
  sub.listener = fillOutListener({});
  __privateGet(this, _subscriptions).delete(sub.subscriptionId);
  __privateGet(this, _endedSubscriptions).add(sub.subscriptionId);
  __privateMethod(this, _ObjectSetListenerWebsocket_instances, sendSubscribeMessage_fn).call(this);
  if (__privateGet(this, _maybeDisconnectTimeout)) {
    clearTimeout(__privateGet(this, _maybeDisconnectTimeout));
  }
  __privateSet(this, _maybeDisconnectTimeout, setTimeout(
    () => {
      __privateSet(this, _maybeDisconnectTimeout, void 0);
      if (__privateGet(this, _subscriptions).size === 0) {
        __privateGet(this, _cycleWebsocket).call(this);
      }
    },
    15e3
    /* ms */
  ));
};
ensureWebsocket_fn = async function() {
  var _a;
  if (__privateGet(this, _ws) == null) {
    const {
      baseUrl,
      tokenProvider
    } = __privateGet(this, _client2);
    const url = constructWebsocketUrl(baseUrl, await __privateGet(this, _client2).ontologyRid);
    const token = await tokenProvider();
    if (__privateGet(this, _ws) == null) {
      const nextConnectTime = (__privateGet(this, _lastWsConnect) ?? 0) + this.MINIMUM_RECONNECT_DELAY_MS;
      if (nextConnectTime > Date.now()) {
        await new Promise((resolve) => {
          setTimeout(resolve, nextConnectTime - Date.now());
        });
      }
      __privateSet(this, _lastWsConnect, Date.now());
      if (__privateGet(this, _ws) == null) {
        if (true) {
          (_a = __privateGet(this, _logger2)) == null ? void 0 : _a.debug("Creating websocket");
        }
        __privateSet(this, _ws, new browser_default(url, [`Bearer-${token}`]));
        __privateGet(this, _ws).addEventListener("close", __privateGet(this, _onClose));
        __privateGet(this, _ws).addEventListener("message", __privateGet(this, _onMessage));
        __privateGet(this, _ws).addEventListener("open", __privateGet(this, _onOpen));
      }
    }
    if (__privateGet(this, _ws).readyState === browser_default.CONNECTING) {
      const ws2 = __privateGet(this, _ws);
      return new Promise((resolve, reject) => {
        function cleanup() {
          ws2.removeEventListener("open", open);
          ws2.removeEventListener("error", error);
          ws2.removeEventListener("close", cleanup);
        }
        function open() {
          cleanup();
          resolve();
        }
        function error(evt) {
          cleanup();
          reject(evt);
        }
        ws2.addEventListener("open", open);
        ws2.addEventListener("error", error);
        ws2.addEventListener("close", cleanup);
      });
    }
  }
};
_onOpen = new WeakMap();
_onMessage = new WeakMap();
_handleMessage_objectSetChanged = new WeakMap();
fetchInterfaceMapping_fn = async function(objectTypeApiName, interfaceApiName) {
  if (interfaceApiName == null) return {};
  const interfaceMap = (await __privateGet(this, _client2).ontologyProvider.getObjectDefinition(objectTypeApiName)).interfaceMap;
  return {
    [interfaceApiName]: {
      [objectTypeApiName]: interfaceMap[interfaceApiName]
    }
  };
};
_handleMessage_refreshObjectSet = new WeakMap();
_handleMessage_subscribeResponses = new WeakMap();
handleMessage_subscriptionClosed_fn = function(payload) {
  const sub = __privateGet(this, _subscriptions).get(payload.id);
  if (sub == null && __privateGet(this, _endedSubscriptions).has(payload.id)) return;
  !sub ? true ? invariant(false, `Expected subscription id ${payload.id}`) : invariant(false) : void 0;
  __privateGet(this, _tryCatchOnError).call(this, sub, true, payload.cause);
  __privateMethod(this, _ObjectSetListenerWebsocket_instances, unsubscribe_fn).call(this, sub, "error");
};
_onClose = new WeakMap();
_cycleWebsocket = new WeakMap();
_tryCatchOnError = new WeakMap();
__privateAdd(_ObjectSetListenerWebsocket, _instances, /* @__PURE__ */ new WeakMap());
var ObjectSetListenerWebsocket = _ObjectSetListenerWebsocket;
function constructWebsocketUrl(baseUrl, ontologyRid) {
  const base = new URL(baseUrl);
  const url = new URL(`api/v2/ontologySubscriptions/ontologies/${ontologyRid}/streamSubscriptions`, base);
  url.protocol = url.protocol.replace("https", "wss");
  return url;
}
var uuidCounter = 0;
function nextUuid() {
  return `00000000-0000-0000-0000-${(uuidCounter++).toString().padStart(12, "0")}`;
}

// node_modules/@osdk/client/build/browser/objectSet/createObjectSet.js
function isObjectTypeDefinition(def) {
  return def.type === "object";
}
function isObjectSet(o) {
  return o != null && typeof o === "object" && isWireObjectSet(objectSetDefinitions.get(o));
}
function getWireObjectSet(objectSet) {
  return objectSetDefinitions.get(objectSet);
}
var objectSetDefinitions = /* @__PURE__ */ new WeakMap();
function createObjectSet(objectType, clientCtx, objectSet = resolveBaseObjectSetType(objectType)) {
  const base = {
    aggregate: aggregate4.bind(globalThis, augmentRequestContext(clientCtx, () => ({
      finalMethodCall: "aggregate"
    })), objectType, objectSet),
    fetchPage: fetchPageInternal.bind(globalThis, augmentRequestContext(clientCtx, () => ({
      finalMethodCall: "fetchPage"
    })), objectType, objectSet),
    fetchPageWithErrors: fetchPageWithErrorsInternal.bind(globalThis, augmentRequestContext(clientCtx, () => ({
      finalMethodCall: "fetchPageWithErrors"
    })), objectType, objectSet),
    where: (clause) => {
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "filter",
        objectSet,
        where: modernToLegacyWhereClause(clause, objectType)
      });
    },
    pivotTo: function(type) {
      return createSearchAround(type)();
    },
    union: (...objectSets) => {
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "union",
        objectSets: [objectSet, ...objectSets.map((os) => objectSetDefinitions.get(os))]
      });
    },
    intersect: (...objectSets) => {
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "intersect",
        objectSets: [objectSet, ...objectSets.map((os) => objectSetDefinitions.get(os))]
      });
    },
    subtract: (...objectSets) => {
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "subtract",
        objectSets: [objectSet, ...objectSets.map((os) => objectSetDefinitions.get(os))]
      });
    },
    asyncIter: async function* (args) {
      let $nextPageToken = void 0;
      do {
        const result = await fetchPageInternal(augmentRequestContext(clientCtx, () => ({
          finalMethodCall: "asyncIter"
        })), objectType, objectSet, {
          ...args,
          $pageSize: 1e4,
          $nextPageToken
        });
        $nextPageToken = result.nextPageToken;
        for (const obj of result.data) {
          yield obj;
        }
      } while ($nextPageToken != null);
    },
    fetchOne: isObjectTypeDefinition(objectType) ? async (primaryKey, options) => {
      return await fetchSingle(augmentRequestContext(clientCtx, () => ({
        finalMethodCall: "fetchOne"
      })), objectType, options, await createWithPk(clientCtx, objectType, objectSet, primaryKey));
    } : void 0,
    fetchOneWithErrors: isObjectTypeDefinition(objectType) ? async (primaryKey, options) => {
      return await fetchSingleWithErrors(augmentRequestContext(clientCtx, () => ({
        finalMethodCall: "fetchOneWithErrors"
      })), objectType, options, await createWithPk(clientCtx, objectType, objectSet, primaryKey));
    } : void 0,
    subscribe: (listener, opts) => {
      const pendingSubscribe = ObjectSetListenerWebsocket.getInstance(clientCtx).subscribe(objectType, objectSet, listener, opts == null ? void 0 : opts.properties);
      return {
        unsubscribe: async () => (await pendingSubscribe)()
      };
    },
    withProperties: (clause) => {
      const definitionMap = /* @__PURE__ */ new Map();
      const derivedProperties = {};
      for (const key of Object.keys(clause)) {
        const derivedPropertyDefinition = clause[key](createWithPropertiesObjectSet(objectType, {
          type: "methodInput"
        }, definitionMap));
        derivedProperties[key] = definitionMap.get(derivedPropertyDefinition);
      }
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "withProperties",
        derivedProperties,
        objectSet
      });
    },
    $objectSetInternals: {
      def: objectType
    }
  };
  function createSearchAround(link) {
    return () => {
      return clientCtx.objectSetFactory(objectType, clientCtx, {
        type: "searchAround",
        objectSet,
        link
      });
    };
  }
  objectSetDefinitions.set(base, objectSet);
  return base;
}
async function createWithPk(clientCtx, objectType, objectSet, primaryKey) {
  const objDef = await clientCtx.ontologyProvider.getObjectDefinition(objectType.apiName);
  const withPk = {
    type: "filter",
    objectSet,
    where: {
      type: "eq",
      field: objDef.primaryKeyApiName,
      value: primaryKey
    }
  };
  return withPk;
}

// node_modules/@osdk/client/build/browser/util/interfaceUtils.js
function isInterfaceActionParam(o) {
  return o != null && typeof o === "object" && "$objectType" in o && "$primaryKey" in o;
}

// node_modules/@osdk/client/build/browser/util/isOntologyObjectV2.js
function isOntologyObjectV2(o) {
  return o && typeof o === "object" && typeof o.__apiName === "string" && o.__primaryKey != null;
}

// node_modules/@osdk/client/build/browser/util/isOsdkObject.js
function isOsdkBaseObject(o) {
  return o && typeof o === "object" && typeof o.$apiName === "string" && o.$primaryKey != null;
}

// node_modules/@osdk/client/build/browser/util/toDataValue.js
async function toDataValue(value, client) {
  if (value == null) {
    return value;
  }
  if (Array.isArray(value) || value instanceof Set) {
    const values = Array.from(value);
    if (values.some((dataValue) => isAttachmentUpload(dataValue) || isAttachmentFile(dataValue))) {
      const converted = [];
      for (const value2 of values) {
        converted.push(await toDataValue(value2, client));
      }
      return converted;
    }
    const promiseArray = Array.from(value, async (innerValue) => await toDataValue(innerValue, client));
    return Promise.all(promiseArray);
  }
  if (isAttachmentUpload(value)) {
    const attachment = await Attachment_exports.upload(client, value.data, {
      filename: value.name
    });
    return await toDataValue(attachment.rid, client);
  }
  if (isAttachmentFile(value)) {
    const attachment = await Attachment_exports.upload(client, value, {
      filename: value.name
    });
    return await toDataValue(attachment.rid, client);
  }
  if (isOntologyObjectV2(value)) {
    return await toDataValue(value.__primaryKey, client);
  }
  if (isOsdkBaseObject(value)) {
    return await toDataValue(value.$primaryKey, client);
  }
  if (isWireObjectSet(value)) {
    return value;
  }
  if (isObjectSet(value)) {
    return getWireObjectSet(value);
  }
  if (isMediaReference(value)) {
    return value;
  }
  if (isInterfaceActionParam(value)) {
    return {
      objectTypeApiName: value.$objectType,
      primaryKeyValue: value.$primaryKey
    };
  }
  if (typeof value === "object") {
    return Object.entries(value).reduce(async (promisedAcc, [key, structValue]) => {
      const acc = await promisedAcc;
      acc[key] = await toDataValue(structValue, client);
      return acc;
    }, Promise.resolve({}));
  }
  return value;
}

// node_modules/@osdk/client/build/browser/actions/applyAction.js
async function applyAction(client, action, parameters, options = {}) {
  var _a;
  const clientWithHeaders = addUserAgentAndRequestContextHeaders(augmentRequestContext(client, () => ({
    finalMethodCall: "applyAction"
  })), action);
  if (Array.isArray(parameters)) {
    const response = await Action_exports.applyBatch(clientWithHeaders, await client.ontologyRid, action.apiName, {
      requests: parameters ? await remapBatchActionParams(parameters, client) : [],
      options: {
        returnEdits: (options == null ? void 0 : options.$returnEdits) ? "ALL" : "NONE"
      }
    });
    const edits = response.edits;
    return (options == null ? void 0 : options.$returnEdits) ? (edits == null ? void 0 : edits.type) === "edits" ? remapActionResponse(response) : edits : void 0;
  } else {
    const response = await Action_exports.apply(clientWithHeaders, await client.ontologyRid, action.apiName, {
      parameters: await remapActionParams(parameters, client),
      options: {
        mode: (options == null ? void 0 : options.$validateOnly) ? "VALIDATE_ONLY" : "VALIDATE_AND_EXECUTE",
        returnEdits: (options == null ? void 0 : options.$returnEdits) ? "ALL_V2_WITH_DELETIONS" : "NONE"
      }
    });
    if (options == null ? void 0 : options.$validateOnly) {
      return response.validation;
    }
    if (((_a = response.validation) == null ? void 0 : _a.result) === "INVALID") {
      throw new ActionValidationError(response.validation);
    }
    const edits = response.edits;
    return (options == null ? void 0 : options.$returnEdits) ? (edits == null ? void 0 : edits.type) === "edits" ? remapActionResponse(response) : edits : void 0;
  }
}
async function remapActionParams(params, client) {
  if (params == null) {
    return {};
  }
  const parameterMap = {};
  for (const [key, value] of Object.entries(params)) {
    parameterMap[key] = await toDataValue(value, client);
  }
  return parameterMap;
}
async function remapBatchActionParams(params, client) {
  const remappedParams = await Promise.all(params.map(async (param) => {
    return {
      parameters: await remapActionParams(param, client)
    };
  }));
  return remappedParams;
}
function remapActionResponse(response) {
  var _a, _b;
  const editResponses = response == null ? void 0 : response.edits;
  if ((editResponses == null ? void 0 : editResponses.type) === "edits") {
    const remappedActionResponse = {
      type: editResponses.type,
      deletedLinksCount: editResponses.deletedLinksCount,
      deletedObjectsCount: editResponses.deletedObjectsCount,
      addedLinks: [],
      deletedLinks: [],
      addedObjects: [],
      deletedObjects: [],
      modifiedObjects: [],
      editedObjectTypes: []
    };
    const editedObjectTypesSet = /* @__PURE__ */ new Set();
    for (const edit of editResponses.edits) {
      if (edit.type === "addLink" || edit.type === "deleteLink") {
        const osdkEdit = {
          linkTypeApiNameAtoB: edit.linkTypeApiNameAtoB,
          linkTypeApiNameBtoA: edit.linkTypeApiNameBtoA,
          aSideObject: edit.aSideObject,
          bSideObject: edit.bSideObject
        };
        edit.type === "addLink" ? remappedActionResponse.addedLinks.push(osdkEdit) : (_a = remappedActionResponse.deletedLinks) == null ? void 0 : _a.push(osdkEdit);
        editedObjectTypesSet.add(edit.aSideObject.objectType);
        editedObjectTypesSet.add(edit.bSideObject.objectType);
      } else if (edit.type === "addObject" || edit.type === "deleteObject" || edit.type === "modifyObject") {
        const osdkEdit = {
          objectType: edit.objectType,
          primaryKey: edit.primaryKey
        };
        if (edit.type === "addObject") {
          remappedActionResponse.addedObjects.push(osdkEdit);
        } else if (edit.type === "deleteObject") {
          (_b = remappedActionResponse.deletedObjects) == null ? void 0 : _b.push(osdkEdit);
        } else if (edit.type === "modifyObject") {
          remappedActionResponse.modifiedObjects.push(osdkEdit);
        }
        editedObjectTypesSet.add(edit.objectType);
      } else {
        if (true) {
          console.warn(`Unexpected edit type: ${JSON.stringify(edit)}`);
        }
      }
    }
    remappedActionResponse.editedObjectTypes = [...editedObjectTypesSet];
    return remappedActionResponse;
  }
}

// node_modules/@osdk/client/build/browser/Client.js
var additionalContext = Symbol("additionalContext");
var ErrorMessage = Symbol("ErrorMessage");

// node_modules/@osdk/shared.client.impl/build/browser/createSharedClientContext.js
function createSharedClientContext(baseUrl, tokenProvider, userAgent, fetchFn = fetch) {
  if (baseUrl.length === 0) {
    throw new Error("baseUrl cannot be empty");
  }
  const retryingFetchWithAuthOrThrow = createFetchHeaderMutator(createRetryingFetch(createFetchOrThrow(fetchFn)), async (headers) => {
    const token = await tokenProvider();
    headers.set("Authorization", `Bearer ${token}`);
    headers.set("Fetch-User-Agent", [headers.get("Fetch-User-Agent"), userAgent].filter((x) => x && (x == null ? void 0 : x.length) > 0).join(" "));
    return headers;
  });
  return {
    baseUrl,
    fetch: async (input, init) => {
      try {
        return await retryingFetchWithAuthOrThrow(input, init);
      } catch (e) {
        const betterError = e instanceof PalantirApiError ? new PalantirApiError(e.message, e.errorName, e.errorCode, e.statusCode, e.errorInstanceId, e.parameters) : new Error("Captured stack trace for error: " + (e.message ?? e));
        betterError.cause = e;
        throw betterError;
      }
    },
    tokenProvider
  };
}

// node_modules/@osdk/client/build/browser/util/streamutils.js
var START_TOKEN = new Uint8Array([123, 34, 100, 97, 116, 97, 34, 58, 91]);
var OBJECT_OPEN_CHAR_CODE = 123;
var OBJECT_CLOSE_CHAR_CODE = 125;
async function* parseStreamedResponse(asyncIterable) {
  const utf8decoder = new TextDecoder("utf-8");
  let parsedStart = false;
  let prevChunks = [];
  let openBracesCount = 0;
  for await (let chunk of asyncIterable) {
    let i = 0;
    if (!parsedStart) {
      parsedStart = true;
      if (startsWith(chunk, START_TOKEN)) {
        i = START_TOKEN.length;
      }
    }
    for (; i < chunk.length; i++) {
      while (openBracesCount === 0 && chunk[i] !== OBJECT_OPEN_CHAR_CODE && i < chunk.length) {
        i++;
      }
      let j = i;
      for (; j < chunk.length; j++) {
        const c = chunk[j];
        if (c === OBJECT_OPEN_CHAR_CODE) {
          openBracesCount++;
        } else if (c === OBJECT_CLOSE_CHAR_CODE) {
          openBracesCount--;
          if (0 === openBracesCount) {
            yield combineAndParse(utf8decoder, prevChunks, chunk.subarray(i, j + 1));
            prevChunks = [];
            i = j;
            break;
          }
        }
      }
      if (j === chunk.length) {
        prevChunks.push(chunk.subarray(i));
        break;
      }
    }
  }
}
function startsWith(a, b) {
  if (a.length < b.length) {
    return false;
  }
  for (let i = 0; i < b.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function combineAndParse(utf8decoder, prev, curr) {
  let str = "";
  for (const chunk of prev) {
    str += utf8decoder.decode(chunk, {
      stream: true
    });
  }
  str += utf8decoder.decode(curr);
  return JSON.parse(str);
}
async function* iterateReadableStream(readableStream) {
  let res = await readableStream.read();
  while (!res.done) {
    yield res.value;
    res = await readableStream.read();
  }
}

// node_modules/@osdk/client/build/browser/util/timeseriesUtils.js
function getTimeRange(body) {
  if ("$startTime" in body || "$endTime" in body) {
    return {
      type: "absolute",
      startTime: body.$startTime,
      endTime: body.$endTime
    };
  }
  return body.$before ? {
    type: "relative",
    startTime: {
      when: "BEFORE",
      value: body.$before,
      unit: TimeseriesDurationMapping[body.$unit]
    }
  } : {
    type: "relative",
    endTime: {
      when: "AFTER",
      value: body.$after,
      unit: TimeseriesDurationMapping[body.$unit]
    }
  };
}
async function* asyncIterPointsHelper(iterator) {
  var _a;
  const reader = (_a = iterator.body) == null ? void 0 : _a.getReader();
  for await (const point of parseStreamedResponse(iterateReadableStream(reader))) {
    yield {
      time: point.time,
      value: point.value
    };
  }
}

// node_modules/@osdk/client/build/browser/createGeotimeSeriesProperty.js
var _triplet, _client3;
var GeotimeSeriesPropertyImpl = class {
  constructor(client, objectApiName, primaryKey, propertyName, initialValue) {
    __privateAdd(this, _triplet);
    __privateAdd(this, _client3);
    __privateSet(this, _client3, client);
    __privateSet(this, _triplet, [objectApiName, primaryKey, propertyName]);
    if (initialValue != null) {
      this.lastFetchedValue = initialValue;
    }
  }
  async getLatestValue() {
    const latestPointPromise = TimeSeriesValueBankProperty_exports.getLatestValue(__privateGet(this, _client3), await __privateGet(this, _client3).ontologyRid, ...__privateGet(this, _triplet));
    latestPointPromise.then(
      (latestPoint) => this.lastFetchedValue = latestPoint,
      // eslint-disable-next-line no-console
      (err) => void console.error(err)
    );
    return latestPointPromise;
  }
  async getAllValues(query) {
    const allPoints = [];
    for await (const point of this.asyncIterValues(query)) {
      allPoints.push(point);
    }
    return allPoints;
  }
  async *asyncIterValues(query) {
    const streamPointsIterator = await TimeSeriesValueBankProperty_exports.streamValues(__privateGet(this, _client3), await __privateGet(this, _client3).ontologyRid, ...__privateGet(this, _triplet), query ? {
      range: getTimeRange(query)
    } : {});
    for await (const timeseriesPoint of asyncIterPointsHelper(streamPointsIterator)) {
      yield timeseriesPoint;
    }
  }
};
_triplet = new WeakMap();
_client3 = new WeakMap();

// node_modules/@osdk/client/build/browser/createMediaReferenceProperty.js
var _triplet2, _client4;
var MediaReferencePropertyImpl = class {
  constructor(args) {
    __privateAdd(this, _triplet2);
    __privateAdd(this, _client4);
    const {
      client,
      objectApiName,
      primaryKey,
      propertyName
    } = args;
    __privateSet(this, _client4, client);
    __privateSet(this, _triplet2, [objectApiName, primaryKey, propertyName]);
  }
  async fetchContents() {
    return MediaReferenceProperty_exports.getMediaContent(__privateGet(this, _client4), await __privateGet(this, _client4).ontologyRid, ...__privateGet(this, _triplet2), {
      preview: true
      // TODO: Can turn this back off when backend is no longer in beta.
    });
  }
  async fetchMetadata() {
    const r = await MediaReferenceProperty_exports.getMediaMetadata(__privateGet(this, _client4), await __privateGet(this, _client4).ontologyRid, ...__privateGet(this, _triplet2), {
      preview: true
      // TODO: Can turn this back off when backend is no longer in beta.
    });
    return {
      path: r.path,
      sizeBytes: Number(r.sizeBytes),
      mediaType: r.mediaType
    };
  }
};
_triplet2 = new WeakMap();
_client4 = new WeakMap();

// node_modules/@osdk/client/build/browser/createTimeseriesProperty.js
var _triplet3, _client5;
var TimeSeriesPropertyImpl = class {
  constructor(client, objectApiName, primaryKey, propertyName) {
    __privateAdd(this, _triplet3);
    __privateAdd(this, _client5);
    __privateSet(this, _client5, client);
    __privateSet(this, _triplet3, [objectApiName, primaryKey, propertyName]);
  }
  async getFirstPoint() {
    return TimeSeriesPropertyV2_exports.getFirstPoint(__privateGet(this, _client5), await __privateGet(this, _client5).ontologyRid, ...__privateGet(this, _triplet3));
  }
  async getLastPoint() {
    return TimeSeriesPropertyV2_exports.getLastPoint(__privateGet(this, _client5), await __privateGet(this, _client5).ontologyRid, ...__privateGet(this, _triplet3));
  }
  async getAllPoints(query) {
    const allPoints = [];
    for await (const point of this.asyncIterPoints(query)) {
      allPoints.push(point);
    }
    return allPoints;
  }
  async *asyncIterPoints(query) {
    const streamPointsIterator = await TimeSeriesPropertyV2_exports.streamPoints(__privateGet(this, _client5), await __privateGet(this, _client5).ontologyRid, ...__privateGet(this, _triplet3), query ? {
      range: getTimeRange(query)
    } : {});
    for await (const timeseriesPoint of asyncIterPointsHelper(streamPointsIterator)) {
      yield timeseriesPoint;
    }
  }
};
_triplet3 = new WeakMap();
_client5 = new WeakMap();

// node_modules/@osdk/client/build/browser/public-utils/hydrateAttachmentFromRid.js
function hydrateAttachmentFromRidInternal(client, rid) {
  return {
    rid,
    async fetchContents() {
      return Attachment_exports.read(client, rid);
    },
    async fetchMetadata() {
      const r = await Attachment_exports.get(client, rid);
      return {
        ...r,
        sizeBytes: Number(r.sizeBytes)
      };
    }
  };
}

// node_modules/@osdk/client/build/browser/util/objectSpecifierUtils.js
function createObjectSpecifierFromPrimaryKey(objectDef, primaryKey) {
  return `${objectDef.apiName}:${primaryKey}`;
}
function extractPrimaryKeyFromObjectSpecifier(ObjectSpecifier) {
  return ObjectSpecifier.split(":")[1];
}

// node_modules/@osdk/client/build/browser/ontology/OntologyProvider.js
var InterfaceDefinitions = Symbol("InterfaceDefinitions");

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects/InternalSymbols.js
var UnderlyingOsdkObject = Symbol("Underlying Object");
var ObjectDefRef = Symbol("ObjectDefinition");
var InterfaceDefRef = Symbol("InterfaceDefinition");
var ClientRef = Symbol("ClientRef");

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects/createOsdkInterface.js
function createOsdkInterface(underlying, interfaceDef) {
  const [objApiNamespace] = extractNamespace(interfaceDef.apiName);
  return Object.freeze(Object.defineProperties({}, {
    // first to minimize hidden classes
    [UnderlyingOsdkObject]: {
      value: underlying
    },
    "$apiName": {
      value: interfaceDef.apiName,
      enumerable: true
    },
    "$as": {
      value: underlying.$as,
      enumerable: false
    },
    "$objectType": {
      value: underlying.$objectType,
      enumerable: "$objectType" in underlying
    },
    "$primaryKey": {
      value: underlying.$primaryKey,
      enumerable: "$primaryKey" in underlying
    },
    "$objectSpecifier": {
      value: underlying.$objectSpecifier,
      enumerable: "$objectSpecifier" in underlying
    },
    "$title": {
      value: underlying.$title,
      enumerable: "$title" in underlying
    },
    "$rid": {
      value: underlying.$rid,
      enumerable: "$rid" in underlying
    },
    "$clone": {
      value: clone,
      enumerable: false
    },
    [InterfaceDefRef]: {
      value: interfaceDef
    },
    ...Object.fromEntries(Object.keys(interfaceDef.properties).map((p) => {
      const objDef = underlying[ObjectDefRef];
      const [apiNamespace, apiName] = extractNamespace(p);
      const targetPropName = objDef.interfaceMap[interfaceDef.apiName][p];
      return [apiNamespace === objApiNamespace ? apiName : p, {
        enumerable: targetPropName in underlying,
        value: underlying[targetPropName]
      }];
    }))
  }));
  function clone(update) {
    if (update == null) {
      return underlying.$clone().$as(interfaceDef);
    }
    for (const key of Object.keys(update)) {
      if (!(key in interfaceDef.properties)) {
        throw new Error(`Invalid property ${key} for interface ${interfaceDef.apiName}`);
      }
    }
    const remappedProps = Object.fromEntries(Object.keys(update).map((p) => mapProperty(p, update[p])).filter((x) => x != null));
    return underlying.$clone(remappedProps).$as(interfaceDef);
  }
  function mapProperty(propertyName, value) {
    const objDef = underlying[ObjectDefRef];
    const targetPropName = objDef.interfaceMap[interfaceDef.apiName][propertyName];
    if (targetPropName == null) {
      throw new Error(`Cannot clone interface with ${propertyName} as property is not implemented by the underlying object type ${objDef.apiName}`);
    }
    return [targetPropName, value];
  }
}

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects/getDollarAs.js
var get$as = createSimpleCache(/* @__PURE__ */ new WeakMap(), $asFactory).get;
var osdkObjectToInterfaceView = createSimpleCache(/* @__PURE__ */ new WeakMap(), () => /* @__PURE__ */ new Map());
function $asFactory(objDef) {
  return function(targetMinDef) {
    var _a, _b;
    let targetInterfaceApiName;
    if (typeof targetMinDef === "string") {
      if (targetMinDef === objDef.apiName) {
        return this[UnderlyingOsdkObject];
      }
      if (((_a = objDef.interfaceMap) == null ? void 0 : _a[targetMinDef]) == null) {
        throw new Error(`Object does not implement interface '${targetMinDef}'.`);
      }
      targetInterfaceApiName = targetMinDef;
    } else if (targetMinDef.apiName === objDef.apiName) {
      return this[UnderlyingOsdkObject];
    } else {
      if (targetMinDef.type === "object") {
        throw new Error(`'${targetMinDef.apiName}' is not an interface nor is it '${objDef.apiName}', which is the object type.`);
      }
      targetInterfaceApiName = targetMinDef.apiName;
    }
    const def = objDef[InterfaceDefinitions][targetInterfaceApiName];
    if (!def) {
      throw new Error(`Object does not implement interface '${targetInterfaceApiName}'.`);
    }
    const underlying = this[UnderlyingOsdkObject];
    const existing = (_b = osdkObjectToInterfaceView.get(underlying).get(targetInterfaceApiName)) == null ? void 0 : _b.deref();
    if (existing) return existing;
    const osdkInterface = createOsdkInterface(underlying, def.def);
    osdkObjectToInterfaceView.get(underlying).set(targetInterfaceApiName, new WeakRef(osdkInterface));
    return osdkInterface;
  };
}

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects/getDollarLink.js
function get$link(holder) {
  const client = holder[ClientRef];
  const objDef = holder[ObjectDefRef];
  const rawObj = holder[UnderlyingOsdkObject];
  return Object.freeze(Object.fromEntries(Object.keys(objDef.links).map((linkName) => {
    const linkDef = objDef.links[linkName];
    const objectSet = client.objectSetFactory(objDef, client).where({
      [objDef.primaryKeyApiName]: rawObj.$primaryKey
    }).pivotTo(linkName);
    const value = !linkDef.multiplicity ? {
      fetchOne: (options) => fetchSingle(client, objDef, options ?? {}, getWireObjectSet(objectSet)),
      fetchOneWithErrors: (options) => fetchSingleWithErrors(client, objDef, options ?? {}, getWireObjectSet(objectSet))
    } : objectSet;
    return [linkName, value];
  })));
}

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects/createOsdkObject.js
var specialPropertyTypes = /* @__PURE__ */ new Set(["attachment", "geotimeSeriesReference", "mediaReference", "numericTimeseries", "stringTimeseries", "sensorTimeseries"]);
var basePropDefs = {
  "$as": {
    get: function() {
      return get$as(this[ObjectDefRef]);
    }
  },
  "$link": {
    get: function() {
      return get$link(this);
    }
  },
  "$clone": {
    value: function(update) {
      const rawObj = this[UnderlyingOsdkObject];
      const def = this[ObjectDefRef];
      if (update == null) {
        return createOsdkObject(this[ClientRef], def, {
          ...rawObj
        });
      }
      if (def.primaryKeyApiName in update && rawObj[def.primaryKeyApiName] !== update[def.primaryKeyApiName]) {
        throw new Error(`Cannot update ${def.apiName} object with differing primary key values `);
      }
      if (def.titleProperty in update && !("$title" in update)) {
        update.$title = update[def.titleProperty];
      }
      const newObject = {
        ...this[UnderlyingOsdkObject],
        ...update
      };
      return createOsdkObject(this[ClientRef], this[ObjectDefRef], newObject);
    }
  },
  "$objectSpecifier": {
    get: function() {
      const rawObj = this[UnderlyingOsdkObject];
      return createObjectSpecifierFromPrimaryKey(this[ObjectDefRef], rawObj.$primaryKey);
    },
    enumerable: true
  }
};
function createOsdkObject(client, objectDef, simpleOsdkProperties, derivedPropertyTypeByName = {}) {
  const rawObj = simpleOsdkProperties;
  Object.defineProperties(rawObj, {
    [UnderlyingOsdkObject]: {
      enumerable: false,
      value: simpleOsdkProperties
    },
    [ObjectDefRef]: {
      value: objectDef,
      enumerable: false
    },
    [ClientRef]: {
      value: client,
      enumerable: false
    },
    ...basePropDefs
  });
  for (const propKey of Object.keys(rawObj)) {
    if (propKey in objectDef.properties && typeof objectDef.properties[propKey].type === "string" && specialPropertyTypes.has(objectDef.properties[propKey].type)) {
      rawObj[propKey] = createSpecialProperty(client, objectDef, rawObj, propKey);
    } else if (propKey in derivedPropertyTypeByName && typeof derivedPropertyTypeByName[propKey].type === "string" && specialPropertyTypes.has(derivedPropertyTypeByName[propKey].type)) {
      const rawValue = rawObj[propKey];
      if (derivedPropertyTypeByName[propKey].type === "attachment") {
        if (Array.isArray(rawValue)) {
          rawObj[propKey] = rawValue.map((a) => hydrateAttachmentFromRidInternal(client, a.rid));
        } else {
          rawObj[propKey] = hydrateAttachmentFromRidInternal(client, rawValue.rid);
        }
      } else {
        true ? invariant(false, "Derived property aggregations for Timeseries and Media are not supported") : invariant(false);
      }
    }
  }
  return Object.freeze(rawObj);
}
function createSpecialProperty(client, objectDef, rawObject, p) {
  const rawValue = rawObject[p];
  const propDef = objectDef.properties[p];
  if (true) {
    !(propDef != null && typeof propDef.type === "string" && specialPropertyTypes.has(propDef.type)) ? true ? invariant(false) : invariant(false) : void 0;
  }
  if (propDef.type === "attachment") {
    if (Array.isArray(rawValue)) {
      return rawValue.map((a) => hydrateAttachmentFromRidInternal(client, a.rid));
    }
    return hydrateAttachmentFromRidInternal(client, rawValue.rid);
  }
  if (propDef.type === "numericTimeseries" || propDef.type === "stringTimeseries" || propDef.type === "sensorTimeseries") {
    return new TimeSeriesPropertyImpl(client, objectDef.apiName, rawObject[objectDef.primaryKeyApiName], p);
  }
  if (propDef.type === "geotimeSeriesReference") {
    return new GeotimeSeriesPropertyImpl(client, objectDef.apiName, rawObject[objectDef.primaryKeyApiName], p, rawValue.type === "geotimeSeriesValue" ? {
      time: rawValue.timestamp,
      value: {
        type: "Point",
        coordinates: rawValue.position
      }
    } : void 0);
  }
  if (propDef.type === "mediaReference") {
    return new MediaReferencePropertyImpl({
      client,
      objectApiName: objectDef.apiName,
      primaryKey: rawObject[objectDef.primaryKeyApiName],
      propertyName: p
    });
  }
}

// node_modules/@osdk/client/build/browser/object/convertWireToOsdkObjects.js
async function convertWireToOsdkObjects(client, objects, interfaceApiName, forceRemoveRid = false, derivedPropertyTypesByName, selectedProps, strictNonNull = false) {
  fixObjectPropertiesInPlace(objects, forceRemoveRid);
  const ifaceDef = interfaceApiName ? await client.ontologyProvider.getInterfaceDefinition(interfaceApiName) : void 0;
  const ifaceSelected = ifaceDef ? selectedProps ?? Object.keys(ifaceDef.properties) : void 0;
  const ret = [];
  for (const rawObj of objects) {
    const objectDef = await client.ontologyProvider.getObjectDefinition(rawObj.$apiName);
    !objectDef ? true ? invariant(false, `Missing definition for '${rawObj.$apiName}'`) : invariant(false) : void 0;
    let objProps;
    let conforming = true;
    if (ifaceDef && ifaceSelected) {
      invariantInterfacesAsViews(objectDef, ifaceDef.apiName, client);
      conforming && (conforming = isConforming(client, ifaceDef, rawObj, ifaceSelected));
      reframeAsObjectInPlace(objectDef, ifaceDef.apiName, rawObj);
      objProps = convertInterfacePropNamesToObjectPropNames(objectDef, ifaceDef.apiName, ifaceSelected);
    } else {
      objProps = selectedProps ?? Object.keys(objectDef.properties);
    }
    conforming && (conforming = isConforming(client, objectDef, rawObj, objProps));
    if (strictNonNull === "throw" && !conforming) {
      throw new Error("Unable to safely convert objects as some non nullable properties are null");
    } else if (strictNonNull === "drop" && !conforming) {
      continue;
    }
    let osdkObject = createOsdkObject(client, objectDef, rawObj, derivedPropertyTypesByName);
    if (interfaceApiName) osdkObject = osdkObject.$as(interfaceApiName);
    ret.push(osdkObject);
  }
  return ret;
}
async function convertWireToOsdkObjects2(client, objects, interfaceApiName, derivedPropertyTypeByName, forceRemoveRid = false, selectedProps, strictNonNull = false, interfaceToObjectTypeMappings = {}) {
  fixObjectPropertiesInPlace(objects, forceRemoveRid);
  const ret = [];
  for (const rawObj of objects) {
    const objectDef = await client.ontologyProvider.getObjectDefinition(rawObj.$apiName);
    !objectDef ? true ? invariant(false, `Missing definition for '${rawObj.$apiName}'`) : invariant(false) : void 0;
    const interfaceToObjMapping = interfaceApiName ? interfaceToObjectTypeMappings[interfaceApiName][rawObj.$apiName] : void 0;
    const ifaceSelected = interfaceApiName && interfaceToObjMapping ? selectedProps ? Object.keys(interfaceToObjMapping).filter((val) => {
      selectedProps == null ? void 0 : selectedProps.includes(interfaceToObjMapping[val]);
    }) : [...Object.values(interfaceToObjMapping), objectDef.primaryKeyApiName] : void 0;
    let objProps;
    let conforming = true;
    if (interfaceApiName && ifaceSelected) {
      invariantInterfacesAsViews(objectDef, interfaceApiName, client);
      objProps = ifaceSelected;
    } else {
      objProps = selectedProps ?? Object.keys(objectDef.properties);
    }
    conforming && (conforming = isConforming(client, objectDef, rawObj, objProps));
    if (strictNonNull === "throw" && !conforming) {
      throw new Error("Unable to safely convert objects as some non nullable properties are null");
    } else if (strictNonNull === "drop" && !conforming) {
      continue;
    }
    let osdkObject = createOsdkObject(client, objectDef, rawObj, derivedPropertyTypeByName);
    if (interfaceApiName) osdkObject = osdkObject.$as(interfaceApiName);
    ret.push(osdkObject);
  }
  return ret;
}
function convertInterfacePropNamesToObjectPropNames(objectDef, interfaceApiName, ifacePropsToMap) {
  return ifacePropsToMap.map((ifaceProp) => objectDef.interfaceMap[interfaceApiName][ifaceProp]);
}
function reframeAsObjectInPlace(objectDef, interfaceApiName, rawObj) {
  const newProps = {};
  for (const [sptProp, regularProp] of Object.entries(objectDef.interfaceMap[interfaceApiName])) {
    if (sptProp in rawObj) {
      const value = rawObj[sptProp];
      delete rawObj[sptProp];
      if (value !== void 0) {
        newProps[regularProp] = value;
      }
    }
  }
  Object.assign(rawObj, newProps);
  if (!(objectDef.primaryKeyApiName in rawObj)) {
    rawObj[objectDef.primaryKeyApiName] = rawObj.$primaryKey;
  }
}
function isConforming(client, def, obj, propsToCheck) {
  var _a;
  for (const propName of propsToCheck) {
    if (propName in def.properties && def.properties[propName].nullable === false && obj[propName] == null) {
      if (true) {
        (_a = client.logger) == null ? void 0 : _a.debug({
          obj: {
            $apiName: obj["$apiName"],
            $objectType: obj["$objectType"],
            $primaryKey: obj["$primaryKey"]
          }
        }, `Found object that does not conform to its definition. Expected ${def.apiName}'s ${propName} to not be null.`);
      }
      return false;
    }
  }
  return true;
}
function invariantInterfacesAsViews(objectDef, interfaceApiName, client) {
  var _a;
  if (((_a = objectDef.interfaceMap) == null ? void 0 : _a[interfaceApiName]) == null) {
    const warning = "Interfaces are only supported 'as views' but your metadata object is missing the correct information. This suggests your interfaces have not been migrated to the newer version yet and you cannot use this version of the SDK.";
    if (client.logger) {
      client.logger.warn(warning);
    } else {
      console.error(`WARNING! ${warning}`);
    }
    throw new Error(warning);
  }
}
function fixObjectPropertiesInPlace(objs, forceRemoveRid) {
  for (const obj of objs) {
    if (forceRemoveRid) {
      delete obj.__rid;
    }
    if (obj.__rid) {
      obj.$rid = obj.__rid;
      delete obj.__rid;
    }
    obj.$apiName ?? (obj.$apiName = obj.__apiName);
    obj.$objectType = obj.$apiName;
    obj.$primaryKey ?? (obj.$primaryKey = obj.__primaryKey);
    obj.$title ?? (obj.$title = obj.__title);
    delete obj.__apiName;
    delete obj.__primaryKey;
    delete obj.__title;
  }
}

// node_modules/@osdk/client/build/browser/object/Cache.js
function createClientCache(fn) {
  const cache = /* @__PURE__ */ new WeakMap();
  function set(client, key, value) {
    if (cache.get(client.clientCacheKey) == null) {
      cache.set(client.clientCacheKey, /* @__PURE__ */ new Map());
    }
    cache.get(client.clientCacheKey).set(key, value);
    return value;
  }
  return {
    get: function(client, key) {
      if (cache.get(client.clientCacheKey) == null) {
        cache.set(client.clientCacheKey, /* @__PURE__ */ new Map());
      }
      let r = cache.get(client.clientCacheKey).get(key);
      if (r === void 0 && fn !== void 0) {
        return set(client, key, fn(client, key));
      } else {
        return r;
      }
    },
    set,
    remove: function(client, key) {
      if (cache.get(client.clientCacheKey) == null) return false;
      return cache.get(client.clientCacheKey).delete(key);
    }
  };
}
function createAsyncClientCache(fn, createCacheLocal = createClientCache) {
  const cache = createCacheLocal();
  const inProgress = createCacheLocal();
  const ret = {
    getOrUndefined: function(client, key) {
      return cache.get(client, key);
    },
    get: async function(client, key) {
      return cache.get(client, key) ?? inProgress.get(client, key) ?? ret.set(client, key, fn(client, key));
    },
    set: async function(client, k, v) {
      try {
        const r = await inProgress.set(client, k, v);
        cache.set(client, k, r);
        inProgress.remove(client, k);
        return r;
      } catch (e) {
        inProgress.remove(client, k);
        throw e;
      }
    }
  };
  return ret;
}

// node_modules/@osdk/generator-converters/build/browser/wirePropertyV2ToSdkPropertyDefinition.js
function wirePropertyV2ToSdkPropertyDefinition(input, isNullable = true, log) {
  const sdkPropDefinition = objectPropertyTypeToSdkPropertyDefinition(input.dataType, log);
  if (sdkPropDefinition == null) {
    return void 0;
  }
  switch (input.dataType.type) {
    case "integer":
    case "string":
    case "byte":
    case "decimal":
    case "double":
    case "float":
    case "long":
    case "short":
    case "boolean":
    case "date":
    case "attachment":
    case "mediaReference":
    case "geopoint":
    case "geoshape":
    case "timestamp":
    case "timeseries":
    case "marking":
    case "geotimeSeriesReference":
    case "struct":
      return {
        displayName: input.displayName,
        multiplicity: false,
        description: input.description,
        type: sdkPropDefinition,
        nullable: input.nullable == null ? isNullable : input.nullable
      };
    case "array": {
      return {
        displayName: input.displayName,
        multiplicity: true,
        description: input.description,
        type: sdkPropDefinition,
        nullable: true
      };
    }
    case "cipherText":
    case "vector": {
      log == null ? void 0 : log.info(`${JSON.stringify(input.dataType.type)} is not a supported dataType`);
      return void 0;
    }
    default:
      input.dataType;
      log == null ? void 0 : log.info(`${JSON.stringify(input.dataType)} is not a supported dataType`);
      return void 0;
  }
}
function objectPropertyTypeToSdkPropertyDefinition(propertyType, log) {
  var _a, _b;
  switch (propertyType.type) {
    case "integer":
    case "string":
    case "byte":
    case "decimal":
    case "double":
    case "float":
    case "long":
    case "short":
    case "boolean":
    case "attachment":
    case "geopoint":
    case "geoshape":
    case "timestamp":
    case "marking":
    case "geotimeSeriesReference":
    case "mediaReference":
      return propertyType.type;
    case "date":
      return "datetime";
    case "array":
      return objectPropertyTypeToSdkPropertyDefinition(propertyType.subType);
    case "timeseries":
      if (((_a = propertyType.itemType) == null ? void 0 : _a.type) === "string") {
        return "stringTimeseries";
      } else if (((_b = propertyType.itemType) == null ? void 0 : _b.type) === "double") {
        return "numericTimeseries";
      } else return "sensorTimeseries";
    case "struct": {
      return propertyType.structFieldTypes.reduce((structMap, structField) => {
        structMap[structField.apiName] = objectPropertyTypeToSdkPropertyDefinition(structField.dataType);
        return structMap;
      }, {});
    }
    case "cipherText":
    case "vector": {
      log == null ? void 0 : log.info(`${JSON.stringify(propertyType.type)} is not a supported propertyType`);
      return void 0;
    }
    default: {
      log == null ? void 0 : log.info(`${JSON.stringify(propertyType)} is not a supported propertyType`);
      return void 0;
    }
  }
}

// node_modules/@osdk/generator-converters/build/browser/__UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition.js
function __UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition(interfaceType, v2, log) {
  return {
    type: "interface",
    rid: interfaceType.rid,
    apiName: interfaceType.apiName,
    displayName: interfaceType.displayName,
    description: interfaceType.description,
    implements: interfaceType.allExtendsInterfaces ?? interfaceType.extendsInterfaces,
    properties: Object.fromEntries(Object.entries(interfaceType.allProperties ?? interfaceType.properties).map(([key, value]) => {
      return [key, wirePropertyV2ToSdkPropertyDefinition(value, true, log)];
    }).filter(([key, value]) => value != null)),
    links: {},
    implementedBy: interfaceType.implementedByObjectTypes
  };
}

// node_modules/@osdk/generator-converters/build/browser/getEditedEntities.js
function getModifiedEntityTypes(action) {
  const addedObjects = /* @__PURE__ */ new Set();
  const modifiedObjects = /* @__PURE__ */ new Set();
  for (const operation of action.operations) {
    switch (operation.type) {
      case "createObject":
        addedObjects.add(operation.objectTypeApiName);
        break;
      case "modifyObject":
        modifiedObjects.add(operation.objectTypeApiName);
        break;
      case "deleteObject":
      case "createLink":
      case "deleteLink":
      case "createInterfaceObject":
      case "modifyInterfaceObject":
      case "deleteInterfaceObject":
        break;
      default:
    }
  }
  return {
    addedObjects,
    modifiedObjects
  };
}

// node_modules/@osdk/generator-converters/build/browser/wireActionTypeV2ToSdkActionMetadata.js
function wireActionTypeV2ToSdkActionMetadata(input) {
  const modifiedEntityTypes = getModifiedEntityTypes(input);
  return {
    type: "action",
    apiName: input.apiName,
    parameters: Object.fromEntries(Object.entries(input.parameters).map(([key, value]) => [key, wireActionParameterV2ToSdkParameterDefinition(value)])),
    displayName: input.displayName,
    description: input.description,
    modifiedEntities: createModifiedEntities(modifiedEntityTypes.addedObjects, modifiedEntityTypes.modifiedObjects),
    rid: input.rid,
    status: input.status
  };
}
function wireActionParameterV2ToSdkParameterDefinition(value) {
  return {
    multiplicity: value.dataType.type === "array",
    type: actionPropertyToSdkPropertyDefinition(value.dataType.type === "array" ? value.dataType.subType : value.dataType),
    nullable: !value.required,
    description: value.description
  };
}
function actionPropertyToSdkPropertyDefinition(parameterType) {
  switch (parameterType.type) {
    case "string":
    case "boolean":
    case "attachment":
    case "double":
    case "integer":
    case "long":
    case "timestamp":
    case "mediaReference":
    case "marking":
    case "objectType":
      return parameterType.type;
    case "date":
      return "datetime";
    case "objectSet":
      return {
        type: "objectSet",
        objectSet: parameterType.objectTypeApiName
      };
    case "object":
      return {
        type: "object",
        object: parameterType.objectTypeApiName
      };
    case "array":
      return actionPropertyToSdkPropertyDefinition(parameterType.subType);
    case "interfaceObject":
      return {
        type: "interface",
        interface: parameterType.interfaceTypeApiName
      };
    case "struct":
      return {
        type: "struct",
        struct: parameterType.fields.reduce((structMap, structField) => {
          structMap[structField.name] = actionPropertyToSdkPropertyDefinition(structField.fieldType);
          return structMap;
        }, {})
      };
    default:
      throw new Error(`Unsupported action parameter type: ${JSON.stringify(parameterType)}`);
  }
}
function createModifiedEntities(addedObjects, modifiedObjects) {
  const entities = {};
  for (const key of addedObjects) {
    entities[key] = {
      created: true,
      modified: false
    };
  }
  for (const key of modifiedObjects) {
    if (entities[key]) {
      entities[key].modified = true;
    } else {
      entities[key] = {
        created: false,
        modified: true
      };
    }
  }
  return entities;
}

// node_modules/@osdk/generator-converters/build/browser/wirePropertyV2ToSdkPrimaryKeyTypeDefinition.js
function wirePropertyV2ToSdkPrimaryKeyTypeDefinition(input) {
  switch (input.dataType.type) {
    case "integer":
    case "double":
    case "string":
    case "boolean":
    case "byte":
    case "long":
    case "short": {
      return input.dataType.type;
    }
    case "date": {
      return "datetime";
    }
    case "timestamp": {
      return "timestamp";
    }
    case "geopoint":
    case "geoshape":
    case "decimal":
    case "attachment":
    case "timeseries":
    case "array":
    case "marking":
    case "float":
    case "geotimeSeriesReference":
    case "mediaReference":
    case "struct":
    case "cipherText":
    case "vector":
      throw new Error(`Type not supported for primaryKey: ${input.dataType.type}`);
    default:
      input.dataType;
      throw new Error(`Unknown type encountered for primaryKey: ${input.dataType}`);
  }
}

// node_modules/@osdk/generator-converters/build/browser/wireObjectTypeFullMetadataToSdkObjectMetadata.js
function wireObjectTypeFullMetadataToSdkObjectMetadata(objectTypeWithLink, v2, log) {
  if (objectTypeWithLink.objectType.properties[objectTypeWithLink.objectType.primaryKey] === void 0) {
    throw new Error(`Primary key ${objectTypeWithLink.objectType.primaryKey} not found in ${objectTypeWithLink.objectType.apiName}`);
  }
  if (objectTypeWithLink.implementsInterfaces2 == null && objectTypeWithLink.implementsInterfaces != null) {
    throw new Error("Your ontology.json file is missing the implementsInterfaces2 field. Please regenerate it.");
  }
  const interfaceMap = objectTypeWithLink.implementsInterfaces2 ? Object.fromEntries(Object.entries(objectTypeWithLink.implementsInterfaces2).map(([interfaceApiName, impl]) => [interfaceApiName, impl.properties])) : {};
  return {
    type: "object",
    apiName: objectTypeWithLink.objectType.apiName,
    description: objectTypeWithLink.objectType.description,
    primaryKeyApiName: objectTypeWithLink.objectType.primaryKey,
    primaryKeyType: wirePropertyV2ToSdkPrimaryKeyTypeDefinition(objectTypeWithLink.objectType.properties[objectTypeWithLink.objectType.primaryKey]),
    links: Object.fromEntries(objectTypeWithLink.linkTypes.map((linkType) => {
      return [linkType.apiName, {
        multiplicity: linkType.cardinality === "MANY",
        targetType: linkType.objectTypeApiName
      }];
    })),
    properties: Object.fromEntries(Object.entries(objectTypeWithLink.objectType.properties).map(([key, value]) => [key, wirePropertyV2ToSdkPropertyDefinition(value, !(v2 && objectTypeWithLink.objectType.primaryKey === key), log)]).filter(([key, value]) => value != null)),
    implements: objectTypeWithLink.implementsInterfaces,
    interfaceMap,
    inverseInterfaceMap: Object.fromEntries(Object.entries(interfaceMap).map(([interfaceApiName, props]) => [interfaceApiName, invertProps(props)])),
    icon: supportedIconTypes.includes(objectTypeWithLink.objectType.icon.type) ? objectTypeWithLink.objectType.icon : void 0,
    titleProperty: objectTypeWithLink.objectType.titleProperty,
    displayName: objectTypeWithLink.objectType.displayName,
    pluralDisplayName: objectTypeWithLink.objectType.pluralDisplayName,
    status: objectTypeWithLink.objectType.status,
    rid: objectTypeWithLink.objectType.rid,
    visibility: objectTypeWithLink.objectType.visibility
  };
}
function invertProps(a) {
  return a ? Object.fromEntries(Object.entries(a).map(([k, v]) => [v, k])) : void 0;
}
var supportedIconTypes = ["blueprint"];

// node_modules/@osdk/generator-converters/build/browser/isNullableQueryDataType.js
function isNullableQueryDataType(input) {
  if (input.type === "null") {
    return true;
  }
  if (input.type === "union") {
    return input.unionTypes.some((t) => isNullableQueryDataType(t));
  }
  return false;
}

// node_modules/@osdk/generator-converters/build/browser/wireQueryDataTypeToQueryDataTypeDefinition.js
function wireQueryDataTypeToQueryDataTypeDefinition(input) {
  switch (input.type) {
    case "double":
    case "float":
    case "integer":
    case "long":
    case "attachment":
    case "boolean":
    case "date":
    case "string":
    case "timestamp":
      return {
        type: input.type,
        nullable: false
      };
    case "object":
      return {
        type: "object",
        object: input.objectTypeApiName,
        nullable: false
      };
    case "objectSet":
      return {
        type: "objectSet",
        objectSet: input.objectTypeApiName,
        nullable: false
      };
    case "array":
      return {
        ...wireQueryDataTypeToQueryDataTypeDefinition(input.subType),
        multiplicity: true
      };
    case "set":
      return {
        type: "set",
        set: wireQueryDataTypeToQueryDataTypeDefinition(input.subType),
        nullable: false
      };
    case "union":
      const allowNulls = isNullableQueryDataType(input);
      if (allowNulls && input.unionTypes.length === 2) {
        const nonNull = input.unionTypes.find((t) => t.type != null);
        if (nonNull) {
          return {
            ...wireQueryDataTypeToQueryDataTypeDefinition(nonNull),
            nullable: true
          };
        }
      }
      return {
        type: "union",
        union: input.unionTypes.reduce((acc, t) => {
          if (t.type === "null") {
            return acc;
          }
          acc.push(wireQueryDataTypeToQueryDataTypeDefinition(t));
          return acc;
        }, []),
        nullable: allowNulls
      };
    case "struct":
      return {
        type: "struct",
        struct: Object.fromEntries(input.fields.map((f) => [f.name, wireQueryDataTypeToQueryDataTypeDefinition(f.fieldType)])),
        nullable: false
      };
    case "twoDimensionalAggregation":
      return {
        type: "twoDimensionalAggregation",
        twoDimensionalAggregation: get2DQueryAggregationProps(input),
        nullable: false
      };
    case "threeDimensionalAggregation":
      return {
        type: "threeDimensionalAggregation",
        threeDimensionalAggregation: get3DQueryAggregationProps(input),
        nullable: false
      };
    case "entrySet":
      const keyType = wireQueryDataTypeToQueryDataTypeDefinition(input.keyType);
      if (!validMapKeyTypes.includes(keyType.type)) {
        throw new Error("Map types with a key type of " + keyType.type + " are not supported" + validMapKeyTypes.toString());
      }
      if (keyType.multiplicity === true) {
        throw new Error("Map types cannot have keys as arrays");
      }
      return {
        type: "map",
        nullable: false,
        keyType,
        valueType: wireQueryDataTypeToQueryDataTypeDefinition(input.valueType)
      };
    case "null":
    case "unsupported":
      throw new Error(`Unable to process query because the server indicated an unsupported QueryDataType.type: ${input.type}. Please check that your query is using supported types.`);
    default:
      throw new Error(`Unsupported QueryDataType.type ${input.type}`);
  }
}
function get2DQueryAggregationProps(input) {
  if (input.keyType.type === "range") {
    return {
      keyType: input.keyType.type,
      keySubtype: input.keyType.subType.type,
      valueType: input.valueType.type
    };
  } else {
    if (guardInvalidKeyTypes(input.keyType)) {
      return {
        keyType: input.keyType.type,
        valueType: input.valueType.type
      };
    }
    throw new Error(`Cannot create 2D aggregation with ${input.keyType.type} as its type`);
  }
}
function get3DQueryAggregationProps(input) {
  if (input.keyType.type === "range") {
    return {
      keyType: input.keyType.type,
      keySubtype: input.keyType.subType.type,
      valueType: get2DQueryAggregationProps(input.valueType)
    };
  } else {
    if (guardInvalidKeyTypes(input.keyType)) {
      return {
        keyType: input.keyType.type,
        valueType: get2DQueryAggregationProps(input.valueType)
      };
    }
    throw new Error(`Cannot create 3D aggregation with ${input.keyType.type} as its type`);
  }
}
function guardInvalidKeyTypes(key) {
  return key.type === "string" || key.type === "boolean";
}
var validMapKeyTypes = ["string", "object", "double", "float", "integer", "long", "date", "timestamp", "byte", "datetime", "decimal", "marking", "short", "objectType"];

// node_modules/@osdk/generator-converters/build/browser/wireQueryTypeV2ToSdkQueryMetadata.js
function wireQueryTypeV2ToSdkQueryMetadata(input) {
  return {
    type: "query",
    apiName: input.apiName,
    description: input.description,
    displayName: input.displayName,
    version: input.version,
    parameters: Object.fromEntries(Object.entries(input.parameters).map(([name, parameter]) => [name, wireQueryParameterV2ToQueryParameterDefinition(parameter)])),
    output: wireQueryDataTypeToQueryDataTypeDefinition(input.output),
    rid: input.rid
  };
}
function wireQueryParameterV2ToQueryParameterDefinition(parameter) {
  return {
    description: parameter.description,
    ...wireQueryDataTypeToQueryDataTypeDefinition(parameter.dataType)
  };
}

// node_modules/@osdk/client/build/browser/ontology/loadActionMetadata.js
async function loadActionMetadata(client, actionType) {
  const r = await ActionTypeV2_exports.get(client, await client.ontologyRid, actionType);
  return wireActionTypeV2ToSdkActionMetadata(r);
}

// node_modules/@osdk/client/build/browser/ontology/loadFullObjectMetadata.js
async function loadFullObjectMetadata(client, objectType) {
  const full = await ObjectTypeV2_exports.getFullMetadata(client, await client.ontologyRid, objectType, {
    preview: true
  });
  const ret = wireObjectTypeFullMetadataToSdkObjectMetadata(full, true);
  return {
    ...ret
  };
}

// node_modules/@osdk/client/build/browser/ontology/loadInterfaceMetadata.js
async function loadInterfaceMetadata(client, objectType) {
  const r = await OntologyInterface_exports.get(client, await client.ontologyRid, objectType, {
    preview: true
  });
  return __UNSTABLE_wireInterfaceTypeV2ToSdkObjectDefinition(r, true);
}

// node_modules/@osdk/client/build/browser/ontology/loadQueryMetadata.js
async function loadQueryMetadata(client, queryType) {
  const r = await QueryType_exports.get(client, await client.ontologyRid, queryType);
  return wireQueryTypeV2ToSdkQueryMetadata(r);
}

// node_modules/@osdk/client/build/browser/ontology/StandardOntologyProvider.js
var createStandardOntologyProviderFactory = () => {
  return (client) => {
    function makeGetter(fn) {
      const cache = createAsyncClientCache((client2, key) => fn(client2, key, false));
      return async (apiName) => {
        return await cache.get(client, apiName);
      };
    }
    const ret = {
      getObjectDefinition: makeGetter(async function(client2, key) {
        var _a;
        let objectDef = await loadFullObjectMetadata(client2, key);
        const interfaceDefs = Object.fromEntries((await Promise.all(((_a = objectDef.implements) == null ? void 0 : _a.map((i) => ret.getInterfaceDefinition(i))) ?? [])).map((i) => [i.apiName, {
          def: i,
          handler: void 0
        }]));
        const fullObjectDef = {
          ...objectDef,
          [InterfaceDefinitions]: interfaceDefs
        };
        return fullObjectDef;
      }),
      getInterfaceDefinition: makeGetter(async function(client2, key) {
        return loadInterfaceMetadata(client2, key);
      }),
      getQueryDefinition: makeGetter(async function(client2, key) {
        const r = await loadQueryMetadata(client2, key);
        return r;
      }),
      getActionDefinition: makeGetter(async function(client2, key) {
        const r = await loadActionMetadata(client2, key);
        return r;
      })
    };
    return ret;
  };
};

// node_modules/@osdk/client/build/browser/util/UserAgent.js
var USER_AGENT = `osdk-client/${"2.2.0-beta.16"}`;

// node_modules/@osdk/client/build/browser/createMinimalClient.js
function createMinimalClient(metadata, baseUrl, tokenProvider, options = {}, fetchFn = global.fetch, objectSetFactory = createObjectSet, createOntologyProviderFactory = createStandardOntologyProviderFactory) {
  if (true) {
    try {
      new URL(baseUrl);
    } catch (e) {
      const hint = !baseUrl.startsWith("http://") || !baseUrl.startsWith("https://") ? ". Did you forget to add 'http://' or 'https://'?" : "";
      throw new Error(`Invalid stack URL: ${baseUrl}${hint}`);
    }
  }
  const processedBaseUrl = new URL(baseUrl);
  processedBaseUrl.pathname += processedBaseUrl.pathname.endsWith("/") ? "" : "/";
  const minimalClient = {
    ...createSharedClientContext(processedBaseUrl.toString(), tokenProvider, USER_AGENT, fetchFn),
    objectSetFactory,
    objectFactory: convertWireToOsdkObjects,
    objectFactory2: convertWireToOsdkObjects2,
    ontologyRid: metadata.ontologyRid,
    logger: options.logger,
    clientCacheKey: {},
    requestContext: {}
  };
  return Object.freeze(Object.assign(minimalClient, {
    ontologyProvider: createOntologyProviderFactory(options)(minimalClient)
  }));
}

// node_modules/@osdk/client/build/browser/fetchMetadata.js
var fetchMetadataInternal = async (client, definition) => {
  if (definition.type === "object") {
    const {
      [InterfaceDefinitions]: interfaceDefs,
      ...objectTypeDef
    } = await client.ontologyProvider.getObjectDefinition(definition.apiName);
    return objectTypeDef;
  } else if (definition.type === "interface") {
    return client.ontologyProvider.getInterfaceDefinition(definition.apiName);
  } else if (definition.type === "action") {
    return client.ontologyProvider.getActionDefinition(definition.apiName);
  } else if (definition.type === "query") {
    return client.ontologyProvider.getQueryDefinition(definition.apiName);
  } else {
    throw new Error("Not implemented for given definition");
  }
};

// node_modules/@osdk/client/build/browser/logger/BaseLogger.js
function noop() {
}
var levels = {
  trace: 10,
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  fatal: 60
};
var _factory;
var BaseLogger = class {
  constructor(bindings, options = {}, factory) {
    __privateAdd(this, _factory);
    __publicField(this, "trace", noop);
    __publicField(this, "debug", noop);
    __publicField(this, "warn", noop);
    __publicField(this, "info", noop);
    __publicField(this, "error", noop);
    __publicField(this, "fatal", noop);
    var _a;
    this.bindings = bindings;
    this.options = options;
    __privateSet(this, _factory, factory);
    for (const k of ["trace", "debug", "info", "warn", "error", "fatal"]) {
      if (((_a = this.options) == null ? void 0 : _a.level) && !this.isLevelEnabled(k)) {
        continue;
      }
      this[k] = this.createLogMethod(k, bindings);
    }
  }
  child(bindings, options) {
    var _a, _b;
    return new (__privateGet(this, _factory))({
      ...this.bindings,
      ...bindings
    }, {
      level: (_a = options ?? this.options) == null ? void 0 : _a.level,
      msgPrefix: [(_b = this.options) == null ? void 0 : _b.msgPrefix, options == null ? void 0 : options.msgPrefix].filter((x) => x).join(" ")
    });
  }
  isLevelEnabled(level) {
    var _a;
    const ourLevel = ((_a = this.options) == null ? void 0 : _a.level) ?? "info";
    return level in levels && ourLevel in levels && levels[level] >= levels[ourLevel];
  }
};
_factory = new WeakMap();

// node_modules/@osdk/client/build/browser/logger/MinimalLogger.js
var MinimalLogger = class _MinimalLogger extends BaseLogger {
  constructor(bindings = {}, options = {}) {
    super(bindings, {
      ...options,
      level: options.level ?? "error"
    }, _MinimalLogger);
  }
  createLogMethod(name, bindings) {
    var _a;
    const msgs = [name];
    if ((_a = this.options) == null ? void 0 : _a.msgPrefix) {
      msgs.push(this.options.msgPrefix);
    }
    if (typeof bindings === "object" && "methodName" in bindings) {
      msgs.push(`.${bindings.methodName}()`);
    }
    return (...args) => {
      console[name === "fatal" ? "error" : name](msgs.join(" "), ...args);
    };
  }
};

// node_modules/@osdk/client/build/browser/util/isOsdkBaseObject.js
function isOsdkBaseObject2(o) {
  return o && typeof o === "object" && typeof o.$apiName === "string" && o.$primaryKey != null;
}

// node_modules/@osdk/client/build/browser/util/toDataValueQueries.js
async function toDataValueQueries(value, client, desiredType) {
  if (value == null) {
    return value;
  }
  if (Array.isArray(value) && desiredType.multiplicity) {
    const values = Array.from(value);
    if (values.some((dataValue) => isAttachmentUpload(dataValue) || isAttachmentFile(dataValue))) {
      const converted = [];
      for (const value2 of values) {
        converted.push(await toDataValueQueries(value2, client, desiredType));
      }
      return converted;
    }
    const promiseArray = Array.from(value, async (innerValue) => await toDataValueQueries(innerValue, client, desiredType));
    return Promise.all(promiseArray);
  }
  switch (desiredType.type) {
    case "attachment": {
      if (isAttachmentUpload(value)) {
        const attachment = await Attachment_exports.upload(client, value.data, {
          filename: value.name
        });
        return attachment.rid;
      }
      if (isAttachmentFile(value)) {
        const attachment = await Attachment_exports.upload(client, value, {
          filename: value.name
        });
        return attachment.rid;
      }
      return value;
    }
    case "twoDimensionalAggregation": {
      return {
        groups: value
      };
    }
    case "threeDimensionalAggregation": {
      return {
        groups: value
      };
    }
    case "set": {
      if (value instanceof Set) {
        const promiseArray = Array.from(value, async (innerValue) => await toDataValueQueries(innerValue, client, desiredType["set"]));
        return Promise.all(promiseArray);
      }
      break;
    }
    case "object": {
      if (isOsdkBaseObject2(value)) {
        return value.$primaryKey;
      }
      break;
    }
    case "objectSet": {
      if (isWireObjectSet(value)) {
        return value;
      }
      if (isObjectSet(value)) {
        return getWireObjectSet(value);
      }
      break;
    }
    case "map": {
      if (typeof value === "object") {
        const entrySet = [];
        for (const [key, mapValue] of Object.entries(value)) {
          entrySet.push({
            key: desiredType.keyType.type === "object" ? extractPrimaryKeyFromObjectSpecifier(key) : await toDataValueQueries(key, client, desiredType.keyType),
            value: await toDataValueQueries(mapValue, client, desiredType.valueType)
          });
        }
        return entrySet;
      }
      break;
    }
    case "struct": {
      if (typeof value === "object") {
        const structMap = {};
        for (const [key, structValue] of Object.entries(value)) {
          structMap[key] = await toDataValueQueries(structValue, client, desiredType["struct"][key]);
        }
        return structMap;
      }
    }
    case "boolean":
    case "date":
    case "double":
    case "float":
    case "integer":
    case "long":
    case "string":
    case "timestamp":
      return value;
  }
  return value;
}

// node_modules/@osdk/client/build/browser/queries/applyQuery.js
async function applyQuery(client, query, params) {
  const qd = await client.ontologyProvider.getQueryDefinition(query.apiName);
  const response = await Query_exports.execute(addUserAgentAndRequestContextHeaders(augmentRequestContext(client, () => ({
    finalMethodCall: "applyQuery"
  })), query), await client.ontologyRid, query.apiName, {
    parameters: params ? await remapQueryParams(params, client, qd.parameters) : {}
  });
  const objectOutputDefs = await getRequiredDefinitions(qd.output, client);
  const remappedResponse = await remapQueryResponse(client, qd.output, response.value, objectOutputDefs);
  return remappedResponse;
}
async function remapQueryParams(params, client, paramTypes) {
  const parameterMap = {};
  for (const [key, value] of Object.entries(params)) {
    parameterMap[key] = await toDataValueQueries(value, client, paramTypes[key]);
  }
  return parameterMap;
}
async function remapQueryResponse(client, responseDataType, responseValue, definitions) {
  if (responseValue == null) {
    if (responseDataType.nullable) {
      return void 0;
    } else {
      throw new Error("Got null response when nullable was not allowed");
    }
  }
  if (responseDataType.multiplicity != null && responseDataType.multiplicity) {
    const withoutMultiplicity = {
      ...responseDataType,
      multiplicity: false
    };
    for (let i = 0; i < responseValue.length; i++) {
      responseValue[i] = await remapQueryResponse(client, withoutMultiplicity, responseValue[i], definitions);
    }
    return responseValue;
  }
  switch (responseDataType.type) {
    case "union": {
      throw new Error("Union return types are not yet supported");
    }
    case "set": {
      for (let i = 0; i < responseValue.length; i++) {
        responseValue[i] = await remapQueryResponse(client, responseDataType.set, responseValue[i], definitions);
      }
      return responseValue;
    }
    case "attachment": {
      return hydrateAttachmentFromRidInternal(client, responseValue);
    }
    case "object": {
      const def = definitions.get(responseDataType.object);
      if (!def || def.type !== "object") {
        throw new Error(`Missing definition for ${responseDataType.object}`);
      }
      return createQueryObjectResponse(responseValue, def);
    }
    case "objectSet": {
      const def = definitions.get(responseDataType.objectSet);
      if (!def) {
        throw new Error(`Missing definition for ${responseDataType.objectSet}`);
      }
      if (typeof responseValue === "string") {
        return createObjectSet(def, client, {
          type: "intersect",
          objectSets: [{
            type: "base",
            objectType: responseDataType.objectSet
          }, {
            type: "reference",
            reference: responseValue
          }]
        });
      }
      return createObjectSet(def, client, responseValue);
    }
    case "struct": {
      for (const [key, subtype] of Object.entries(responseDataType.struct)) {
        if (requiresConversion(subtype)) {
          responseValue[key] = await remapQueryResponse(client, subtype, responseValue[key], definitions);
        }
      }
      return responseValue;
    }
    case "map": {
      const map = {};
      !Array.isArray(responseValue) ? true ? invariant(false, "Expected array entry") : invariant(false) : void 0;
      for (const entry of responseValue) {
        !entry.key ? true ? invariant(false, "Expected key") : invariant(false) : void 0;
        !entry.value ? true ? invariant(false, "Expected value") : invariant(false) : void 0;
        const key = responseDataType.keyType.type === "object" ? getObjectSpecifier(entry.key, responseDataType.keyType.object, definitions) : entry.key;
        const value = await remapQueryResponse(client, responseDataType.valueType, entry.value, definitions);
        map[key] = value;
      }
      return map;
    }
    case "twoDimensionalAggregation": {
      const result = [];
      for (const {
        key,
        value
      } of responseValue.groups) {
        result.push({
          key,
          value
        });
      }
      return result;
    }
    case "threeDimensionalAggregation": {
      const result = [];
      for (const {
        key,
        groups
      } of responseValue.groups) {
        const subResult = [];
        for (const {
          key: subKey,
          value
        } of groups) {
          subResult.push({
            key: subKey,
            value
          });
        }
        result.push({
          key,
          groups: subResult
        });
      }
      return result;
    }
  }
  return responseValue;
}
async function getRequiredDefinitions(dataType, client) {
  const result = /* @__PURE__ */ new Map();
  switch (dataType.type) {
    case "objectSet": {
      const objectDef = await client.ontologyProvider.getObjectDefinition(dataType.objectSet);
      result.set(dataType.objectSet, objectDef);
      break;
    }
    case "object": {
      const objectDef = await client.ontologyProvider.getObjectDefinition(dataType.object);
      result.set(dataType.object, objectDef);
      break;
    }
    case "set": {
      return getRequiredDefinitions(dataType.set, client);
    }
    case "map": {
      for (const value of [dataType.keyType, dataType.valueType]) {
        for (const [type, objectDef] of await getRequiredDefinitions(value, client)) {
          result.set(type, objectDef);
        }
      }
      break;
    }
    case "struct": {
      for (const value of Object.values(dataType.struct)) {
        for (const [type, objectDef] of await getRequiredDefinitions(value, client)) {
          result.set(type, objectDef);
        }
      }
      break;
    }
    case "attachment":
    case "boolean":
    case "date":
    case "double":
    case "float":
    case "integer":
    case "long":
    case "string":
    case "threeDimensionalAggregation":
    case "timestamp":
    case "twoDimensionalAggregation":
    case "union":
      break;
  }
  return result;
}
function requiresConversion(dataType) {
  switch (dataType.type) {
    case "boolean":
    case "date":
    case "double":
    case "float":
    case "integer":
    case "long":
    case "string":
    case "timestamp":
      return false;
    case "union":
      return true;
    case "struct":
      return Object.values(dataType.struct).some(requiresConversion);
    case "set":
      return requiresConversion(dataType.set);
    case "attachment":
    case "objectSet":
    case "twoDimensionalAggregation":
    case "threeDimensionalAggregation":
    case "object":
      return true;
    default:
      return false;
  }
}
function getObjectSpecifier(primaryKey, objectTypeApiName, definitions) {
  const def = definitions.get(objectTypeApiName);
  if (!def || def.type !== "object") {
    throw new Error(`Missing definition for ${objectTypeApiName}`);
  }
  return createObjectSpecifierFromPrimaryKey(def, primaryKey);
}
function createQueryObjectResponse(primaryKey, objectDef) {
  return {
    $apiName: objectDef.apiName,
    $title: void 0,
    $objectType: objectDef.apiName,
    $primaryKey: primaryKey,
    $objectSpecifier: createObjectSpecifierFromPrimaryKey(objectDef, primaryKey)
  };
}

// node_modules/@osdk/client/build/browser/createClient.js
var ActionInvoker = class {
  constructor(clientCtx, actionDef) {
    this.applyAction = applyAction.bind(void 0, clientCtx, actionDef);
    this.batchApplyAction = applyAction.bind(void 0, clientCtx, actionDef);
  }
};
var QueryInvoker = class {
  constructor(clientCtx, queryDef) {
    this.executeFunction = applyQuery.bind(void 0, clientCtx, queryDef);
  }
};
function createClientInternal(objectSetFactory, baseUrl, ontologyRid, tokenProvider, options = void 0, fetchFn = fetch) {
  if (typeof ontologyRid === "string") {
    if (!ontologyRid.startsWith("ri.")) {
      throw new Error("Invalid ontology RID");
    }
  } else {
    ontologyRid.then((ontologyRid2) => {
      if (!ontologyRid2.startsWith("ri.")) {
        throw new Error("Invalid ontology RID");
      }
    });
  }
  const clientCtx = createMinimalClient({
    ontologyRid
  }, baseUrl, tokenProvider, {
    ...options,
    logger: (options == null ? void 0 : options.logger) ?? new MinimalLogger()
  }, fetchFn, objectSetFactory);
  const fetchMetadata = fetchMetadataInternal.bind(void 0, clientCtx);
  const client = Object.defineProperties(function(o) {
    if (o.type === "object" || o.type === "interface") {
      return objectSetFactory(o, clientCtx);
    } else if (o.type === "action") {
      return new ActionInvoker(clientCtx, o);
    } else if (o.type === "query") {
      return new QueryInvoker(clientCtx, o);
    } else if (o.type === "experiment") {
      switch (o.name) {
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__getBulkLinks.name:
          return {
            getBulkLinks: createBulkLinksAsyncIterFactory(clientCtx)
          };
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchOneByRid.name:
          return {
            fetchOneByRid: async (objectType, rid, options2) => {
              return await fetchSingle(clientCtx, objectType, options2, createWithRid([rid]));
            }
          };
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__createMediaReference.name:
          return {
            createMediaReference: async (args) => {
              const {
                data,
                fileName,
                objectType,
                propertyType
              } = args;
              return await MediaReferenceProperty_exports.upload(clientCtx, await clientCtx.ontologyRid, objectType.apiName, propertyType, data, {
                mediaItemPath: fileName,
                preview: true
              });
            }
          };
        case __EXPERIMENTAL__NOT_SUPPORTED_YET__fetchPageByRid.name:
          return {
            fetchPageByRid: async (objectOrInterfaceType, rids, options2 = {}) => {
              return await fetchPage(clientCtx, objectOrInterfaceType, options2, createWithRid(rids));
            }
          };
      }
      throw new Error("not implemented");
    } else {
      throw new Error("not implemented");
    }
  }, {
    [symbolClientContext]: {
      value: clientCtx
    },
    ["__osdkClientContext"]: {
      value: clientCtx
    },
    [additionalContext]: {
      value: clientCtx
    },
    fetchMetadata: {
      value: fetchMetadata
    }
  });
  return client;
}
var createClient = createClientInternal.bind(void 0, createObjectSet);
function createWithRid(rids) {
  return {
    type: "static",
    "objects": rids
  };
}

// node_modules/@osdk/client/build/browser/createPlatformClient.js
function createPlatformClient(baseUrl, tokenProvider, options = void 0, fetchFn = fetch) {
  return createSharedClientContext(baseUrl, tokenProvider, USER_AGENT, fetchFn);
}

// node_modules/@osdk/client/build/browser/util/datetimeConverters.js
var isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?$/;
var extractDate = (dateTime) => {
  !(dateTime.length < 33) ? true ? invariant(false, "Invalid date format. Provided input is too long.") : invariant(false) : void 0;
  !isoRegex.test(dateTime) ? true ? invariant(false, `Invalid date format. Expected ISO 8601 format, but received ${dateTime}`) : invariant(false) : void 0;
  return extractDateFromIsoString(dateTime);
};
var extractDateInUTC = (date) => {
  return extractDateFromIsoString(date.toISOString());
};
var extractDateInLocalTime = (date) => {
  return extractDateFromIsoString(generateOffsetUtcString(date));
};
var generateOffsetUtcString = (date) => {
  const offsetMs = date.getTimezoneOffset() * 60 * 1e3;
  return new Date(date.getTime() - offsetMs).toISOString();
};
var extractDateFromIsoString = (dateTime) => {
  return dateTime.split("T")[0];
};
export {
  ActionValidationError,
  PalantirApiError,
  createAttachmentUpload,
  createClient,
  createObjectSpecifierFromPrimaryKey,
  createPlatformClient,
  extractDate,
  extractDateInLocalTime,
  extractDateInUTC,
  isOk
};
//# sourceMappingURL=@osdk_client.js.map
