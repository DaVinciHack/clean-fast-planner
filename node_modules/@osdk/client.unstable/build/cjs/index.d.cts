import { ConjureContext } from 'conjure-lite';

/**
 * A derived property that references an aggregation on a set of linked objects.
 * The linked object is specified by a LinkDefinition.
 */
interface AggregatedPropertyDefinition {
    aggregation: DerivedPropertyAggregation$1;
    linkDefinition: LinkDefinition$2;
}
/**
 * Use all properties.
 */
interface AllPropertiesPropertySet$1 {
}
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an AndFilter iff it matches all of the filters.
 */
interface AndFilter$1 {
    filters: Array<ObjectSetFilter$1>;
}
/**
 * An object matches an ApproximateLinkPresenceFilter iff it contains a link to any object along the provided RelationId
 * and if the starting object is on the provided RelationSide of the relation.
 *
 * WARNING: Due to the performance constraints, this filter does not always check if the linked object actually exists.
 * As a consequence it is possible that ApproximateLinkPresenceFilter will yield more objects, including those which are
 * linked to non-existent ones. Hence, whenever this filter is used, result set should be treated as approximate.
 *
 * It is guaranteed that no links will be missed during filtering, so in order to make results accurate, it is enough for
 * clients to filter out results linked to non-existing objects.
 *
 * If use case relies on linked objects existence and requires accurate results, clients are encouraged to use ObjectSetLinkFilter instead.
 */
interface ApproximateLinkPresenceFilter {
    relationId: RelationId$1;
    relationSide: RelationSide$1;
}
/**
 * An object property value whose type is array.
 */
type ArrayPropertyValue = Array<PropertyValue>;
/**
 * Cast the provided object set to the raw object types. This drops interface views on interface-based
 * object sets and convert them into unions of the underlying object types. This also disallows referring
 * to interface property API names and forces property selection to use object type property API names.
 */
interface AsBaseObjectTypesObjectSet {
    objectSet: ObjectSet;
}
/**
 * Cast the provided object set to the provided object type or interface type which results in a new scope of the
 * object set, controlling what properties you can reference in sorts or filters. Objects which cannot be cast as
 * the provided type are dropped. Objects can be cast to an object type if they are of that type or to an
 * interface if their object type implements said interface or a child interface of it.
 *
 * For example, suppose "Vehicle" is an interface and "Car" implements it. "Vehicle" declares a property
 * "capacity", and on Cars, the local property "seats" fulfills the interface property. It is not possible to
 * select "capacity" when the object set is "Base(Car)". However it is possible to query "capacity" if the object
 * set is cast to "Car" via "AsType(Base(Car), type="Vehicle")".
 */
interface AsTypeObjectSet {
    objectSet: ObjectSet;
    type: ObjectTypeOrInterfaceTypeIdentifier;
}
/**
 * The rid of an Attachment.
 */
type AttachmentPropertyValue = string;
/**
 * Object Set containing all objects with a given ObjectTypeId.
 */
interface BaseObjectSet {
    objectTypeId: ObjectTypeId$1;
}
/**
 * An object property value whose type is boolean (true-false).
 */
type BooleanPropertyValue = boolean;
interface CalculatedPropertyDefinition_numeric {
    type: "numeric";
    numeric: NumericOutputCalculation;
}
interface CalculatedPropertyDefinition_datetime {
    type: "datetime";
    datetime: DateTimeOutputCalculation;
}
/**
 * A derived property that is calculated from other properties.
 * It can be a literal, a reference to another property or an operation.
 */
type CalculatedPropertyDefinition = CalculatedPropertyDefinition_numeric | CalculatedPropertyDefinition_datetime;
/**
 * Reference to a specific catalog file
 */
interface CatalogFileReference {
    datasetRid: DatasetRid$1;
    endTransactionRid: TransactionRid;
    logicalFilePath: string;
}
/**
 * This property type represents an encrypted or plain text value used by the Cipher Service.
 */
type CipherTextPropertyValue = string;
interface CreateTemporaryObjectSetRequest {
    objectSet: ObjectSet;
    objectSetFilterContext?: ObjectSetFilterContext | null | undefined;
    timeToLive: TimeToLive;
}
interface CreateTemporaryObjectSetResponse {
    objectSetRid: ObjectSetRid;
}
/**
 * Used to record custom provenance information.
 */
interface CustomProvenance {
    identifier: CustomProvenanceIdentifier;
    parameters: Record<string, any>;
}
/**
 * Identifies a custom provenance record.
 */
type CustomProvenanceIdentifier = string;
/**
 * Reference to a dataset containing the media with an optional thumbnail reference.
 */
interface DatasetFileReference {
    fileReference: CatalogFileReference;
    thumbnailReference?: CatalogFileReference | null | undefined;
}
/**
 * The identifier of a foundry dataset
 */
type DatasetRid$1 = string;
/**
 * String representation of an ISO-8601 formatted date in a YYYY-MM-DD format.
 */
type DateLiteral = string;
/**
 * A specific part of a date (such as day, month, or year)
 */
type DatePart = "DAY" | "MONTH" | "QUARTER" | "YEAR";
/**
 * String representation of an ISO-8601 formatted date in a YYYY-MM-DD format.
 */
type DatePropertyValue = string;
/**
 * An operation on two property nodes of type datetime for the purposes of defining a derived property.
 */
interface DateTimeBinaryOperation {
    leftOperand: DateTimeOutputCalculation;
    rightOperand: DateTimeOutputCalculation;
}
interface DateTimeLiteral_date {
    type: "date";
    date: DateLiteral;
}
interface DateTimeLiteral_timestamp {
    type: "timestamp";
    timestamp: TimestampLiteral;
}
/**
 * A literal value for the purposes of defining a derived property via a date operation.
 */
type DateTimeLiteral = DateTimeLiteral_date | DateTimeLiteral_timestamp;
interface DateTimeOperation_max {
    type: "max";
    max: DateTimeBinaryOperation;
}
interface DateTimeOperation_min {
    type: "min";
    min: DateTimeBinaryOperation;
}
/**
 * An operation on one or two property nodes of type datetime for the purposes of defining a derived property.
 */
type DateTimeOperation = DateTimeOperation_max | DateTimeOperation_min;
interface DateTimeOutputCalculation_literal {
    type: "literal";
    literal: DateTimeLiteral;
}
interface DateTimeOutputCalculation_propertyIdentifier {
    type: "propertyIdentifier";
    propertyIdentifier: PropertyIdentifier;
}
interface DateTimeOutputCalculation_operation {
    type: "operation";
    operation: DateTimeOperation;
}
/**
 * A calculation node that is used to define a derived property via an operation which returns a date output.
 */
type DateTimeOutputCalculation = DateTimeOutputCalculation_literal | DateTimeOutputCalculation_propertyIdentifier | DateTimeOutputCalculation_operation;
interface DateTimeToNumericCalculation_extractDatePart {
    type: "extractDatePart";
    extractDatePart: ExtractDatePartCalculation;
}
/**
 * A calculation node that is used to define a derived property via an operation which takes a date input and
 * returns a numeric output.
 */
type DateTimeToNumericCalculation = DateTimeToNumericCalculation_extractDatePart;
/**
 * String representation of a decimal value. This value can be returned in a scientific notation with the exponent
 * preceded by a letter 'E' followed by a '+'/'-' sign (for example 4.321E+8 or 0.332E-5).
 */
type DecimalPropertyValue = string;
/**
 * A collection of derived properties that can be referenced inside a FilteredObjectSet.
 * They are ephemeral and only exist for the lifetime of a request.
 *
 * Note: There may only be a single entry for a given property identifier. An exception will be thrown
 * otherwise.
 *
 * A derived property id may not overlap with any existing PropertyIdentifier that is already defined in the
 * Ontology for a given object type. An exception will be thrown at runtime if this limitation is not
 * respected. NB: This may lead to sudden breaks if the Ontology is updated to include a property that shares
 * a propertyIdentifier already contained in a user defined property definition.
 */
type DerivedProperties = Array<DerivedPropertiesEntry>;
/**
 * A derived property that can be referenced in an object set or aggregation.
 * It is ephemeral and only exists for the lifetime of a request.
 */
interface DerivedPropertiesEntry {
    definition: DerivedPropertyDefinition;
    propertyIdentifier: PropertyIdentifier;
}
interface DerivedPropertyAggregation_count$1 {
    type: "count";
    count: LinkedCountMetric$1;
}
interface DerivedPropertyAggregation_avg$1 {
    type: "avg";
    avg: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_max$1 {
    type: "max";
    max: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_min$1 {
    type: "min";
    min: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_sum$1 {
    type: "sum";
    sum: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_percentile {
    type: "percentile";
    percentile: LinkedPercentileMetric;
}
interface DerivedPropertyAggregation_cardinality {
    type: "cardinality";
    cardinality: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_exactCardinality$1 {
    type: "exactCardinality";
    exactCardinality: LinkedPropertyMetric;
}
interface DerivedPropertyAggregation_standardDeviation {
    type: "standardDeviation";
    standardDeviation: LinkedDispersionMetric;
}
interface DerivedPropertyAggregation_variance {
    type: "variance";
    variance: LinkedDispersionMetric;
}
interface DerivedPropertyAggregation_collectList$1 {
    type: "collectList";
    collectList: LinkedCollection$1;
}
interface DerivedPropertyAggregation_collectSet$1 {
    type: "collectSet";
    collectSet: LinkedCollection$1;
}
/**
 * An aggregation function and what it should be computed on (e.g. a property).
 */
type DerivedPropertyAggregation$1 = DerivedPropertyAggregation_count$1 | DerivedPropertyAggregation_avg$1 | DerivedPropertyAggregation_max$1 | DerivedPropertyAggregation_min$1 | DerivedPropertyAggregation_sum$1 | DerivedPropertyAggregation_percentile | DerivedPropertyAggregation_cardinality | DerivedPropertyAggregation_exactCardinality$1 | DerivedPropertyAggregation_standardDeviation | DerivedPropertyAggregation_variance | DerivedPropertyAggregation_collectList$1 | DerivedPropertyAggregation_collectSet$1;
interface DerivedPropertyDefinition_nativeProperty {
    type: "nativeProperty";
    nativeProperty: PropertyIdentifier;
}
interface DerivedPropertyDefinition_linkedObjectProperty {
    type: "linkedObjectProperty";
    linkedObjectProperty: LinkedObjectPropertyDefinition;
}
interface DerivedPropertyDefinition_linkedObjectsAggregationProperty {
    type: "linkedObjectsAggregationProperty";
    linkedObjectsAggregationProperty: LinkedObjectsAggregationPropertyDefinition;
}
interface DerivedPropertyDefinition_calculatedProperty {
    type: "calculatedProperty";
    calculatedProperty: CalculatedPropertyDefinition;
}
interface DerivedPropertyDefinition_linkedProperty {
    type: "linkedProperty";
    linkedProperty: LinkedPropertyDefinition;
}
interface DerivedPropertyDefinition_aggregatedProperty {
    type: "aggregatedProperty";
    aggregatedProperty: AggregatedPropertyDefinition;
}
/**
 * The definition of a derived property. It can be a native property, linked object property,
 * linked objects aggregation property or a calculated property.
 */
type DerivedPropertyDefinition = DerivedPropertyDefinition_nativeProperty | DerivedPropertyDefinition_linkedObjectProperty | DerivedPropertyDefinition_linkedObjectsAggregationProperty | DerivedPropertyDefinition_calculatedProperty | DerivedPropertyDefinition_linkedProperty | DerivedPropertyDefinition_aggregatedProperty;
/**
 * A Foundry link with link side specified.
 *
 * Returned in the context of a GetBulkLinksPageRequest, where the direction of the links to objects is
 * specified. Meaning the object specified in the request will appear on the specified LinkSide of the response's
 * DirectedFoundryLink.
 */
interface DirectedFoundryLink {
    link: FoundryLink;
    linkSide: LinkSide;
}
/**
 * Information that specifies side of the given link type rid. Used in the context of a GetBulkLinksPageRequest,
 * where a set of links is loaded for a given set of objects and link types.
 */
interface DirectedLinkTypeRid {
    linkSide: LinkSide;
    linkTypeRid: LinkTypeRid$1;
}
/**
 * Geospatial distance.
 */
interface Distance$1 {
    unit: DistanceUnit$1;
    value: number | "NaN" | "Infinity" | "-Infinity";
}
/**
 * A unit of geospatial distance.
 */
type DistanceUnit$1 = "MILLIMETER" | "CENTIMETER" | "METER" | "KILOMETER" | "INCH" | "FOOT" | "YARD" | "MILE" | "NAUTICAL_MILE";
/**
 * A literal double value for the purposes of defining a derived property via a numeric operation.
 */
type DoubleLiteral = number | "NaN" | "Infinity" | "-Infinity";
/**
 * An object property value whose type is double-precision floating point.
 */
type DoublePropertyValue = number | "NaN" | "Infinity" | "-Infinity";
/**
 * The primary key of an object or a link.
 */
type EntityPrimaryKey = Record<PropertyTypeRid$1, PropertyValue>;
/**
 * A unique identifier of an object type or a link type.
 */
type EntityTypeRid = string;
interface EntityVersion_v1 {
    type: "v1";
    v1: EntityVersionV1;
}
/**
 * Version of the returned object or many-to-many link.
 * It is guaranteed that the entity has not changed as long as the returned value is the same.
 */
type EntityVersion = EntityVersion_v1;
/**
 * Token representing a version of the returned object or many-to-many link.
 */
type EntityVersionV1 = string;
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, it should have `supportsExactMatching` set to true on the object type definition in OMS.
 * If no terms are provided, this filter will match ALL objects.
 */
interface ExactMatchFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    terms: Array<any>;
}
/**
 * A calculation node that is used to define a derived property via a date part extraction operation.
 */
interface ExtractDatePartCalculation {
    dateOperand: DateTimeOutputCalculation;
    datePart: DatePart;
}
/**
 * Object Set containing objects in provided Object Set that match the provided filter.
 */
interface FilteredObjectSet {
    derivedProperties?: TypedDerivedProperties | null | undefined;
    filter: ObjectSetFilter$1;
    objectSet: ObjectSet;
    runtimeDerivedProperties?: LegacyDerivedProperties | null | undefined;
}
interface FilterParameter_unresolved$1 {
    type: "unresolved";
    unresolved: UnresolvedFilterParameter$1;
}
interface FilterParameter_resolved$1 {
    type: "resolved";
    resolved: ResolvedFilterParameter$1;
}
/**
 * A filter parameter.
 */
type FilterParameter$1 = FilterParameter_unresolved$1 | FilterParameter_resolved$1;
/**
 * A value to match on in a filter.
 */
type FilterValue$1 = any;
/**
 * A unique identifier for a Trident fork.
 */
type ForkRid = string;
/**
 * A Foundry link.
 */
interface FoundryLink {
    linkTypeRid: EntityTypeRid;
    objectSideA: FoundryObjectReference;
    objectSideB: FoundryObjectReference;
    primaryKey: EntityPrimaryKey;
    version: EntityVersion;
}
/**
 * Identifiers that reference a single `FoundryObject`.
 *
 * The ObjectRid will be returned based on the setting of the ObjectLoadingResponseOptions#shouldLoadObjectRids
 * flag in the request. It will always be returned by default unless specifically opted out and clients
 * can upgrade by throwing in the empty case.
 */
interface FoundryObjectReference {
    objectLocatorV2: ObjectLocatorV2;
    objectRid?: ObjectRid$1 | null | undefined;
}
/**
 * Parameters used to control fuzzy searching.
 */
interface Fuzziness {
    maxEditDistance: MaxEditDistance;
}
/**
 * An object matches a GeoBoundingBoxFilter iff the value of the provided property is within the provided bounds.
 * This filter is only supported on geo_point property types.
 */
interface GeoBoundingBoxFilter$1 {
    bottomRight: string;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    topLeft: string;
}
/**
 * An object matches a GeoDistanceFilter iff the value of the provided property is within the provided distance
 * of the provided location i.e. sits within a circle centered at the provided location.
 */
interface GeoDistanceFilter$1 {
    distance: Distance$1;
    location: string;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * An object property value that represents a latitude-longitude pair.
 */
interface GeoPointPropertyValue {
    latitude: number | "NaN" | "Infinity" | "-Infinity";
    longitude: number | "NaN" | "Infinity" | "-Infinity";
}
/**
 * An object matches a GeoPolygonFilter iff the value of the provided property is within bounds of the provided
 * polygon. This filter is only supported on geo_point property types.
 */
interface GeoPolygonFilter$1 {
    polygon: Array<string>;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * Filter properties of type geo_shape or geo_point.
 */
interface GeoShapeFilter$1 {
    geoShapeQuery: GeoShapeQuery$1;
    spatialFilterMode: GeoShapeSpatialFilterMode$1;
}
/**
 * An object property value that represents a geoshape. This value is guaranteed to be a valid GeoJSON.
 */
type GeoShapePropertyValue = any;
interface GeoShapeQuery_geoBoundingBoxFilter$1 {
    type: "geoBoundingBoxFilter";
    geoBoundingBoxFilter: GeoBoundingBoxFilter$1;
}
interface GeoShapeQuery_geoPolygonFilter$1 {
    type: "geoPolygonFilter";
    geoPolygonFilter: GeoPolygonFilter$1;
}
/**
 * Union type for valid queries over geo shape properties.
 */
type GeoShapeQuery$1 = GeoShapeQuery_geoBoundingBoxFilter$1 | GeoShapeQuery_geoPolygonFilter$1;
/**
 * Geometry operation under which to evaluate the geo shape query.
 */
type GeoShapeSpatialFilterMode$1 = "INTERSECTS" | "DISJOINT" | "WITHIN";
/**
 * The ID for a Geotime series within an integration; this can be written into Geotime by an end user
 * and is therefore unsafe.
 */
type GeotimeSeriesId = string;
/**
 * A reference to a Geotime integration; this is randomly generated and is therefore safe to log.
 */
type GeotimeSeriesIntegrationRid$1 = string;
/**
 * The property value for a Geotime series reference
 */
interface GeotimeSeriesReference {
    geotimeSeriesId: GeotimeSeriesId;
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationRid$1;
}
/**
 * An object property value that represents a GeotimeSeriesReference.
 */
type GeotimeSeriesReferencePropertyValue = GeotimeSeriesReference;
interface GetBulkLinksPageRequest {
    linksRequests: Array<GetBulkLinksPageRequestEntry>;
    objectLoadingResponseOptions?: ObjectLoadingResponseOptions | null | undefined;
    objectPagingResponseOptions?: ObjectPagingResponseOptions | null | undefined;
    objectSetContext: ObjectSetContext;
    pageSize: number;
    pageToken?: GetBulkLinksPageToken | null | undefined;
    responseOptions?: ResponseOptions | null | undefined;
}
/**
 * A single query entry for paging links. Query specifies the link types with link side and object selection,
 * where the objects in the object selection are expected to appear on the link side of the corresponding link
 * types.
 */
interface GetBulkLinksPageRequestEntry {
    directedLinkTypes: Array<DirectedLinkTypeRid>;
    objects: ObjectsSelection;
}
/**
 * Results contains a list of LoadedObjectLinksResultV2 that includes requested ObjectIdentifier and a list of
 * found DirectedFoundryLinks. The sum of all links will not exceed 100_000 in a single page.
 */
interface GetBulkLinksPageResponse {
    pageToken?: GetBulkLinksPageToken | null | undefined;
    results: Array<LoadedObjectLinksResultV2>;
    usageCost?: UsageCost | null | undefined;
}
interface GetBulkLinksPageToken_pageToken {
    type: "pageToken";
    pageToken: PageToken;
}
/**
 * A token for paging links.
 */
type GetBulkLinksPageToken = GetBulkLinksPageToken_pageToken;
/**
 * An object matches a HasPropertyFilter iff it has the provided property and its value is non-null.
 */
interface HasPropertyFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * An object property value whose type is integer.
 */
type IntegerPropertyValue = number;
/**
 * Object Set containing all objects of object types which implement the supplied interface or a child interface
 * of it.
 */
interface InterfaceBaseObjectSet {
    interfaceTypeRid: InterfaceTypeRid$1;
}
/**
 * ObjectSet containing all objects that are linked to the Interface objects in provided object set via
 * an Interface Link Type, and are on the opposite side of the Interface objects in the object set. The provided
 * object set's scope must contain the Interface that is being searched around. If performed on Object Types
 * implementing the Interface, the object set must be first cast to the Interface with AsTypeObjectSet.
 */
interface InterfaceLinkSearchAroundObjectSet {
    interfaceLinkTypeRid: InterfaceLinkTypeRid$1;
    objectSet: ObjectSet;
}
/**
 * Resource Identifier of an interface link type.
 */
type InterfaceLinkTypeRid$1 = string;
/**
 * An object matches an InterfaceTypeFilter iff the set of interfaces it implements contains the provided
 * interface.
 */
interface InterfaceTypeFilter {
    interfaceTypeRid: InterfaceTypeRid$1;
}
/**
 * Resource Identifier of an interface type.
 */
type InterfaceTypeRid$1 = string;
/**
 * Object Set containing objects present in all provided Object Sets. When the provided Object Sets have
 * different types, the objects along with the interface views of all interfaces involved in the
 * intersection are returned.
 *
 * For example, in "Intersected(InterfaceBase(Drivable), InterfaceBase(Flyable))", the interface views
 * provided in the response will contain the views for each object type that implements both the Drivable and
 * Flyable interfaces.
 */
interface IntersectedObjectSet {
    objectSets: Array<ObjectSet>;
}
/**
 * WARNING: this feature is supported only for object types stored in Object Storage V2
 *
 * ObjectSet containing the top k objects with propertyId nearest to the given vector.
 */
interface KnnObjectSet {
    kValue: number;
    objectSet: ObjectSet;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    vector: Vector;
}
/**
 * ObjectSet containing the top k objects with propertyId nearest to the given vector.
 */
interface KnnObjectSetV2 {
    kValue: number;
    objectSet: ObjectSet;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    query: KnnQuery;
}
interface KnnQuery_vector {
    type: "vector";
    vector: Vector;
}
interface KnnQuery_text {
    type: "text";
    text: string;
}
/**
 * Supported ways to query using knn. Can either use a vector directly, or use text which will get embedding using
 * the model specified in the Ontology.
 */
type KnnQuery = KnnQuery_vector | KnnQuery_text;
/**
 * A collection of derived properties that can be referenced in an object set or aggregation.
 * They are ephemeral and only exist for the lifetime of a request.
 */
type LegacyDerivedProperties = Record<PropertyId$1, DerivedPropertyDefinition>;
interface LinkDefinition_nativeLink {
    type: "nativeLink";
    nativeLink: NativeLinkDefinition;
}
interface LinkDefinition_methodLink {
    type: "methodLink";
    methodLink: MethodLinkDefinition;
}
/**
 * Describes which objects are linked together.
 * Formally, link can be modelled as a function `f: object -> ObjectSet`
 * Links can be defined statically at write-time or dynamically as a result of a computation.
 */
type LinkDefinition$2 = LinkDefinition_nativeLink | LinkDefinition_methodLink;
/**
 * A collection of values of a property.
 */
interface LinkedCollection$1 {
    limit: number;
    property: PropertyIdentifier;
}
/**
 * Total count of objects
 */
interface LinkedCountMetric$1 {
}
/**
 * A property to compute a dispersion metric for.
 */
interface LinkedDispersionMetric {
    method: LinkedDispersionMetricMethod;
    property?: DerivedPropertyDefinition | null | undefined;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * Method to be used to provide final value for standard deviation or variance.
 * Use POPULATION when you have the entire set of data to work with OR
 * Use SAMPLE when you have an incomplete set of data (with at least 2 values) to work with.
 * An in depth explanation here: https://en.wikipedia.org/wiki/Bessel%27s_correction
 */
type LinkedDispersionMetricMethod = "POPULATION" | "SAMPLE";
/**
 * A derived property that references a property on a linked object.
 * The linked object is specified by a link type and direction.
 *
 * NB: The contract for this derived property is that it may not change the cardinality of the source object set.
 * This means that only one-to-one and one-to-many link types are supported. Additionally, the target property
 * must be on the 'one' side of the link in the latter case.
 *
 * If the desired target property is on the 'many' side of a link, then either a linked objects aggregation
 * should be considered, or the link direction should be reversed (one-to-many case only).
 */
interface LinkedObjectPropertyDefinition {
    relationId?: RelationId$1 | null | undefined;
    relationIdentifier?: RelationIdentifier | null | undefined;
    relationSide?: LinkedPropertyRelationSide | null | undefined;
    targetObjectSet: ObjectSet;
    targetProperty?: DerivedPropertyDefinition | null | undefined;
    targetPropertyId?: PropertyId$1 | null | undefined;
}
/**
 * A derived property that references an aggregation on a set of linked objects.
 * The linked objects are specified by a link type and direction.
 */
interface LinkedObjectsAggregationPropertyDefinition {
    metric: DerivedPropertyAggregation$1;
    relationId?: RelationId$1 | null | undefined;
    relationIdentifier?: RelationIdentifier | null | undefined;
    relationSide: LinkedPropertyRelationSide;
    targetObjectSet: ObjectSet;
}
/**
 * A property to compute a percentile metric for.
 */
interface LinkedPercentileMetric {
    percentile: number | "NaN" | "Infinity" | "-Infinity";
    property?: DerivedPropertyDefinition | null | undefined;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * A derived property that references a property on a linked object.
 * The linked object is specified by a LinkDefinition.
 */
interface LinkedPropertyDefinition {
    linkDefinition: LinkDefinition$2;
    linkedPropertyIdentifier: PropertyIdentifier;
}
/**
 * A property to compute a metric for.
 */
interface LinkedPropertyMetric {
    property?: DerivedPropertyDefinition | null | undefined;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * Side of a relation linking to a linked derived property.
 *
 * For many-to-many link types SOURCE corresponds to object type A in the OMS many to many link definition, and
 * TARGET corresponds to object type B.
 *
 * For one-to-many link types SOURCE generally corresponds to the ONE (or primary key) side in the OMS one to
 * many link definition, and TARGET corresponds to the MANY (or foreign key) side.
 * WARNING: In the self-referential one-to-many join case, this is inverted.
 */
type LinkedPropertyRelationSide = "SOURCE" | "TARGET";
/**
 * Side of a link.
 *
 * For many-to-many link types SOURCE corresponds to object type A in the OMS many to many link definition, and
 * TARGET corresponds to object type B.
 *
 * For one-to-many link types SOURCE generally corresponds to the ONE (or primary key) side in the OMS one to
 * many link definition, and TARGET corresponds to the MANY (or foreign key) side.
 * WARNING: In the self-referential one-to-many join case, this is inverted.
 */
type LinkSide = "SOURCE" | "TARGET";
/**
 * A unique identifier of a link type.
 */
type LinkTypeRid$1 = string;
/**
 * Successful links retrieval result for a requested object.
 */
interface LoadedObjectLinksResultV2 {
    links: Array<DirectedFoundryLink>;
    objectIdentifier: ObjectIdentifier;
}
/**
 * String representation of a 64-bit long value. This value has no formatting of any kind, and contains only
 * digits (with an optional leading '-' sign for negative numbers).
 */
type LongPropertyValue = string;
/**
 * An object property value representing a marking. This value cannot be used as a primary key.
 */
type MarkingPropertyValue = string;
/**
 * This static object set was created via materializing some other object set.
 */
interface MaterializationProvenance {
    materializationTime: string;
    objectSetRid: ObjectSetRid;
}
/**
 * The maximum distance between words to consider them to be a match.
 *
 * The distance is measured as the minimum number of operations required to change one word into another. Operations consist of insertions,
 * deletions or substitutions of a single character, or transposition of two adjacent characters. (Damerau–Levenshtein distance)
 *
 * The AUTO strategy determines the max edit distance based on the length of the term:
 * - terms of length {0, 1, 2} must match exactly,
 * - terms of length {3, 4, 5} have one edit allowed,
 * - terms longer than 5 have two edits allowed.
 *
 * AUTO should generally be the preferred value for the edit distance.
 */
type MaxEditDistance = "AUTO" | "LEVENSHTEIN_ZERO" | "LEVENSHTEIN_ONE" | "LEVENSHTEIN_TWO";
/**
 * A token that can be used to access the media item. This token is only valid for a limited time and can be used to access the media item without authentication repeatedly during the lifetime of the token.
 * This token will only be present if explicitly requested by the client by setting  `referenceSigningOptions.signMediaReferences` to true in the endpoints that support it.
 * This token can only be generated for media items that are backed by a media set view datasource.
 * This token will not be generated for media items in arrays.
 * NOTE: This token is generated for the calling user and should not be shared.
 */
type MediaItemReadToken = string;
/**
 * Reference to a media set item containing the media
 */
interface MediaItemReference {
    mediaItemRid: MediaItemRid$1;
    mediaSetRid: MediaSetRid$1;
}
/**
 * The identifier of the media item in the media set backing the media
 */
type MediaItemRid$1 = string;
/**
 * A reference to an immutable piece of media.
 */
interface MediaReference$1 {
    mimeType: MimeType$1;
    reference: MediaValueReference;
}
/**
 * An object property value that represents a MediaReference.
 */
type MediaReferencePropertyValue = MediaReference$1;
/**
 * The identifier of the media set backing the media
 */
type MediaSetRid$1 = string;
/**
 * The identifier of the media set view backing the media
 */
type MediaSetViewRid$1 = string;
interface MediaValueReference_mediaItem {
    type: "mediaItem";
    mediaItem: MediaItemReference;
}
interface MediaValueReference_mediaViewItem {
    type: "mediaViewItem";
    mediaViewItem: MediaViewItemReference$1;
}
interface MediaValueReference_datasetFile {
    type: "datasetFile";
    datasetFile: DatasetFileReference;
}
/**
 * A reference to media contained in either a media set or a dataset.
 */
type MediaValueReference = MediaValueReference_mediaItem | MediaValueReference_mediaViewItem | MediaValueReference_datasetFile;
/**
 * Reference to a media set view item containing the media
 */
interface MediaViewItemReference$1 {
    mediaItemRid: MediaItemRid$1;
    mediaSetRid: MediaSetRid$1;
    mediaSetViewRid: MediaSetViewRid$1;
    token?: MediaItemReadToken | null | undefined;
}
/**
 * Object Set which has not yet been resolved into a concrete definition and acts as a method input parameter.
 *
 * Allows for constructing object-sets which can act as methods.
 *
 * An attempt to compute such object-set in object loading or aggregation endpoints will end up with an error.
 */
interface MethodInputObjectSet {
}
/**
 * Defines links computed at runtime based on the supplied object set method.
 */
interface MethodLinkDefinition {
    method: ObjectSet;
}
/**
 * Expected to match mime format from  https://www.iana.org/assignments/media-types/media-types.xhtml
 */
type MimeType$1 = string;
/**
 * This filter analyzes the query string.
 * The output of the analysis of a string are called tokens, for example the string "The Quick Brown Fox"
 * produces the tokens "the", "quick", "brown", "fox" using the default analyzer.
 *
 * An object matches a MultiMatchFilter iff the tokens for the specified query match exactly
 * any of the tokens from values in the properties specified in the PropertySet.
 *
 * For example, a query with "The Quick Brown Fox" for a property with the default analyzer
 * queries for `"the" OR "quick" OR "brown" OR "fox"`, so would match "The brown fox jumped over the fence".
 *
 * Additional Japanese query behavior:
 *
 * Custom tokenization gets applied against properties that use the standard analyzer
 * if the query includes at least one Han or hiragana character
 * and contains no characters that are not Han, hiragana, katakana, alphanumerics, or punctuation.
 *
 * In the custom tokenization, a sequence of the following characters is considered one token: Han and
 * hiragana, katakana, alphabets, or numbers. For example, the string "はねだ空港ターミナルA発バス231" produces the
 * tokens "はねだ空港", "ターミナル", "A", "発", "バス", "231."
 *
 * Each token is treated as a PhraseFilter, so any multi-token Japanese query string results in
 * AndFilter or OrFilter of PhraseFilters, depending upon the MultiMatch operator used.
 * The PhraseFilter's PhraseMatch mode is determined by the following rules:
 *
 * - Any token except for the last token is treated with PhraseMatchMode.PHRASE.
 * - If the last token is a Han/hiragana sequence, PhraseMatchMode.PHRASE gets applied to the token.
 * - If the last token is katakana or alphanumeric, PhraseMatchMode.PHRASE_PREFIX get applied to the token.
 *
 * If all properties uses the standard analyzer, the And/Or of PhraseFilters is applied across all properties,
 * which means that if multiple properties are included in the PropertySet, the operator is AND, and the full set
 * of tokens in the query exists across the PropertySet properties, the Japanese behavior will return a match,
 * even if the full set of tokens are not present within the value of any one property,
 */
interface MultiMatchFilter$1 {
    fuzziness?: Fuzziness | null | undefined;
    fuzzy?: boolean | null | undefined;
    operator?: MultiMatchFilterOperator$1 | null | undefined;
    propertySet: PropertySet$1;
    query: string;
}
/**
 * AND or OR.
 */
type MultiMatchFilterOperator$1 = "AND" | "OR";
/**
 * The current user's attributes under the given key. This resolves to a list of values.
 */
interface MultipassAttribute$1 {
    key: MultipassAttributeKey;
}
/**
 * The key of the Multipass attribute.
 */
type MultipassAttributeKey = string;
/**
 * The current user's Multipass user id.
 */
interface MultipassUserId$1 {
}
/**
 * Defines links based on the supplied relation identifier.
 */
interface NativeLinkDefinition {
    linkedRelationSide?: LinkedPropertyRelationSide | null | undefined;
    relationIdentifier: RelationIdentifier;
}
/**
 * An object matches a NotFilter iff it does not match the provided filter.
 */
interface NotFilter$1 {
    filter: ObjectSetFilter$1;
}
/**
 * Variant representing a null value. Null values are currently expected to only be returned inside array
 * property values - no property value will be otherwise returned for properties that do not have a value, or
 * where that value is null.
 */
interface NullPropertyValue {
}
/**
 * An operation on two property nodes for the purposes of defining a derived property.
 */
interface NumericBinaryOperation {
    leftOperand: NumericOutputCalculation;
    rightOperand: NumericOutputCalculation;
}
interface NumericLiteral_double {
    type: "double";
    double: DoubleLiteral;
}
/**
 * A literal value for the purposes of defining a derived property via a numeric operation.
 */
type NumericLiteral = NumericLiteral_double;
interface NumericOperation_add {
    type: "add";
    add: NumericBinaryOperation;
}
interface NumericOperation_subtract {
    type: "subtract";
    subtract: NumericBinaryOperation;
}
interface NumericOperation_divide {
    type: "divide";
    divide: NumericBinaryOperation;
}
interface NumericOperation_multiply {
    type: "multiply";
    multiply: NumericBinaryOperation;
}
interface NumericOperation_negate {
    type: "negate";
    negate: NumericUnaryOperation;
}
interface NumericOperation_absolute {
    type: "absolute";
    absolute: NumericUnaryOperation;
}
interface NumericOperation_max {
    type: "max";
    max: NumericBinaryOperation;
}
interface NumericOperation_min {
    type: "min";
    min: NumericBinaryOperation;
}
/**
 * An operation on one or two property nodes for the purposes of defining a derived property.
 */
type NumericOperation = NumericOperation_add | NumericOperation_subtract | NumericOperation_divide | NumericOperation_multiply | NumericOperation_negate | NumericOperation_absolute | NumericOperation_max | NumericOperation_min;
interface NumericOutputCalculation_operation {
    type: "operation";
    operation: NumericOperation;
}
interface NumericOutputCalculation_literal {
    type: "literal";
    literal: NumericLiteral;
}
interface NumericOutputCalculation_propertyId {
    type: "propertyId";
    propertyId: PropertyId$1;
}
interface NumericOutputCalculation_property {
    type: "property";
    property: DerivedPropertyDefinition;
}
interface NumericOutputCalculation_fromDateTimeCalculation {
    type: "fromDateTimeCalculation";
    fromDateTimeCalculation: DateTimeToNumericCalculation;
}
/**
 * A calculation node that is used to define a derived property via a numeric operation.
 */
type NumericOutputCalculation = NumericOutputCalculation_operation | NumericOutputCalculation_literal | NumericOutputCalculation_propertyId | NumericOutputCalculation_property | NumericOutputCalculation_fromDateTimeCalculation;
/**
 * An operation on one property node for the purposes of defining a derived property.
 */
interface NumericUnaryOperation {
    operand: NumericOutputCalculation;
}
interface ObjectIdentifier_objectRid {
    type: "objectRid";
    objectRid: ObjectRid$1;
}
interface ObjectIdentifier_objectLocatorV2 {
    type: "objectLocatorV2";
    objectLocatorV2: ObjectLocatorV2;
}
/**
 * Information necessary to uniquely identify an object.
 */
type ObjectIdentifier = ObjectIdentifier_objectRid | ObjectIdentifier_objectLocatorV2;
/**
 * Optional features to toggle when generating the object loading response.
 */
interface ObjectLoadingResponseOptions {
    shouldLoadObjectRids?: boolean | null | undefined;
}
/**
 * Information necessary to uniquely identify an object.
 */
interface ObjectLocatorV2 {
    objectPrimaryKey: ObjectPrimaryKeyV2;
    objectTypeRid: ObjectTypeRid$1;
}
/**
 * Optional features to toggle when generating paging responses.
 */
interface ObjectPagingResponseOptions {
    enableMemoryBasedPaging: boolean;
    requireConsistentPaging?: boolean | null | undefined;
}
/**
 * The primary key of an object.
 */
type ObjectPrimaryKeyV2 = Record<PropertyTypeRid$1, PropertyValue>;
/**
 * Resource identifier of an object.
 */
type ObjectRid$1 = string;
interface ObjectSet_base {
    type: "base";
    base: BaseObjectSet;
}
interface ObjectSet_interfaceBase {
    type: "interfaceBase";
    interfaceBase: InterfaceBaseObjectSet;
}
interface ObjectSet_static {
    type: "static";
    static: StaticObjectSet;
}
interface ObjectSet_referenced {
    type: "referenced";
    referenced: ReferencedObjectSet;
}
interface ObjectSet_filtered {
    type: "filtered";
    filtered: FilteredObjectSet;
}
interface ObjectSet_intersected {
    type: "intersected";
    intersected: IntersectedObjectSet;
}
interface ObjectSet_subtracted {
    type: "subtracted";
    subtracted: SubtractedObjectSet;
}
interface ObjectSet_unioned {
    type: "unioned";
    unioned: UnionedObjectSet;
}
interface ObjectSet_searchAround {
    type: "searchAround";
    searchAround: SearchAroundObjectSet;
}
interface ObjectSet_softLinkSearchAround {
    type: "softLinkSearchAround";
    softLinkSearchAround: SoftLinkSearchAroundObjectSet;
}
interface ObjectSet_interfaceLinkSearchAround {
    type: "interfaceLinkSearchAround";
    interfaceLinkSearchAround: InterfaceLinkSearchAroundObjectSet;
}
interface ObjectSet_asType {
    type: "asType";
    asType: AsTypeObjectSet;
}
interface ObjectSet_asBaseObjectTypes {
    type: "asBaseObjectTypes";
    asBaseObjectTypes: AsBaseObjectTypesObjectSet;
}
interface ObjectSet_knn {
    type: "knn";
    knn: KnnObjectSet;
}
interface ObjectSet_knnV2 {
    type: "knnV2";
    knnV2: KnnObjectSetV2;
}
interface ObjectSet_methodInput {
    type: "methodInput";
    methodInput: MethodInputObjectSet;
}
interface ObjectSet_withProperties {
    type: "withProperties";
    withProperties: WithPropertiesObjectSet;
}
/**
 * Supported Object Sets and Object Set operations. Refer to documentation of a particular Object Set for details.
 */
type ObjectSet = ObjectSet_base | ObjectSet_interfaceBase | ObjectSet_static | ObjectSet_referenced | ObjectSet_filtered | ObjectSet_intersected | ObjectSet_subtracted | ObjectSet_unioned | ObjectSet_searchAround | ObjectSet_softLinkSearchAround | ObjectSet_interfaceLinkSearchAround | ObjectSet_asType | ObjectSet_asBaseObjectTypes | ObjectSet_knn | ObjectSet_knnV2 | ObjectSet_methodInput | ObjectSet_withProperties;
/**
 * Additional context used to execute object set request queries.
 */
interface ObjectSetContext {
    forkRid?: ForkRid | null | undefined;
    objectSetFilterContext?: ObjectSetFilterContext | null | undefined;
    ontologyBranchRid?: OntologyBranchRid$1 | null | undefined;
    owningRid?: OwningRid | null | undefined;
    reportUsage?: boolean | null | undefined;
    snapshotId?: SnapshotId | null | undefined;
    workstateRid?: WorkstateRid | null | undefined;
}
interface ObjectSetFilter_or$1 {
    type: "or";
    or: OrFilter$1;
}
interface ObjectSetFilter_and$1 {
    type: "and";
    and: AndFilter$1;
}
interface ObjectSetFilter_not$1 {
    type: "not";
    not: NotFilter$1;
}
interface ObjectSetFilter_range$1 {
    type: "range";
    range: RangeFilter$1;
}
interface ObjectSetFilter_wildcard$1 {
    type: "wildcard";
    wildcard: WildcardFilter$1;
}
interface ObjectSetFilter_terms$1 {
    type: "terms";
    terms: TermsFilter$1;
}
interface ObjectSetFilter_exactMatch$1 {
    type: "exactMatch";
    exactMatch: ExactMatchFilter$1;
}
interface ObjectSetFilter_phrase$1 {
    type: "phrase";
    phrase: PhraseFilter$1;
}
interface ObjectSetFilter_prefixOnLastToken$1 {
    type: "prefixOnLastToken";
    prefixOnLastToken: PrefixOnLastTokenFilter$1;
}
interface ObjectSetFilter_geoBoundingBox$1 {
    type: "geoBoundingBox";
    geoBoundingBox: GeoBoundingBoxFilter$1;
}
interface ObjectSetFilter_geoDistance$1 {
    type: "geoDistance";
    geoDistance: GeoDistanceFilter$1;
}
interface ObjectSetFilter_geoPolygon$1 {
    type: "geoPolygon";
    geoPolygon: GeoPolygonFilter$1;
}
interface ObjectSetFilter_geoShape$1 {
    type: "geoShape";
    geoShape: GeoShapeFilter$1;
}
interface ObjectSetFilter_objectType$1 {
    type: "objectType";
    objectType: ObjectTypeFilter$1;
}
interface ObjectSetFilter_interfaceType {
    type: "interfaceType";
    interfaceType: InterfaceTypeFilter;
}
interface ObjectSetFilter_hasProperty$1 {
    type: "hasProperty";
    hasProperty: HasPropertyFilter$1;
}
interface ObjectSetFilter_linkPresence$1 {
    type: "linkPresence";
    linkPresence: ApproximateLinkPresenceFilter;
}
interface ObjectSetFilter_objectSetLink {
    type: "objectSetLink";
    objectSetLink: ObjectSetLinkFilter;
}
interface ObjectSetFilter_objectSetInterfaceLink {
    type: "objectSetInterfaceLink";
    objectSetInterfaceLink: ObjectSetInterfaceLinkFilter;
}
interface ObjectSetFilter_multiMatch$1 {
    type: "multiMatch";
    multiMatch: MultiMatchFilter$1;
}
interface ObjectSetFilter_relativeDateRange$1 {
    type: "relativeDateRange";
    relativeDateRange: RelativeDateRangeFilter$1;
}
interface ObjectSetFilter_relativeTimeRange$1 {
    type: "relativeTimeRange";
    relativeTimeRange: RelativeTimeRangeFilter$1;
}
interface ObjectSetFilter_parameterizedRange$1 {
    type: "parameterizedRange";
    parameterizedRange: ParameterizedRangeFilter$1;
}
interface ObjectSetFilter_parameterizedWildcard$1 {
    type: "parameterizedWildcard";
    parameterizedWildcard: ParameterizedWildcardFilter$1;
}
interface ObjectSetFilter_parameterizedTerms$1 {
    type: "parameterizedTerms";
    parameterizedTerms: ParameterizedTermsFilter$1;
}
interface ObjectSetFilter_parameterizedExactMatch$1 {
    type: "parameterizedExactMatch";
    parameterizedExactMatch: ParameterizedExactMatchFilter$1;
}
interface ObjectSetFilter_parameterizedPrefixOnLastToken {
    type: "parameterizedPrefixOnLastToken";
    parameterizedPrefixOnLastToken: ParameterizedPrefixOnLastTokenFilter;
}
interface ObjectSetFilter_userContext$1 {
    type: "userContext";
    userContext: UserContextFilter$1;
}
/**
 * Filter to be applied to an Object Set. Refer to documentation of a particular ObjectSetFilter for details.
 */
type ObjectSetFilter$1 = ObjectSetFilter_or$1 | ObjectSetFilter_and$1 | ObjectSetFilter_not$1 | ObjectSetFilter_range$1 | ObjectSetFilter_wildcard$1 | ObjectSetFilter_terms$1 | ObjectSetFilter_exactMatch$1 | ObjectSetFilter_phrase$1 | ObjectSetFilter_prefixOnLastToken$1 | ObjectSetFilter_geoBoundingBox$1 | ObjectSetFilter_geoDistance$1 | ObjectSetFilter_geoPolygon$1 | ObjectSetFilter_geoShape$1 | ObjectSetFilter_objectType$1 | ObjectSetFilter_interfaceType | ObjectSetFilter_hasProperty$1 | ObjectSetFilter_linkPresence$1 | ObjectSetFilter_objectSetLink | ObjectSetFilter_objectSetInterfaceLink | ObjectSetFilter_multiMatch$1 | ObjectSetFilter_relativeDateRange$1 | ObjectSetFilter_relativeTimeRange$1 | ObjectSetFilter_parameterizedRange$1 | ObjectSetFilter_parameterizedWildcard$1 | ObjectSetFilter_parameterizedTerms$1 | ObjectSetFilter_parameterizedExactMatch$1 | ObjectSetFilter_parameterizedPrefixOnLastToken | ObjectSetFilter_userContext$1;
/**
 * Overrides for unresolved filter parameters in used parameterized object set filters.
 */
interface ObjectSetFilterContext {
    parameterOverrides: Record<UnresolvedFilterParameterId, FilterValue$1>;
}
/**
 * Matches iff it contains a link to any object in the provided objectSet, along the provided Interface Link
 * Type specified by the InterfaceLinkTypeRid, and if the starting object is on the SOURCE side of the
 * Interface Link Type.
 *
 * The SOURCE side is the Interface Type that the Interface Link Type belongs to.
 */
interface ObjectSetInterfaceLinkFilter {
    interfaceLinkTypeRid: InterfaceLinkTypeRid$1;
    objectSet: ObjectSet;
}
/**
 * Matches iff it contains a link to any object in the provided objectSet, along the provided RelationId, and if
 * the starting object is on the provided RelationSide of the relation.
 */
interface ObjectSetLinkFilter {
    objectSet: ObjectSet;
    relationId: RelationId$1;
    relationSide: RelationSide$1;
}
/**
 * Resource identifier of an Object Set.
 */
type ObjectSetRid = string;
interface ObjectsSelection_objects {
    type: "objects";
    objects: Array<ObjectIdentifier>;
}
/**
 * Union type for selecting objects to be queried along links.
 */
type ObjectsSelection = ObjectsSelection_objects;
/**
 * An object matches an ObjectTypeFilter iff its ObjectTypeId matches the provided ObjectTypeId.
 */
interface ObjectTypeFilter$1 {
    objectTypeId: ObjectTypeId$1;
}
/**
 * Id of an object type.
 */
type ObjectTypeId$1 = string;
interface ObjectTypeOrInterfaceTypeIdentifier_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid$1;
}
interface ObjectTypeOrInterfaceTypeIdentifier_interfaceTypeRid {
    type: "interfaceTypeRid";
    interfaceTypeRid: InterfaceTypeRid$1;
}
/**
 * Identifier of an object type or interface type.
 */
type ObjectTypeOrInterfaceTypeIdentifier = ObjectTypeOrInterfaceTypeIdentifier_objectTypeRid | ObjectTypeOrInterfaceTypeIdentifier_interfaceTypeRid;
/**
 * A unique identifier of an object type.
 */
type ObjectTypeRid$1 = string;
/**
 * A unique identifier for an ontology branch.
 */
type OntologyBranchRid$1 = string;
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an OrFilter iff it matches at least one of the filters.
 */
interface OrFilter$1 {
    filters: Array<ObjectSetFilter$1>;
}
/**
 * Resource identifier of a gatekeeper resource which OSS can use to permission additional metadata about
 * the execution of requests.
 * For requests that run with Backend.HIGHBURY, this owning rid will be used as Spark Reporter's
 * "owning rid" and therefore anyone who has the "foundry:read-data" operation on this rid as well as the
 * data involved in the queried object set will be able to see associated metadata, for example spark query
 * plans and rdd graphs.
 * For requests which require embeddings generation through LMS, this owning rid will be used as the attribution
 * rid for the request to LMS. If no owning rid is provided, user attribution is used instead for the LMS request.
 */
type OwningRid = string;
/**
 * A reference to the next page of results.
 */
type PageToken = string;
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, the index for that property must define a .raw multifield of type keyword.
 * If no terms are provided, this filter will match ALL objects.
 */
interface ParameterizedExactMatchFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    terms: Array<FilterParameter$1>;
}
/**
 * Behaves the same as PrefixOnLastTokenFilter, except the query is parameterized.
 *
 * Consult PrefixOnLastTokenFilter docs for more details.
 */
interface ParameterizedPrefixOnLastTokenFilter {
    propertyIdentifier: PropertyIdentifier;
    query: FilterParameter$1;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface ParameterizedRangeFilter$1 {
    gt?: FilterParameter$1 | null | undefined;
    gte?: FilterParameter$1 | null | undefined;
    lt?: FilterParameter$1 | null | undefined;
    lte?: FilterParameter$1 | null | undefined;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * An object matches a TermsFilter iff the analyzed value of the provided property matches any of the provided
 * terms, or in case when no property is provided - iff analyzed value of any of the native properties matches
 * any of the provided terms; runtime derived properties will be ignored.
 *
 * If no terms are provided, this filter will match ALL objects.
 */
interface ParameterizedTermsFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    terms: Array<FilterParameter$1>;
}
/**
 * An object matches a WildcardFilter iff the value of the provided property matches the provided term, or in
 * case when no property is provided - iff any of the native properties match the provided term; runtime derived
 * properties will be ignored.
 */
interface ParameterizedWildcardFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    term: FilterParameter$1;
}
/**
 * This filter analyzes the query string if the underlying property is searchable. Otherwise, the filter is
 * effectively an ExactMatch filter in PhraseMatchMode.PHRASE mode and a WildcardFilter in
 * PhraseMatchMode.PHRASE_PREFIX mode.
 *
 * The output of the analysis of a string are called tokens, for example the string "The Quick Brown Fox"
 * produces the tokens "the", "quick", "brown", "fox" using the default analyzer.
 *
 * An object matches a PhraseFilter iff tokens from specified phrase match tokens for the specified property set
 * according to the PhraseMatchMode specified.
 *
 * For example, a query with phrase "The Quick Brown Fox" and PhraseMatchMode.PHRASE for a property with the
 * default analyzer will match `"the" followed by "quick" followed by "brown" followed by "fox"`.
 * So this would match "The quick brown fox is climbing the tree",
 * but not "The Quick brown foxy bear" (does not include term "fox"),
 * nor "the brown rabbit met the quick fox near the river" (not the expected order of tokens),
 * nor "the quick smart and fast brown fox" (more terms than expected in-between prior terms).
 *
 * With PhraseMatchMode.PHRASE_PREFIX and phrase "The Quick Brown F" for a property with the default analyzer,
 * the query would match `"the" followed by "quick" followed by "brown" followed by "f*"`.
 * However, note that "f*" has a behavior different than the wildcard filter:
 *
 * - Against Phonograph, this will result in a `match_phrase_prefix` Elasticsearch query, which means that
 * "f*" matches only the first 50 tokens, in alphabetical order, that begin with "f" amongst all tokens for
 * all values for the specified properties.
 * - Against Highbury, this will use a lucene `SpanNearQuery`, which has the same behavior.
 *
 * So this filter could not match an object with "I saw the quick brown fox climbing the tree" if there more
 * than 50 tokens that start with "f" before "fox", e.g. "face", "fail", "fair".
 * We recommend using the `PrefixOnLastTokenFilter` instead, which does not have the same token order guarantees
 * as the phrase filter, but does allow for a wildcard matches on the last term.
 *
 * Unless MultiMatchFilter and PrefixOnLastTokenFilter, PhraseFilter has no special behavior for Japanese
 * text queries, because results match user expectations without the need for extra logic.
 */
interface PhraseFilter$1 {
    matchMode?: PhraseMatchMode$1 | null | undefined;
    phrase: string;
    propertySet?: PropertySet$1 | null | undefined;
}
/**
 * Defines how phrase search matches results.
 */
type PhraseMatchMode$1 = "PHRASE" | "PHRASE_PREFIX";
/**
 * This filter analyzes the query string if the underlying property is searchable. Otherwise, the filter
 * effectively works like a simple prefix query and the query string isn't tokenized.
 *
 * The output of the analysis of a string are called tokens, for example the string "The Quick Brown Fox"
 * produces the tokens "the", "quick", "brown", "fox" using the default analyzer.
 *
 * An object matches a PrefixOnLastTokenFilter iff the tokens for the specified query match all tokens from
 * the specified property, using exact match for every token except for the last, and prefix match for the last
 * token.
 * Ordering of tokens in the query string is not checked when performing the matches.
 * If the field is not analyzed, the filter will be equivalent to a Wildcard filter, as we analyze the query
 * string with the property analyzer (which is identity for a non-analyzed property).
 *
 * For example, a query with "The Quick Brown F" for a property with the default analyzer queries for
 * `"the" AND "quick" AND "brown" AND "f*"`, so would match "the brown fox reached the quick rabbit" but not
 * "the fox quickly jumped over the brown fence".
 *
 * Only works on string properties. OSS will throw an exception if the property type is not string.
 *
 * Additional Japanese query behavior:
 *
 * Custom tokenization gets applied iff a filter has Japanese query string and uses standard analyzer. If it uses
 * non-standard analyzer, it does not tokenize the string, assuming the given analyzer can handle Japanese query.
 *
 * In the custom tokenization, a sequence of the following characters is considered as one token: Han and
 * Hiragana, Katakana, Alphabets, or numbers. For example, the string "はねだ空港ターミナルA発バス231" produces the
 * tokens "はねだ空港", "ターミナル", "A", "発", "バス", "231" using JapaneseTokenization.
 *
 * Each tokenized string are treated as PhraseFilter, so any multi-token Japanese query string results in
 * AndFilter of PhraseFilters of each token. Also, in tokenized AndFilter, phrase mode for each token
 * PhraseFilter depends on its character type it sets the phrase mode is set following the rules below:
 *
 * - Any token except for the last token is treated with PhraseMatchMode.PHRASE.
 * - If the last token is Han and Hiragana, PhraseMatchMode.PHRASE gets applied to the token.
 * - If the last token is Katakana or Alphanumerics, PhraseMatchMode.PHRASE_PREFIX get applied to the token.
 */
interface PrefixOnLastTokenFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    query: string;
}
/**
 * Specifies the primary key property of an object type which is present on all object types.
 */
interface PrimaryKeyProperty {
}
/**
 * API name of a property type or shared property type.
 */
type PropertyApiName = string;
/**
 * Id of a property.
 */
type PropertyId$1 = string;
interface PropertyIdentifier_propertyId {
    type: "propertyId";
    propertyId: PropertyId$1;
}
interface PropertyIdentifier_propertyApiName {
    type: "propertyApiName";
    propertyApiName: PropertyApiName;
}
interface PropertyIdentifier_structFieldSelector {
    type: "structFieldSelector";
    structFieldSelector: StructFieldSelector;
}
interface PropertyIdentifier_titleProperty {
    type: "titleProperty";
    titleProperty: TitleProperty;
}
interface PropertyIdentifier_primaryKeyProperty {
    type: "primaryKeyProperty";
    primaryKeyProperty: PrimaryKeyProperty;
}
/**
 * Identifier of a property.
 */
type PropertyIdentifier = PropertyIdentifier_propertyId | PropertyIdentifier_propertyApiName | PropertyIdentifier_structFieldSelector | PropertyIdentifier_titleProperty | PropertyIdentifier_primaryKeyProperty;
/**
 * A mapping from the property of one ObjectType to the property of another. The two properties must share
 * the same Shared Property Type. One of the properties must be a primary key.
 */
interface PropertyMapping {
    fromProperty: PropertyTypeIdentifier$2;
    toProperty: PropertyTypeIdentifier$2;
}
interface PropertySet_propertyWhitelist$1 {
    type: "propertyWhitelist";
    propertyWhitelist: PropertyWhitelistPropertySet$1;
}
interface PropertySet_allProperties$1 {
    type: "allProperties";
    allProperties: AllPropertiesPropertySet$1;
}
/**
 * Specification of a subset of properties to use.
 */
type PropertySet$1 = PropertySet_propertyWhitelist$1 | PropertySet_allProperties$1;
/**
 * An identifier of a PropertyType including the ObjectTypeRid it belongs to.
 */
interface PropertyTypeIdentifier$2 {
    objectTypeRid: ObjectTypeRid$1;
    propertyTypeRid: PropertyTypeRid$1;
}
/**
 * A unique identifier of a property type.
 */
type PropertyTypeRid$1 = string;
interface PropertyValue_array {
    type: "array";
    array: ArrayPropertyValue;
}
interface PropertyValue_attachment {
    type: "attachment";
    attachment: AttachmentPropertyValue;
}
interface PropertyValue_boolean {
    type: "boolean";
    boolean: BooleanPropertyValue;
}
interface PropertyValue_cipherText {
    type: "cipherText";
    cipherText: CipherTextPropertyValue;
}
interface PropertyValue_date {
    type: "date";
    date: DatePropertyValue;
}
interface PropertyValue_decimal {
    type: "decimal";
    decimal: DecimalPropertyValue;
}
interface PropertyValue_double {
    type: "double";
    double: DoublePropertyValue;
}
interface PropertyValue_geoPoint {
    type: "geoPoint";
    geoPoint: GeoPointPropertyValue;
}
interface PropertyValue_geoShape {
    type: "geoShape";
    geoShape: GeoShapePropertyValue;
}
interface PropertyValue_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferencePropertyValue;
}
interface PropertyValue_integer {
    type: "integer";
    integer: IntegerPropertyValue;
}
interface PropertyValue_long {
    type: "long";
    long: LongPropertyValue;
}
interface PropertyValue_marking {
    type: "marking";
    marking: MarkingPropertyValue;
}
interface PropertyValue_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferencePropertyValue;
}
interface PropertyValue_null {
    type: "null";
    null: NullPropertyValue;
}
interface PropertyValue_string {
    type: "string";
    string: StringPropertyValue;
}
interface PropertyValue_struct {
    type: "struct";
    struct: StructPropertyValue;
}
interface PropertyValue_timeDependent {
    type: "timeDependent";
    timeDependent: TimeDependentPropertyValue$1;
}
interface PropertyValue_timestamp {
    type: "timestamp";
    timestamp: TimestampPropertyValue;
}
interface PropertyValue_vector {
    type: "vector";
    vector: VectorPropertyValue;
}
/**
 * The value of an object property.
 */
type PropertyValue = PropertyValue_array | PropertyValue_attachment | PropertyValue_boolean | PropertyValue_cipherText | PropertyValue_date | PropertyValue_decimal | PropertyValue_double | PropertyValue_geoPoint | PropertyValue_geoShape | PropertyValue_geotimeSeriesReference | PropertyValue_integer | PropertyValue_long | PropertyValue_marking | PropertyValue_mediaReference | PropertyValue_null | PropertyValue_string | PropertyValue_struct | PropertyValue_timeDependent | PropertyValue_timestamp | PropertyValue_vector;
/**
 * Use a specified subset of properties.
 */
interface PropertyWhitelistPropertySet$1 {
    properties: Array<PropertyId$1>;
    propertyIdentifiers?: Array<PropertyIdentifier> | null | undefined;
}
/**
 * Codex seriesId qualified with a time series syncRid
 */
interface QualifiedSeriesIdPropertyValue$1 {
    seriesId: SeriesIdPropertyValue$1;
    syncRid: TimeSeriesSyncRid$1;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface RangeFilter$1 {
    gt?: any | null | undefined;
    gte?: any | null | undefined;
    lt?: any | null | undefined;
    lte?: any | null | undefined;
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
}
/**
 * Object Set referencing a saved Object Set with a given ObjectSetRid.
 */
interface ReferencedObjectSet {
    objectSetRid: ObjectSetRid;
}
/**
 * Id of a relation.
 */
type RelationId$1 = string;
interface RelationIdentifier_relationId {
    type: "relationId";
    relationId: RelationId$1;
}
interface RelationIdentifier_interfaceLinkType {
    type: "interfaceLinkType";
    interfaceLinkType: InterfaceLinkTypeRid$1;
}
/**
 * Identifier of a relation.
 *
 * Note: this is currently under development and is not supported!
 */
type RelationIdentifier = RelationIdentifier_relationId | RelationIdentifier_interfaceLinkType;
/**
 * Side of a relation.
 *
 * For many-to-many link types SOURCE corresponds to object type A in the OMS many to many link definition, and
 * TARGET corresponds to object type B.
 *
 * For one-to-many link types SOURCE generally corresponds to the ONE (or primary key) side in the OMS one to
 * many link definition, and TARGET corresponds to the MANY (or foreign key) side.
 * WARNING: In the self-referential one-to-many join case, this is inverted.
 */
type RelationSide$1 = "SOURCE" | "TARGET" | "EITHER";
/**
 * An object matches a RelativeDateRangeFilter iff the value of the provided date property is within the provided
 * time range.
 */
interface RelativeDateRangeFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    sinceRelativePointInTime?: RelativePointInTime$2 | null | undefined;
    timeZoneId: TimeZoneId$2;
    untilRelativePointInTime?: RelativePointInTime$2 | null | undefined;
}
/**
 * A point in time specified in terms of distance from the time of query.
 */
interface RelativePointInTime$2 {
    timeUnit: RelativeTimeUnit$2;
    value: number;
}
/**
 * An object matches a RelativeTimeRangeFilter iff the value of the provided timestamp property is within the
 * provided time range.
 */
interface RelativeTimeRangeFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    sinceRelativeMillis?: number | null | undefined;
    untilRelativeMillis?: number | null | undefined;
}
/**
 * A relative time unit
 */
type RelativeTimeUnit$2 = "DAY" | "WEEK" | "MONTH" | "YEAR";
/**
 * A resolved filter parameter.
 */
interface ResolvedFilterParameter$1 {
    value: FilterValue$1;
}
/**
 * Optional features to enable when generating the response.
 */
interface ResponseOptions {
    includeObjectSetEntities: boolean;
    includeUsageCost?: boolean | null | undefined;
}
/**
 * ObjectSet containing all objects that are linked to objects in provided object set, and are
 * on the opposite side of the provided relation side (or in case of either, any of the sides).
 */
interface SearchAroundObjectSet {
    objectSet: ObjectSet;
    relationId: RelationId$1;
    relationSide: RelationSide$1;
}
/**
 * Codex seriesId.
 */
type SeriesIdPropertyValue$1 = string;
/**
 * A snapshot id uniquely identifies a Funnel snapshot, which represents object types versions at a specific
 * point in time. Snapshot ids should be used for scrolls, or point-in-time searches in order to guarantee
 * consistent results across view requests.
 */
type SnapshotId = string;
/**
 * ObjectSet containing all objects that are linked to objects in the provided object set, using property
 * mappings provided at runtime as opposed to providing a predefined relation.
 */
interface SoftLinkSearchAroundObjectSet {
    objectSet: ObjectSet;
    propertyMapping: PropertyMapping;
}
/**
 * Object Set containing objects with given ObjectRids.
 *
 * Note: It's more performant to use FilteredObjectSet with ExactMatchFilter on primary keys, as it saves on
 * resolving the ObjectRids to ObjectLocators which can add 100s of milliseconds to the request runtime.
 */
interface StaticObjectSet {
    objectRids: Array<ObjectRid$1>;
    provenance?: StaticObjectSetProvenance | null | undefined;
}
interface StaticObjectSetProvenance_materialization {
    type: "materialization";
    materialization: MaterializationProvenance;
}
interface StaticObjectSetProvenance_custom {
    type: "custom";
    custom: CustomProvenance;
}
/**
 * Describes the origin of the particular set of objects in a static object set.
 */
type StaticObjectSetProvenance = StaticObjectSetProvenance_materialization | StaticObjectSetProvenance_custom;
/**
 * An object property value whose type is string.
 */
type StringPropertyValue = string;
/**
 * A list of StructElements
 */
interface Struct {
    structElements: Array<StructElement$1>;
}
/**
 * Represents an entry in a struct.
 */
interface StructElement$1 {
    structElementRid: StructFieldRid$1;
    structElementValue: PropertyValue;
}
/**
 * API name of a struct field.
 */
type StructFieldApiName = string;
/**
 * A unique identifier for a field of a struct property type or struct shared property type
 */
type StructFieldRid$1 = string;
/**
 * Used to specify a specific struct field to submit a query against.
 * This feature is not supported in OSv1 (Phonograph) and will throw.
 */
interface StructFieldSelector {
    structPropertyField: StructPropertyField;
    structPropertyIdentifier: StructPropertyIdentifier;
}
/**
 * Provides means of specifying a struct field.
 */
interface StructPropertyField {
    structPropertyFieldIdentifier: StructPropertyFieldIdentifier;
}
interface StructPropertyFieldIdentifier_apiName {
    type: "apiName";
    apiName: StructFieldApiName;
}
/**
 * Struct fields can be specified by the rid or API name.
 */
type StructPropertyFieldIdentifier = StructPropertyFieldIdentifier_apiName;
interface StructPropertyIdentifier_apiName {
    type: "apiName";
    apiName: PropertyApiName;
}
/**
 * Structs can only be specified by API name for now.
 */
type StructPropertyIdentifier = StructPropertyIdentifier_apiName;
/**
 * An object property value whose type is struct.
 */
type StructPropertyValue = Struct;
/**
 * Object Set containing objects present in first provided Object Set and no other Object Sets. The return type
 * is the same as the type of the first provided Object Set.
 */
interface SubtractedObjectSet {
    objectSets: Array<ObjectSet>;
}
/**
 * A unique identifier of a codex template and optionally a codex template version which resolves to a derived
 * series. If no version is provided, the latest version is used.
 */
interface TemplateRidPropertyValue$1 {
    templateRid: string;
    templateVersion?: string | null | undefined;
}
/**
 * This filter does not analyze the query string.
 *
 * An object matches a TermsFilter iff the tokens of the provided property match any of the provided terms.
 *
 * For example, a property with value "The Quick Brown Fox", using the default analyzer, would produce the tokens
 * ["the", "quick", "brown", "fox"], and would therefore match a terms filter with "brown" as a term,
 * but not one with "Brown" or "Brown Fox" as a term.
 * It is recommended to use filter only against properties which support exact matches.
 *
 * If no property is provided, this filter will consider the tokens for all native properties; runtime derived
 * properties will be ignored.
 * If no terms are provided, this filter will match all objects.
 */
interface TermsFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    terms: Array<any>;
}
interface TimeDependentPropertyValue_seriesId$1 {
    type: "seriesId";
    seriesId: SeriesIdPropertyValue$1;
}
interface TimeDependentPropertyValue_templateRid$1 {
    type: "templateRid";
    templateRid: TemplateRidPropertyValue$1;
}
interface TimeDependentPropertyValue_qualifiedSeriesId$1 {
    type: "qualifiedSeriesId";
    qualifiedSeriesId: QualifiedSeriesIdPropertyValue$1;
}
/**
 * Identifies a time series in codex.
 * The qualifiedSeriesId variant should be used when there are multiple time series datasources backing this
 * property value (and therefore we need to specify which one to qualify with).
 */
type TimeDependentPropertyValue$1 = TimeDependentPropertyValue_seriesId$1 | TimeDependentPropertyValue_templateRid$1 | TimeDependentPropertyValue_qualifiedSeriesId$1;
/**
 * A rid identifying a time series sync.
 */
type TimeSeriesSyncRid$1 = string;
/**
 * Number of milliseconds since Unix epoch.
 */
interface TimestampLiteral {
    timestamp: number;
}
/**
 * Number of milliseconds since Unix epoch.
 */
type TimestampPropertyValue = number;
/**
 * Time to live for a temporary object set.
 */
type TimeToLive = "ONE_HOUR" | "ONE_DAY";
/**
 * An identifier of a time zone, e.g. "Europe/London" as defined by the Time Zone Database.
 */
type TimeZoneId$2 = string;
/**
 * Specifies the title property of an object type which is present on all object types.
 */
interface TitleProperty {
}
/**
 * The identifier of a transaction in a foundry dataset
 */
type TransactionRid = string;
/**
 * A collection of derived properties that can be referenced in an object set or aggregation.
 * They are ephemeral and only exist for the lifetime of a request.
 *
 * Note: There may only be a single entry for a given object type or interface type. An exception will be thrown
 * otherwise
 *
 * However, just as with properties defined in the Ontology, it is valid to add derived properties that share
 * the same PropertyIdentifier to multiple object types. We do not enforce that these derived properties should
 * share the same definition or indeed the same data type.
 */
type TypedDerivedProperties = Array<TypedDerivedPropertiesEntry>;
/**
 * A collection of derived properties acting on a single interface or object type.
 * They are ephemeral and only exist for the lifetime of a request.
 */
interface TypedDerivedPropertiesEntry {
    derivedProperties: DerivedProperties;
    objectTypeOrInterfaceIdentifier: ObjectTypeOrInterfaceTypeIdentifier;
}
/**
 * Object Set containing objects present in at least one of the provided Object Sets. When the provided Object
 * Sets have different types, the objects along with the interface views of all interfaces involved in the
 * intersection are returned.
 *
 * For example, in "Intersected(InterfaceBase(Drivable), InterfaceBase(Flyable))", the interface views
 * provided in the response will contain the views for each object type that implements at least one of the
 * Drivable and Flyable interfaces. The views for an object type will contain both the Driable view and the
 * Flyable view if the object type implements both.
 */
interface UnionedObjectSet {
    objectSets: Array<ObjectSet>;
}
/**
 * An unresolved filter parameter.
 */
interface UnresolvedFilterParameter$1 {
    defaultValue?: FilterValue$1 | null | undefined;
    description?: string | null | undefined;
    name: string;
    parameterId: UnresolvedFilterParameterId;
}
/**
 * Id of an unresolved filter parameter.
 */
type UnresolvedFilterParameterId = string;
/**
 * WARNING: this feature is not yet supported
 *
 * Estimate of the usage cost generated by this request.
 *
 * Recorded values are influenced by how much data and compute was required to carry out the request as well
 * as the owner of the resource determined by the provided `owningRid`.
 *
 * NOTE: The reported usage does not account for the Object Storage V1 cost.
 *
 * Please refer to resource management documentation for more details.
 */
interface UsageCost {
    computeUsage?: number | "NaN" | "Infinity" | "-Infinity" | null | undefined;
}
/**
 * An object matches an UserContextFilter iff the value of the provided property is exactly equal to the provided user context.
 */
interface UserContextFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    userContext: UserContextValue$1;
}
interface UserContextValue_multipassUserId$1 {
    type: "multipassUserId";
    multipassUserId: MultipassUserId$1;
}
interface UserContextValue_multipassAttribute$1 {
    type: "multipassAttribute";
    multipassAttribute: MultipassAttribute$1;
}
/**
 * Represents a value that is resolved at runtime via the context of who is querying the object set.
 */
type UserContextValue$1 = UserContextValue_multipassUserId$1 | UserContextValue_multipassAttribute$1;
interface Vector_doubleVector {
    type: "doubleVector";
    doubleVector: Array<number | "NaN" | "Infinity" | "-Infinity">;
}
/**
 * A vector of values.
 */
type Vector = Vector_doubleVector;
/**
 * An object property value whose type is vector.
 */
type VectorPropertyValue = Vector;
/**
 * This filter does not analyze the query string.
 *
 * An object matches a WildcardFilter iff the tokens of the provided property matches the term with a wildcard
 * suffix.
 *
 * For example, a query with value "The Quick Brown F" will search for tokens which match "The Quick Brown F*".
 * If searched on a property with the default analyzer with value "The Quick Brown Fox", it will not match
 * as the value tokens are ["the", "quick", "brown", "fox"].
 * It is recommended to use filter only against properties which support exact matches.
 *
 * If no property is provided, this filter will consider the tokens for all native properties; runtime derived
 * properties will be ignored.
 */
interface WildcardFilter$1 {
    propertyId?: PropertyId$1 | null | undefined;
    propertyIdentifier?: PropertyIdentifier | null | undefined;
    term: string;
}
/**
 * Object set with extra derived properties defined in the query.
 */
interface WithPropertiesObjectSet {
    derivedProperties: TypedDerivedProperties;
    objectSet: ObjectSet;
}
/**
 * Resource identifier of a Phonograph2 workstate.
 */
type WorkstateRid = string;

/**
 * Creates a temporary object set that will live for at least as long as the provided TTL, and will get deleted
 * at some point after that.
 *
 * Temporary object sets created by unscoped user tokens can only be accessed by the user that created them; a
 * gatekeeper resource is registered for every such temporary object set. NOTE: The same gatekeeper resource may
 * be reused for the same userId across different createTemporaryObjectSet requests.
 *
 * If the temporary object set is created from a build that uses a 'security-rid' output then the temp object
 * set will be secured using the relevant OutputSecurityRid for the build.
 *
 * Whenever an object set (temporary, or otherwise) referencing a temporary object set gets saved or used in
 * versioned object sets, the reference gets replaced with a full definition of the previously saved temporary
 * object. This is to ensure that they do not inherit the TTL of temporary object sets they reference.
 *
 * Please consider using temporary object sets whenever there is a need to save an object set just to be able to
 * pass it to another service without a need to persist it indefinitely.
 */
declare function createTemporaryObjectSet(ctx: ConjureContext, request: CreateTemporaryObjectSetRequest): Promise<CreateTemporaryObjectSetResponse>;

/**
 * Returns a page of all `FoundryLink`s for a given relation based on a list of object identifiers. Response will
 * contain entries for every requested object regardless of links found.
 *
 * The API supports fetching links for maximum 5_000 ObjectIdentifiers in a single request.
 * Results are always limited to the maximum of 100_000 links, without applying any particular order. Specifically,
 * this means that if total links count is above 100_000 then the whole result set should be considered partial,
 * i.e. there is no guarantee that for a given object all links have been retrieved.
 * Note that this endpoint does not check if objects referenced by the returned links actually exist. For instance,
 * when primary keys in the join table become stale, it will still return links based on the stale join table records.
 *
 * Note that this API does not support OSv1 links and will throw an exception if links provided are backed by OSv1.
 */
declare function getBulkLinksPage(ctx: ConjureContext, request: GetBulkLinksPageRequest): Promise<GetBulkLinksPageResponse>;

/**
 * AttachmentListType specifies that this parameter must be a list of Attachment rids.
 */
interface AttachmentListType {
}
/**
 * A parameter type that consists of a list of Attachment rids.
 */
interface AttachmentListValue {
    attachments: Array<string>;
}
/**
 * AttachmentType specifies that this parameter must be the rid of an Attachment.
 */
interface AttachmentType {
}
/**
 * A parameter type that consists of an Attachment rid.
 */
interface AttachmentValue {
    attachment: string;
}
/**
 * AutoGenerated is a type used to denote the user has opted for auto-generated PKs. Primary keys will be auto-generated with a random UUID. UUID primary key generation and object creation will be handled within Actions Service.
 */
interface AutoGenerated {
}
interface BaseParameterType_boolean {
    type: "boolean";
    boolean: BooleanType$1;
}
interface BaseParameterType_booleanList {
    type: "booleanList";
    booleanList: BooleanListType;
}
interface BaseParameterType_integer {
    type: "integer";
    integer: IntegerType$1;
}
interface BaseParameterType_integerList {
    type: "integerList";
    integerList: IntegerListType;
}
interface BaseParameterType_long {
    type: "long";
    long: LongType$1;
}
interface BaseParameterType_longList {
    type: "longList";
    longList: LongListType;
}
interface BaseParameterType_double {
    type: "double";
    double: DoubleType$1;
}
interface BaseParameterType_doubleList {
    type: "doubleList";
    doubleList: DoubleListType;
}
interface BaseParameterType_string {
    type: "string";
    string: StringType$1;
}
interface BaseParameterType_stringList {
    type: "stringList";
    stringList: StringListType;
}
interface BaseParameterType_decimal {
    type: "decimal";
    decimal: DecimalType$1;
}
interface BaseParameterType_decimalList {
    type: "decimalList";
    decimalList: DecimalListType;
}
interface BaseParameterType_geohash {
    type: "geohash";
    geohash: GeohashType;
}
interface BaseParameterType_geohashList {
    type: "geohashList";
    geohashList: GeohashListType;
}
interface BaseParameterType_geoshape {
    type: "geoshape";
    geoshape: GeoshapeType;
}
interface BaseParameterType_geoshapeList {
    type: "geoshapeList";
    geoshapeList: GeoshapeListType;
}
interface BaseParameterType_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: TimeSeriesReferenceType;
}
interface BaseParameterType_timestamp {
    type: "timestamp";
    timestamp: TimestampType$1;
}
interface BaseParameterType_timestampList {
    type: "timestampList";
    timestampList: TimestampListType;
}
interface BaseParameterType_date {
    type: "date";
    date: DateType$1;
}
interface BaseParameterType_dateList {
    type: "dateList";
    dateList: DateListType;
}
interface BaseParameterType_objectReference {
    type: "objectReference";
    objectReference: ObjectReferenceType;
}
interface BaseParameterType_objectReferenceList {
    type: "objectReferenceList";
    objectReferenceList: ObjectReferenceListType;
}
interface BaseParameterType_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ObjectSetRidType;
}
interface BaseParameterType_interfaceReference {
    type: "interfaceReference";
    interfaceReference: InterfaceReferenceType;
}
interface BaseParameterType_interfaceReferenceList {
    type: "interfaceReferenceList";
    interfaceReferenceList: InterfaceReferenceListType;
}
interface BaseParameterType_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ObjectTypeReferenceType;
}
interface BaseParameterType_attachment {
    type: "attachment";
    attachment: AttachmentType;
}
interface BaseParameterType_attachmentList {
    type: "attachmentList";
    attachmentList: AttachmentListType;
}
interface BaseParameterType_marking {
    type: "marking";
    marking: MarkingType$1;
}
interface BaseParameterType_markingList {
    type: "markingList";
    markingList: MarkingListType;
}
interface BaseParameterType_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferenceType;
}
interface BaseParameterType_mediaReferenceList {
    type: "mediaReferenceList";
    mediaReferenceList: MediaReferenceListType;
}
interface BaseParameterType_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferenceType;
}
interface BaseParameterType_geotimeSeriesReferenceList {
    type: "geotimeSeriesReferenceList";
    geotimeSeriesReferenceList: GeotimeSeriesReferenceListType;
}
interface BaseParameterType_struct {
    type: "struct";
    struct: StructType$1;
}
interface BaseParameterType_structList {
    type: "structList";
    structList: StructListType;
}
/**
 * All of the possible types for Parameters.
 */
type BaseParameterType = BaseParameterType_boolean | BaseParameterType_booleanList | BaseParameterType_integer | BaseParameterType_integerList | BaseParameterType_long | BaseParameterType_longList | BaseParameterType_double | BaseParameterType_doubleList | BaseParameterType_string | BaseParameterType_stringList | BaseParameterType_decimal | BaseParameterType_decimalList | BaseParameterType_geohash | BaseParameterType_geohashList | BaseParameterType_geoshape | BaseParameterType_geoshapeList | BaseParameterType_timeSeriesReference | BaseParameterType_timestamp | BaseParameterType_timestampList | BaseParameterType_date | BaseParameterType_dateList | BaseParameterType_objectReference | BaseParameterType_objectReferenceList | BaseParameterType_objectSetRid | BaseParameterType_interfaceReference | BaseParameterType_interfaceReferenceList | BaseParameterType_objectTypeReference | BaseParameterType_attachment | BaseParameterType_attachmentList | BaseParameterType_marking | BaseParameterType_markingList | BaseParameterType_mediaReference | BaseParameterType_mediaReferenceList | BaseParameterType_geotimeSeriesReference | BaseParameterType_geotimeSeriesReferenceList | BaseParameterType_struct | BaseParameterType_structList;
interface BaseParameterTypeModification_boolean {
    type: "boolean";
    boolean: BooleanType$1;
}
interface BaseParameterTypeModification_booleanList {
    type: "booleanList";
    booleanList: BooleanListType;
}
interface BaseParameterTypeModification_integer {
    type: "integer";
    integer: IntegerType$1;
}
interface BaseParameterTypeModification_integerList {
    type: "integerList";
    integerList: IntegerListType;
}
interface BaseParameterTypeModification_long {
    type: "long";
    long: LongType$1;
}
interface BaseParameterTypeModification_longList {
    type: "longList";
    longList: LongListType;
}
interface BaseParameterTypeModification_double {
    type: "double";
    double: DoubleType$1;
}
interface BaseParameterTypeModification_doubleList {
    type: "doubleList";
    doubleList: DoubleListType;
}
interface BaseParameterTypeModification_string {
    type: "string";
    string: StringType$1;
}
interface BaseParameterTypeModification_stringList {
    type: "stringList";
    stringList: StringListType;
}
interface BaseParameterTypeModification_decimal {
    type: "decimal";
    decimal: DecimalType$1;
}
interface BaseParameterTypeModification_decimalList {
    type: "decimalList";
    decimalList: DecimalListType;
}
interface BaseParameterTypeModification_geohash {
    type: "geohash";
    geohash: GeohashType;
}
interface BaseParameterTypeModification_geohashList {
    type: "geohashList";
    geohashList: GeohashListType;
}
interface BaseParameterTypeModification_geoshape {
    type: "geoshape";
    geoshape: GeoshapeType;
}
interface BaseParameterTypeModification_geoshapeList {
    type: "geoshapeList";
    geoshapeList: GeoshapeListType;
}
interface BaseParameterTypeModification_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: TimeSeriesReferenceType;
}
interface BaseParameterTypeModification_timestamp {
    type: "timestamp";
    timestamp: TimestampType$1;
}
interface BaseParameterTypeModification_timestampList {
    type: "timestampList";
    timestampList: TimestampListType;
}
interface BaseParameterTypeModification_date {
    type: "date";
    date: DateType$1;
}
interface BaseParameterTypeModification_dateList {
    type: "dateList";
    dateList: DateListType;
}
interface BaseParameterTypeModification_objectReference {
    type: "objectReference";
    objectReference: ObjectReferenceType;
}
interface BaseParameterTypeModification_objectReferenceList {
    type: "objectReferenceList";
    objectReferenceList: ObjectReferenceListType;
}
interface BaseParameterTypeModification_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ObjectSetRidType;
}
interface BaseParameterTypeModification_interfaceReference {
    type: "interfaceReference";
    interfaceReference: InterfaceReferenceTypeModification;
}
interface BaseParameterTypeModification_interfaceReferenceList {
    type: "interfaceReferenceList";
    interfaceReferenceList: InterfaceReferenceListTypeModification;
}
interface BaseParameterTypeModification_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ObjectTypeReferenceType;
}
interface BaseParameterTypeModification_attachment {
    type: "attachment";
    attachment: AttachmentType;
}
interface BaseParameterTypeModification_attachmentList {
    type: "attachmentList";
    attachmentList: AttachmentListType;
}
interface BaseParameterTypeModification_marking {
    type: "marking";
    marking: MarkingType$1;
}
interface BaseParameterTypeModification_markingList {
    type: "markingList";
    markingList: MarkingListType;
}
interface BaseParameterTypeModification_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferenceType;
}
interface BaseParameterTypeModification_mediaReferenceList {
    type: "mediaReferenceList";
    mediaReferenceList: MediaReferenceListType;
}
interface BaseParameterTypeModification_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferenceType;
}
interface BaseParameterTypeModification_geotimeSeriesReferenceList {
    type: "geotimeSeriesReferenceList";
    geotimeSeriesReferenceList: GeotimeSeriesReferenceListType;
}
interface BaseParameterTypeModification_struct {
    type: "struct";
    struct: StructType$1;
}
interface BaseParameterTypeModification_structList {
    type: "structList";
    structList: StructListType;
}
/**
 * All of the possible types for Parameters.
 */
type BaseParameterTypeModification = BaseParameterTypeModification_boolean | BaseParameterTypeModification_booleanList | BaseParameterTypeModification_integer | BaseParameterTypeModification_integerList | BaseParameterTypeModification_long | BaseParameterTypeModification_longList | BaseParameterTypeModification_double | BaseParameterTypeModification_doubleList | BaseParameterTypeModification_string | BaseParameterTypeModification_stringList | BaseParameterTypeModification_decimal | BaseParameterTypeModification_decimalList | BaseParameterTypeModification_geohash | BaseParameterTypeModification_geohashList | BaseParameterTypeModification_geoshape | BaseParameterTypeModification_geoshapeList | BaseParameterTypeModification_timeSeriesReference | BaseParameterTypeModification_timestamp | BaseParameterTypeModification_timestampList | BaseParameterTypeModification_date | BaseParameterTypeModification_dateList | BaseParameterTypeModification_objectReference | BaseParameterTypeModification_objectReferenceList | BaseParameterTypeModification_objectSetRid | BaseParameterTypeModification_interfaceReference | BaseParameterTypeModification_interfaceReferenceList | BaseParameterTypeModification_objectTypeReference | BaseParameterTypeModification_attachment | BaseParameterTypeModification_attachmentList | BaseParameterTypeModification_marking | BaseParameterTypeModification_markingList | BaseParameterTypeModification_mediaReference | BaseParameterTypeModification_mediaReferenceList | BaseParameterTypeModification_geotimeSeriesReference | BaseParameterTypeModification_geotimeSeriesReferenceList | BaseParameterTypeModification_struct | BaseParameterTypeModification_structList;
/**
 * BooleanListType specifies that this parameter must be a list of Booleans.
 */
interface BooleanListType {
}
/**
 * A parameter value type that consists of a list of Booleans.
 */
interface BooleanListValue {
    booleans: Array<boolean>;
}
/**
 * BooleanType specifies that this parameter must be a Boolean.
 */
interface BooleanType$1 {
}
/**
 * A parameter value type that is a Boolean.
 */
type BooleanValue = boolean;
interface CbacMarkingPicker {
}
interface Checkbox {
    layout?: MultipleChoiceItemLayoutOptions | null | undefined;
}
/**
 * An id for ConditionValues stored in ObjectSetFilters
 */
type ConditionValueId = string;
interface CreateObjectOption_autoGenerated {
    type: "autoGenerated";
    autoGenerated: AutoGenerated;
}
interface CreateObjectOption_userInput {
    type: "userInput";
    userInput: UserInput;
}
type CreateObjectOption = CreateObjectOption_autoGenerated | CreateObjectOption_userInput;
interface DataValue_boolean {
    type: "boolean";
    boolean: BooleanValue;
}
interface DataValue_booleanList {
    type: "booleanList";
    booleanList: BooleanListValue;
}
interface DataValue_integer {
    type: "integer";
    integer: IntegerValue;
}
interface DataValue_integerList {
    type: "integerList";
    integerList: IntegerListValue;
}
interface DataValue_long {
    type: "long";
    long: LongValue;
}
interface DataValue_longList {
    type: "longList";
    longList: LongListValue;
}
interface DataValue_double {
    type: "double";
    double: DoubleValue;
}
interface DataValue_doubleList {
    type: "doubleList";
    doubleList: DoubleListValue;
}
interface DataValue_string {
    type: "string";
    string: StringValue;
}
interface DataValue_stringList {
    type: "stringList";
    stringList: StringListValue;
}
interface DataValue_decimal {
    type: "decimal";
    decimal: DecimalValue;
}
interface DataValue_decimalList {
    type: "decimalList";
    decimalList: DecimalListValue;
}
interface DataValue_date {
    type: "date";
    date: DateValue;
}
interface DataValue_dateList {
    type: "dateList";
    dateList: DateListValue;
}
interface DataValue_geohash {
    type: "geohash";
    geohash: GeohashValue;
}
interface DataValue_geohashList {
    type: "geohashList";
    geohashList: GeohashListValue;
}
interface DataValue_geoshape {
    type: "geoshape";
    geoshape: GeoshapeValue;
}
interface DataValue_geoshapeList {
    type: "geoshapeList";
    geoshapeList: GeoshapeListValue;
}
interface DataValue_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: TimeSeriesReferenceValue;
}
interface DataValue_timestamp {
    type: "timestamp";
    timestamp: TimestampValue;
}
interface DataValue_timestampList {
    type: "timestampList";
    timestampList: TimestampListValue;
}
interface DataValue_null {
    type: "null";
    null: NullValue;
}
interface DataValue_objectLocator {
    type: "objectLocator";
    objectLocator: ObjectLocatorValue;
}
interface DataValue_objectLocatorList {
    type: "objectLocatorList";
    objectLocatorList: ObjectLocatorListValue;
}
interface DataValue_objectType {
    type: "objectType";
    objectType: ObjectTypeValue;
}
interface DataValue_attachment {
    type: "attachment";
    attachment: AttachmentValue;
}
interface DataValue_attachmentList {
    type: "attachmentList";
    attachmentList: AttachmentListValue;
}
interface DataValue_marking {
    type: "marking";
    marking: MarkingValue;
}
interface DataValue_markingList {
    type: "markingList";
    markingList: MarkingListValue;
}
interface DataValue_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferenceValue;
}
interface DataValue_mediaReferenceList {
    type: "mediaReferenceList";
    mediaReferenceList: MediaReferenceListValue;
}
interface DataValue_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferenceValue;
}
interface DataValue_geotimeSeriesReferenceList {
    type: "geotimeSeriesReferenceList";
    geotimeSeriesReferenceList: GeotimeSeriesReferenceListValue;
}
interface DataValue_struct {
    type: "struct";
    struct: StructValue;
}
interface DataValue_structList {
    type: "structList";
    structList: StructListValue;
}
type DataValue = DataValue_boolean | DataValue_booleanList | DataValue_integer | DataValue_integerList | DataValue_long | DataValue_longList | DataValue_double | DataValue_doubleList | DataValue_string | DataValue_stringList | DataValue_decimal | DataValue_decimalList | DataValue_date | DataValue_dateList | DataValue_geohash | DataValue_geohashList | DataValue_geoshape | DataValue_geoshapeList | DataValue_timeSeriesReference | DataValue_timestamp | DataValue_timestampList | DataValue_null | DataValue_objectLocator | DataValue_objectLocatorList | DataValue_objectType | DataValue_attachment | DataValue_attachmentList | DataValue_marking | DataValue_markingList | DataValue_mediaReference | DataValue_mediaReferenceList | DataValue_geotimeSeriesReference | DataValue_geotimeSeriesReferenceList | DataValue_struct | DataValue_structList;
/**
 * DateListType specifies that this parameter must be a list of Dates.
 */
interface DateListType {
}
/**
 * A parameter value type that consists of a list of strings representing dates.
 */
interface DateListValue {
    dates: Array<string>;
}
interface DateTimePicker {
}
/**
 * DateType specifies that this parameter must be a Date.
 */
interface DateType$1 {
}
/**
 * A parameter value type that is a String representation of a date.
 */
interface DateValue {
    dateValue: string;
}
/**
 * DecimalListType specifies that this parameter must be a list of Decimals.
 */
interface DecimalListType {
    precision?: number | null | undefined;
    scale?: number | null | undefined;
}
/**
 * A parameter value type that is a list of Decimals. Each value can be returned in a scientific notation with
 * the exponent preceded by a letter 'E' followed by a '+'/'-' sign (for example 4.321E+8 or 0.332E-5).
 */
interface DecimalListValue {
    decimals: Array<string>;
}
/**
 * DecimalType specifies that this parameter must be a Decimal.
 */
interface DecimalType$1 {
    precision?: number | null | undefined;
    scale?: number | null | undefined;
}
/**
 * A parameter value type that is a Decimal. This value can be returned in a scientific notation with the
 * exponent preceded by a letter 'E' followed by a '+'/'-' sign (for example 4.321E+8 or 0.332E-5).
 */
interface DecimalValue {
    decimalValue: string;
}
interface DefaultTimezone_localTimezone {
    type: "localTimezone";
    localTimezone: LocalTimezone;
}
interface DefaultTimezone_setTimezone {
    type: "setTimezone";
    setTimezone: SpecifiedTimezone;
}
type DefaultTimezone = DefaultTimezone_localTimezone | DefaultTimezone_setTimezone;
/**
 * DoubleListType specifies that this parameter must be a list of Doubles.
 */
interface DoubleListType {
}
/**
 * A parameter value type that consists of a lists of Doubles.
 */
interface DoubleListValue {
    doubles: Array<number | "NaN" | "Infinity" | "-Infinity">;
}
/**
 * DoubleType specifies that this parameter must be a Double.
 */
interface DoubleType$1 {
}
/**
 * A parameter value type that is a Double.
 */
type DoubleValue = number | "NaN" | "Infinity" | "-Infinity";
interface Dropdown {
}
interface FilePicker {
}
/**
 * GeohashListType specifies that this parameter must be a list of Geohashes.
 */
interface GeohashListType {
}
/**
 * A parameter value type that consists of a list of Geohashes. Only WGS-84 coordinates are supported.
 */
interface GeohashListValue {
    geohashes: Array<string>;
}
/**
 * GeohashType specifies that this parameter must be a Geohash.
 */
interface GeohashType {
}
/**
 * A parameter value type that is a Geohash. Only WGS-84 coordinates are supported.
 */
interface GeohashValue {
    geohash: string;
}
/**
 * This value is guaranteed to be a valid GeoJSON.
 */
type Geoshape = any;
/**
 * GeoshapeListType specifies that this parameter must be a list of Geoshapes.
 */
interface GeoshapeListType {
}
/**
 * A parameter value type that consists of a list of Geoshapes.
 */
interface GeoshapeListValue {
    geoshapes: Array<Geoshape>;
}
/**
 * GeoshapeType specifies that this parameter must be a Geoshape.
 */
interface GeoshapeType {
}
/**
 * A parameter value type that is a Geoshape.
 */
interface GeoshapeValue {
    geoshape: Geoshape;
}
/**
 * GeotimeSeriesReferenceListType specifies that this parameter must be a list of GeotimeSeriesReferences.
 * valid allowedParameterValues: ParameterGeotimeSeriesReferenceOrEmpty
 * valid prefill DataValues: None
 */
interface GeotimeSeriesReferenceListType {
}
/**
 * A parameter type that consists of a list of GeotimeSeriesReferences.
 */
interface GeotimeSeriesReferenceListValue {
    geotimeSeriesReferences: Array<GeotimeSeriesReferenceValue>;
}
/**
 * GeotimeSeriesReferenceType specifies that this parameter must be a GeotimeSeriesReference.
 * valid allowedParameterValues: ParameterGeotimeSeriesReferenceOrEmpty
 * valid prefill DataValues: None
 */
interface GeotimeSeriesReferenceType {
}
/**
 * A parameter type that consists of a GeotimeSeriesReference.
 */
interface GeotimeSeriesReferenceValue {
    integrationRid: string;
    seriesId: string;
}
/**
 * IntegerListType specifies that this parameter must be a list of Integers.
 */
interface IntegerListType {
}
/**
 * A parameter value type that consists of a lists of Integers.
 */
interface IntegerListValue {
    integers: Array<number>;
}
/**
 * IntegerType specifies that this parameter must be an Integer.
 */
interface IntegerType$1 {
}
/**
 * A parameter value type that is an Integer.
 */
type IntegerValue = number;
/**
 * Visual intent color to apply to element.
 */
type Intent$1 = "PRIMARY" | "SUCCESS" | "WARNING" | "DANGER";
interface InterfaceReferenceListType {
    interfaceTypeRid: InterfaceTypeRid;
}
interface InterfaceReferenceListTypeModification {
    interfaceTypeRidOrIdInRequest: InterfaceTypeRidOrIdInRequest;
}
interface InterfaceReferenceType {
    interfaceTypeRid: InterfaceTypeRid;
}
interface InterfaceReferenceTypeModification {
    interfaceTypeRidOrIdInRequest: InterfaceTypeRidOrIdInRequest;
}
/**
 * Optionally specifies the min and max parameter list lengths permitted for a parameter. This type is only
 * usable with list type parameters.
 */
interface ListLengthValidation {
    maxLength?: number | null | undefined;
    minLength?: number | null | undefined;
}
/**
 * Object representing that the timezone should always be displayed to the user relative to their system timezone
 */
interface LocalTimezone {
}
/**
 * LongListType specifies that this parameter must be a list of Longs.
 */
interface LongListType {
}
/**
 * A parameter value type that consists of a lists of Longs.
 */
interface LongListValue {
    longs: Array<number>;
}
/**
 * LongType specifies that this parameter must be a Long.
 */
interface LongType$1 {
}
/**
 * A parameter value type that is a Long.
 */
type LongValue = number;
interface MandatoryMarkingPicker {
}
/**
 * MarkingListType specifies that this parameter must be a list of Markings.
 */
interface MarkingListType {
}
/**
 * A parameter type that consists of a list of Marking values.
 */
interface MarkingListValue {
    markings: Array<string>;
}
/**
 * MarkingType specifies that this parameter must be a CBAC or Madatory Marking type.
 */
interface MarkingType$1 {
}
/**
 * A parameter type that consists of Marking Values.
 */
interface MarkingValue {
    marking: string;
}
interface MediaReference_mediaSetViewItem {
    type: "mediaSetViewItem";
    mediaSetViewItem: MediaViewItemReference;
}
type MediaReference = MediaReference_mediaSetViewItem;
/**
 * MediaReferenceListType specifies that this parameter must be a list of MediaReferences.
 */
interface MediaReferenceListType {
}
/**
 * A parameter type that consists of a list of MediaReferences.
 */
interface MediaReferenceListValue {
    mediaReferences: Array<MediaReferenceValue>;
}
/**
 * MediaReferenceType specifies that this parameter must be a MediaReference.
 */
interface MediaReferenceType {
}
/**
 * A parameter type that consists of a MediaReference.
 */
interface MediaReferenceValue {
    mediaReference: MediaReference;
    mimeType: MimeType;
}
interface MediaViewItemReference {
    mediaItemRid: MediaItemRid;
    mediaSetRid: MediaSetRid;
    mediaSetViewRid: MediaSetViewRid;
}
/**
 * Expected to match mime format from  https://www.iana.org/assignments/media-types/media-types.xhtml
 */
type MimeType = string;
type MultipleChoiceItemLayoutOptions = "STACKED" | "INLINE";
interface NowValue {
}
/**
 * A parameter value type representing null.
 */
interface NullValue {
}
interface NumericInput {
}
interface ObjectLocator {
    objectTypeId: ObjectTypeId;
    primaryKey: ObjectPrimaryKey;
}
/**
 * A parameter value type that consists of a list of ObjectLocators.
 */
interface ObjectLocatorListValue {
    objectLocatorList: Array<ObjectLocator>;
}
/**
 * A parameter value type that is an ObjectLocator.
 */
type ObjectLocatorValue = ObjectLocator;
type ObjectPrimaryKey = Record<PropertyTypeId, PrimaryKeyValue>;
/**
 * ObjectReferenceListType specifies that this parameter must be a list of ObjectLocators.
 */
interface ObjectReferenceListType {
    objectTypeId: ObjectTypeId;
}
/**
 * ObjectReferenceType specifies that this parameter must be an ObjectLocator. An additional optional field maybeCreateObjectOption is included for handling upsert action types by providing flexibility of object creation from a user-specified PK or auto-generated UID PK.
 */
interface ObjectReferenceType {
    maybeCreateObjectOption?: CreateObjectOption | null | undefined;
    objectTypeId: ObjectTypeId;
}
/**
 * ObjectSetRidType specifies that this parameter must be an ObjectSetRid.
 */
interface ObjectSetRidType {
    objectTypeId: ObjectTypeId;
}
/**
 * An ObjectTypeReferenceType can be used to supply an object type to a function. This is useful for
 * addInterfaceRule where you need to specify what type of object you're creating.
 * NOTE: this is NOT an object instance.
 */
interface ObjectTypeReferenceType {
}
/**
 * A parameter value that references a specific object type.
 */
interface ObjectTypeValue {
    objectTypeId: ObjectTypeId;
}
interface OntologyIrBaseParameterType_boolean {
    type: "boolean";
    boolean: BooleanType$1;
}
interface OntologyIrBaseParameterType_booleanList {
    type: "booleanList";
    booleanList: BooleanListType;
}
interface OntologyIrBaseParameterType_integer {
    type: "integer";
    integer: IntegerType$1;
}
interface OntologyIrBaseParameterType_integerList {
    type: "integerList";
    integerList: IntegerListType;
}
interface OntologyIrBaseParameterType_long {
    type: "long";
    long: LongType$1;
}
interface OntologyIrBaseParameterType_longList {
    type: "longList";
    longList: LongListType;
}
interface OntologyIrBaseParameterType_double {
    type: "double";
    double: DoubleType$1;
}
interface OntologyIrBaseParameterType_doubleList {
    type: "doubleList";
    doubleList: DoubleListType;
}
interface OntologyIrBaseParameterType_string {
    type: "string";
    string: StringType$1;
}
interface OntologyIrBaseParameterType_stringList {
    type: "stringList";
    stringList: StringListType;
}
interface OntologyIrBaseParameterType_decimal {
    type: "decimal";
    decimal: DecimalType$1;
}
interface OntologyIrBaseParameterType_decimalList {
    type: "decimalList";
    decimalList: DecimalListType;
}
interface OntologyIrBaseParameterType_geohash {
    type: "geohash";
    geohash: GeohashType;
}
interface OntologyIrBaseParameterType_geohashList {
    type: "geohashList";
    geohashList: GeohashListType;
}
interface OntologyIrBaseParameterType_geoshape {
    type: "geoshape";
    geoshape: GeoshapeType;
}
interface OntologyIrBaseParameterType_geoshapeList {
    type: "geoshapeList";
    geoshapeList: GeoshapeListType;
}
interface OntologyIrBaseParameterType_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: TimeSeriesReferenceType;
}
interface OntologyIrBaseParameterType_timestamp {
    type: "timestamp";
    timestamp: TimestampType$1;
}
interface OntologyIrBaseParameterType_timestampList {
    type: "timestampList";
    timestampList: TimestampListType;
}
interface OntologyIrBaseParameterType_date {
    type: "date";
    date: DateType$1;
}
interface OntologyIrBaseParameterType_dateList {
    type: "dateList";
    dateList: DateListType;
}
interface OntologyIrBaseParameterType_objectReference {
    type: "objectReference";
    objectReference: OntologyIrObjectReferenceType;
}
interface OntologyIrBaseParameterType_objectReferenceList {
    type: "objectReferenceList";
    objectReferenceList: OntologyIrObjectReferenceListType;
}
interface OntologyIrBaseParameterType_objectSetRid {
    type: "objectSetRid";
    objectSetRid: OntologyIrObjectSetRidType;
}
interface OntologyIrBaseParameterType_interfaceReference {
    type: "interfaceReference";
    interfaceReference: OntologyIrInterfaceReferenceType;
}
interface OntologyIrBaseParameterType_interfaceReferenceList {
    type: "interfaceReferenceList";
    interfaceReferenceList: OntologyIrInterfaceReferenceListType;
}
interface OntologyIrBaseParameterType_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ObjectTypeReferenceType;
}
interface OntologyIrBaseParameterType_attachment {
    type: "attachment";
    attachment: AttachmentType;
}
interface OntologyIrBaseParameterType_attachmentList {
    type: "attachmentList";
    attachmentList: AttachmentListType;
}
interface OntologyIrBaseParameterType_marking {
    type: "marking";
    marking: MarkingType$1;
}
interface OntologyIrBaseParameterType_markingList {
    type: "markingList";
    markingList: MarkingListType;
}
interface OntologyIrBaseParameterType_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferenceType;
}
interface OntologyIrBaseParameterType_mediaReferenceList {
    type: "mediaReferenceList";
    mediaReferenceList: MediaReferenceListType;
}
interface OntologyIrBaseParameterType_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferenceType;
}
interface OntologyIrBaseParameterType_geotimeSeriesReferenceList {
    type: "geotimeSeriesReferenceList";
    geotimeSeriesReferenceList: GeotimeSeriesReferenceListType;
}
interface OntologyIrBaseParameterType_struct {
    type: "struct";
    struct: StructType$1;
}
interface OntologyIrBaseParameterType_structList {
    type: "structList";
    structList: StructListType;
}
/**
 * All of the possible types for Parameters.
 */
type OntologyIrBaseParameterType = OntologyIrBaseParameterType_boolean | OntologyIrBaseParameterType_booleanList | OntologyIrBaseParameterType_integer | OntologyIrBaseParameterType_integerList | OntologyIrBaseParameterType_long | OntologyIrBaseParameterType_longList | OntologyIrBaseParameterType_double | OntologyIrBaseParameterType_doubleList | OntologyIrBaseParameterType_string | OntologyIrBaseParameterType_stringList | OntologyIrBaseParameterType_decimal | OntologyIrBaseParameterType_decimalList | OntologyIrBaseParameterType_geohash | OntologyIrBaseParameterType_geohashList | OntologyIrBaseParameterType_geoshape | OntologyIrBaseParameterType_geoshapeList | OntologyIrBaseParameterType_timeSeriesReference | OntologyIrBaseParameterType_timestamp | OntologyIrBaseParameterType_timestampList | OntologyIrBaseParameterType_date | OntologyIrBaseParameterType_dateList | OntologyIrBaseParameterType_objectReference | OntologyIrBaseParameterType_objectReferenceList | OntologyIrBaseParameterType_objectSetRid | OntologyIrBaseParameterType_interfaceReference | OntologyIrBaseParameterType_interfaceReferenceList | OntologyIrBaseParameterType_objectTypeReference | OntologyIrBaseParameterType_attachment | OntologyIrBaseParameterType_attachmentList | OntologyIrBaseParameterType_marking | OntologyIrBaseParameterType_markingList | OntologyIrBaseParameterType_mediaReference | OntologyIrBaseParameterType_mediaReferenceList | OntologyIrBaseParameterType_geotimeSeriesReference | OntologyIrBaseParameterType_geotimeSeriesReferenceList | OntologyIrBaseParameterType_struct | OntologyIrBaseParameterType_structList;
interface OntologyIrDataValue_boolean {
    type: "boolean";
    boolean: BooleanValue;
}
interface OntologyIrDataValue_booleanList {
    type: "booleanList";
    booleanList: BooleanListValue;
}
interface OntologyIrDataValue_integer {
    type: "integer";
    integer: IntegerValue;
}
interface OntologyIrDataValue_integerList {
    type: "integerList";
    integerList: IntegerListValue;
}
interface OntologyIrDataValue_long {
    type: "long";
    long: LongValue;
}
interface OntologyIrDataValue_longList {
    type: "longList";
    longList: LongListValue;
}
interface OntologyIrDataValue_double {
    type: "double";
    double: DoubleValue;
}
interface OntologyIrDataValue_doubleList {
    type: "doubleList";
    doubleList: DoubleListValue;
}
interface OntologyIrDataValue_string {
    type: "string";
    string: StringValue;
}
interface OntologyIrDataValue_stringList {
    type: "stringList";
    stringList: StringListValue;
}
interface OntologyIrDataValue_decimal {
    type: "decimal";
    decimal: DecimalValue;
}
interface OntologyIrDataValue_decimalList {
    type: "decimalList";
    decimalList: DecimalListValue;
}
interface OntologyIrDataValue_date {
    type: "date";
    date: DateValue;
}
interface OntologyIrDataValue_dateList {
    type: "dateList";
    dateList: DateListValue;
}
interface OntologyIrDataValue_geohash {
    type: "geohash";
    geohash: GeohashValue;
}
interface OntologyIrDataValue_geohashList {
    type: "geohashList";
    geohashList: GeohashListValue;
}
interface OntologyIrDataValue_geoshape {
    type: "geoshape";
    geoshape: GeoshapeValue;
}
interface OntologyIrDataValue_geoshapeList {
    type: "geoshapeList";
    geoshapeList: GeoshapeListValue;
}
interface OntologyIrDataValue_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: OntologyIrTimeSeriesReferenceValue;
}
interface OntologyIrDataValue_timestamp {
    type: "timestamp";
    timestamp: TimestampValue;
}
interface OntologyIrDataValue_timestampList {
    type: "timestampList";
    timestampList: TimestampListValue;
}
interface OntologyIrDataValue_null {
    type: "null";
    null: NullValue;
}
interface OntologyIrDataValue_objectLocator {
    type: "objectLocator";
    objectLocator: OntologyIrObjectLocatorValue;
}
interface OntologyIrDataValue_objectLocatorList {
    type: "objectLocatorList";
    objectLocatorList: OntologyIrObjectLocatorListValue;
}
interface OntologyIrDataValue_objectType {
    type: "objectType";
    objectType: OntologyIrObjectTypeValue;
}
interface OntologyIrDataValue_attachment {
    type: "attachment";
    attachment: AttachmentValue;
}
interface OntologyIrDataValue_attachmentList {
    type: "attachmentList";
    attachmentList: AttachmentListValue;
}
interface OntologyIrDataValue_marking {
    type: "marking";
    marking: MarkingValue;
}
interface OntologyIrDataValue_markingList {
    type: "markingList";
    markingList: MarkingListValue;
}
interface OntologyIrDataValue_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferenceValue;
}
interface OntologyIrDataValue_mediaReferenceList {
    type: "mediaReferenceList";
    mediaReferenceList: MediaReferenceListValue;
}
interface OntologyIrDataValue_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferenceValue;
}
interface OntologyIrDataValue_geotimeSeriesReferenceList {
    type: "geotimeSeriesReferenceList";
    geotimeSeriesReferenceList: GeotimeSeriesReferenceListValue;
}
interface OntologyIrDataValue_struct {
    type: "struct";
    struct: StructValue;
}
interface OntologyIrDataValue_structList {
    type: "structList";
    structList: StructListValue;
}
type OntologyIrDataValue = OntologyIrDataValue_boolean | OntologyIrDataValue_booleanList | OntologyIrDataValue_integer | OntologyIrDataValue_integerList | OntologyIrDataValue_long | OntologyIrDataValue_longList | OntologyIrDataValue_double | OntologyIrDataValue_doubleList | OntologyIrDataValue_string | OntologyIrDataValue_stringList | OntologyIrDataValue_decimal | OntologyIrDataValue_decimalList | OntologyIrDataValue_date | OntologyIrDataValue_dateList | OntologyIrDataValue_geohash | OntologyIrDataValue_geohashList | OntologyIrDataValue_geoshape | OntologyIrDataValue_geoshapeList | OntologyIrDataValue_timeSeriesReference | OntologyIrDataValue_timestamp | OntologyIrDataValue_timestampList | OntologyIrDataValue_null | OntologyIrDataValue_objectLocator | OntologyIrDataValue_objectLocatorList | OntologyIrDataValue_objectType | OntologyIrDataValue_attachment | OntologyIrDataValue_attachmentList | OntologyIrDataValue_marking | OntologyIrDataValue_markingList | OntologyIrDataValue_mediaReference | OntologyIrDataValue_mediaReferenceList | OntologyIrDataValue_geotimeSeriesReference | OntologyIrDataValue_geotimeSeriesReferenceList | OntologyIrDataValue_struct | OntologyIrDataValue_structList;
interface OntologyIrInterfaceReferenceListType {
    interfaceTypeRid: InterfaceTypeApiName;
}
interface OntologyIrInterfaceReferenceType {
    interfaceTypeRid: InterfaceTypeApiName;
}
interface OntologyIrObjectLocator {
    objectTypeId: ObjectTypeApiName;
    primaryKey: OntologyIrObjectPrimaryKey;
}
/**
 * A parameter value type that consists of a list of ObjectLocators.
 */
interface OntologyIrObjectLocatorListValue {
    objectLocatorList: Array<OntologyIrObjectLocator>;
}
/**
 * A parameter value type that is an ObjectLocator.
 */
type OntologyIrObjectLocatorValue = OntologyIrObjectLocator;
type OntologyIrObjectPrimaryKey = Record<ObjectTypeFieldApiName, PrimaryKeyValue>;
/**
 * ObjectReferenceListType specifies that this parameter must be a list of ObjectLocators.
 */
interface OntologyIrObjectReferenceListType {
    objectTypeId: ObjectTypeApiName;
}
/**
 * ObjectReferenceType specifies that this parameter must be an ObjectLocator. An additional optional field maybeCreateObjectOption is included for handling upsert action types by providing flexibility of object creation from a user-specified PK or auto-generated UID PK.
 */
interface OntologyIrObjectReferenceType {
    maybeCreateObjectOption?: CreateObjectOption | null | undefined;
    objectTypeId: ObjectTypeApiName;
}
/**
 * ObjectSetRidType specifies that this parameter must be an ObjectSetRid.
 */
interface OntologyIrObjectSetRidType {
    objectTypeId: ObjectTypeApiName;
}
/**
 * A parameter value that references a specific object type.
 */
interface OntologyIrObjectTypeValue {
    objectTypeId: ObjectTypeApiName;
}
interface OntologyIrTimeDependentPropertyValue_seriesId {
    type: "seriesId";
    seriesId: SeriesIdPropertyValue;
}
interface OntologyIrTimeDependentPropertyValue_templateRid {
    type: "templateRid";
    templateRid: TemplateRidPropertyValue;
}
interface OntologyIrTimeDependentPropertyValue_qualifiedSeriesId {
    type: "qualifiedSeriesId";
    qualifiedSeriesId: OntologyIrQualifiedSeriesIdPropertyValue;
}
/**
 * Identifies a time series in codex.
 * The qualifiedSeriesId variant should be used when there are multiple time series datasources backing this
 * property value (and therefore we need to specify which one to qualify with).
 */
type OntologyIrTimeDependentPropertyValue = OntologyIrTimeDependentPropertyValue_seriesId | OntologyIrTimeDependentPropertyValue_templateRid | OntologyIrTimeDependentPropertyValue_qualifiedSeriesId;
/**
 * A parameter type that consists of a TimeDependentPropertyValue.
 */
interface OntologyIrTimeSeriesReferenceValue {
    timeSeriesReference: OntologyIrTimeDependentPropertyValue;
}
interface ParameterDisabled {
}
interface ParameterEditable {
}
interface ParameterHidden {
}
interface ParameterNotRequired {
}
interface ParameterRenderHint_dropdown {
    type: "dropdown";
    dropdown: Dropdown;
}
interface ParameterRenderHint_userDropdown {
    type: "userDropdown";
    userDropdown: UserDropdown;
}
interface ParameterRenderHint_radio {
    type: "radio";
    radio: Radio;
}
interface ParameterRenderHint_checkbox {
    type: "checkbox";
    checkbox: Checkbox;
}
interface ParameterRenderHint_numericInput {
    type: "numericInput";
    numericInput: NumericInput;
}
interface ParameterRenderHint_textInput {
    type: "textInput";
    textInput: TextInput;
}
interface ParameterRenderHint_textArea {
    type: "textArea";
    textArea: TextArea;
}
interface ParameterRenderHint_dateTimePicker {
    type: "dateTimePicker";
    dateTimePicker: DateTimePicker;
}
interface ParameterRenderHint_filePicker {
    type: "filePicker";
    filePicker: FilePicker;
}
interface ParameterRenderHint_resourcePicker {
    type: "resourcePicker";
    resourcePicker: ResourcePicker;
}
interface ParameterRenderHint_cbacMarkingPicker {
    type: "cbacMarkingPicker";
    cbacMarkingPicker: CbacMarkingPicker;
}
interface ParameterRenderHint_mandatoryMarkingPicker {
    type: "mandatoryMarkingPicker";
    mandatoryMarkingPicker: MandatoryMarkingPicker;
}
type ParameterRenderHint = ParameterRenderHint_dropdown | ParameterRenderHint_userDropdown | ParameterRenderHint_radio | ParameterRenderHint_checkbox | ParameterRenderHint_numericInput | ParameterRenderHint_textInput | ParameterRenderHint_textArea | ParameterRenderHint_dateTimePicker | ParameterRenderHint_filePicker | ParameterRenderHint_resourcePicker | ParameterRenderHint_cbacMarkingPicker | ParameterRenderHint_mandatoryMarkingPicker;
interface ParameterRequired {
}
interface ParameterRequiredConfiguration_required {
    type: "required";
    required: ParameterRequired;
}
interface ParameterRequiredConfiguration_notRequired {
    type: "notRequired";
    notRequired: ParameterNotRequired;
}
interface ParameterRequiredConfiguration_listLengthValidation {
    type: "listLengthValidation";
    listLengthValidation: ListLengthValidation;
}
/**
 * Specifies the number of values that are valid for a given parameter.
 */
type ParameterRequiredConfiguration = ParameterRequiredConfiguration_required | ParameterRequiredConfiguration_notRequired | ParameterRequiredConfiguration_listLengthValidation;
interface ParameterVisibility_editable {
    type: "editable";
    editable: ParameterEditable;
}
interface ParameterVisibility_disabled {
    type: "disabled";
    disabled: ParameterDisabled;
}
interface ParameterVisibility_hidden {
    type: "hidden";
    hidden: ParameterHidden;
}
type ParameterVisibility = ParameterVisibility_editable | ParameterVisibility_disabled | ParameterVisibility_hidden;
interface PrimaryKeyValue_boolean {
    type: "boolean";
    boolean: BooleanValue;
}
interface PrimaryKeyValue_integer {
    type: "integer";
    integer: IntegerValue;
}
interface PrimaryKeyValue_long {
    type: "long";
    long: LongValue;
}
interface PrimaryKeyValue_double {
    type: "double";
    double: DoubleValue;
}
interface PrimaryKeyValue_string {
    type: "string";
    string: StringValue;
}
interface PrimaryKeyValue_date {
    type: "date";
    date: DateValue;
}
interface PrimaryKeyValue_timestamp {
    type: "timestamp";
    timestamp: TimestampValue;
}
type PrimaryKeyValue = PrimaryKeyValue_boolean | PrimaryKeyValue_integer | PrimaryKeyValue_long | PrimaryKeyValue_double | PrimaryKeyValue_string | PrimaryKeyValue_date | PrimaryKeyValue_timestamp;
interface Radio {
    layout?: MultipleChoiceItemLayoutOptions | null | undefined;
}
/**
 * Side of a relation.
 */
type RelationSide = "SOURCE" | "TARGET" | "EITHER";
interface ResourcePicker {
}
interface SectionHidden {
}
interface SectionVisibility_visible {
    type: "visible";
    visible: SectionVisible;
}
interface SectionVisibility_hidden {
    type: "hidden";
    hidden: SectionHidden;
}
/**
 * Specifies if the section is visible or hidden
 */
type SectionVisibility = SectionVisibility_visible | SectionVisibility_hidden;
interface SectionVisible {
}
interface SpecifiedTimezone {
    timezone: string;
}
/**
 * StringListType specifies that this parameter must be a list of Strings.
 */
interface StringListType {
}
/**
 * A parameter value type that consists of a list of Strings.
 */
interface StringListValue {
    strings: Array<string>;
}
/**
 * StringType specifies that this parameter must be a String.
 */
interface StringType$1 {
}
/**
 * A parameter value type that is a String.
 */
type StringValue = string;
interface StructFieldBaseParameterType_boolean {
    type: "boolean";
    boolean: BooleanType$1;
}
interface StructFieldBaseParameterType_integer {
    type: "integer";
    integer: IntegerType$1;
}
interface StructFieldBaseParameterType_long {
    type: "long";
    long: LongType$1;
}
interface StructFieldBaseParameterType_double {
    type: "double";
    double: DoubleType$1;
}
interface StructFieldBaseParameterType_string {
    type: "string";
    string: StringType$1;
}
interface StructFieldBaseParameterType_geohash {
    type: "geohash";
    geohash: GeohashType;
}
interface StructFieldBaseParameterType_timestamp {
    type: "timestamp";
    timestamp: TimestampType$1;
}
interface StructFieldBaseParameterType_date {
    type: "date";
    date: DateType$1;
}
/**
 * All of the possible types for fields of a Struct Parameter. This should be the intersection of allowed struct
 * property field types (https://www.palantir.com/docs/foundry/object-link-types/structs-overview/), and the
 * inhabitants of the BaseParameterType union.
 */
type StructFieldBaseParameterType = StructFieldBaseParameterType_boolean | StructFieldBaseParameterType_integer | StructFieldBaseParameterType_long | StructFieldBaseParameterType_double | StructFieldBaseParameterType_string | StructFieldBaseParameterType_geohash | StructFieldBaseParameterType_timestamp | StructFieldBaseParameterType_date;
interface StructFieldDataValue_boolean {
    type: "boolean";
    boolean: BooleanValue;
}
interface StructFieldDataValue_integer {
    type: "integer";
    integer: IntegerValue;
}
interface StructFieldDataValue_long {
    type: "long";
    long: LongValue;
}
interface StructFieldDataValue_double {
    type: "double";
    double: DoubleValue;
}
interface StructFieldDataValue_string {
    type: "string";
    string: StringValue;
}
interface StructFieldDataValue_date {
    type: "date";
    date: DateValue;
}
interface StructFieldDataValue_geohash {
    type: "geohash";
    geohash: GeohashValue;
}
interface StructFieldDataValue_timestamp {
    type: "timestamp";
    timestamp: TimestampValue;
}
interface StructFieldDataValue_null {
    type: "null";
    null: NullValue;
}
/**
 * DataValue types that are allowed as struct parameter field. Each struct field in a struct parameter is mapped
 * mapped to a StructFieldDataValue. See StructFieldBaseParameterType for which types are supported for struct
 * parameter fields.
 */
type StructFieldDataValue = StructFieldDataValue_boolean | StructFieldDataValue_integer | StructFieldDataValue_long | StructFieldDataValue_double | StructFieldDataValue_string | StructFieldDataValue_date | StructFieldDataValue_geohash | StructFieldDataValue_timestamp | StructFieldDataValue_null;
/**
 * A string identifier used to map struct property fields to their respective constraints.
 * This identifier is intentionally generically typed. Constraints used on ontology types should interpret the
 * identifier as a struct field API name and pipeline builder should interpret the identifier as a dataset
 * struct column field name.
 */
type StructFieldIdentifier$1 = string;
/**
 * StructListType specifies that this parameter must be a list of Structs.
 */
interface StructListType {
    structFieldTypes: Record<StructParameterFieldApiName, StructFieldBaseParameterType>;
}
/**
 * A parameter type that consists of a list of Structs.
 */
interface StructListValue {
    structs: Array<StructValue>;
}
/**
 * A struct field of a struct parameter.
 */
interface StructParameterField {
    structFieldApiName: StructParameterFieldApiName;
    structFieldDataValue: StructFieldDataValue;
}
/**
 * An API name that identifies a struct field in a struct parameter.
 */
type StructParameterFieldApiName = string;
/**
 * StructType specifies that this parameter must be a Struct.
 */
interface StructType$1 {
    structFieldTypes: Record<StructParameterFieldApiName, StructFieldBaseParameterType>;
}
/**
 * A parameter type that consists of a Struct.
 */
interface StructValue {
    structFields: Array<StructParameterField>;
}
type TemporalUnit = "SECOND" | "MINUTE" | "HOUR" | "DAY" | "WEEK";
interface TextArea {
}
interface TextInput {
}
interface TimeDependentPropertyValue_seriesId {
    type: "seriesId";
    seriesId: SeriesIdPropertyValue;
}
interface TimeDependentPropertyValue_templateRid {
    type: "templateRid";
    templateRid: TemplateRidPropertyValue;
}
interface TimeDependentPropertyValue_qualifiedSeriesId {
    type: "qualifiedSeriesId";
    qualifiedSeriesId: QualifiedSeriesIdPropertyValue;
}
/**
 * Identifies a time series in codex.
 * The qualifiedSeriesId variant should be used when there are multiple time series datasources backing this
 * property value (and therefore we need to specify which one to qualify with).
 */
type TimeDependentPropertyValue = TimeDependentPropertyValue_seriesId | TimeDependentPropertyValue_templateRid | TimeDependentPropertyValue_qualifiedSeriesId;
interface TimeFormat_timeFormat24Hour {
    type: "timeFormat24Hour";
    timeFormat24Hour: TimeFormat24Hour;
}
interface TimeFormat_timeFormat12Hour {
    type: "timeFormat12Hour";
    timeFormat12Hour: TimeFormat12Hour;
}
type TimeFormat = TimeFormat_timeFormat24Hour | TimeFormat_timeFormat12Hour;
/**
 * Object representing that the time format should be in 12 hour format
 */
interface TimeFormat12Hour {
}
/**
 * Object representing that the time format should be in 24 hour format
 */
interface TimeFormat24Hour {
}
/**
 * TimeSeriesReferenceType specifies that this parameter must be a TimeSeriesReference.
 */
interface TimeSeriesReferenceType {
}
/**
 * A parameter type that consists of a TimeDependentPropertyValue.
 */
interface TimeSeriesReferenceValue {
    timeSeriesReference: TimeDependentPropertyValue;
}
/**
 * The timezone configuration of a timestamp value
 */
interface TimestampConfiguration {
    canUserModifyTimezone: boolean;
    defaultTimezone: DefaultTimezone;
    timeFormat?: TimeFormat | null | undefined;
}
/**
 * TimestampListType specifies that this parameter must be a list of Timestamps.
 */
interface TimestampListType {
    configuration?: TimestampConfiguration | null | undefined;
}
/**
 * A parameter value type that consists of a list of Timestamps.
 */
interface TimestampListValue {
    timestamps: Array<string>;
}
/**
 * TimestampType specifies that this parameter must be a Timestamp.
 */
interface TimestampType$1 {
    configuration?: TimestampConfiguration | null | undefined;
}
/**
 * A parameter value type that is a Timestamp.
 */
type TimestampValue = string;
interface UserDropdown {
}
/**
 * UserInput is a type used to denote the user has opted for user-inputted PKs. Object creation will be handled within Actions Service.
 */
interface UserInput {
}

/**
 * An rid uniquely identifying a `Workflow`. This rid is a randomly generated identifier and is safe
 * to log.
 */
type WorkflowRid = string;

/**
 * A derived property that references aggregations on a linked object type.
 * The linked object type is specified by a LinkDefinition.
 */
interface AggregatedPropertiesDefinition {
    linkDefinition: LinkDefinition$1;
    propertyTypeMapping: Record<PropertyTypeRid, DerivedPropertyAggregation>;
}
interface DerivedPropertiesDefinition_linkedProperties {
    type: "linkedProperties";
    linkedProperties: LinkedPropertiesDefinition;
}
interface DerivedPropertiesDefinition_aggregatedProperties {
    type: "aggregatedProperties";
    aggregatedProperties: AggregatedPropertiesDefinition;
}
type DerivedPropertiesDefinition = DerivedPropertiesDefinition_linkedProperties | DerivedPropertiesDefinition_aggregatedProperties;
interface DerivedPropertyAggregation_count {
    type: "count";
    count: LinkedCountMetric;
}
interface DerivedPropertyAggregation_avg {
    type: "avg";
    avg: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_max {
    type: "max";
    max: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_min {
    type: "min";
    min: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_sum {
    type: "sum";
    sum: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_approximateCardinality {
    type: "approximateCardinality";
    approximateCardinality: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_exactCardinality {
    type: "exactCardinality";
    exactCardinality: PropertyTypeIdentifier$1;
}
interface DerivedPropertyAggregation_collectList {
    type: "collectList";
    collectList: LinkedCollection;
}
interface DerivedPropertyAggregation_collectSet {
    type: "collectSet";
    collectSet: LinkedCollection;
}
/**
 * An aggregation function and what it should be computed on (e.g. a property type on the linked object type).
 */
type DerivedPropertyAggregation = DerivedPropertyAggregation_count | DerivedPropertyAggregation_avg | DerivedPropertyAggregation_max | DerivedPropertyAggregation_min | DerivedPropertyAggregation_sum | DerivedPropertyAggregation_approximateCardinality | DerivedPropertyAggregation_exactCardinality | DerivedPropertyAggregation_collectList | DerivedPropertyAggregation_collectSet;
interface DerivedPropertyLinkTypeIdentifier_linkType {
    type: "linkType";
    linkType: LinkTypeRid;
}
type DerivedPropertyLinkTypeIdentifier = DerivedPropertyLinkTypeIdentifier_linkType;
/**
 * Specifies a side of a link type to indicate a direction derived property is going from. Its semantic
 * meaning depends on the context of usage.
 *
 * For many-to-many link types SOURCE corresponds to object type A in the link type definition, and
 * TARGET corresponds to object type B.
 *
 * For one-to-many link types SOURCE generally corresponds to the ONE (or primary key) side in the
 * link type definition, and TARGET corresponds to the MANY (or foreign key) side.
 * EXCEPTION: In self-referential one-to-many link types, this is inverted: SOURCE corresponds to the MANY side
 * and TARGET corresponds to the ONE side in self-referential one-to-many link types.
 *
 * See also: `https://github.palantir.build/foundry/ontology-metadata-service/blob/6e9dc4f117cb56e0f0ffb0027a85ca946275e417/docs/adr/0057-link-type-side-semantics.md`
 * for more context surrounding this decision.
 */
type DerivedPropertyLinkTypeSide = "SOURCE" | "TARGET";
interface LinkDefinition_linkTypeLink {
    type: "linkTypeLink";
    linkTypeLink: LinkTypeLinkDefinition;
}
interface LinkDefinition_multiHopLink {
    type: "multiHopLink";
    multiHopLink: MultiHopLinkDefinition;
}
type LinkDefinition$1 = LinkDefinition_linkTypeLink | LinkDefinition_multiHopLink;
/**
 * A collection of values of a property type.
 */
interface LinkedCollection {
    limit: number;
    linkedProperty: PropertyTypeIdentifier$1;
}
/**
 * Total count of objects
 */
interface LinkedCountMetric {
}
/**
 * A derived property definition that references property types on a linked object type.
 * The linked object type is specified by a LinkDefinition.
 */
interface LinkedPropertiesDefinition {
    linkDefinition: LinkDefinition$1;
    propertyTypeMapping: Record<PropertyTypeRid, PropertyTypeIdentifier$1>;
}
interface LinkTypeLinkDefinition {
    linkTypeIdentifier: DerivedPropertyLinkTypeIdentifier;
    linkTypeSide: DerivedPropertyLinkTypeSide;
}
/**
 * A link definition formed from sequentially traversing one or more multi hop steps.
 */
interface MultiHopLinkDefinition {
    steps: Array<MultiHopStepDefinition>;
}
interface MultiHopStepDefinition_searchAround {
    type: "searchAround";
    searchAround: SearchAroundStep;
}
type MultiHopStepDefinition = MultiHopStepDefinition_searchAround;
/**
 * A derived property that references aggregations on a linked object type.
 * The linked object type is specified by a LinkDefinition.
 */
interface OntologyIrAggregatedPropertiesDefinition {
    linkDefinition: OntologyIrLinkDefinition$1;
    propertyTypeMapping: Record<ObjectTypeFieldApiName, OntologyIrDerivedPropertyAggregation>;
}
interface OntologyIrDerivedPropertiesDefinition_linkedProperties {
    type: "linkedProperties";
    linkedProperties: OntologyIrLinkedPropertiesDefinition;
}
interface OntologyIrDerivedPropertiesDefinition_aggregatedProperties {
    type: "aggregatedProperties";
    aggregatedProperties: OntologyIrAggregatedPropertiesDefinition;
}
type OntologyIrDerivedPropertiesDefinition = OntologyIrDerivedPropertiesDefinition_linkedProperties | OntologyIrDerivedPropertiesDefinition_aggregatedProperties;
interface OntologyIrDerivedPropertyAggregation_count {
    type: "count";
    count: LinkedCountMetric;
}
interface OntologyIrDerivedPropertyAggregation_avg {
    type: "avg";
    avg: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_max {
    type: "max";
    max: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_min {
    type: "min";
    min: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_sum {
    type: "sum";
    sum: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_approximateCardinality {
    type: "approximateCardinality";
    approximateCardinality: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_exactCardinality {
    type: "exactCardinality";
    exactCardinality: OntologyIrPropertyTypeIdentifier;
}
interface OntologyIrDerivedPropertyAggregation_collectList {
    type: "collectList";
    collectList: OntologyIrLinkedCollection;
}
interface OntologyIrDerivedPropertyAggregation_collectSet {
    type: "collectSet";
    collectSet: OntologyIrLinkedCollection;
}
/**
 * An aggregation function and what it should be computed on (e.g. a property type on the linked object type).
 */
type OntologyIrDerivedPropertyAggregation = OntologyIrDerivedPropertyAggregation_count | OntologyIrDerivedPropertyAggregation_avg | OntologyIrDerivedPropertyAggregation_max | OntologyIrDerivedPropertyAggregation_min | OntologyIrDerivedPropertyAggregation_sum | OntologyIrDerivedPropertyAggregation_approximateCardinality | OntologyIrDerivedPropertyAggregation_exactCardinality | OntologyIrDerivedPropertyAggregation_collectList | OntologyIrDerivedPropertyAggregation_collectSet;
interface OntologyIrDerivedPropertyLinkTypeIdentifier_linkType {
    type: "linkType";
    linkType: LinkTypeId;
}
type OntologyIrDerivedPropertyLinkTypeIdentifier = OntologyIrDerivedPropertyLinkTypeIdentifier_linkType;
interface OntologyIrLinkDefinition_linkTypeLink {
    type: "linkTypeLink";
    linkTypeLink: OntologyIrLinkTypeLinkDefinition;
}
interface OntologyIrLinkDefinition_multiHopLink {
    type: "multiHopLink";
    multiHopLink: OntologyIrMultiHopLinkDefinition;
}
type OntologyIrLinkDefinition$1 = OntologyIrLinkDefinition_linkTypeLink | OntologyIrLinkDefinition_multiHopLink;
/**
 * A collection of values of a property type.
 */
interface OntologyIrLinkedCollection {
    limit: number;
    linkedProperty: OntologyIrPropertyTypeIdentifier;
}
/**
 * A derived property definition that references property types on a linked object type.
 * The linked object type is specified by a LinkDefinition.
 */
interface OntologyIrLinkedPropertiesDefinition {
    linkDefinition: OntologyIrLinkDefinition$1;
    propertyTypeMapping: Record<ObjectTypeFieldApiName, OntologyIrPropertyTypeIdentifier>;
}
interface OntologyIrLinkTypeLinkDefinition {
    linkTypeIdentifier: OntologyIrDerivedPropertyLinkTypeIdentifier;
    linkTypeSide: DerivedPropertyLinkTypeSide;
}
/**
 * A link definition formed from sequentially traversing one or more multi hop steps.
 */
interface OntologyIrMultiHopLinkDefinition {
    steps: Array<OntologyIrMultiHopStepDefinition>;
}
interface OntologyIrMultiHopStepDefinition_searchAround {
    type: "searchAround";
    searchAround: OntologyIrSearchAroundStep;
}
type OntologyIrMultiHopStepDefinition = OntologyIrMultiHopStepDefinition_searchAround;
interface OntologyIrPropertyTypeIdentifier_propertyType {
    type: "propertyType";
    propertyType: ObjectTypeFieldApiName;
}
type OntologyIrPropertyTypeIdentifier = OntologyIrPropertyTypeIdentifier_propertyType;
interface OntologyIrSearchAroundStep {
    linkTypeIdentifier: OntologyIrDerivedPropertyLinkTypeIdentifier;
    linkTypeSide: DerivedPropertyLinkTypeSide;
}
interface PropertyTypeIdentifier_propertyType {
    type: "propertyType";
    propertyType: PropertyTypeRid;
}
type PropertyTypeIdentifier$1 = PropertyTypeIdentifier_propertyType;
interface SearchAroundStep {
    linkTypeIdentifier: DerivedPropertyLinkTypeIdentifier;
    linkTypeSide: DerivedPropertyLinkTypeSide;
}

/**
 * Information describing the provenance of an action type.
 */
interface ActionTypeProvenance {
    source: ActionTypeProvenanceSource;
}
interface ActionTypeProvenanceSource_marketplace {
    type: "marketplace";
    marketplace: MarketplaceEntityProvenance;
}
/**
 * Information describing the source provenance of an ontology entity modeled as an extensible union.
 * Each service or client which defines the definition of an ontology entity can declare their custom
 * representation of provenance metadata. Examples may include references to resources, their versions,
 * timestamps etc.
 */
type ActionTypeProvenanceSource = ActionTypeProvenanceSource_marketplace;
/**
 * Provenance of an entity originating from Builder pipeline.
 */
interface BuilderEntityProvenance {
    pipelineRid: BuilderPipelineRid;
}
/**
 * Edits History
 */
interface EditsHistoryProvenance {
    objectTypeRid: ObjectTypeRid;
}
/**
 * Information describing the provenance of an ontology entity.
 */
interface EntityProvenance {
    source: EntityProvenanceSource;
}
interface EntityProvenanceSource_builder {
    type: "builder";
    builder: BuilderEntityProvenance;
}
interface EntityProvenanceSource_marketplace {
    type: "marketplace";
    marketplace: MarketplaceEntityProvenance;
}
interface EntityProvenanceSource_editsHistory {
    type: "editsHistory";
    editsHistory: EditsHistoryProvenance;
}
/**
 * Information describing the source provenance of an ontology entity modeled as an extensible union.
 * Each service or client which defines the definition of an ontology entity can declare their custom
 * representation of provenance metadata. Examples may include references to resources, their versions,
 * timestamps etc.
 */
type EntityProvenanceSource = EntityProvenanceSource_builder | EntityProvenanceSource_marketplace | EntityProvenanceSource_editsHistory;
type MarketplaceBlockSetInstallationRid = string;
/**
 * Provenance of an entity originating from Marketplace product installation.
 */
interface MarketplaceEntityProvenance {
    installationRid: MarketplaceBlockSetInstallationRid;
}

type Alignment = "LEFT" | "CENTER" | "RIGHT";
/**
 * Always true.
 */
interface AlwaysCondition {
}
/**
 * True if all conditions are true.
 */
interface AndCondition$1 {
    conditions: Array<Condition$1>;
}
interface ColorStyle_intent {
    type: "intent";
    intent: Intent;
}
interface ColorStyle_primaryRgb {
    type: "primaryRgb";
    primaryRgb: RgbColor;
}
interface ColorStyle_none {
    type: "none";
    none: NoColorStyle;
}
type ColorStyle = ColorStyle_intent | ColorStyle_primaryRgb | ColorStyle_none;
interface Condition_always {
    type: "always";
    always: AlwaysCondition;
}
interface Condition_and$1 {
    type: "and";
    and: AndCondition$1;
}
interface Condition_or$1 {
    type: "or";
    or: OrCondition$1;
}
interface Condition_not$1 {
    type: "not";
    not: NotCondition$1;
}
interface Condition_isNull {
    type: "isNull";
    isNull: IsNullCondition;
}
interface Condition_stringComparison {
    type: "stringComparison";
    stringComparison: StringComparisonCondition;
}
interface Condition_exactBooleanMatch {
    type: "exactBooleanMatch";
    exactBooleanMatch: ExactBooleanMatchCondition;
}
interface Condition_exactNumericMatch {
    type: "exactNumericMatch";
    exactNumericMatch: ExactNumericMatchCondition;
}
interface Condition_exactDateMatch {
    type: "exactDateMatch";
    exactDateMatch: ExactDateMatchCondition;
}
interface Condition_numericRange {
    type: "numericRange";
    numericRange: NumericRangeCondition;
}
interface Condition_dateRange {
    type: "dateRange";
    dateRange: DateRangeCondition;
}
interface Condition_timestampRange {
    type: "timestampRange";
    timestampRange: TimestampRangeCondition;
}
interface Condition_relativeDateRange {
    type: "relativeDateRange";
    relativeDateRange: RelativeDateRangeCondition;
}
interface Condition_relativeTimestampRange {
    type: "relativeTimestampRange";
    relativeTimestampRange: RelativeTimestampRangeCondition;
}
interface Condition_math {
    type: "math";
    math: MathCondition;
}
type Condition$1 = Condition_always | Condition_and$1 | Condition_or$1 | Condition_not$1 | Condition_isNull | Condition_stringComparison | Condition_exactBooleanMatch | Condition_exactNumericMatch | Condition_exactDateMatch | Condition_numericRange | Condition_dateRange | Condition_timestampRange | Condition_relativeDateRange | Condition_relativeTimestampRange | Condition_math;
interface DateRangeCondition {
    property: ValueReference;
    since?: ValueReferenceOrStringConstant | null | undefined;
    until?: ValueReferenceOrStringConstant | null | undefined;
}
interface ExactBooleanMatchCondition {
    property: ValueReference;
    value: boolean;
}
interface ExactDateMatchCondition {
    property: ValueReference;
    value: string;
}
interface ExactNumericMatchCondition {
    property: ValueReference;
    value: ValueReferenceOrDoubleConstant;
}
interface FormatStyle {
    alignment?: Alignment | null | undefined;
    color: ColorStyle;
}
type Intent = "HIGHLIGHT" | "SUCCESS" | "WARNING" | "DANGER";
/**
 * True if the value of the referenced property is null for the user. This can happen either if the underlying
 * value is null, or the user cannot access the data source that generates the referenced property.
 */
interface IsNullCondition {
    property: ValueReference;
}
/**
 * Reference to the property this rule is being applied to.
 */
interface It {
}
interface MathBinaryOperation {
    left: MathValue;
    op: MathBinaryOperator;
    right: MathValue;
}
type MathBinaryOperator = "PLUS" | "MINUS" | "TIMES" | "DIVIDE";
interface MathComparison {
    left: MathValue;
    op: MathOperator;
    right: MathValue;
}
interface MathCondition {
    comparison: MathComparison;
}
type MathOperator = "EQUAL" | "NOT_EQUAL" | "GREATER_THAN" | "LESS_THAN" | "GREATER_THAN_OR_EQUAL" | "LESS_THAN_OR_EQUAL";
interface MathUnaryOperation {
    op: MathUnaryOperator;
    property: MathValue;
}
type MathUnaryOperator = "MINUS" | "ABS";
interface MathValue_reference {
    type: "reference";
    reference: ValueReference;
}
interface MathValue_constant {
    type: "constant";
    constant: number | "NaN" | "Infinity" | "-Infinity";
}
interface MathValue_binaryOperation {
    type: "binaryOperation";
    binaryOperation: MathBinaryOperation;
}
interface MathValue_unaryOperation {
    type: "unaryOperation";
    unaryOperation: MathUnaryOperation;
}
type MathValue = MathValue_reference | MathValue_constant | MathValue_binaryOperation | MathValue_unaryOperation;
/**
 * No color style should be applied. This can be thought of as an empty 'optional<ColorStyle>'.
 */
interface NoColorStyle {
}
/**
 * Flip the result of the condition.
 */
interface NotCondition$1 {
    condition: Condition$1;
}
interface NumericRangeCondition {
    from?: ValueReferenceOrDoubleConstant | null | undefined;
    property: ValueReference;
    until?: ValueReferenceOrDoubleConstant | null | undefined;
}
/**
 * True if at least one condition is true.
 */
interface OrCondition$1 {
    conditions: Array<Condition$1>;
}
interface RelativeDateRangeCondition {
    property: ValueReference;
    sinceRelative?: RelativePointInTime$1 | null | undefined;
    timeZoneId: TimeZoneId$1;
    untilRelative?: RelativePointInTime$1 | null | undefined;
}
interface RelativePointInTime$1 {
    timeUnit: RelativeTimeUnit$1;
    value: number;
}
interface RelativeTimestampRangeCondition {
    property: ValueReference;
    sinceRelativeMillis?: number | null | undefined;
    untilRelativeMillis?: number | null | undefined;
}
type RelativeTimeUnit$1 = "SECOND" | "MINUTE" | "HOUR" | "DAY" | "WEEK" | "MONTH" | "YEAR";
interface RgbColor {
    blue: number;
    green: number;
    red: number;
}
/**
 * A formatting rule. Apply the format if the condition evaluates to true.
 */
interface Rule {
    condition: Condition$1;
    style: FormatStyle;
}
/**
 * A rule chain will evaluate rules one-by-one first-to-last. The first matching rule (for which the condition
 * is true) will apply the format, stopping evaluation of this chain. Use this to implement conditionals.
 */
interface RuleChain {
    rules: Array<Rule>;
}
/**
 * A set of rules that can be applied to a property. This should correspond to a semantic set of formatting
 * rules.
 *
 * For example:
 * - Number (accounting): renders negative numbers with "()", and sets the right amount of parentheses.
 * - Number (compact): renders millions as `$nM`
 * - ...
 *
 * These rules can be re-used in different contexts by re-binding the value references as required.
 */
interface RuleSet {
    chains: Array<RuleChain>;
    description?: string | null | undefined;
    itType?: DataType | null | undefined;
    name: string;
    namedTypes: Record<ValueReferenceId, RuleSetNamedType>;
    rid: RuleSetRid;
}
interface RuleSetNamedType {
    id: ValueReferenceId;
    name: string;
    type: DataType;
}
/**
 * Compare a string to a set of static values.
 */
interface StringComparisonCondition {
    caseSensitive: boolean;
    operator: StringComparisonOperator;
    property: ValueReference;
}
interface StringComparisonOperator_contains {
    type: "contains";
    contains: StringConditionValue;
}
interface StringComparisonOperator_startsWith {
    type: "startsWith";
    startsWith: StringConditionValue;
}
interface StringComparisonOperator_endsWith {
    type: "endsWith";
    endsWith: StringConditionValue;
}
interface StringComparisonOperator_exactly {
    type: "exactly";
    exactly: StringConditionValue;
}
type StringComparisonOperator = StringComparisonOperator_contains | StringComparisonOperator_startsWith | StringComparisonOperator_endsWith | StringComparisonOperator_exactly;
/**
 * Value used for string operators. If there is more than one value in the `values`
 * property, the operator will OR all the values.
 */
interface StringConditionValue {
    values: Array<ValueReferenceOrStringConstant>;
}
interface TimestampRangeCondition {
    from?: ValueReferenceOrDatetimeConstant | null | undefined;
    property: ValueReference;
    until?: ValueReferenceOrDatetimeConstant | null | undefined;
}
/**
 * An identifier of a time zone, e.g. "Europe/London" as defined by the Time Zone Database.
 */
type TimeZoneId$1 = string;
interface ValueReference_it {
    type: "it";
    it: It;
}
interface ValueReference_valueReferenceId {
    type: "valueReferenceId";
    valueReferenceId: ValueReferenceId;
}
type ValueReference = ValueReference_it | ValueReference_valueReferenceId;
interface ValueReferenceOrDatetimeConstant_constant {
    type: "constant";
    constant: string;
}
interface ValueReferenceOrDatetimeConstant_reference {
    type: "reference";
    reference: ValueReference;
}
type ValueReferenceOrDatetimeConstant = ValueReferenceOrDatetimeConstant_constant | ValueReferenceOrDatetimeConstant_reference;
interface ValueReferenceOrDoubleConstant_constant {
    type: "constant";
    constant: number | "NaN" | "Infinity" | "-Infinity";
}
interface ValueReferenceOrDoubleConstant_reference {
    type: "reference";
    reference: ValueReference;
}
type ValueReferenceOrDoubleConstant = ValueReferenceOrDoubleConstant_constant | ValueReferenceOrDoubleConstant_reference;
interface ValueReferenceOrStringConstant_constant {
    type: "constant";
    constant: string;
}
interface ValueReferenceOrStringConstant_reference {
    type: "reference";
    reference: ValueReference;
}
type ValueReferenceOrStringConstant = ValueReferenceOrStringConstant_constant | ValueReferenceOrStringConstant_reference;

/**
 * An ID referencing a backup stored in Funnel.
 */
type BackupId = string;
/**
 * Migration to cast a property to another type.
 */
interface CastMigration {
    property: PropertyTypeRid;
    source: Type;
    target: Type;
}
/**
 * Migration to cast a property to another type.
 */
interface CastStructFieldMigration {
    property: PropertyTypeRid;
    source: StructPropertyFieldType;
    structField: StructFieldRid;
    target: StructPropertyFieldType;
}
/**
 * Migration to drop all patches applied to the ObjectType.
 */
interface DropAllPatchesMigration {
}
/**
 * Migration to drop the given datasource.
 */
interface DropDatasourceMigration {
    datasource: DatasourceRid;
}
/**
 * Migration to drop the given property.
 */
interface DropPropertyMigration {
    property: PropertyTypeRid;
}
/**
 * Migration to drop a struct field of a struct property
 */
interface DropStructFieldMigration {
    property: PropertyTypeRid;
    structField: StructFieldRid;
}
/**
 * Update the edits resolution strategy of an object type from edits always win to latest timestamp.
 */
interface EditsWinToLatestTimestamp {
    datasourceProperties: Array<PropertyTypeRid>;
    datasourceRid: DatasourceRid;
    timestampPropertyRid: PropertyTypeRid;
    timestampValue: any;
}
interface InitializationSource_backup {
    type: "backup";
    backup: PatchBackup;
}
/**
 * Metadata regarding the source of data that can be used to run a one time initialization of an ontology entity.
 */
type InitializationSource = InitializationSource_backup;
/**
 * Migration that can be used to initialize an ontology entity with data that's stored in the initialization
 * source.
 */
interface InitializePatchesMigration {
    datasourceRenames: Array<RenameDatasourceMigration>;
    initializationSource: InitializationSource;
    primaryKeyRenames: PrimaryKeyRenames;
    propertyRenames: Array<RenamePropertyMigration>;
}
/**
 * Update the edits resolution strategy of an object type from latest timestamp to edits always win.
 */
interface LatestTimestampToEditsWin {
    datasourceRid: DatasourceRid;
    timestampPropertyRid: PropertyTypeRid;
}
interface NonRevertibleMigration_initializePatches {
    type: "initializePatches";
    initializePatches: InitializePatchesMigration;
}
interface NonRevertibleMigration_permanentlyDeletePatches {
    type: "permanentlyDeletePatches";
    permanentlyDeletePatches: PermanentlyDeletePatchesMigration;
}
/**
 * Migration that cannot be reverted in future, this migration type implies that all migrations before it will be checkpointed.
 */
type NonRevertibleMigration = NonRevertibleMigration_initializePatches | NonRevertibleMigration_permanentlyDeletePatches;
interface ObjectTypePrimaryKeyRename {
    rename: RenamePropertyMigration;
}
/**
 * Migration to cast a property to another type.
 */
interface OntologyIrCastMigration {
    property: ObjectTypeFieldApiName;
    source: OntologyIrType;
    target: OntologyIrType;
}
/**
 * Migration to cast a property to another type.
 */
interface OntologyIrCastStructFieldMigration {
    property: ObjectTypeFieldApiName;
    source: StructPropertyFieldType;
    structField: StructFieldRid;
    target: StructPropertyFieldType;
}
/**
 * Migration to drop the given property.
 */
interface OntologyIrDropPropertyMigration {
    property: ObjectTypeFieldApiName;
}
/**
 * Migration to drop a struct field of a struct property
 */
interface OntologyIrDropStructFieldMigration {
    property: ObjectTypeFieldApiName;
    structField: StructFieldRid;
}
/**
 * Update the edits resolution strategy of an object type from edits always win to latest timestamp.
 */
interface OntologyIrEditsWinToLatestTimestamp {
    datasourceProperties: Array<ObjectTypeFieldApiName>;
    datasourceRid: DatasourceRid;
    timestampPropertyRid: ObjectTypeFieldApiName;
    timestampValue: any;
}
interface OntologyIrInitializationSource_backup {
    type: "backup";
    backup: OntologyIrPatchBackup;
}
/**
 * Metadata regarding the source of data that can be used to run a one time initialization of an ontology entity.
 */
type OntologyIrInitializationSource = OntologyIrInitializationSource_backup;
/**
 * Migration that can be used to initialize an ontology entity with data that's stored in the initialization
 * source.
 */
interface OntologyIrInitializePatchesMigration {
    datasourceRenames: Array<RenameDatasourceMigration>;
    initializationSource: OntologyIrInitializationSource;
    primaryKeyRenames: OntologyIrPrimaryKeyRenames;
    propertyRenames: Array<OntologyIrRenamePropertyMigration>;
}
/**
 * Update the edits resolution strategy of an object type from latest timestamp to edits always win.
 */
interface OntologyIrLatestTimestampToEditsWin {
    datasourceRid: DatasourceRid;
    timestampPropertyRid: ObjectTypeFieldApiName;
}
interface OntologyIrNonRevertibleMigration_initializePatches {
    type: "initializePatches";
    initializePatches: OntologyIrInitializePatchesMigration;
}
interface OntologyIrNonRevertibleMigration_permanentlyDeletePatches {
    type: "permanentlyDeletePatches";
    permanentlyDeletePatches: PermanentlyDeletePatchesMigration;
}
/**
 * Migration that cannot be reverted in future, this migration type implies that all migrations before it will be checkpointed.
 */
type OntologyIrNonRevertibleMigration = OntologyIrNonRevertibleMigration_initializePatches | OntologyIrNonRevertibleMigration_permanentlyDeletePatches;
interface OntologyIrObjectTypePrimaryKeyRename {
    rename: OntologyIrRenamePropertyMigration;
}
/**
 * Contains the information that can be used to restore patches that were deleted by mistake.
 */
interface OntologyIrPatchBackup {
    backupId: BackupId;
    objectTypeRid: ObjectTypeApiName;
    ontologyVersion: OntologyVersion;
}
interface OntologyIrPrimaryKeyRenames_objectType {
    type: "objectType";
    objectType: OntologyIrObjectTypePrimaryKeyRename;
}
type OntologyIrPrimaryKeyRenames = OntologyIrPrimaryKeyRenames_objectType;
/**
 * Migration to rename one property to another.
 */
interface OntologyIrRenamePropertyMigration {
    source: ObjectTypeFieldApiName;
    target: ObjectTypeFieldApiName;
}
/**
 * Migration to rename a struct property field to another.
 */
interface OntologyIrRenameStructFieldMigration {
    property: ObjectTypeFieldApiName;
    sourceStructField: StructFieldRid;
    targetStructField: StructFieldRid;
}
/**
 * A SchemaMigrationInstruction with a unique identifier.
 */
interface OntologyIrSchemaMigration {
    instruction: OntologyIrSchemaMigrationInstruction;
    rid: SchemaMigrationRid;
}
interface OntologyIrSchemaMigrationInstruction_dropProperty {
    type: "dropProperty";
    dropProperty: OntologyIrDropPropertyMigration;
}
interface OntologyIrSchemaMigrationInstruction_dropStructField {
    type: "dropStructField";
    dropStructField: OntologyIrDropStructFieldMigration;
}
interface OntologyIrSchemaMigrationInstruction_dropDatasource {
    type: "dropDatasource";
    dropDatasource: DropDatasourceMigration;
}
interface OntologyIrSchemaMigrationInstruction_dropAllPatches {
    type: "dropAllPatches";
    dropAllPatches: DropAllPatchesMigration;
}
interface OntologyIrSchemaMigrationInstruction_renameDatasource {
    type: "renameDatasource";
    renameDatasource: RenameDatasourceMigration;
}
interface OntologyIrSchemaMigrationInstruction_renameProperty {
    type: "renameProperty";
    renameProperty: OntologyIrRenamePropertyMigration;
}
interface OntologyIrSchemaMigrationInstruction_renameStructField {
    type: "renameStructField";
    renameStructField: OntologyIrRenameStructFieldMigration;
}
interface OntologyIrSchemaMigrationInstruction_cast {
    type: "cast";
    cast: OntologyIrCastMigration;
}
interface OntologyIrSchemaMigrationInstruction_castStructField {
    type: "castStructField";
    castStructField: OntologyIrCastStructFieldMigration;
}
interface OntologyIrSchemaMigrationInstruction_revert {
    type: "revert";
    revert: RevertMigration;
}
interface OntologyIrSchemaMigrationInstruction_nonRevertible {
    type: "nonRevertible";
    nonRevertible: OntologyIrNonRevertibleMigration;
}
interface OntologyIrSchemaMigrationInstruction_updateEditsResolutionStrategy {
    type: "updateEditsResolutionStrategy";
    updateEditsResolutionStrategy: OntologyIrUpdateEditsResolutionStrategyMigration;
}
/**
 * One out of potentially many instructions on how to transition from one version to another.
 */
type OntologyIrSchemaMigrationInstruction = OntologyIrSchemaMigrationInstruction_dropProperty | OntologyIrSchemaMigrationInstruction_dropStructField | OntologyIrSchemaMigrationInstruction_dropDatasource | OntologyIrSchemaMigrationInstruction_dropAllPatches | OntologyIrSchemaMigrationInstruction_renameDatasource | OntologyIrSchemaMigrationInstruction_renameProperty | OntologyIrSchemaMigrationInstruction_renameStructField | OntologyIrSchemaMigrationInstruction_cast | OntologyIrSchemaMigrationInstruction_castStructField | OntologyIrSchemaMigrationInstruction_revert | OntologyIrSchemaMigrationInstruction_nonRevertible | OntologyIrSchemaMigrationInstruction_updateEditsResolutionStrategy;
/**
 * Instructions on how to transition from one schema version to another.
 */
interface OntologyIrSchemaTransition {
    migrations: Array<OntologyIrSchemaMigration>;
    source: SchemaVersion;
    target: SchemaVersion;
}
interface OntologyIrUpdateEditsResolutionStrategyMigration_latestTimestampToEditsWin {
    type: "latestTimestampToEditsWin";
    latestTimestampToEditsWin: OntologyIrLatestTimestampToEditsWin;
}
interface OntologyIrUpdateEditsResolutionStrategyMigration_editsWinToLatestTimestamp {
    type: "editsWinToLatestTimestamp";
    editsWinToLatestTimestamp: OntologyIrEditsWinToLatestTimestamp;
}
/**
 * Migration to communicate to Funnel that the edits resolution strategy for an object type has changed. Funnel
 * will handle this accordingly by updating their internal patch structure.
 *
 * This migration is set internally and automatically by OMS and therefore should not be manually defined by
 * users.
 */
type OntologyIrUpdateEditsResolutionStrategyMigration = OntologyIrUpdateEditsResolutionStrategyMigration_latestTimestampToEditsWin | OntologyIrUpdateEditsResolutionStrategyMigration_editsWinToLatestTimestamp;
/**
 * Contains the information that can be used to restore patches that were deleted by mistake.
 */
interface PatchBackup {
    backupId: BackupId;
    objectTypeRid: ObjectTypeRid;
    ontologyVersion: OntologyVersion;
}
/**
 * A migration that will permanently delete patches applied on an object type. This is a required migration to be present if changing or modifying the primary key of an object type that has received edits.
 */
interface PermanentlyDeletePatchesMigration {
}
interface PrimaryKeyRenames_objectType {
    type: "objectType";
    objectType: ObjectTypePrimaryKeyRename;
}
type PrimaryKeyRenames = PrimaryKeyRenames_objectType;
/**
 * Migration to rename one datasource to another.
 */
interface RenameDatasourceMigration {
    source: DatasourceRid;
    target: DatasourceRid;
}
/**
 * Migration to rename one property to another.
 */
interface RenamePropertyMigration {
    source: PropertyTypeRid;
    target: PropertyTypeRid;
}
/**
 * Migration to rename a struct property field to another.
 */
interface RenameStructFieldMigration {
    property: PropertyTypeRid;
    sourceStructField: StructFieldRid;
    targetStructField: StructFieldRid;
}
/**
 * Revert a previous migration.
 */
interface RevertMigration {
    revert: SchemaMigrationRid;
}
/**
 * A SchemaMigrationInstruction with a unique identifier.
 */
interface SchemaMigration {
    instruction: SchemaMigrationInstruction;
    rid: SchemaMigrationRid;
}
interface SchemaMigrationInstruction_dropProperty {
    type: "dropProperty";
    dropProperty: DropPropertyMigration;
}
interface SchemaMigrationInstruction_dropStructField {
    type: "dropStructField";
    dropStructField: DropStructFieldMigration;
}
interface SchemaMigrationInstruction_dropDatasource {
    type: "dropDatasource";
    dropDatasource: DropDatasourceMigration;
}
interface SchemaMigrationInstruction_dropAllPatches {
    type: "dropAllPatches";
    dropAllPatches: DropAllPatchesMigration;
}
interface SchemaMigrationInstruction_renameDatasource {
    type: "renameDatasource";
    renameDatasource: RenameDatasourceMigration;
}
interface SchemaMigrationInstruction_renameProperty {
    type: "renameProperty";
    renameProperty: RenamePropertyMigration;
}
interface SchemaMigrationInstruction_renameStructField {
    type: "renameStructField";
    renameStructField: RenameStructFieldMigration;
}
interface SchemaMigrationInstruction_cast {
    type: "cast";
    cast: CastMigration;
}
interface SchemaMigrationInstruction_castStructField {
    type: "castStructField";
    castStructField: CastStructFieldMigration;
}
interface SchemaMigrationInstruction_revert {
    type: "revert";
    revert: RevertMigration;
}
interface SchemaMigrationInstruction_nonRevertible {
    type: "nonRevertible";
    nonRevertible: NonRevertibleMigration;
}
interface SchemaMigrationInstruction_updateEditsResolutionStrategy {
    type: "updateEditsResolutionStrategy";
    updateEditsResolutionStrategy: UpdateEditsResolutionStrategyMigration;
}
/**
 * One out of potentially many instructions on how to transition from one version to another.
 */
type SchemaMigrationInstruction = SchemaMigrationInstruction_dropProperty | SchemaMigrationInstruction_dropStructField | SchemaMigrationInstruction_dropDatasource | SchemaMigrationInstruction_dropAllPatches | SchemaMigrationInstruction_renameDatasource | SchemaMigrationInstruction_renameProperty | SchemaMigrationInstruction_renameStructField | SchemaMigrationInstruction_cast | SchemaMigrationInstruction_castStructField | SchemaMigrationInstruction_revert | SchemaMigrationInstruction_nonRevertible | SchemaMigrationInstruction_updateEditsResolutionStrategy;
/**
 * Instructions on how to transition from one schema version to another.
 */
interface SchemaTransition {
    migrations: Array<SchemaMigration>;
    source: SchemaVersion;
    target: SchemaVersion;
}
interface UpdateEditsResolutionStrategyMigration_latestTimestampToEditsWin {
    type: "latestTimestampToEditsWin";
    latestTimestampToEditsWin: LatestTimestampToEditsWin;
}
interface UpdateEditsResolutionStrategyMigration_editsWinToLatestTimestamp {
    type: "editsWinToLatestTimestamp";
    editsWinToLatestTimestamp: EditsWinToLatestTimestamp;
}
/**
 * Migration to communicate to Funnel that the edits resolution strategy for an object type has changed. Funnel
 * will handle this accordingly by updating their internal patch structure.
 *
 * This migration is set internally and automatically by OMS and therefore should not be manually defined by
 * users.
 */
type UpdateEditsResolutionStrategyMigration = UpdateEditsResolutionStrategyMigration_latestTimestampToEditsWin | UpdateEditsResolutionStrategyMigration_editsWinToLatestTimestamp;

type GothamDatasourceMetadata = "GOTHAM_DSR_DATASOURCE_NAME" | "GOTHAM_DSR_OBJECT_GID" | "GOTHAM_DSR_CREATED_BY" | "GOTHAM_DSR_LAST_UPDATED_BY" | "GOTHAM_DSR_CREATED_AT" | "GOTHAM_DSR_LAST_UPDATED_AT";
interface GothamIntrinsic_startDate {
    type: "startDate";
    startDate: GothamIntrinsicStartDate;
}
interface GothamIntrinsic_endDate {
    type: "endDate";
    endDate: GothamIntrinsicEndDate;
}
interface GothamIntrinsic_latLong {
    type: "latLong";
    latLong: GothamIntrinsicLatLong;
}
interface GothamIntrinsic_mgrs {
    type: "mgrs";
    mgrs: GothamIntrinsicMgrs;
}
type GothamIntrinsic = GothamIntrinsic_startDate | GothamIntrinsic_endDate | GothamIntrinsic_latLong | GothamIntrinsic_mgrs;
/**
 * This property represents a Gotham End Date Intrinsic. This should be mapped from a Timestamp property.
 */
interface GothamIntrinsicEndDate {
}
/**
 * This property represents a Gotham Lat/Long Intrinsic. This should be mapped from a GeoHash property.
 */
interface GothamIntrinsicLatLong {
}
/**
 * This property represents a Gotham MGRS Intrinsic. This should be mapped from a String property.
 */
interface GothamIntrinsicMgrs {
}
/**
 * This property represents a Gotham Start Date Intrinsic. This should be mapped from a Timestamp property.
 */
interface GothamIntrinsicStartDate {
}
type GothamIntrinsicV2 = "GOTHAM_INTRINSIC_START_DATE" | "GOTHAM_INTRINSIC_END_DATE" | "GOTHAM_INTRINSIC_LAT_LONG" | "GOTHAM_INTRINSIC_MGRS";
/**
 * A foundry property that represents an object level intrinsic in Gotham. These are read from TypeClasses.
 */
interface GothamObjectIntrinsicMapping {
    gothamIntrinsicType: GothamIntrinsic;
}
type GothamObjectTypeUri = string;
/**
 * These values represent the 3 base object types from Gotham ontology.
 */
type GothamOntologyParentType = "ENTITY" | "DOCUMENT" | "EVENT";
type GothamOntologyParentTypeUri = string;
type GothamPropertyComponentUri = string;
interface GothamPropertyDatasourceMapping_property {
    type: "property";
    property: GothamPropertyDatasourceMappingProperty;
}
interface GothamPropertyDatasourceMapping_struct {
    type: "struct";
    struct: GothamPropertyDatasourceMappingStruct;
}
type GothamPropertyDatasourceMapping = GothamPropertyDatasourceMapping_property | GothamPropertyDatasourceMapping_struct;
interface GothamPropertyDatasourceMappingProperty {
    propertyMappings: Record<GothamDatasourceMetadata, PropertyTypeRid>;
}
interface GothamPropertyDatasourceMappingStruct {
    propertyMappings: Record<GothamDatasourceMetadata, StructFieldRid>;
}
/**
 * A foundry property that represents a property level intrinsic in Gotham. These are read from TypeClasses.
 * The propertyMappings field stores which other properties this intrinsic should be set for in Gotham.
 */
interface GothamPropertyIntrinsicMapping {
    gothamIntrinsicType: GothamIntrinsic;
    propertyMappings: Array<PropertyTypeRid>;
}
/**
 * The propertyMappings field stores which properties populate the intrinsic values for specific Gotham
 * intrinsics.
 *
 * A foundry property that represents a property level intrinsic in Gotham. These are read from TypeClasses.
 */
interface GothamPropertyIntrinsicMappingV2 {
    propertyMappings: Record<GothamIntrinsicV2, PropertyTypeRid>;
}
/**
 * The propertyMappings field stores which struct fields populate the Gotham intrinsic values for this property.
 * Struct fields that are marked as intrinsics here will be ignored during type mapping. This means if you had a
 * struct like {age: int, startDate: timestamp (intrinsic), location: geohash (intrinsic)}, Gotham would ignore
 * the latter 2 fields and map this as an integer property type, not a struct property type.
 */
interface GothamPropertyIntrinsicMappingV3 {
    propertyMappings: Record<GothamIntrinsicV2, StructFieldRid>;
}
type GothamPropertyTypeUri = string;
interface ObjectTypeGothamMapping {
    dataSource?: PropertyTypeRid | null | undefined;
    gothamMappingEnabled?: boolean | null | undefined;
    gothamTitleProperty?: PropertyTypeRid | null | undefined;
    objectLevelIntrinsics: Record<PropertyTypeRid, GothamObjectIntrinsicMapping>;
    objectLevelIntrinsicsV2: Record<GothamIntrinsicV2, PropertyTypeRid>;
    parentType: GothamOntologyParentType;
    parentTypeUri?: GothamOntologyParentTypeUri | null | undefined;
    propertyLevelDatasources: Record<PropertyTypeRid, GothamPropertyDatasourceMapping>;
    propertyLevelIntrinsics: Record<PropertyTypeRid, GothamPropertyIntrinsicMapping>;
    propertyLevelIntrinsicsV2: Record<PropertyTypeRid, GothamPropertyIntrinsicMappingV2>;
    propertyLevelIntrinsicsV3: Record<PropertyTypeRid, GothamPropertyIntrinsicMappingV3>;
    propertyMapping: Record<PropertyTypeRid, PropertyTypeGothamMapping>;
    revDbIntegrationState: RevDbIntegrationState;
    uri: GothamObjectTypeUri;
}
interface PropertyTypeGothamMapping {
    structApiNameToComponentUriMapping: Record<ObjectTypeFieldApiName, GothamPropertyComponentUri>;
    uri: GothamPropertyTypeUri;
}
type RevDbIntegrationState = "ENABLED" | "PAUSED" | "DISABLED";
interface SharedPropertyTypeGothamMapping {
    structApiNameToComponentUriMapping: Record<ObjectTypeFieldApiName, GothamPropertyComponentUri>;
    uri: GothamPropertyTypeUri;
}

/**
 * Action Log is not required for this ObjectType.
 */
interface ActionLogNotRequired {
}
/**
 * Action Log is required for this ObjectType.
 */
interface ActionLogRequiredForObjectType {
}
/**
 * Types of Action Log requiredness. Currently logging is either required or not but in future other kinds of
 * requiredness, such as property-level logging requiredness, may be introduced.
 */
interface ActionLogRequirednessMetadata {
    actionLogRequirednessSetting: ActionLogRequirednessSetting;
    lastUpdated: string;
}
interface ActionLogRequirednessSetting_actionLogNotRequired {
    type: "actionLogNotRequired";
    actionLogNotRequired: ActionLogNotRequired;
}
interface ActionLogRequirednessSetting_actionLogRequiredForObjectType {
    type: "actionLogRequiredForObjectType";
    actionLogRequiredForObjectType: ActionLogRequiredForObjectType;
}
/**
 * Types of Action Log requiredness. Currently logging is either required or not but in future other kinds of
 * requiredness may be introduced.
 */
type ActionLogRequirednessSetting = ActionLogRequirednessSetting_actionLogNotRequired | ActionLogRequirednessSetting_actionLogRequiredForObjectType;
type Alias = string;
/**
 * Delegates the selected transform profile to Funnel.
 */
interface AutomaticTransformProfile {
}
/**
 * With this strategy, whether a datasource is alive for a given object is evaluated on a
 * datasource-by-datasource basis. This can have unintuitive consequences if properties are moved between
 * different datasources, as the MarkAlive instructions within the patch will not be adjusted to reflect the new
 * datasources containing the edited properties. In such cases, if the new datasource were not otherwise marked
 * as alive, the values of the migrated properties would become nulls.
 */
interface DatasourceScopedLivenessStrategy {
}
type DayOfWeek = "MONDAY" | "TUESDAY" | "WEDNESDAY" | "THURSDAY" | "FRIDAY" | "SATURDAY" | "SUNDAY";
interface DayTime {
    day: DayOfWeek;
    time: string;
    zoneId: string;
}
interface EditsHistory_config {
    type: "config";
    config: EditsHistoryConfig;
}
interface EditsHistory_none {
    type: "none";
    none: NoEditsHistory;
}
type EditsHistory = EditsHistory_config | EditsHistory_none;
/**
 * Edits history tracking is enabled for this entity with the specified configuration. All action edits
 * for objects of this object type will be available for querying from the point the history was enabled.
 */
interface EditsHistoryConfig {
    store: ObjectTypeRid;
}
/**
 * Contains configuration to import edits history from Phonograph to Funnel/Highbury.
 */
interface EditsHistoryImportConfiguration {
}
/**
 * Wrapper for multiple strategies as objects can have multiple datasources.
 */
interface EditsResolutionStrategies {
    strategies: Record<DatasourceRid, EditsResolutionStrategy>;
}
interface EditsResolutionStrategy_timestampProperty {
    type: "timestampProperty";
    timestampProperty: TimestampPropertyStrategy;
}
/**
 * The strategy used when resolving conflicts between user edits and datasource values.
 */
type EditsResolutionStrategy = EditsResolutionStrategy_timestampProperty;
/**
 * Contains ObjectDb configurations for a particular ObjectType or LinkType.
 */
interface EntityConfig {
    objectDbTypeConfigs: Record<ObjectDbType, ObjectDbTypeConfig>;
}
interface EntityMigrationCategory_objectStorageV1 {
    type: "objectStorageV1";
    objectStorageV1: ObjectStorageV1;
}
interface EntityMigrationCategory_readOnlyV1V2 {
    type: "readOnlyV1V2";
    readOnlyV1V2: ReadOnlyV1V2;
}
/**
 * Migration category depending on the previous targetStorageBackend setting.
 */
type EntityMigrationCategory = EntityMigrationCategory_objectStorageV1 | EntityMigrationCategory_readOnlyV1V2;
/**
 * Funnel jobs for this object types will be run with the largest possible transform profile. Note that this
 * value is designed as a break-the-glass option for failing jobs and should be used carefully. Unnecessary
 * usage of this option could lead to expensive builds and hog resources from other builds/services.
 */
interface ExtraLargeTransformProfile {
}
/**
 * Contains additional metadata associated with a LinkType.
 */
interface LinkTypeEntityMetadata {
    arePatchesEnabled: boolean;
    entityConfig: EntityConfig;
    provenance?: EntityProvenance | null | undefined;
    redacted?: boolean | null | undefined;
    targetStorageBackend: StorageBackend;
}
/**
 * Contains configuration for Phonograph to Funnel/Highbury migration.
 */
interface MigrationConfiguration {
    entityMigrationCategory: EntityMigrationCategory;
    importEditsHistory?: boolean | null | undefined;
    minMigrationDuration: string;
    transitionRetryLimit: number;
    transitionWindows: TransitionWindows;
}
/**
 * Edits history is disabled for this entity.
 */
interface NoEditsHistory {
}
/**
 * Configuration for one instance of an ObjectDb, for example for one Highbury cluster.
 * If `configValue` is left empty, the ObjectDb should apply the default configuration for this entity.
 * If `configValue` is present, interpretation of the string is responsibility of the ObjectDb.
 */
interface ObjectDbConfig {
    configValue?: string | null | undefined;
}
/**
 * Represents the type of ObjectDb, for example Highbury or Writeback. The value corresponds to the type field
 * advertised by the ObjectDb in the "funnel-sync-manager" discovery role.
 *
 * The maximum size of the objects DB type is 20 bytes, when encoded in UTF-8.
 */
type ObjectDbType = string;
/**
 * Configuration for one type of ObjectDb which contains the individual configurations for each cluster
 * of the particular ObjectDbType.
 */
interface ObjectDbTypeConfig {
    objectDbConfigs: Record<ObjectDbRid, ObjectDbConfig>;
}
/**
 * With this strategy, liveness is no longer evaluated on a datasource-by-datasource level, and is evaluated at
 * the object level. This provides improved UX for MDOs, and has no effect for non-MDOs.
 */
interface ObjectScopedLivenessStrategy {
}
/**
 * Entity can be stored in Phonograph. Note that it is not guaranteed that the object type or link type is
 * currently registered with Phonograph. There is no guarantee the object type or link type has finished
 * syncing and is queryable via Phonograph.
 */
interface ObjectStorageV1 {
}
/**
 * Entity can be stored in Highbury and other V2 Object DBs. It is not possible to store the entity in Phonograph.
 * Edits can be enabled or disabled using the `arePatchesEnabled` field in ObjectTypeEntityMetadata/LinkTypeEntityMetadata.
 *
 * Note that this field indicates a target state. There is no guarantee that the object type or link type has
 * finished syncing. A migration may currently be in progress and queries may still be served by Phonograph during
 * particular stages of the migration process.
 *
 * In order to determine whether the object type or link type can be queried via OSv2 the Funnel getCurrentView
 * endpoint can be used.
 */
interface ObjectStorageV2 {
    editsHistoryImportConfiguration?: EditsHistoryImportConfiguration | null | undefined;
    migrationConfiguration?: MigrationConfiguration | null | undefined;
}
type ObjectTypeAlias = Alias;
/**
 * Contains additional metadata associated with an ObjectType.
 */
interface ObjectTypeEntityMetadata {
    actionLogRequirednessMetadata?: ActionLogRequirednessMetadata | null | undefined;
    aliases: Array<ObjectTypeAlias>;
    arePatchesEnabled: boolean;
    diffEdits: boolean;
    editsHistory: EditsHistory;
    editsResolutionStrategies: EditsResolutionStrategies;
    entityConfig: EntityConfig;
    gothamMapping?: ObjectTypeGothamMapping | null | undefined;
    objectTypeIndexingSettings?: ObjectTypeIndexingSettings | null | undefined;
    patchApplicationStrategy: PatchApplicationStrategy;
    provenance?: EntityProvenance | null | undefined;
    redacted?: boolean | null | undefined;
    targetStorageBackend: StorageBackend;
}
/**
 * Settings related to indexing object types in Funnel.
 */
interface ObjectTypeIndexingSettings {
    transformProfileConfig?: TransformProfileConfig | null | undefined;
}
/**
 * Contains additional metadata associated with a LinkType.
 */
interface OntologyIrLinkTypeEntityMetadata {
    arePatchesEnabled: boolean;
}
interface PatchApplicationStrategy_datasourceScopedLiveness {
    type: "datasourceScopedLiveness";
    datasourceScopedLiveness: DatasourceScopedLivenessStrategy;
}
interface PatchApplicationStrategy_objectScopedLiveness {
    type: "objectScopedLiveness";
    objectScopedLiveness: ObjectScopedLivenessStrategy;
}
type PatchApplicationStrategy = PatchApplicationStrategy_datasourceScopedLiveness | PatchApplicationStrategy_objectScopedLiveness;
/**
 * Entity can be stored in Phonograph and Highbury though the data is read-only. Edits are disabled.
 * This is a legacy state which should not be used anymore. OMS guarantees that the latest version of each
 * ontology does not return this state for any object type or link type.
 */
interface ReadOnlyV1V2 {
}
type SharedPropertyTypeAlias = Alias;
interface StorageBackend_objectStorageV1 {
    type: "objectStorageV1";
    objectStorageV1: ObjectStorageV1;
}
interface StorageBackend_readOnlyV1V2 {
    type: "readOnlyV1V2";
    readOnlyV1V2: ReadOnlyV1V2;
}
interface StorageBackend_objectStorageV2 {
    type: "objectStorageV2";
    objectStorageV2: ObjectStorageV2;
}
/**
 * Storage backend intended to be used for the Entity. This is used to indicate whether
 * an entity can be stored in Phonograph or Highbury.
 */
type StorageBackend = StorageBackend_objectStorageV1 | StorageBackend_readOnlyV1V2 | StorageBackend_objectStorageV2;
/**
 * For this strategy, the datasource value should be used when the time in the given timestamp property is
 * more recent than the time the patch is applied.
 */
interface TimestampPropertyStrategy {
    timestampPropertyRid: PropertyTypeRid;
}
interface TransformProfileConfig_automatic {
    type: "automatic";
    automatic: AutomaticTransformProfile;
}
interface TransformProfileConfig_extraLarge {
    type: "extraLarge";
    extraLarge: ExtraLargeTransformProfile;
}
/**
 * A transform profile is an abstraction over the set of Spark profiles to be used for a Funnel job. The exact
 * Spark profiles used may be defined elsewhere (e.g. Funnel).
 */
type TransformProfileConfig = TransformProfileConfig_automatic | TransformProfileConfig_extraLarge;
/**
 * An interval between two times. A start and end time that are exactly the same mean all day.
 */
interface TransitionWindow {
    end: DayTime;
    start: DayTime;
}
/**
 * A set of TransitionWindows during which the migration state machine can do possibly disruptive transitions.
 * An empty set means that it is always safe to do the transitions. Examples of disruptive transitions are
 * temporarily disabling edits and perf degradation when interacting with migrating ontology entity.
 */
interface TransitionWindows {
    timeIntervals: Array<TransitionWindow>;
}

type ActionParameterShapeId = string;
interface ActionTypeBlockDataV2 {
    actionType: ActionType;
    parameterIds: Record<ActionParameterShapeId, ParameterId>;
}
interface ActionTypePermissionInformation {
    restrictionStatus: ActionTypeRestrictionStatus;
}
interface ActionTypeRestrictionStatus {
    hasRolesApplied: boolean;
    ontologyPackageRid?: OntologyPackageRid | null | undefined;
}
type BlockInternalId = string;
interface BlockPermissionInformation {
    actionTypes: Record<ActionTypeRid, ActionTypePermissionInformation>;
    linkTypes: Record<LinkTypeRid, LinkTypePermissionInformation>;
    objectTypes: Record<ObjectTypeRid, ObjectTypePermissionInformation>;
}
type BlockShapeId = BlockInternalId;
/**
 * API_NAME_FORMATTED is the recommended option for most use cases. API_NAME_FORMATTED uses the snake case format
 * of property api names while API_NAME uses the default camel case format. DATASOURCE_COLUMN_NAME uses the
 * column names of the backing datasource. However, it will use API_NAME_FORMATTED for columns that do not have
 * a backing column name (eg. edit-only properties). DATASOURCE_COLUMN_NAME should generally only be used for
 * migration of writeback datasets from V1 backend. PROPERTY_ID is deprecated.
 */
type ColumnNameType = "PROPERTY_RID" | "PROPERTY_ID" | "API_NAME" | "API_NAME_FORMATTED" | "DATASOURCE_COLUMN_NAME";
interface DataFilter {
    datasourceFilter: DatasourcePredicate;
    propertyFilter: PropertyPredicate;
}
/**
 * Ontology as code uses this as a stable ID for the datasource input
 */
type DataSetName = string;
interface DatasourcePredicate_or {
    type: "or";
    or: Array<DatasourcePredicate>;
}
interface DatasourcePredicate_hasRid {
    type: "hasRid";
    hasRid: DatasourceRid;
}
interface DatasourcePredicate_isOnlyDatasource {
    type: "isOnlyDatasource";
    isOnlyDatasource: IsOnlyDatasource;
}
type DatasourcePredicate = DatasourcePredicate_or | DatasourcePredicate_hasRid | DatasourcePredicate_isOnlyDatasource;
/**
 * Ontology as code uses this as a stable ID for GeotimeSeriesIntegration inputs
 */
type GeotimeSeriesIntegrationName = string;
interface ImportedActionType {
    apiName: ActionTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    parameters: Array<ImportedParameter>;
}
interface ImportedInterfaceLinkType {
    apiName: InterfaceLinkTypeApiName;
    cardinality: InterfaceLinkTypeCardinality;
    description?: string | null | undefined;
    displayName: string;
    required: boolean;
}
interface ImportedInterfaceType {
    apiName: InterfaceTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    links: Array<ImportedInterfaceLinkType>;
    properties: Array<ImportedSharedPropertyType>;
}
interface ImportedLinkDefinition_manyToMany {
    type: "manyToMany";
    manyToMany: ImportedManyToManyLinkDefinition;
}
interface ImportedLinkDefinition_oneToMany {
    type: "oneToMany";
    oneToMany: ImportedOneToManyLinkDefinition;
}
type ImportedLinkDefinition = ImportedLinkDefinition_manyToMany | ImportedLinkDefinition_oneToMany;
interface ImportedLinkType {
    definition: ImportedLinkDefinition;
    id: LinkTypeId;
}
interface ImportedManyToManyLinkDefinition {
    objectTypeApiNameA: ObjectTypeApiName;
    objectTypeApiNameB: ObjectTypeApiName;
    objectTypeAToBLinkDisplayName: string;
    objectTypeBToALinkDisplayName: string;
}
interface ImportedObjectType {
    apiName: ObjectTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    propertyTypes: Array<ImportedPropertyType>;
}
interface ImportedOneToManyLinkDefinition {
    cardinality?: OneToManyLinkCardinalityHint | null | undefined;
    manyToOneLinkDisplayName: string;
    objectTypeApiNameManySide: ObjectTypeApiName;
    objectTypeApiNameOneSide: ObjectTypeApiName;
    oneToManyLinkDisplayName: string;
}
interface ImportedParameter {
    description?: string | null | undefined;
    displayName: string;
    id: ParameterId;
    type: BaseParameterType;
}
interface ImportedPropertyType {
    apiName: ObjectTypeFieldApiName;
    description?: string | null | undefined;
    displayName: string;
    sharedPropertyType?: ObjectTypeFieldApiName | null | undefined;
    type: Type;
}
interface ImportedSharedPropertyType {
    apiName: ObjectTypeFieldApiName;
    description?: string | null | undefined;
    displayName: string;
    type: Type;
}
interface ImportedTypes {
    actionTypes: Array<ImportedActionType>;
    interfaceTypes: Array<ImportedInterfaceType>;
    linkTypes: Array<ImportedLinkType>;
    objectTypes: Array<ImportedObjectType>;
    sharedPropertyTypes: Array<ImportedSharedPropertyType>;
}
type InstallLocationBlockShapeId = BlockShapeId;
interface InterfaceTypeBlockDataV2 {
    interfaceType: InterfaceType;
}
/**
 * Will only match if there is a single datasource that matches the output type (e.g. a dataset datasource
 * with an export dataset, or a restricted view datasource with an export restricted view). In the case of exporting
 * an RV datasource as a dataset, use DatasourcePredicate#hasRid instead.
 */
interface IsOnlyDatasource {
}
interface KnownMarketplaceIdentifiers {
    actionParameterIds: Record<ActionTypeRid, Record<ParameterId, BlockInternalId>>;
    actionParameters: Record<ParameterRid, BlockInternalId>;
    actionTypes: Record<ActionTypeRid, BlockInternalId>;
    datasourceColumns: Record<BlockInternalId, any>;
    datasources: Record<BlockInternalId, any>;
    filesDatasources: Record<BlockInternalId, any>;
    functions: Record<FunctionRid, Record<FunctionVersion, BlockInternalId>>;
    geotimeSeriesSyncs: Record<GeotimeSeriesIntegrationRid, BlockInternalId>;
    groupIds: Record<GroupId, BlockInternalId>;
    interfaceLinkTypes: Record<InterfaceLinkTypeRid, BlockInternalId>;
    interfaceTypes: Record<InterfaceTypeRid, BlockInternalId>;
    linkTypeIds: Record<LinkTypeId, BlockInternalId>;
    linkTypes: Record<LinkTypeRid, BlockInternalId>;
    objectTypeIds: Record<ObjectTypeId, BlockInternalId>;
    objectTypes: Record<ObjectTypeRid, BlockInternalId>;
    propertyTypeIds: Record<ObjectTypeId, Record<PropertyTypeId, BlockInternalId>>;
    propertyTypes: Record<PropertyTypeRid, BlockInternalId>;
    shapeIdForInstallPrefix?: BlockShapeId | null | undefined;
    shapeIdForOntologyAllowSchemaMigrations?: BlockShapeId | null | undefined;
    sharedPropertyTypes: Record<SharedPropertyTypeRid, BlockInternalId>;
    timeSeriesSyncs: Record<TimeSeriesSyncRid, BlockInternalId>;
    valueTypes: Record<ValueTypeRid$1, Record<ValueTypeVersionId$1, BlockInternalId>>;
    webhooks: Record<WebhookRid, BlockInternalId>;
    workshopModules: Record<ModuleRid, BlockInternalId>;
}
interface LinkTypeBlockDataV2 {
    datasources: Array<ManyToManyLinkTypeDatasource>;
    entityMetadata?: LinkTypeEntityMetadata | null | undefined;
    linkType: LinkType;
}
interface LinkTypePermissionInformation {
    restrictionStatus: LinkTypeRestrictionStatus;
}
interface LinkTypeRestrictionStatus {
    editRestrictedByDatasources: boolean;
    ontologyPackageRid?: OntologyPackageRid | null | undefined;
    restrictedByDatasources: boolean;
}
/**
 * Local overridden alias of OMS public API representation of ObjectTypeEntityMetadata. In OMS API we model
 * editsResolutionStrategies field as non-optional, but Marketplace ontology block data uploaded to
 * artifacts faces similar constraints as our internal StorageObjectTypeEntityMetadata and we need to provide
 * runtime conversion with default value.
 */
interface MarketplaceObjectTypeEntityMetadata {
    actionLogRequirednessMetadata?: ActionLogRequirednessMetadata | null | undefined;
    aliases: Array<ObjectTypeAlias>;
    arePatchesEnabled: boolean;
    diffEdits: boolean;
    editsHistory?: EditsHistory | null | undefined;
    editsResolutionStrategies?: EditsResolutionStrategies | null | undefined;
    entityConfig: EntityConfig;
    gothamMapping?: ObjectTypeGothamMapping | null | undefined;
    patchApplicationStrategy?: PatchApplicationStrategy | null | undefined;
    provenance?: EntityProvenance | null | undefined;
    redacted?: boolean | null | undefined;
    targetStorageBackend: StorageBackend;
}
/**
 * Ontology as code uses this as a stable ID for MediaSetView inputs
 */
type MediaSetViewName = string;
interface ObjectsWritebackDataset {
    columnMapping: Record<PropertyTypeRid, ColumnName>;
    objectTypeRid: ObjectTypeRid;
    outputMode: OutputMode;
    rid: WritebackDatasetRid;
    spec: WritebackDatasetSpec;
}
interface ObjectTypeBlockDataV2 {
    datasources: Array<ObjectTypeDatasource>;
    entityMetadata?: MarketplaceObjectTypeEntityMetadata | null | undefined;
    objectType: ObjectType;
    schemaMigrations?: SchemaMigrationBlockData | null | undefined;
    writebackDatasets: Array<ObjectsWritebackDataset>;
}
interface ObjectTypePermissionInformation {
    restrictionStatus: ObjectTypeRestrictionStatus;
}
interface ObjectTypeRestrictionStatus {
    editRestrictedByDatasources: boolean;
    ontologyPackageRid?: OntologyPackageRid | null | undefined;
    restrictedByDatasources: boolean;
}
interface OntologyBlockDataV2 {
    actionTypes: Record<ActionTypeRid, ActionTypeBlockDataV2>;
    blockOutputCompassLocations: Record<BlockShapeId, InstallLocationBlockShapeId>;
    blockPermissionInformation?: BlockPermissionInformation | null | undefined;
    interfaceTypes: Record<InterfaceTypeRid, InterfaceTypeBlockDataV2>;
    knownIdentifiers: KnownMarketplaceIdentifiers;
    linkTypes: Record<LinkTypeRid, LinkTypeBlockDataV2>;
    objectTypes: Record<ObjectTypeRid, ObjectTypeBlockDataV2>;
    ruleSets: Record<RuleSetRid, RuleSet>;
    sharedPropertyTypes: Record<SharedPropertyTypeRid, SharedPropertyTypeBlockDataV2>;
}
interface OntologyIrActionTypeBlockDataV2 {
    actionType: OntologyIrActionType;
}
interface OntologyIrBlockPermissionInformation {
    actionTypes: Record<ActionTypeApiName, ActionTypePermissionInformation>;
    linkTypes: Record<LinkTypeId, LinkTypePermissionInformation>;
    objectTypes: Record<ObjectTypeApiName, ObjectTypePermissionInformation>;
}
interface OntologyIrImportedActionType {
    apiName: ActionTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    parameters: Array<OntologyIrImportedParameter>;
}
interface OntologyIrImportedInterfaceType {
    apiName: InterfaceTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    links: Array<ImportedInterfaceLinkType>;
    properties: Array<OntologyIrImportedSharedPropertyType>;
}
interface OntologyIrImportedObjectType {
    apiName: ObjectTypeApiName;
    description?: string | null | undefined;
    displayName: string;
    propertyTypes: Array<OntologyIrImportedPropertyType>;
}
interface OntologyIrImportedParameter {
    description?: string | null | undefined;
    displayName: string;
    id: ParameterId;
    type: OntologyIrBaseParameterType;
}
interface OntologyIrImportedPropertyType {
    apiName: ObjectTypeFieldApiName;
    description?: string | null | undefined;
    displayName: string;
    sharedPropertyType?: ObjectTypeFieldApiName | null | undefined;
    type: OntologyIrType;
}
interface OntologyIrImportedSharedPropertyType {
    apiName: ObjectTypeFieldApiName;
    description?: string | null | undefined;
    displayName: string;
    type: OntologyIrType;
}
interface OntologyIrImportedTypes {
    actionTypes: Array<OntologyIrImportedActionType>;
    interfaceTypes: Array<OntologyIrImportedInterfaceType>;
    linkTypes: Array<ImportedLinkType>;
    objectTypes: Array<OntologyIrImportedObjectType>;
    sharedPropertyTypes: Array<OntologyIrImportedSharedPropertyType>;
}
interface OntologyIrInterfaceTypeBlockDataV2 {
    interfaceType: OntologyIrInterfaceType;
}
interface OntologyIrKnownMarketplaceIdentifiers {
    actionParameterIds: Record<ActionTypeApiName, Record<ParameterId, BlockInternalId>>;
    actionParameters: Record<ParameterRid, BlockInternalId>;
    actionTypes: Record<ActionTypeApiName, BlockInternalId>;
    datasourceColumns: Record<BlockInternalId, any>;
    datasources: Record<BlockInternalId, any>;
    filesDatasources: Record<BlockInternalId, any>;
    functions: Record<FunctionRid, Record<FunctionVersion, BlockInternalId>>;
    geotimeSeriesSyncs: Record<GeotimeSeriesIntegrationName, BlockInternalId>;
    groupIds: Record<GroupId, BlockInternalId>;
    interfaceLinkTypes: Record<InterfaceLinkTypeApiName, BlockInternalId>;
    interfaceTypes: Record<InterfaceTypeApiName, BlockInternalId>;
    linkTypeIds: Record<LinkTypeId, BlockInternalId>;
    linkTypes: Record<LinkTypeId, BlockInternalId>;
    objectTypeIds: Record<ObjectTypeApiName, BlockInternalId>;
    objectTypes: Record<ObjectTypeApiName, BlockInternalId>;
    propertyTypeIds: Record<ObjectTypeApiName, Record<ObjectTypeFieldApiName, BlockInternalId>>;
    propertyTypes: Record<ObjectTypeFieldApiName, BlockInternalId>;
    shapeIdForInstallPrefix?: BlockShapeId | null | undefined;
    shapeIdForOntologyAllowSchemaMigrations?: BlockShapeId | null | undefined;
    sharedPropertyTypes: Record<ObjectTypeFieldApiName, BlockInternalId>;
    timeSeriesSyncs: Record<TimeSeriesSyncName, BlockInternalId>;
    valueTypes: Record<ValueTypeRid$1, Record<ValueTypeVersionId$1, BlockInternalId>>;
    webhooks: Record<WebhookRid, BlockInternalId>;
    workshopModules: Record<ModuleRid, BlockInternalId>;
}
interface OntologyIrLinkTypeBlockDataV2 {
    datasources: Array<OntologyIrManyToManyLinkTypeDatasource>;
    entityMetadata?: OntologyIrLinkTypeEntityMetadata | null | undefined;
    linkType: OntologyIrLinkType;
}
/**
 * Local overridden alias of OMS public API representation of ObjectTypeEntityMetadata. In OMS API we model
 * editsResolutionStrategies field as non-optional, but Marketplace ontology block data uploaded to
 * artifacts faces similar constraints as our internal StorageObjectTypeEntityMetadata and we need to provide
 * runtime conversion with default value.
 */
interface OntologyIrMarketplaceObjectTypeEntityMetadata {
    arePatchesEnabled: boolean;
}
/**
 * Property reference containing the api name of the object
 */
interface OntologyIrObjectPropertyReference {
    apiName: ObjectTypeFieldApiName;
    object: ObjectTypeApiName;
}
interface OntologyIrObjectsWritebackDataset {
    columnMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    objectTypeRid: ObjectTypeApiName;
    outputMode: OutputMode;
    rid: WritebackDatasetRid;
    spec: WritebackDatasetSpec;
}
interface OntologyIrObjectTypeBlockDataV2 {
    datasources: Array<OntologyIrObjectTypeDatasource>;
    entityMetadata?: OntologyIrMarketplaceObjectTypeEntityMetadata | null | undefined;
    objectType: OntologyIrObjectType;
}
interface OntologyIrOntologyBlockDataV2 {
    actionTypes: Record<ActionTypeApiName, OntologyIrActionTypeBlockDataV2>;
    blockPermissionInformation?: OntologyIrBlockPermissionInformation | null | undefined;
    interfaceTypes: Record<InterfaceTypeApiName, OntologyIrInterfaceTypeBlockDataV2>;
    linkTypes: Record<LinkTypeId, OntologyIrLinkTypeBlockDataV2>;
    objectTypes: Record<ObjectTypeApiName, OntologyIrObjectTypeBlockDataV2>;
    sharedPropertyTypes: Record<ObjectTypeFieldApiName, OntologyIrSharedPropertyTypeBlockDataV2>;
}
/**
 * Because complex objects can't be used as map keys over the wire, this is used in many to many link dataset datasource
 */
interface OntologyIrPropertyToColumnMapping {
    column: ColumnName;
    property: OntologyIrObjectPropertyReference;
}
/**
 * Because complex objects can't be used as map keys over the wire, this is used in link definitions
 */
interface OntologyIrPropertyToPropertyMapping {
    from: OntologyIrObjectPropertyReference;
    to: OntologyIrObjectPropertyReference;
}
interface OntologyIrSchemaMigrationBlockData {
    propertyTypeRidsToIds: Record<ObjectTypeFieldApiName, ObjectTypeFieldApiName>;
    schemaMigrations: OntologyIrSchemaTransitionsWithSchemaVersion;
}
interface OntologyIrSchemaTransitionsWithSchemaVersion {
    schemaTransitions: Array<OntologyIrSchemaTransition>;
    schemaVersion: SchemaVersion;
}
interface OntologyIrSharedPropertyTypeBlockDataV2 {
    sharedPropertyType: OntologyIrSharedPropertyType;
}
type OutputMode = "RESTRICTED_VIEW" | "DATASET";
interface PatchesConfiguration {
    lowLatencyUpdatesEnabled: boolean;
}
interface PropertyPredicate_and {
    type: "and";
    and: Array<PropertyPredicate>;
}
interface PropertyPredicate_or {
    type: "or";
    or: Array<PropertyPredicate>;
}
interface PropertyPredicate_not {
    type: "not";
    not: PropertyPredicate;
}
interface PropertyPredicate_hasId {
    type: "hasId";
    hasId: PropertyId;
}
interface PropertyPredicate_hasRid {
    type: "hasRid";
    hasRid: PropertyRid;
}
type PropertyPredicate = PropertyPredicate_and | PropertyPredicate_or | PropertyPredicate_not | PropertyPredicate_hasId | PropertyPredicate_hasRid;
type PropertyRid = string;
/**
 * Ontology as code uses this as a stable ID for the restricted view input
 */
type RestrictedViewName = string;
interface SchemaConfiguration {
    columnNameType: ColumnNameType;
}
interface SchemaMigrationBlockData {
    propertyTypeRidsToIds: Record<PropertyTypeRid, PropertyTypeId>;
    schemaMigrations: SchemaTransitionsWithSchemaVersion;
}
interface SchemaTransitionsWithSchemaVersion {
    schemaTransitions: Array<SchemaTransition>;
    schemaVersion: SchemaVersion;
}
interface SharedPropertyTypeBlockDataV2 {
    sharedPropertyType: SharedPropertyType;
}
/**
 * Ontology as code uses this as a stable ID for the stream input
 */
type StreamName = string;
/**
 * Ontology as code uses this as a stable ID for TimeSeriesSync inputs
 */
type TimeSeriesSyncName = string;
/**
 * The index of the validation rule within an action. This is used both for identification and ordering.
 */
type ValidationRuleIndex = number;
type WritebackDatasetRid = string;
interface WritebackDatasetSpec {
    filter: DataFilter;
    patchesConfiguration?: PatchesConfiguration | null | undefined;
    schemaConfiguration: SchemaConfiguration;
}

interface AllPropertiesPropertySet {
}
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an AndFilter iff it matches all of the filters.
 */
interface AndFilter {
    filters: Array<ObjectSetFilter>;
}
interface Distance {
    unit: DistanceUnit;
    value: number | "NaN" | "Infinity" | "-Infinity";
}
type DistanceUnit = "MILLIMETER" | "CENTIMETER" | "METER" | "KILOMETER" | "INCH" | "FOOT" | "YARD" | "MILE" | "NAUTICAL_MILE";
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, the index for that property must define a .raw multifield of type keyword.
 * If no terms are provided, this filter will match ALL objects.
 */
interface ExactMatchFilter {
    propertyId: PropertyTypeId;
    terms: Array<any>;
}
interface FilterParameter_unresolved {
    type: "unresolved";
    unresolved: UnresolvedFilterParameter;
}
interface FilterParameter_resolved {
    type: "resolved";
    resolved: ResolvedFilterParameter;
}
type FilterParameter = FilterParameter_unresolved | FilterParameter_resolved;
type FilterValue = any;
/**
 * An object matches a GeoBoundingBoxFilter iff the value of the provided property is within the provided bounds.
 * Works on geohash properties.
 */
interface GeoBoundingBoxFilter {
    bottomRight: string;
    propertyId: PropertyTypeId;
    topLeft: string;
}
/**
 * An object matches a GeoDistanceFilter iff the value of the provided property is within the provided distance
 * of the provided location i.e. sits within a circle centered at the provided location.
 */
interface GeoDistanceFilter {
    distance: Distance;
    location: string;
    propertyId: PropertyTypeId;
}
/**
 * An object matches a GeoPolygonFilter iff the value of the provided property is within bounds of the provided polygon.
 */
interface GeoPolygonFilter {
    polygon: Array<string>;
    propertyId: PropertyTypeId;
}
/**
 * Filter properties of type geo_shape or geo_point.
 */
interface GeoShapeFilter {
    geoShapeQuery: GeoShapeQuery;
    spatialFilterMode: GeoShapeSpatialFilterMode;
}
interface GeoShapeQuery_geoBoundingBoxFilter {
    type: "geoBoundingBoxFilter";
    geoBoundingBoxFilter: GeoBoundingBoxFilter;
}
interface GeoShapeQuery_geoPolygonFilter {
    type: "geoPolygonFilter";
    geoPolygonFilter: GeoPolygonFilter;
}
/**
 * Union type for valid queries over geo shape properties.
 */
type GeoShapeQuery = GeoShapeQuery_geoBoundingBoxFilter | GeoShapeQuery_geoPolygonFilter;
/**
 * Geometry operation under which to evaluate the geo shape query.
 */
type GeoShapeSpatialFilterMode = "INTERSECTS" | "DISJOINT" | "WITHIN";
/**
 * An object matches a HasPropertyFilter iff it has a property with the provided PropertyId.
 */
interface HasPropertyFilter {
    propertyId: PropertyTypeId;
}
/**
 * An object matches a LinkPresenceFilter iff it contains a link to any object along the provided RelationId
 * and if the starting object is on the provided RelationSide of the relation.
 */
interface LinkPresenceFilter {
    relationId: RelationId;
    relationSide: RelationSide;
}
/**
 * An object matches a MultiMatchFilter iff any of the fields matches the query, or in the case where a
 * property whitelist is provided - iff any of the specifed fields matches the query.
 */
interface MultiMatchFilter {
    fuzzy: boolean;
    operator?: MultiMatchFilterOperator | null | undefined;
    propertySet: PropertySet;
    query: string;
}
type MultiMatchFilterOperator = "AND" | "OR";
/**
 * The current user's attributes under the given key. This resolves to a list of values.
 */
interface MultipassAttribute {
    key: string;
}
/**
 * The current user's Multipass user id.
 */
interface MultipassUserId {
}
/**
 * An object matches a NotFilter iff it does not match the provided filter.
 */
interface NotFilter {
    filter: ObjectSetFilter;
}
interface ObjectSetFilter_or {
    type: "or";
    or: OrFilter;
}
interface ObjectSetFilter_and {
    type: "and";
    and: AndFilter;
}
interface ObjectSetFilter_not {
    type: "not";
    not: NotFilter;
}
interface ObjectSetFilter_range {
    type: "range";
    range: RangeFilter;
}
interface ObjectSetFilter_wildcard {
    type: "wildcard";
    wildcard: WildcardFilter;
}
interface ObjectSetFilter_terms {
    type: "terms";
    terms: TermsFilter;
}
interface ObjectSetFilter_exactMatch {
    type: "exactMatch";
    exactMatch: ExactMatchFilter;
}
interface ObjectSetFilter_phrase {
    type: "phrase";
    phrase: PhraseFilter;
}
interface ObjectSetFilter_prefixOnLastToken {
    type: "prefixOnLastToken";
    prefixOnLastToken: PrefixOnLastTokenFilter;
}
interface ObjectSetFilter_geoBoundingBox {
    type: "geoBoundingBox";
    geoBoundingBox: GeoBoundingBoxFilter;
}
interface ObjectSetFilter_geoDistance {
    type: "geoDistance";
    geoDistance: GeoDistanceFilter;
}
interface ObjectSetFilter_geoPolygon {
    type: "geoPolygon";
    geoPolygon: GeoPolygonFilter;
}
interface ObjectSetFilter_geoShape {
    type: "geoShape";
    geoShape: GeoShapeFilter;
}
interface ObjectSetFilter_objectType {
    type: "objectType";
    objectType: ObjectTypeFilter;
}
interface ObjectSetFilter_hasProperty {
    type: "hasProperty";
    hasProperty: HasPropertyFilter;
}
interface ObjectSetFilter_linkPresence {
    type: "linkPresence";
    linkPresence: LinkPresenceFilter;
}
interface ObjectSetFilter_multiMatch {
    type: "multiMatch";
    multiMatch: MultiMatchFilter;
}
interface ObjectSetFilter_relativeDateRange {
    type: "relativeDateRange";
    relativeDateRange: RelativeDateRangeFilter;
}
interface ObjectSetFilter_relativeTimeRange {
    type: "relativeTimeRange";
    relativeTimeRange: RelativeTimeRangeFilter;
}
interface ObjectSetFilter_parameterizedRange {
    type: "parameterizedRange";
    parameterizedRange: ParameterizedRangeFilter;
}
interface ObjectSetFilter_parameterizedWildcard {
    type: "parameterizedWildcard";
    parameterizedWildcard: ParameterizedWildcardFilter;
}
interface ObjectSetFilter_parameterizedTerms {
    type: "parameterizedTerms";
    parameterizedTerms: ParameterizedTermsFilter;
}
interface ObjectSetFilter_parameterizedExactMatch {
    type: "parameterizedExactMatch";
    parameterizedExactMatch: ParameterizedExactMatchFilter;
}
interface ObjectSetFilter_userContext {
    type: "userContext";
    userContext: UserContextFilter;
}
/**
 * Filter to be applied to an Object Set. Refer to documentation of a particular ObjectSetFilter for details.
 */
type ObjectSetFilter = ObjectSetFilter_or | ObjectSetFilter_and | ObjectSetFilter_not | ObjectSetFilter_range | ObjectSetFilter_wildcard | ObjectSetFilter_terms | ObjectSetFilter_exactMatch | ObjectSetFilter_phrase | ObjectSetFilter_prefixOnLastToken | ObjectSetFilter_geoBoundingBox | ObjectSetFilter_geoDistance | ObjectSetFilter_geoPolygon | ObjectSetFilter_geoShape | ObjectSetFilter_objectType | ObjectSetFilter_hasProperty | ObjectSetFilter_linkPresence | ObjectSetFilter_multiMatch | ObjectSetFilter_relativeDateRange | ObjectSetFilter_relativeTimeRange | ObjectSetFilter_parameterizedRange | ObjectSetFilter_parameterizedWildcard | ObjectSetFilter_parameterizedTerms | ObjectSetFilter_parameterizedExactMatch | ObjectSetFilter_userContext;
/**
 * An object matches an ObjectTypeFilter iff its ObjectTypeId matches the provided ObjectTypeId.
 */
interface ObjectTypeFilter {
    objectTypeId: ObjectTypeId;
}
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an AndFilter iff it matches all of the filters.
 */
interface OntologyIrAndFilter {
    filters: Array<OntologyIrObjectSetFilter>;
}
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, the index for that property must define a .raw multifield of type keyword.
 * If no terms are provided, this filter will match ALL objects.
 */
interface OntologyIrExactMatchFilter {
    propertyId: ObjectTypeFieldApiName;
    terms: Array<any>;
}
/**
 * An object matches a GeoBoundingBoxFilter iff the value of the provided property is within the provided bounds.
 * Works on geohash properties.
 */
interface OntologyIrGeoBoundingBoxFilter {
    bottomRight: string;
    propertyId: ObjectTypeFieldApiName;
    topLeft: string;
}
/**
 * An object matches a GeoDistanceFilter iff the value of the provided property is within the provided distance
 * of the provided location i.e. sits within a circle centered at the provided location.
 */
interface OntologyIrGeoDistanceFilter {
    distance: Distance;
    location: string;
    propertyId: ObjectTypeFieldApiName;
}
/**
 * An object matches a GeoPolygonFilter iff the value of the provided property is within bounds of the provided polygon.
 */
interface OntologyIrGeoPolygonFilter {
    polygon: Array<string>;
    propertyId: ObjectTypeFieldApiName;
}
/**
 * Filter properties of type geo_shape or geo_point.
 */
interface OntologyIrGeoShapeFilter {
    geoShapeQuery: OntologyIrGeoShapeQuery;
    spatialFilterMode: GeoShapeSpatialFilterMode;
}
interface OntologyIrGeoShapeQuery_geoBoundingBoxFilter {
    type: "geoBoundingBoxFilter";
    geoBoundingBoxFilter: OntologyIrGeoBoundingBoxFilter;
}
interface OntologyIrGeoShapeQuery_geoPolygonFilter {
    type: "geoPolygonFilter";
    geoPolygonFilter: OntologyIrGeoPolygonFilter;
}
/**
 * Union type for valid queries over geo shape properties.
 */
type OntologyIrGeoShapeQuery = OntologyIrGeoShapeQuery_geoBoundingBoxFilter | OntologyIrGeoShapeQuery_geoPolygonFilter;
/**
 * An object matches a HasPropertyFilter iff it has a property with the provided PropertyId.
 */
interface OntologyIrHasPropertyFilter {
    propertyId: ObjectTypeFieldApiName;
}
/**
 * An object matches a MultiMatchFilter iff any of the fields matches the query, or in the case where a
 * property whitelist is provided - iff any of the specifed fields matches the query.
 */
interface OntologyIrMultiMatchFilter {
    fuzzy: boolean;
    operator?: MultiMatchFilterOperator | null | undefined;
    propertySet: OntologyIrPropertySet;
    query: string;
}
/**
 * An object matches a NotFilter iff it does not match the provided filter.
 */
interface OntologyIrNotFilter {
    filter: OntologyIrObjectSetFilter;
}
interface OntologyIrObjectSetFilter_or {
    type: "or";
    or: OntologyIrOrFilter;
}
interface OntologyIrObjectSetFilter_and {
    type: "and";
    and: OntologyIrAndFilter;
}
interface OntologyIrObjectSetFilter_not {
    type: "not";
    not: OntologyIrNotFilter;
}
interface OntologyIrObjectSetFilter_range {
    type: "range";
    range: OntologyIrRangeFilter;
}
interface OntologyIrObjectSetFilter_wildcard {
    type: "wildcard";
    wildcard: OntologyIrWildcardFilter;
}
interface OntologyIrObjectSetFilter_terms {
    type: "terms";
    terms: OntologyIrTermsFilter;
}
interface OntologyIrObjectSetFilter_exactMatch {
    type: "exactMatch";
    exactMatch: OntologyIrExactMatchFilter;
}
interface OntologyIrObjectSetFilter_phrase {
    type: "phrase";
    phrase: OntologyIrPhraseFilter;
}
interface OntologyIrObjectSetFilter_prefixOnLastToken {
    type: "prefixOnLastToken";
    prefixOnLastToken: OntologyIrPrefixOnLastTokenFilter;
}
interface OntologyIrObjectSetFilter_geoBoundingBox {
    type: "geoBoundingBox";
    geoBoundingBox: OntologyIrGeoBoundingBoxFilter;
}
interface OntologyIrObjectSetFilter_geoDistance {
    type: "geoDistance";
    geoDistance: OntologyIrGeoDistanceFilter;
}
interface OntologyIrObjectSetFilter_geoPolygon {
    type: "geoPolygon";
    geoPolygon: OntologyIrGeoPolygonFilter;
}
interface OntologyIrObjectSetFilter_geoShape {
    type: "geoShape";
    geoShape: OntologyIrGeoShapeFilter;
}
interface OntologyIrObjectSetFilter_objectType {
    type: "objectType";
    objectType: OntologyIrObjectTypeFilter;
}
interface OntologyIrObjectSetFilter_hasProperty {
    type: "hasProperty";
    hasProperty: OntologyIrHasPropertyFilter;
}
interface OntologyIrObjectSetFilter_linkPresence {
    type: "linkPresence";
    linkPresence: LinkPresenceFilter;
}
interface OntologyIrObjectSetFilter_multiMatch {
    type: "multiMatch";
    multiMatch: OntologyIrMultiMatchFilter;
}
interface OntologyIrObjectSetFilter_relativeDateRange {
    type: "relativeDateRange";
    relativeDateRange: OntologyIrRelativeDateRangeFilter;
}
interface OntologyIrObjectSetFilter_relativeTimeRange {
    type: "relativeTimeRange";
    relativeTimeRange: OntologyIrRelativeTimeRangeFilter;
}
interface OntologyIrObjectSetFilter_parameterizedRange {
    type: "parameterizedRange";
    parameterizedRange: OntologyIrParameterizedRangeFilter;
}
interface OntologyIrObjectSetFilter_parameterizedWildcard {
    type: "parameterizedWildcard";
    parameterizedWildcard: OntologyIrParameterizedWildcardFilter;
}
interface OntologyIrObjectSetFilter_parameterizedTerms {
    type: "parameterizedTerms";
    parameterizedTerms: OntologyIrParameterizedTermsFilter;
}
interface OntologyIrObjectSetFilter_parameterizedExactMatch {
    type: "parameterizedExactMatch";
    parameterizedExactMatch: OntologyIrParameterizedExactMatchFilter;
}
interface OntologyIrObjectSetFilter_userContext {
    type: "userContext";
    userContext: UserContextFilter;
}
/**
 * Filter to be applied to an Object Set. Refer to documentation of a particular ObjectSetFilter for details.
 */
type OntologyIrObjectSetFilter = OntologyIrObjectSetFilter_or | OntologyIrObjectSetFilter_and | OntologyIrObjectSetFilter_not | OntologyIrObjectSetFilter_range | OntologyIrObjectSetFilter_wildcard | OntologyIrObjectSetFilter_terms | OntologyIrObjectSetFilter_exactMatch | OntologyIrObjectSetFilter_phrase | OntologyIrObjectSetFilter_prefixOnLastToken | OntologyIrObjectSetFilter_geoBoundingBox | OntologyIrObjectSetFilter_geoDistance | OntologyIrObjectSetFilter_geoPolygon | OntologyIrObjectSetFilter_geoShape | OntologyIrObjectSetFilter_objectType | OntologyIrObjectSetFilter_hasProperty | OntologyIrObjectSetFilter_linkPresence | OntologyIrObjectSetFilter_multiMatch | OntologyIrObjectSetFilter_relativeDateRange | OntologyIrObjectSetFilter_relativeTimeRange | OntologyIrObjectSetFilter_parameterizedRange | OntologyIrObjectSetFilter_parameterizedWildcard | OntologyIrObjectSetFilter_parameterizedTerms | OntologyIrObjectSetFilter_parameterizedExactMatch | OntologyIrObjectSetFilter_userContext;
/**
 * An object matches an ObjectTypeFilter iff its ObjectTypeId matches the provided ObjectTypeId.
 */
interface OntologyIrObjectTypeFilter {
    objectTypeId: ObjectTypeApiName;
}
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an OrFilter iff it matches at least one of the filters.
 */
interface OntologyIrOrFilter {
    filters: Array<OntologyIrObjectSetFilter>;
}
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, the index for that property must define a .raw multifield of type keyword.
 * If no terms are provided, this filter will match ALL objects.
 */
interface OntologyIrParameterizedExactMatchFilter {
    propertyId: ObjectTypeFieldApiName;
    terms: Array<FilterParameter>;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface OntologyIrParameterizedRangeFilter {
    gt?: FilterParameter | null | undefined;
    gte?: FilterParameter | null | undefined;
    lt?: FilterParameter | null | undefined;
    lte?: FilterParameter | null | undefined;
    propertyId: ObjectTypeFieldApiName;
}
/**
 * An object matches a TermsFilter iff the analyzed value of the provided property matches any of the provided terms, or in case when
 * no property is provided - iff analyzed value of any of the properties matches any of the provided terms.
 * If no terms are provided, this filter will match ALL objects.
 */
interface OntologyIrParameterizedTermsFilter {
    propertyId?: ObjectTypeFieldApiName | null | undefined;
    terms: Array<FilterParameter>;
}
/**
 * An object matches a WildcardFilter iff the value of the provided property matches the provided term, or in case when
 * no property is provided - iff any of the properties match the provided term.
 */
interface OntologyIrParameterizedWildcardFilter {
    propertyId?: ObjectTypeFieldApiName | null | undefined;
    term: FilterParameter;
}
/**
 * An object matches a PhraseFilter iff the specified phrase matches it according to the PhraseMatchMode specified.
 */
interface OntologyIrPhraseFilter {
    matchMode?: PhraseMatchMode | null | undefined;
    phrase: string;
    propertySet?: OntologyIrPropertySet | null | undefined;
}
/**
 * An object matches a PrefixOnLastTokenFilter iff the specified property matches all tokens in the query string,
 * using exact match for every token except for the last, and prefix match for the last token. The tokens are
 * generated by analyzing the query string using the analyzer for the property being searched on. Ordering of
 * tokens in the query string is not checked when performing the matches. If the field is not analyzed, the
 * filter will be equivalent to a Phrase filter.
 * Only works on string properties. OSS will throw an exception if the property type is not string.
 */
interface OntologyIrPrefixOnLastTokenFilter {
    propertyId: ObjectTypeFieldApiName;
    query: string;
}
interface OntologyIrPropertySet_propertyWhitelist {
    type: "propertyWhitelist";
    propertyWhitelist: OntologyIrPropertyWhitelistPropertySet;
}
interface OntologyIrPropertySet_allProperties {
    type: "allProperties";
    allProperties: AllPropertiesPropertySet;
}
type OntologyIrPropertySet = OntologyIrPropertySet_propertyWhitelist | OntologyIrPropertySet_allProperties;
interface OntologyIrPropertyWhitelistPropertySet {
    properties: Array<ObjectTypeFieldApiName>;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface OntologyIrRangeFilter {
    gt?: any | null | undefined;
    gte?: any | null | undefined;
    lt?: any | null | undefined;
    lte?: any | null | undefined;
    propertyId: ObjectTypeFieldApiName;
}
/**
 * An object matches a RelativeDateRangeFilter iff the value of the provided date property is within the provided time range.
 */
interface OntologyIrRelativeDateRangeFilter {
    propertyId: ObjectTypeFieldApiName;
    sinceRelativePointInTime?: RelativePointInTime | null | undefined;
    timeZoneId: TimeZoneId;
    untilRelativePointInTime?: RelativePointInTime | null | undefined;
}
/**
 * An object matches a RelativeTimeRangeFilter iff the value of the provided timestamp property is within the provided time range.
 */
interface OntologyIrRelativeTimeRangeFilter {
    propertyId: ObjectTypeFieldApiName;
    sinceRelativeMillis?: number | null | undefined;
    untilRelativeMillis?: number | null | undefined;
}
/**
 * An object matches a TermsFilter iff the analyzed value of the provided property matches any of the provided terms, or in case when
 * no property is provided - iff analyzed value of any of the properties matches any of the provided terms.
 * If no terms are provided, this filter will match ALL objects.
 */
interface OntologyIrTermsFilter {
    propertyId?: ObjectTypeFieldApiName | null | undefined;
    terms: Array<any>;
}
/**
 * An object matches a WildcardFilter iff the value of the provided property matches the provided term, or in case when
 * no property is provided - iff any of the properties match the provided term.
 */
interface OntologyIrWildcardFilter {
    propertyId?: ObjectTypeFieldApiName | null | undefined;
    term: string;
}
/**
 * An ObjectSetFilter used to combine multiple ObjectSetFilters.
 * An object matches an OrFilter iff it matches at least one of the filters.
 */
interface OrFilter {
    filters: Array<ObjectSetFilter>;
}
/**
 * An object matches an ExactMatchFilter iff the value of the provided property is exactly equal to one of the provided terms.
 * If the property is of string type, the index for that property must define a .raw multifield of type keyword.
 * If no terms are provided, this filter will match ALL objects.
 */
interface ParameterizedExactMatchFilter {
    propertyId: PropertyTypeId;
    terms: Array<FilterParameter>;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface ParameterizedRangeFilter {
    gt?: FilterParameter | null | undefined;
    gte?: FilterParameter | null | undefined;
    lt?: FilterParameter | null | undefined;
    lte?: FilterParameter | null | undefined;
    propertyId: PropertyTypeId;
}
/**
 * An object matches a TermsFilter iff the analyzed value of the provided property matches any of the provided terms, or in case when
 * no property is provided - iff analyzed value of any of the properties matches any of the provided terms.
 * If no terms are provided, this filter will match ALL objects.
 */
interface ParameterizedTermsFilter {
    propertyId?: PropertyTypeId | null | undefined;
    terms: Array<FilterParameter>;
}
/**
 * An object matches a WildcardFilter iff the value of the provided property matches the provided term, or in case when
 * no property is provided - iff any of the properties match the provided term.
 */
interface ParameterizedWildcardFilter {
    propertyId?: PropertyTypeId | null | undefined;
    term: FilterParameter;
}
/**
 * An object matches a PhraseFilter iff the specified phrase matches it according to the PhraseMatchMode specified.
 */
interface PhraseFilter {
    matchMode?: PhraseMatchMode | null | undefined;
    phrase: string;
    propertySet?: PropertySet | null | undefined;
}
/**
 * Defines how phrase search matches results.
 */
type PhraseMatchMode = "PHRASE" | "PHRASE_PREFIX";
/**
 * An object matches a PrefixOnLastTokenFilter iff the specified property matches all tokens in the query string,
 * using exact match for every token except for the last, and prefix match for the last token. The tokens are
 * generated by analyzing the query string using the analyzer for the property being searched on. Ordering of
 * tokens in the query string is not checked when performing the matches. If the field is not analyzed, the
 * filter will be equivalent to a Phrase filter.
 * Only works on string properties. OSS will throw an exception if the property type is not string.
 */
interface PrefixOnLastTokenFilter {
    propertyId: PropertyTypeId;
    query: string;
}
interface PropertySet_propertyWhitelist {
    type: "propertyWhitelist";
    propertyWhitelist: PropertyWhitelistPropertySet;
}
interface PropertySet_allProperties {
    type: "allProperties";
    allProperties: AllPropertiesPropertySet;
}
type PropertySet = PropertySet_propertyWhitelist | PropertySet_allProperties;
interface PropertyWhitelistPropertySet {
    properties: Array<PropertyTypeId>;
}
/**
 * An object matches a RangeFilter iff the value of the provided property is within provided bounds.
 */
interface RangeFilter {
    gt?: any | null | undefined;
    gte?: any | null | undefined;
    lt?: any | null | undefined;
    lte?: any | null | undefined;
    propertyId: PropertyTypeId;
}
/**
 * An object matches a RelativeDateRangeFilter iff the value of the provided date property is within the provided time range.
 */
interface RelativeDateRangeFilter {
    propertyId: PropertyTypeId;
    sinceRelativePointInTime?: RelativePointInTime | null | undefined;
    timeZoneId: TimeZoneId;
    untilRelativePointInTime?: RelativePointInTime | null | undefined;
}
interface RelativePointInTime {
    timeUnit: RelativeTimeUnit;
    value: number;
}
/**
 * An object matches a RelativeTimeRangeFilter iff the value of the provided timestamp property is within the provided time range.
 */
interface RelativeTimeRangeFilter {
    propertyId: PropertyTypeId;
    sinceRelativeMillis?: number | null | undefined;
    untilRelativeMillis?: number | null | undefined;
}
type RelativeTimeUnit = "DAY" | "WEEK" | "MONTH" | "YEAR";
interface ResolvedFilterParameter {
    value: FilterValue;
}
/**
 * An object matches a TermsFilter iff the analyzed value of the provided property matches any of the provided terms, or in case when
 * no property is provided - iff analyzed value of any of the properties matches any of the provided terms.
 * If no terms are provided, this filter will match ALL objects.
 */
interface TermsFilter {
    propertyId?: PropertyTypeId | null | undefined;
    terms: Array<any>;
}
/**
 * An identifier of a time zone, e.g. "Europe/London" as defined by the Time Zone Database.
 */
type TimeZoneId = string;
interface UnresolvedFilterParameter {
    defaultValue?: FilterValue | null | undefined;
    description?: string | null | undefined;
    name: string;
    parameterId: ConditionValueId;
}
/**
 * An object matches an UserContextFilter iff the value of the provided property is exactly equal to the provided user context.
 */
interface UserContextFilter {
    propertyId: PropertyId;
    userContext: UserContextValue;
}
interface UserContextValue_multipassUserId {
    type: "multipassUserId";
    multipassUserId: MultipassUserId;
}
interface UserContextValue_multipassAttribute {
    type: "multipassAttribute";
    multipassAttribute: MultipassAttribute;
}
/**
 * Represents a value that is resolved at runtime via the context of who is querying the object set.
 */
type UserContextValue = UserContextValue_multipassUserId | UserContextValue_multipassAttribute;
/**
 * An object matches a WildcardFilter iff the value of the provided property matches the provided term, or in case when
 * no property is provided - iff any of the properties match the provided term.
 */
interface WildcardFilter {
    propertyId?: PropertyTypeId | null | undefined;
    term: string;
}

/**
 * Identifies a request for access to an ontology entity.
 */
type AccessRequestRid = string;
/**
 * Version of an access request. This is incremented by adding 1 to the previous version.
 */
type AccessRequestVersion = number;
/**
 * Identifies a specific subrequest being used to gain access to an ontology entity.
 * This corresponds to the subtask ID in the Approvals service.
 */
type AccessSubRequestRid = string;
/**
 * The version of a subrequest being used to gain access to a resource.
 * This corresponds to the subtask version in the Approvals service.
 */
type AccessSubRequestVersion = number;
/**
 * Configurations for allowing the original action applier to revert the action.
 */
interface ActionApplierRevertConfig {
    withinDuration?: Duration | null | undefined;
}
interface ActionApplyClientPreferences_disallowedClients {
    type: "disallowedClients";
    disallowedClients: ActionApplyDisallowedClients;
}
type ActionApplyClientPreferences = ActionApplyClientPreferences_disallowedClients;
interface ActionApplyDisallowedClients {
    disallowedFrontendConsumer: Array<ActionTypeFrontendConsumer>;
}
interface ActionLogConfiguration {
    actionLogSummary: Array<ActionLogSummaryPart>;
}
/**
 * The ActionLogic in an ActionType map the Parameters to what edits should be made in Phonograph. It employs
 * LogicRules for the core Action logic and, optionally, an ActionLogRule for capturing a record of the Action
 * execution. We don't allow the mixing of FunctionRule with other LogicRules in the same ActionType.
 */
interface ActionLogic {
    actionLogRule?: ActionLogRule | null | undefined;
    rules: Array<LogicRule>;
}
/**
 * Same as ActionLogic above, except it uses modification types to allow the usage of ridOrIdInRequest types to
 * reference SharedPropertyTypes and InterfaceTypes in the same modifyOntology request as they are created.
 */
interface ActionLogicModification {
    actionLogRule?: ActionLogRuleModification | null | undefined;
    rules: Array<LogicRuleModification>;
}
type ActionLogMessage = string;
/**
 * This signals to OMA that the Object Type will be regenerated as the Action Type changes, rather than modified
 * directly by the user. Also, OMA should not validate that the backing dataset has the required columns, as
 * these will instead be generated on save.
 */
interface ActionLogMetadata {
    actionTypeRids: Array<ActionTypeRid>;
}
type ActionLogParameterReference = ParameterId;
/**
 * Users can optionally configure an ActionLogicRule for their ActionType that defines how Action parameters and
 * their properties should be mapped to properties of their Action Log Object Type.
 */
interface ActionLogRule {
    actionLogObjectTypeId: ObjectTypeId;
    editedObjectRelations: Record<ObjectTypeId, LinkTypeId>;
    enabled: boolean;
    propertyValues: Record<PropertyTypeId, ActionLogValue>;
    reasonCodes: Array<PropertyTypeId>;
}
/**
 * Users can optionally configure an ActionLogicRule for their ActionType that defines how Action parameters and
 * their properties should be mapped to properties of their Action Log Object Type.
 */
interface ActionLogRuleModification {
    actionLogObjectTypeId: ObjectTypeId;
    editedObjectRelations: Record<ObjectTypeId, LinkTypeId>;
    enabled: boolean;
    propertyValues: Record<PropertyTypeId, ActionLogValueModification>;
    reasonCodes: Array<PropertyTypeId>;
}
interface ActionLogSummaryPart_message {
    type: "message";
    message: ActionLogMessage;
}
interface ActionLogSummaryPart_parameter {
    type: "parameter";
    parameter: ActionLogParameterReference;
}
type ActionLogSummaryPart = ActionLogSummaryPart_message | ActionLogSummaryPart_parameter;
interface ActionLogValue_parameterValue {
    type: "parameterValue";
    parameterValue: ParameterId;
}
interface ActionLogValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ActionLogValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValue;
}
interface ActionLogValue_editedObjects {
    type: "editedObjects";
    editedObjects: ObjectTypeId;
}
interface ActionLogValue_allEditedObjects {
    type: "allEditedObjects";
    allEditedObjects: AllEditedObjectsFieldMapping;
}
interface ActionLogValue_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: Empty;
}
interface ActionLogValue_actionRid {
    type: "actionRid";
    actionRid: Empty;
}
interface ActionLogValue_actionTypeVersion {
    type: "actionTypeVersion";
    actionTypeVersion: Empty;
}
interface ActionLogValue_actionTimestamp {
    type: "actionTimestamp";
    actionTimestamp: Empty;
}
interface ActionLogValue_actionUser {
    type: "actionUser";
    actionUser: Empty;
}
interface ActionLogValue_isReverted {
    type: "isReverted";
    isReverted: Empty;
}
interface ActionLogValue_revertUser {
    type: "revertUser";
    revertUser: Empty;
}
interface ActionLogValue_revertTimestamp {
    type: "revertTimestamp";
    revertTimestamp: Empty;
}
interface ActionLogValue_synchronousWebhookInstanceId {
    type: "synchronousWebhookInstanceId";
    synchronousWebhookInstanceId: Empty;
}
interface ActionLogValue_asynchronousWebhookInstanceIds {
    type: "asynchronousWebhookInstanceIds";
    asynchronousWebhookInstanceIds: Empty;
}
interface ActionLogValue_notifiedUsers {
    type: "notifiedUsers";
    notifiedUsers: Empty;
}
interface ActionLogValue_notificationIds {
    type: "notificationIds";
    notificationIds: Empty;
}
interface ActionLogValue_scenarioRid {
    type: "scenarioRid";
    scenarioRid: Empty;
}
interface ActionLogValue_summary {
    type: "summary";
    summary: Array<ActionTypeRichTextComponent>;
}
type ActionLogValue = ActionLogValue_parameterValue | ActionLogValue_objectParameterPropertyValue | ActionLogValue_interfaceParameterPropertyValue | ActionLogValue_editedObjects | ActionLogValue_allEditedObjects | ActionLogValue_actionTypeRid | ActionLogValue_actionRid | ActionLogValue_actionTypeVersion | ActionLogValue_actionTimestamp | ActionLogValue_actionUser | ActionLogValue_isReverted | ActionLogValue_revertUser | ActionLogValue_revertTimestamp | ActionLogValue_synchronousWebhookInstanceId | ActionLogValue_asynchronousWebhookInstanceIds | ActionLogValue_notifiedUsers | ActionLogValue_notificationIds | ActionLogValue_scenarioRid | ActionLogValue_summary;
interface ActionLogValueModification_parameterValue {
    type: "parameterValue";
    parameterValue: ParameterId;
}
interface ActionLogValueModification_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ActionLogValueModification_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValueModification;
}
interface ActionLogValueModification_editedObjects {
    type: "editedObjects";
    editedObjects: ObjectTypeId;
}
interface ActionLogValueModification_allEditedObjects {
    type: "allEditedObjects";
    allEditedObjects: AllEditedObjectsFieldMapping;
}
interface ActionLogValueModification_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: Empty;
}
interface ActionLogValueModification_actionRid {
    type: "actionRid";
    actionRid: Empty;
}
interface ActionLogValueModification_actionTypeVersion {
    type: "actionTypeVersion";
    actionTypeVersion: Empty;
}
interface ActionLogValueModification_actionTimestamp {
    type: "actionTimestamp";
    actionTimestamp: Empty;
}
interface ActionLogValueModification_actionUser {
    type: "actionUser";
    actionUser: Empty;
}
interface ActionLogValueModification_isReverted {
    type: "isReverted";
    isReverted: Empty;
}
interface ActionLogValueModification_revertUser {
    type: "revertUser";
    revertUser: Empty;
}
interface ActionLogValueModification_revertTimestamp {
    type: "revertTimestamp";
    revertTimestamp: Empty;
}
interface ActionLogValueModification_synchronousWebhookInstanceId {
    type: "synchronousWebhookInstanceId";
    synchronousWebhookInstanceId: Empty;
}
interface ActionLogValueModification_asynchronousWebhookInstanceIds {
    type: "asynchronousWebhookInstanceIds";
    asynchronousWebhookInstanceIds: Empty;
}
interface ActionLogValueModification_notifiedUsers {
    type: "notifiedUsers";
    notifiedUsers: Empty;
}
interface ActionLogValueModification_notificationIds {
    type: "notificationIds";
    notificationIds: Empty;
}
interface ActionLogValueModification_scenarioRid {
    type: "scenarioRid";
    scenarioRid: Empty;
}
interface ActionLogValueModification_summary {
    type: "summary";
    summary: Array<ActionTypeRichTextComponent>;
}
type ActionLogValueModification = ActionLogValueModification_parameterValue | ActionLogValueModification_objectParameterPropertyValue | ActionLogValueModification_interfaceParameterPropertyValue | ActionLogValueModification_editedObjects | ActionLogValueModification_allEditedObjects | ActionLogValueModification_actionTypeRid | ActionLogValueModification_actionRid | ActionLogValueModification_actionTypeVersion | ActionLogValueModification_actionTimestamp | ActionLogValueModification_actionUser | ActionLogValueModification_isReverted | ActionLogValueModification_revertUser | ActionLogValueModification_revertTimestamp | ActionLogValueModification_synchronousWebhookInstanceId | ActionLogValueModification_asynchronousWebhookInstanceIds | ActionLogValueModification_notifiedUsers | ActionLogValueModification_notificationIds | ActionLogValueModification_scenarioRid | ActionLogValueModification_summary;
/**
 * A notification that will be triggered on successful completion of an action.
 */
interface ActionNotification {
    body: ActionNotificationBody;
    toRecipients: ActionNotificationRecipients;
}
interface ActionNotificationBody_templateNotification {
    type: "templateNotification";
    templateNotification: TemplateNotificationBody;
}
interface ActionNotificationBody_functionGenerated {
    type: "functionGenerated";
    functionGenerated: FunctionGeneratedNotificationBody;
}
/**
 * The body of an action's notification
 */
type ActionNotificationBody = ActionNotificationBody_templateNotification | ActionNotificationBody_functionGenerated;
/**
 * A Function to be executed with action input parameters or the recipient of the notification.
 */
interface ActionNotificationBodyFunctionExecution {
    functionInputValues: Record<FunctionInputName, FunctionExecutionWithRecipientInput>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
}
/**
 * A Function to be executed with action input parameters or the recipient of the notification.
 */
interface ActionNotificationBodyFunctionExecutionModification {
    functionInputValues: Record<FunctionInputName, FunctionExecutionWithRecipientInputModification>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
}
interface ActionNotificationBodyModification_templateNotification {
    type: "templateNotification";
    templateNotification: TemplateNotificationBodyModification;
}
interface ActionNotificationBodyModification_functionGenerated {
    type: "functionGenerated";
    functionGenerated: FunctionGeneratedNotificationBodyModification;
}
/**
 * The body of an action's notification
 */
type ActionNotificationBodyModification = ActionNotificationBodyModification_templateNotification | ActionNotificationBodyModification_functionGenerated;
/**
 * A notification that will be triggered on successful completion of an action.
 */
interface ActionNotificationModification {
    body: ActionNotificationBodyModification;
    toRecipients: ActionNotificationRecipientsModification;
}
interface ActionNotificationRecipients_parameter {
    type: "parameter";
    parameter: ParameterActionNotificationRecipients;
}
interface ActionNotificationRecipients_functionGenerated {
    type: "functionGenerated";
    functionGenerated: FunctionGeneratedActionNotificationRecipients;
}
/**
 * A notification's recipients.
 */
type ActionNotificationRecipients = ActionNotificationRecipients_parameter | ActionNotificationRecipients_functionGenerated;
interface ActionNotificationRecipientsModification_parameter {
    type: "parameter";
    parameter: ParameterActionNotificationRecipientsModification;
}
interface ActionNotificationRecipientsModification_functionGenerated {
    type: "functionGenerated";
    functionGenerated: FunctionGeneratedActionNotificationRecipientsModification;
}
/**
 * A notification's recipients.
 */
type ActionNotificationRecipientsModification = ActionNotificationRecipientsModification_parameter | ActionNotificationRecipientsModification_functionGenerated;
/**
 * Settings that would be applied to a notification
 */
interface ActionNotificationSettings {
    redactionOverride?: RedactionOverrideOptions | null | undefined;
    renderingSettings: RenderingSettings;
}
/**
 * This provides the conditions under which the Action Type can be reverted. Note that matching one of these
 * conditions is necessary but not sufficient for an action to be reverted, as it is also required that none of
 * the modified entities have received further edits after the action was applied.
 *
 * The list of conditions is not permitted to be empty, and any such modifications will fail.
 */
interface ActionRevert {
    enabledFor: Array<ActionRevertEnabledFor>;
}
interface ActionRevertEnabledFor_actionApplier {
    type: "actionApplier";
    actionApplier: ActionApplierRevertConfig;
}
type ActionRevertEnabledFor = ActionRevertEnabledFor_actionApplier;
/**
 * A wrapper for DynamicObjectSet that includes a ConditionValueMap
 */
interface ActionsObjectSet {
    conditionValues: Record<ConditionValueId, ConditionValue>;
    objectSet: DynamicObjectSet;
}
/**
 * A wrapper for DynamicObjectSet that includes a ConditionValueMap
 */
interface ActionsObjectSetModification {
    conditionValues: Record<ConditionValueId, ConditionValueModification>;
    objectSet: DynamicObjectSet;
}
/**
 * Configuration options related to the submission of an action type
 */
interface ActionSubmissionConfiguration {
    tableSubmissionModeConfiguration?: ActionTableSubmissionModeConfiguration | null | undefined;
}
/**
 * The version of all the ActionTypes.
 */
type ActionsVersion = string;
interface ActionTableSubmissionMode_submitValidEntriesInOrderUntilFirstFailure {
    type: "submitValidEntriesInOrderUntilFirstFailure";
    submitValidEntriesInOrderUntilFirstFailure: SubmitValidEntriesInOrderUntilFirstFailureMode;
}
interface ActionTableSubmissionMode_submitAllValidOrNothingThrowing {
    type: "submitAllValidOrNothingThrowing";
    submitAllValidOrNothingThrowing: SubmitAllValidOrNothingThrowingMode;
}
/**
 * Submission mode defining the validation and processing result handling of action application requests.
 */
type ActionTableSubmissionMode = ActionTableSubmissionMode_submitValidEntriesInOrderUntilFirstFailure | ActionTableSubmissionMode_submitAllValidOrNothingThrowing;
/**
 * Submission Mode configuration in OMA for bulk actions applied via tableEditApplyActionV2
 */
interface ActionTableSubmissionModeConfiguration {
    submissionMode: ActionTableSubmissionMode;
}
interface ActionType {
    actionTypeLogic: ActionTypeLogic;
    metadata: ActionTypeMetadata;
}
/**
 * The name of an ActionType that can be referenced in code. Valid API names have the following conditions:
 * * All lower case kebab-case
 * * Numbers are permitted, but not as the first character.
 * * No special characters are allowed.
 * * API names cannot be longer than 100 characters.
 * API names must be unique - requests that attempt to re-use an existing API name will be rejected.
 */
type ActionTypeApiName = string;
/**
 * A ActionTypeCreate is used to create ActionTypes.
 */
interface ActionTypeCreate {
    actionApplyClientSettings?: ActionApplyClientPreferences | null | undefined;
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadataModification;
    formContentOrdering: Array<FormContent>;
    logic: ActionLogicModification;
    notifications: Array<ActionNotificationModification>;
    notificationSettings?: ActionNotificationSettings | null | undefined;
    packageRid?: OntologyPackageRid | null | undefined;
    parameterOrdering: Array<ParameterId>;
    parameters: Record<ParameterId, PutParameterRequestModification>;
    projectRid?: CompassProjectRid | null | undefined;
    provenance?: ActionTypeProvenanceModification | null | undefined;
    revert?: ActionRevert | null | undefined;
    sections: Record<SectionId, PutSectionRequestModification>;
    status?: ActionTypeStatus | null | undefined;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    typeGroups: Array<TypeGroupRidOrIdInRequest>;
    validations: Record<ValidationRuleIdInRequest, ValidationRuleModification>;
    validationsOrdering: Array<ValidationRuleIdInRequest>;
    webhooks?: ActionWebhooksModification | null | undefined;
}
interface ActionTypeCreatedEvent {
    actionTypeRid: ActionTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface ActionTypeDeletedEvent {
    actionTypeRid: ActionTypeRid;
    deletionMetadata?: DeletionMetadata | null | undefined;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * DisplayMetadata shape used in responses
 */
interface ActionTypeDisplayMetadata {
    configuration: ActionTypeDisplayMetadataConfiguration;
    description: string;
    displayName: string;
    icon?: Icon | null | undefined;
    submitButtonDisplayMetadata?: ButtonDisplayMetadata | null | undefined;
    successMessage: Array<ActionTypeRichTextComponent>;
    typeClasses: Array<TypeClass>;
    undoButtonConfiguration?: boolean | null | undefined;
}
/**
 * Config info for rendering and configuring the layouts of the (inline) action widgets
 */
interface ActionTypeDisplayMetadataConfiguration {
    defaultLayout: DisplayMetadataConfigurationDefaultLayout;
    displayAndFormat: DisplayMetadataConfigurationDisplayAndFormat;
    enableLayoutUserSwitch: boolean;
}
/**
 * DisplayMetadata shape used in requests
 */
interface ActionTypeDisplayMetadataModification {
    configuration?: ActionTypeDisplayMetadataConfiguration | null | undefined;
    description: string;
    displayName: string;
    icon?: Icon | null | undefined;
    submitButtonDisplayMetadata?: ButtonDisplayMetadata | null | undefined;
    successMessage: Array<ActionTypeRichTextComponent>;
    typeClasses: Array<TypeClass>;
    undoButtonConfiguration?: boolean | null | undefined;
}
/**
 * Every ActionType must contain at least one ActionType level validation in order to ensure that they are being
 * secured.
 */
interface ActionTypeDoesNotHaveActionTypeLevelValidationError {
    actionTypeIdentifier: ActionTypeIdentifier;
}
/**
 * The ActionType definition tries to edit a property type that is not editable.
 */
interface ActionTypeEditingNonEditablePropertyTypeError {
    actionTypeIdentifier: ActionTypeIdentifier;
    nonEditablePropertyTypes: Array<PropertyTypeId>;
    objectTypeIdInActionLogicRule: ObjectTypeId;
}
interface ActionTypeEntities {
    affectedInterfaceTypes: Array<InterfaceTypeRid>;
    affectedLinkTypes: Array<LinkTypeId>;
    affectedObjectTypes: Array<ObjectTypeId>;
    typeGroups: Array<TypeGroupRid>;
}
interface ActionTypeError_versionedActionTypesNotFound {
    type: "versionedActionTypesNotFound";
    versionedActionTypesNotFound: VersionedActionTypesNotFoundError;
}
interface ActionTypeError_actionTypesNotFound {
    type: "actionTypesNotFound";
    actionTypesNotFound: ActionTypesNotFoundError;
}
interface ActionTypeError_actionTypesAlreadyExist {
    type: "actionTypesAlreadyExist";
    actionTypesAlreadyExist: ActionTypesAlreadyExistError;
}
interface ActionTypeError_inlineActionTypeCannotBeReferencedByMultipleObjectTypes {
    type: "inlineActionTypeCannotBeReferencedByMultipleObjectTypes";
    inlineActionTypeCannotBeReferencedByMultipleObjectTypes: InlineActionTypeCannotBeReferencedByMultipleObjectTypesError;
}
interface ActionTypeError_actionTypeDoesNotHaveActionTypeLevelValidation {
    type: "actionTypeDoesNotHaveActionTypeLevelValidation";
    actionTypeDoesNotHaveActionTypeLevelValidation: ActionTypeDoesNotHaveActionTypeLevelValidationError;
}
interface ActionTypeError_parameterValidationNotFound {
    type: "parameterValidationNotFound";
    parameterValidationNotFound: ParameterValidationNotFoundError;
}
interface ActionTypeError_parameterValidationReferencesLaterParameters {
    type: "parameterValidationReferencesLaterParameters";
    parameterValidationReferencesLaterParameters: ParameterValidationReferencesLaterParametersError;
}
interface ActionTypeError_parametersDoNotMatchParameterOrdering {
    type: "parametersDoNotMatchParameterOrdering";
    parametersDoNotMatchParameterOrdering: ParametersDoNotMatchParameterOrderingError;
}
interface ActionTypeError_nonExistentParametersUsedInParameterPrefill {
    type: "nonExistentParametersUsedInParameterPrefill";
    nonExistentParametersUsedInParameterPrefill: NonExistentParametersUsedInParameterPrefillError;
}
interface ActionTypeError_deletingAndEditingTheSameActionType {
    type: "deletingAndEditingTheSameActionType";
    deletingAndEditingTheSameActionType: DeletingAndEditingTheSameActionTypeError;
}
interface ActionTypeError_actionTypeEditingNonEditablePropertyType {
    type: "actionTypeEditingNonEditablePropertyType";
    actionTypeEditingNonEditablePropertyType: ActionTypeEditingNonEditablePropertyTypeError;
}
type ActionTypeError = ActionTypeError_versionedActionTypesNotFound | ActionTypeError_actionTypesNotFound | ActionTypeError_actionTypesAlreadyExist | ActionTypeError_inlineActionTypeCannotBeReferencedByMultipleObjectTypes | ActionTypeError_actionTypeDoesNotHaveActionTypeLevelValidation | ActionTypeError_parameterValidationNotFound | ActionTypeError_parameterValidationReferencesLaterParameters | ActionTypeError_parametersDoNotMatchParameterOrdering | ActionTypeError_nonExistentParametersUsedInParameterPrefill | ActionTypeError_deletingAndEditingTheSameActionType | ActionTypeError_actionTypeEditingNonEditablePropertyType;
interface ActionTypeFrontendConsumer_objectMonitoring {
    type: "objectMonitoring";
    objectMonitoring: ObjectMonitoringFrontendConsumer;
}
/**
 * The different Action type frontends.
 */
type ActionTypeFrontendConsumer = ActionTypeFrontendConsumer_objectMonitoring;
/**
 * Request to get the associated OrganizationRid(s) for given ActionTypeRid(s).
 */
interface ActionTypeGetOrganizationsRequest {
    actionTypeRids: Array<ActionTypeRid>;
}
/**
 * Response for ActionTypeGetOrganizationsRequest. Please note that this will contain
 * OrganizationRid(s) only for ActionTypeRid(s) that are visible to the user.
 */
interface ActionTypeGetOrganizationsResponse {
    organizationRidByActionTypeRid: Record<ActionTypeRid, Array<OrganizationRid>>;
}
interface ActionTypeIdentifier_rid {
    type: "rid";
    rid: ActionTypeRid;
}
interface ActionTypeIdentifier_actionTypeIdInRequest {
    type: "actionTypeIdInRequest";
    actionTypeIdInRequest: ActionTypeIdInRequest;
}
/**
 * A type to uniquely identify an ActionType.
 */
type ActionTypeIdentifier = ActionTypeIdentifier_rid | ActionTypeIdentifier_actionTypeIdInRequest;
/**
 * Reference to an ActionType. Used when referencing an ActionType in the same request it is created in.
 */
type ActionTypeIdInRequest = string;
/**
 * ResourceIdentifier for the action type input manager.
 */
type ActionTypeInputManagerRid = string;
interface ActionTypeLevelValidation {
    ordering: Array<ValidationRuleRid>;
    rules: Record<ValidationRuleRid, ValidationRule>;
}
/**
 * Request to batch load ActionTypes. If any of the requested ActionTypes are not available in the specified
 * ActionsVersion (or latest if not specified), they will not be present in the response.
 */
interface ActionTypeLoadAllRequest {
}
/**
 * Request to batch load ActionTypes.
 */
interface ActionTypeLoadRequest {
    actionTypes: Array<ActionTypeRid>;
}
interface ActionTypeLoadRequestV2 {
    rid: ActionTypeRid;
    versionReference?: VersionReference | null | undefined;
}
/**
 * Response to ActionTypeLoadRequest and ActionTypeLoadAllRequest.
 */
interface ActionTypeLoadResponse {
    actionTypes: Record<ActionTypeRid, ActionType>;
}
interface ActionTypeLoadResponseV2 {
    actionType: ActionType;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * Request to batch load ActionTypes at specified version. No more than 100 should be requested.
 */
interface ActionTypeLoadVersionedRequest {
    actionTypes: Array<VersionedActionTypeRid>;
}
/**
 * Response to ActionTypeLoadVersionedRequest.
 */
interface ActionTypeLoadVersionedResponse {
    actionTypes: Array<ActionType>;
}
interface ActionTypeLogic {
    logic: ActionLogic;
    notifications: Array<ActionNotification>;
    revert?: ActionRevert | null | undefined;
    validation: ActionValidation;
    webhooks?: ActionWebhooks | null | undefined;
}
/**
 * An ActionType defines the schema of the edits that can be made to Phonograph.
 */
interface ActionTypeMetadata {
    actionApplyClientSettings?: ActionApplyClientPreferences | null | undefined;
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadata;
    entities?: ActionTypeEntities | null | undefined;
    formContentOrdering: Array<FormContent>;
    notificationSettings: ActionNotificationSettings;
    parameterOrdering: Array<ParameterId>;
    parameters: Record<ParameterId, Parameter>;
    provenance?: ActionTypeProvenance | null | undefined;
    rid: ActionTypeRid;
    sections: Record<SectionId, Section>;
    status: ActionTypeStatus;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    version: ActionTypeVersion;
}
/**
 * An ActionType defines the schema of the edits that can be made to Phonograph.
 */
interface ActionTypeMetadataModification {
    actionApplyClientSettings?: ActionApplyClientPreferences | null | undefined;
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadataModification;
    entities?: ActionTypeEntities | null | undefined;
    formContentOrdering: Array<FormContent>;
    notificationSettings: ActionNotificationSettings;
    parameterOrdering: Array<ParameterId>;
    parameters: Record<ParameterId, Parameter>;
    provenance?: ActionTypeProvenance | null | undefined;
    rid: ActionTypeRid;
    sections: Record<SectionId, Section>;
    status: ActionTypeStatus;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    version: ActionTypeVersion;
}
/**
 * Action type shape for requests. Ensures backend compatibility with the usePlugin LLM endpoint.
 */
interface ActionTypeModificationRequest {
    actionTypeLogic: ActionTypeLogic;
    metadata: ActionTypeMetadataModification;
}
/**
 * Request used to modify ActionTypes.
 */
interface ActionTypeModifyRequest {
    actionsVersion?: ActionsVersion | null | undefined;
    createActionTypes: Array<PutActionTypeRequest>;
    deleteActionTypes: Array<ActionTypeRid>;
    editActionTypes: Record<ActionTypeRid, EditActionTypeRequest>;
}
interface ActionTypeModifyResponse {
    createdActionTypes: Array<ActionType>;
    updatedActionTypes: Record<ActionTypeRid, ActionType>;
}
interface ActionTypeParameterIdentifier_rid {
    type: "rid";
    rid: ParameterRid;
}
interface ActionTypeParameterIdentifier_id {
    type: "id";
    id: ParameterId;
}
/**
 * A type to uniquely identify an ActionType Parameter.
 */
type ActionTypeParameterIdentifier = ActionTypeParameterIdentifier_rid | ActionTypeParameterIdentifier_id;
/**
 * Metadata describing provenance of an entity. Can only be set by the privileged owner.
 */
interface ActionTypeProvenanceModification {
    source: ActionTypeProvenanceSourceModification;
}
interface ActionTypeProvenanceSourceModification_marketplace {
    type: "marketplace";
    marketplace: MarketplaceEntityProvenance;
}
interface ActionTypeProvenanceSourceModification_none {
    type: "none";
    none: NoneEntityProvenance;
}
type ActionTypeProvenanceSourceModification = ActionTypeProvenanceSourceModification_marketplace | ActionTypeProvenanceSourceModification_none;
interface ActionTypeRichTextComponent_message {
    type: "message";
    message: ActionTypeRichTextMessage;
}
interface ActionTypeRichTextComponent_parameter {
    type: "parameter";
    parameter: ActionTypeRichTextParameterReference;
}
interface ActionTypeRichTextComponent_parameterProperty {
    type: "parameterProperty";
    parameterProperty: ActionTypeRichTextParameterPropertyReference;
}
/**
 * Generic type that can used to define a string that should have Action execution details injected into it when
 * it is rendered.
 */
type ActionTypeRichTextComponent = ActionTypeRichTextComponent_message | ActionTypeRichTextComponent_parameter | ActionTypeRichTextComponent_parameterProperty;
/**
 * Indicates that this value in the rendered string should be, quite simply, the given string.
 */
type ActionTypeRichTextMessage = string;
/**
 * Indicates that this value in the rendered string should be replaced with the specified Object Parameter's
 * property value.
 */
type ActionTypeRichTextParameterPropertyReference = ObjectParameterPropertyValue;
/**
 * Indicates that this value in the rendered string should be replaced with the Parameter with the given
 * ParameterId.
 */
type ActionTypeRichTextParameterReference = ParameterId;
/**
 * The rid for an ActionType, autogenerated by Ontology-Metadata-Service and used for permissioning and logging.
 */
type ActionTypeRid = string;
/**
 * There was an attempt to create ActionTypes that already exist.
 */
interface ActionTypesAlreadyExistError {
    actionTypeRids: Array<ActionTypeRid>;
}
/**
 * Request to associate given set of OrganizationRids with the specified ActionTypeRid(s).
 * Users should have permissions to modify the specified ActionTypeRid(s) and also have
 * relevant permissions to apply the specified organizations' markings.
 * An empty set of organizations is not permissible.
 */
interface ActionTypeSetOrganizationsRequest {
    organizationRidByActionTypeRid: Record<ActionTypeRid, Array<OrganizationRid>>;
}
/**
 * ActionTypes were not found.
 */
interface ActionTypesNotFoundError {
    actionTypeRids: Array<ActionTypeRid>;
}
interface ActionTypesSummary {
    maximumNumberOfActionTypes: number;
    visibleEntities: number;
}
interface ActionTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalActionTypeStatus;
}
interface ActionTypeStatus_active {
    type: "active";
    active: ActiveActionTypeStatus;
}
interface ActionTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedActionTypeStatus;
}
interface ActionTypeStatus_example {
    type: "example";
    example: ExampleActionTypeStatus;
}
/**
 * The status to indicate whether the ActionType is either Experimental, Active, Deprecated, or Example.
 */
type ActionTypeStatus = ActionTypeStatus_experimental | ActionTypeStatus_active | ActionTypeStatus_deprecated | ActionTypeStatus_example;
/**
 * Request object to edit existing Action Types.
 */
interface ActionTypeUpdate {
    actionApplyClientSettings?: ActionApplyClientPreferences | null | undefined;
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadataModification;
    formContentOrdering?: Array<FormContent> | null | undefined;
    logic: ActionLogicModification;
    notifications: Array<ActionNotificationModification>;
    notificationSettings?: ActionNotificationSettings | null | undefined;
    parameterOrdering: Array<ParameterId>;
    parametersToCreate: Record<ParameterId, PutParameterRequestModification>;
    parametersToDelete: Array<ParameterRid>;
    parametersToUpdate: Record<ParameterRid, EditParameterRequestModification>;
    provenance?: ActionTypeProvenanceModification | null | undefined;
    revert?: ActionRevert | null | undefined;
    sectionsToCreate: Record<SectionId, PutSectionRequestModification>;
    sectionsToDelete: Array<SectionRid>;
    sectionsToUpdate: Record<SectionRid, EditSectionRequestModification>;
    status?: ActionTypeStatus | null | undefined;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    typeGroups: Array<TypeGroupRidOrIdInRequest>;
    validationsOrdering: Array<ValidationRuleIdentifier>;
    validationsToCreate: Record<ValidationRuleIdInRequest, ValidationRuleModification>;
    validationsToDelete: Array<ValidationRuleRid>;
    validationsToUpdate: Record<ValidationRuleRid, ValidationRuleModification>;
    webhooks?: ActionWebhooksModification | null | undefined;
}
interface ActionTypeUpdatedEvent {
    actionTypeRid: ActionTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * The version of a specific ActionType.
 * This is a legacy versioning from before action types were integrated into OMS.
 * It is deprecated now in favor of ontology versions.
 */
type ActionTypeVersion = string;
interface ActionValidation {
    actionTypeLevelValidation: ActionTypeLevelValidation;
    parameterValidations: Record<ParameterId, ConditionalValidationBlock>;
    sectionValidations: Record<SectionId, SectionDisplayBlock>;
}
/**
 * ActionWebhooks contains the definition for webhooks that are executed as part of running an Action.
 */
interface ActionWebhooks {
    asynchronousPostWritebackWebhooks: Array<AsynchronousPostWritebackWebhook>;
    synchronousPreWritebackWebhook?: SynchronousPreWritebackWebhook | null | undefined;
}
/**
 * ActionWebhooks contains the definition for webhooks that are executed as part of running an Action.
 */
interface ActionWebhooksModification {
    asynchronousPostWritebackWebhooks: Array<AsynchronousPostWritebackWebhookModification>;
    synchronousPreWritebackWebhook?: SynchronousPreWritebackWebhookModification | null | undefined;
}
/**
 * This status indicates that the ActionType will not change on short notice and should thus be safe to use in user facing workflows. They will not be removed without first being deprecated.
 */
interface ActiveActionTypeStatus {
}
/**
 * This status indicates that breaking changes should not be made to the interface and it should be safe to use
 * in user facing workflows. The interface will not be removed without first being deprecated.
 */
interface ActiveInterfaceTypeStatus {
}
/**
 * This status indicates that the LinkType will not change on short notice and should thus be safe to use in user facing workflows. They will not be removed without first being deprecated.
 */
interface ActiveLinkTypeStatus {
}
/**
 * This status indicates that the ObjectType will not change on short notice and should thus be safe to use in user facing workflows. They will not be removed without first being deprecated.
 */
interface ActiveObjectTypeStatus {
}
/**
 * This status indicates that the PropertyType will not change on short notice and should thus be safe to use in user facing workflows. They will not be removed without first being deprecated.
 */
interface ActivePropertyTypeStatus {
}
interface AddInterfaceLinkRule {
    interfaceLinkTypeRid: InterfaceLinkTypeRid;
    interfaceTypeRid: InterfaceTypeRid;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface AddInterfaceLinkRuleModification {
    interfaceLinkTypeRidOrIdInRequest: InterfaceLinkTypeRidOrIdInRequest;
    interfaceTypeRidOrIdInRequest: InterfaceTypeRidOrIdInRequest;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface AddInterfaceRule {
    interfaceTypeRid: InterfaceTypeRid;
    objectType: ParameterId;
    sharedPropertyValues: Record<SharedPropertyTypeRid, LogicRuleValue>;
    structFieldValues: Record<SharedPropertyTypeRid, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface AddInterfaceRuleModification {
    interfaceTypeRidOrIdInRequest: InterfaceTypeRidOrIdInRequest;
    objectType: ParameterId;
    sharedPropertyTypeLogicRuleValueModifications: Array<SharedPropertyTypeLogicRuleValueModification>;
    sharedPropertyTypeStructFieldLogicRuleValueModifications: Array<SharedPropertyTypeStructFieldLogicRuleValueModification>;
}
interface AddLinkRule {
    linkTypeId: LinkTypeId;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface AddObjectRule {
    objectTypeId: ObjectTypeId;
    propertyValues: Record<PropertyTypeId, LogicRuleValue>;
    structFieldValues: Record<PropertyTypeId, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface AddObjectRuleModification {
    objectTypeId: ObjectTypeId;
    propertyValues: Record<PropertyTypeId, LogicRuleValueModification>;
    structFieldValues: Record<PropertyTypeId, Record<ObjectTypeFieldApiName, StructFieldLogicRuleValueModification>>;
    structFieldValuesV2: Record<PropertyTypeId, Array<StructFieldLogicRuleValueMappingModification>>;
}
interface AddOrModifyObjectRule {
    objectTypeId: ObjectTypeId;
    propertyValues: Record<PropertyTypeId, LogicRuleValue>;
    structFieldValues: Record<PropertyTypeId, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface AddOrModifyObjectRuleModification {
    objectTypeId: ObjectTypeId;
    propertyValues: Record<PropertyTypeId, LogicRuleValueModification>;
    structFieldValues: Record<PropertyTypeId, Record<ObjectTypeFieldApiName, StructFieldLogicRuleValueModification>>;
    structFieldValuesV2: Record<PropertyTypeId, Array<StructFieldLogicRuleValueMappingModification>>;
}
interface AddOrModifyObjectRuleModificationV2 {
    objectToModify: ParameterId;
    propertyValues: Record<PropertyTypeId, LogicRuleValueModification>;
    structFieldValues: Record<PropertyTypeId, Record<ObjectTypeFieldApiName, StructFieldLogicRuleValueModification>>;
    structFieldValuesV2: Record<PropertyTypeId, Array<StructFieldLogicRuleValueMappingModification>>;
}
interface AddOrModifyObjectRuleV2 {
    objectToModify: ParameterId;
    propertyValues: Record<PropertyTypeId, LogicRuleValue>;
    structFieldValues: Record<PropertyTypeId, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface AliasEntityIdentifier_sharedPropertyTypeRid {
    type: "sharedPropertyTypeRid";
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface AliasEntityIdentifier_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid;
}
type AliasEntityIdentifier = AliasEntityIdentifier_sharedPropertyTypeRid | AliasEntityIdentifier_objectTypeRid;
/**
 * The mapping which designated what struct fields will get which values in the all edited properties log.
 */
interface AllEditedObjectsFieldMapping {
    objectTypeRid: StructFieldRid;
    primaryKeyType: StructFieldRid;
    primaryKeyValue: StructFieldRid;
}
/**
 * Convert any Foundry supported Resource Identifiers to human-readable format (e.g dataset name).
 * Only to be used for users working in Workspace. E.g. an alert inbox to triage dataset-based data alerts.
 */
interface AllFoundryRids {
}
/**
 * Specifies that notifications to all recipients must render before Action can be executed
 */
interface AllNotificationRenderingMustSucceed {
}
interface AllowedParameterValues_oneOf {
    type: "oneOf";
    oneOf: ParameterValueOneOfOrEmpty;
}
interface AllowedParameterValues_range {
    type: "range";
    range: ParameterRangeOrEmpty;
}
interface AllowedParameterValues_objectQuery {
    type: "objectQuery";
    objectQuery: ParameterObjectQueryOrEmpty;
}
interface AllowedParameterValues_interfaceObjectQuery {
    type: "interfaceObjectQuery";
    interfaceObjectQuery: ParameterInterfaceObjectQueryOrEmpty;
}
interface AllowedParameterValues_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: ParameterObjectPropertyValueOrEmpty;
}
interface AllowedParameterValues_interfacePropertyValue {
    type: "interfacePropertyValue";
    interfacePropertyValue: ParameterInterfacePropertyValueOrEmpty;
}
interface AllowedParameterValues_objectList {
    type: "objectList";
    objectList: ParameterObjectListOrEmpty;
}
interface AllowedParameterValues_user {
    type: "user";
    user: ParameterMultipassUserOrEmpty;
}
interface AllowedParameterValues_multipassGroup {
    type: "multipassGroup";
    multipassGroup: ParameterMultipassGroupOrEmpty;
}
interface AllowedParameterValues_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface AllowedParameterValues_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRangeOrEmpty;
}
interface AllowedParameterValues_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface AllowedParameterValues_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ParameterObjectSetRidOrEmpty;
}
interface AllowedParameterValues_attachment {
    type: "attachment";
    attachment: ParameterAttachmentOrEmpty;
}
interface AllowedParameterValues_cbacMarking {
    type: "cbacMarking";
    cbacMarking: ParameterCbacMarkingOrEmpty;
}
interface AllowedParameterValues_mandatoryMarking {
    type: "mandatoryMarking";
    mandatoryMarking: ParameterMandatoryMarkingOrEmpty;
}
interface AllowedParameterValues_mediaReference {
    type: "mediaReference";
    mediaReference: ParameterMediaReferenceOrEmpty;
}
interface AllowedParameterValues_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ParameterObjectTypeReferenceOrEmpty;
}
interface AllowedParameterValues_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: ParameterTimeSeriesReferenceOrEmpty;
}
interface AllowedParameterValues_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
interface AllowedParameterValues_geoshape {
    type: "geoshape";
    geoshape: ParameterGeoshapeOrEmpty;
}
interface AllowedParameterValues_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: ParameterGeotimeSeriesReferenceOrEmpty;
}
interface AllowedParameterValues_redacted {
    type: "redacted";
    redacted: Redacted;
}
interface AllowedParameterValues_struct {
    type: "struct";
    struct: ParameterStructOrEmpty;
}
interface AllowedParameterValues_valueType {
    type: "valueType";
    valueType: ParameterValueTypeOrEmpty;
}
type AllowedParameterValues = AllowedParameterValues_oneOf | AllowedParameterValues_range | AllowedParameterValues_objectQuery | AllowedParameterValues_interfaceObjectQuery | AllowedParameterValues_objectPropertyValue | AllowedParameterValues_interfacePropertyValue | AllowedParameterValues_objectList | AllowedParameterValues_user | AllowedParameterValues_multipassGroup | AllowedParameterValues_text | AllowedParameterValues_datetime | AllowedParameterValues_boolean | AllowedParameterValues_objectSetRid | AllowedParameterValues_attachment | AllowedParameterValues_cbacMarking | AllowedParameterValues_mandatoryMarking | AllowedParameterValues_mediaReference | AllowedParameterValues_objectTypeReference | AllowedParameterValues_timeSeriesReference | AllowedParameterValues_geohash | AllowedParameterValues_geoshape | AllowedParameterValues_geotimeSeriesReference | AllowedParameterValues_redacted | AllowedParameterValues_struct | AllowedParameterValues_valueType;
interface AllowedParameterValuesModification_oneOf {
    type: "oneOf";
    oneOf: ParameterValueOneOfOrEmpty;
}
interface AllowedParameterValuesModification_range {
    type: "range";
    range: ParameterRangeOrEmptyModification;
}
interface AllowedParameterValuesModification_objectQuery {
    type: "objectQuery";
    objectQuery: ParameterObjectQueryOrEmptyModification;
}
interface AllowedParameterValuesModification_interfaceObjectQuery {
    type: "interfaceObjectQuery";
    interfaceObjectQuery: ParameterInterfaceObjectQueryOrEmptyModification;
}
interface AllowedParameterValuesModification_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: ParameterObjectPropertyValueOrEmptyModification;
}
interface AllowedParameterValuesModification_interfacePropertyValue {
    type: "interfacePropertyValue";
    interfacePropertyValue: ParameterInterfacePropertyValueOrEmptyModification;
}
interface AllowedParameterValuesModification_objectList {
    type: "objectList";
    objectList: ParameterObjectListOrEmpty;
}
interface AllowedParameterValuesModification_user {
    type: "user";
    user: ParameterMultipassUserOrEmptyModification;
}
interface AllowedParameterValuesModification_multipassGroup {
    type: "multipassGroup";
    multipassGroup: ParameterMultipassGroupOrEmpty;
}
interface AllowedParameterValuesModification_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface AllowedParameterValuesModification_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRangeOrEmptyModification;
}
interface AllowedParameterValuesModification_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface AllowedParameterValuesModification_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ParameterObjectSetRidOrEmpty;
}
interface AllowedParameterValuesModification_attachment {
    type: "attachment";
    attachment: ParameterAttachmentOrEmpty;
}
interface AllowedParameterValuesModification_cbacMarking {
    type: "cbacMarking";
    cbacMarking: ParameterCbacMarkingOrEmptyModification;
}
interface AllowedParameterValuesModification_mandatoryMarking {
    type: "mandatoryMarking";
    mandatoryMarking: ParameterMandatoryMarkingOrEmpty;
}
interface AllowedParameterValuesModification_mediaReference {
    type: "mediaReference";
    mediaReference: ParameterMediaReferenceOrEmpty;
}
interface AllowedParameterValuesModification_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ParameterObjectTypeReferenceOrEmptyModification;
}
interface AllowedParameterValuesModification_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: ParameterTimeSeriesReferenceOrEmpty;
}
interface AllowedParameterValuesModification_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
interface AllowedParameterValuesModification_geoshape {
    type: "geoshape";
    geoshape: ParameterGeoshapeOrEmpty;
}
interface AllowedParameterValuesModification_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: ParameterGeotimeSeriesReferenceOrEmpty;
}
interface AllowedParameterValuesModification_redacted {
    type: "redacted";
    redacted: Redacted;
}
interface AllowedParameterValuesModification_struct {
    type: "struct";
    struct: ParameterStructOrEmpty;
}
interface AllowedParameterValuesModification_valueType {
    type: "valueType";
    valueType: ParameterValueTypeOrEmpty;
}
type AllowedParameterValuesModification = AllowedParameterValuesModification_oneOf | AllowedParameterValuesModification_range | AllowedParameterValuesModification_objectQuery | AllowedParameterValuesModification_interfaceObjectQuery | AllowedParameterValuesModification_objectPropertyValue | AllowedParameterValuesModification_interfacePropertyValue | AllowedParameterValuesModification_objectList | AllowedParameterValuesModification_user | AllowedParameterValuesModification_multipassGroup | AllowedParameterValuesModification_text | AllowedParameterValuesModification_datetime | AllowedParameterValuesModification_boolean | AllowedParameterValuesModification_objectSetRid | AllowedParameterValuesModification_attachment | AllowedParameterValuesModification_cbacMarking | AllowedParameterValuesModification_mandatoryMarking | AllowedParameterValuesModification_mediaReference | AllowedParameterValuesModification_objectTypeReference | AllowedParameterValuesModification_timeSeriesReference | AllowedParameterValuesModification_geohash | AllowedParameterValuesModification_geoshape | AllowedParameterValuesModification_geotimeSeriesReference | AllowedParameterValuesModification_redacted | AllowedParameterValuesModification_struct | AllowedParameterValuesModification_valueType;
interface AllowedStructFieldValues_oneOf {
    type: "oneOf";
    oneOf: ParameterValueOneOfOrEmpty;
}
interface AllowedStructFieldValues_range {
    type: "range";
    range: ParameterRangeOrEmpty;
}
interface AllowedStructFieldValues_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface AllowedStructFieldValues_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRangeOrEmpty;
}
interface AllowedStructFieldValues_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface AllowedStructFieldValues_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
type AllowedStructFieldValues = AllowedStructFieldValues_oneOf | AllowedStructFieldValues_range | AllowedStructFieldValues_text | AllowedStructFieldValues_datetime | AllowedStructFieldValues_boolean | AllowedStructFieldValues_geohash;
interface AllowedStructFieldValuesModification_oneOf {
    type: "oneOf";
    oneOf: ParameterValueOneOfOrEmpty;
}
interface AllowedStructFieldValuesModification_range {
    type: "range";
    range: ParameterRangeOrEmptyModification;
}
interface AllowedStructFieldValuesModification_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface AllowedStructFieldValuesModification_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRangeOrEmptyModification;
}
interface AllowedStructFieldValuesModification_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface AllowedStructFieldValuesModification_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
type AllowedStructFieldValuesModification = AllowedStructFieldValuesModification_oneOf | AllowedStructFieldValuesModification_range | AllowedStructFieldValuesModification_text | AllowedStructFieldValuesModification_datetime | AllowedStructFieldValuesModification_boolean | AllowedStructFieldValuesModification_geohash;
interface AllowedStructFieldValuesOverride {
    allowedValues: AllowedStructFieldValues;
}
interface AllowedStructFieldValuesOverrideModification {
    allowedValues: AllowedStructFieldValuesModification;
}
interface AllowedValuesOverride {
    allowedValues: AllowedParameterValues;
}
interface AllowedValuesOverrideModification {
    allowedValues: AllowedParameterValuesModification;
}
interface Analyzer_notAnalyzed {
    type: "notAnalyzed";
    notAnalyzed: NotAnalyzedAnalyzer;
}
interface Analyzer_simpleAnalyzer {
    type: "simpleAnalyzer";
    simpleAnalyzer: SimpleAnalyzer;
}
interface Analyzer_standardAnalyzer {
    type: "standardAnalyzer";
    standardAnalyzer: StandardAnalyzer;
}
interface Analyzer_whitespaceAnalyzer {
    type: "whitespaceAnalyzer";
    whitespaceAnalyzer: WhitespaceAnalyzer;
}
interface Analyzer_languageAnalyzer {
    type: "languageAnalyzer";
    languageAnalyzer: LanguageAnalyzer;
}
/**
 * Union wrapping the various analyzer configurations available for StringPropertyType(s).
 * The analyzer determines how the PropertyType is indexed and made available for searches.
 */
type Analyzer = Analyzer_notAnalyzed | Analyzer_simpleAnalyzer | Analyzer_standardAnalyzer | Analyzer_whitespaceAnalyzer | Analyzer_languageAnalyzer;
interface AndCondition {
    conditions: Array<Condition>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface AndConditionModification {
    conditions: Array<ConditionModification>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
/**
 * Specifies that Action will be executed even if notifications fail to render for some/all recipients
 */
interface AnyNotificationRenderingCanFail {
}
interface ArrayPropertyType {
    subtype: Type;
}
interface ArrayTypeDataConstraints$1 {
    elementsConstraint?: PropertyTypeDataConstraints | null | undefined;
    elementsUnique?: ArrayTypeElementsUniqueConstraint$1 | null | undefined;
    size?: ArrayTypeSizeConstraint$1 | null | undefined;
}
type ArrayTypeDataValue$1 = Array<PropertyTypeDataValue>;
type ArrayTypeElementsUniqueConstraint$1 = boolean;
type ArrayTypeSizeConstraint$1 = RangeSizeConstraint$1;
/**
 * Convert Artifact GIDs into human-readable format. Displays the artifact icon and
 * title as opposed to its GID.
 */
interface ArtifactGidFormatter {
}
interface AsynchronousPostWritebackWebhook_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: StaticWebhookWithDirectInput;
}
interface AsynchronousPostWritebackWebhook_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: StaticWebhookWithFunctionResultInput;
}
/**
 * Union wrapping the various options available for configuring webhook(s) which will be executed asynchronously,
 * post writeback. If any fail, this is not surfaced during the apply Action call.
 */
type AsynchronousPostWritebackWebhook = AsynchronousPostWritebackWebhook_staticDirectInput | AsynchronousPostWritebackWebhook_staticFunctionInput;
interface AsynchronousPostWritebackWebhookModification_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: StaticWebhookWithDirectInputModification;
}
interface AsynchronousPostWritebackWebhookModification_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: StaticWebhookWithFunctionResultInputModification;
}
/**
 * Uses modification types for nested LogicRuleValueModification, otherwise same as
 * AsynchronousPostWritebackWebhook.
 */
type AsynchronousPostWritebackWebhookModification = AsynchronousPostWritebackWebhookModification_staticDirectInput | AsynchronousPostWritebackWebhookModification_staticFunctionInput;
interface AttachmentPropertyType {
}
/**
 * Attribution information for an Ontology modification.
 */
interface Attribution {
    author: string;
    date: string;
}
interface BaseFormatter_knownFormatter {
    type: "knownFormatter";
    knownFormatter: KnownFormatter;
}
interface BaseFormatter_number {
    type: "number";
    number: NumberFormatter;
}
interface BaseFormatter_timestamp {
    type: "timestamp";
    timestamp: TimestampFormatter;
}
interface BaseFormatter_date {
    type: "date";
    date: DateFormatter;
}
interface BaseFormatter_string {
    type: "string";
    string: StringFormatter;
}
interface BaseFormatter_timeDependent {
    type: "timeDependent";
    timeDependent: TimeDependentFormatter;
}
interface BaseFormatter_boolean {
    type: "boolean";
    boolean: BooleanFormatter;
}
/**
 * The basic formatting behavior.
 */
type BaseFormatter = BaseFormatter_knownFormatter | BaseFormatter_number | BaseFormatter_timestamp | BaseFormatter_date | BaseFormatter_string | BaseFormatter_timeDependent | BaseFormatter_boolean;
interface BaseParameterSubtype_marking {
    type: "marking";
    marking: MarkingSubtype;
}
/**
 * Subtypes for Parameters that have additional type information.
 */
type BaseParameterSubtype = BaseParameterSubtype_marking;
type BasePropertyType = "BOOLEAN" | "BYTE" | "DATE" | "DECIMAL" | "DOUBLE" | "FLOAT" | "GEOHASH" | "GEOSHAPE" | "INTEGER" | "LONG" | "SHORT" | "STRING" | "STRUCT" | "TIME_DEPENDENT" | "TIMESTAMP" | "ATTACHMENT" | "MARKING" | "CIPHER_TEXT" | "MEDIA_REFERENCE" | "VECTOR" | "GEOTIME_SERIES_REFERENCE";
/**
 * A basic action notification's email body. Uses Handlebars templating.
 */
interface BasicEmailBody {
    emailContent: string;
    links: Array<NotificationResultTypeLink>;
    subject: string;
}
/**
 * A basic action notification's email body. Uses Handlebars templating.
 */
interface BasicEmailBodyModification {
    emailContent: string;
    links: Array<NotificationResultTypeLinkModification>;
    subject: string;
}
interface BatchedFunctionRule {
    functionDetails: FunctionRule;
    objectSetRidInputName: FunctionInputName;
}
interface BatchedFunctionRuleModification {
    functionDetails: FunctionRuleModification;
    objectSetRidInputName: FunctionInputName;
}
interface BidirectionalRelation {
    cardinality: RelationCardinality;
    definition: JoinDefinition;
    displayMetadataOnSource?: RelationDisplayMetadata | null | undefined;
    displayMetadataOnTarget?: RelationDisplayMetadata | null | undefined;
    id: RelationId;
    rid: RelationRid;
    sourceObjectTypeId: ObjectTypeId;
    targetObjectTypeId: ObjectTypeId;
}
interface BidirectionalRelationCreateRequest {
    bidirectionalRelation: BidirectionalRelationWithoutRid;
}
interface BidirectionalRelationDeleteRequest {
}
interface BidirectionalRelationModifyRequest_create {
    type: "create";
    create: BidirectionalRelationCreateRequest;
}
interface BidirectionalRelationModifyRequest_update {
    type: "update";
    update: BidirectionalRelationUpdateRequest;
}
interface BidirectionalRelationModifyRequest_delete {
    type: "delete";
    delete: BidirectionalRelationDeleteRequest;
}
type BidirectionalRelationModifyRequest = BidirectionalRelationModifyRequest_create | BidirectionalRelationModifyRequest_update | BidirectionalRelationModifyRequest_delete;
interface BidirectionalRelationUpdateRequest {
    bidirectionalRelation: BidirectionalRelationWithoutRid;
}
interface BidirectionalRelationWithoutRid {
    cardinality: RelationCardinality;
    definition: JoinDefinition;
    displayMetadataOnSource?: RelationDisplayMetadata | null | undefined;
    displayMetadataOnTarget?: RelationDisplayMetadata | null | undefined;
    id: RelationId;
    sourceObjectTypeId: ObjectTypeId;
    targetObjectTypeId: ObjectTypeId;
}
interface BlueprintIcon {
    color: string;
    locator: string;
}
interface BooleanFormatter {
    valueIfFalse: string;
    valueIfTrue: string;
}
interface BooleanPropertyType {
}
interface BooleanTypeDataConstraints$1 {
    allowedValues: Array<BooleanTypeDataConstraintValue$1>;
}
type BooleanTypeDataConstraintValue$1 = "TRUE_VALUE" | "FALSE_VALUE" | "NULL_VALUE";
type BooleanTypeDataValue$1 = boolean;
/**
 * Event indicating that a branch was closed. Only non-default branches can be closed.
 */
interface BranchClosedEvent {
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
}
/**
 * Event indicating that a branch was deleted. This event is only sent for deleted non-default branches and
 * can occur when an Ontology is hard-deleted or when a (closed/merged) branch is deleted because of retention.
 * If a default branch is deleted (because of an Ontology hard-deletion), OMS will instead send deletion events
 * for each individual entity in the Ontology.
 *
 * Any service consuming ontology events is expected to delete all data related to a non-default branch (i.e. all
 * specific ontology entities tracked for this brach) when a `BranchDeletedEvent` is received. OMS
 * will not send delete events for all entities on non-default branches during branch deletion.
 */
interface BranchDeletedEvent {
    deletionMetadata: DeletionMetadata;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
}
/**
 * A string indicating the branch name. This is not safe to log as it is user-inputted and may
 * contain sensitive information.
 */
type BranchId = string;
/**
 * Event indicating that a branch was merged. Only non-default branches can be merged.
 */
interface BranchMergedEvent {
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
}
type BuilderPipelineRid = string;
interface BulkExecutionModeConfig {
    bulkFunctionInputName: FunctionInputName;
}
interface ButtonDisplayMetadata {
    intent: Intent$1;
    text: string;
}
interface BytePropertyType {
}
type ByteTypeDataValue$1 = number;
interface CarbonWorkspaceComponentUrlTarget_rid {
    type: "rid";
    rid: RidUrlTarget;
}
/**
 * The second part of a carbon workspace Url target.
 */
type CarbonWorkspaceComponentUrlTarget = CarbonWorkspaceComponentUrlTarget_rid;
interface CarbonWorkspaceComponentUrlTargetModification_rid {
    type: "rid";
    rid: RidUrlTargetModification;
}
/**
 * The second part of a carbon workspace Url target.
 */
type CarbonWorkspaceComponentUrlTargetModification = CarbonWorkspaceComponentUrlTargetModification_rid;
/**
 * A URL target for a carbon workspace.
 */
interface CarbonWorkspaceUrlTarget {
    resource?: CarbonWorkspaceComponentUrlTarget | null | undefined;
}
/**
 * A URL target for a carbon workspace.
 */
interface CarbonWorkspaceUrlTargetModification {
    resource?: CarbonWorkspaceComponentUrlTargetModification | null | undefined;
}
/**
 * Id for a category (group of markings)
 */
type CategoryId = string;
interface CipherTextPropertyType {
    defaultCipherChannelRid?: string | null | undefined;
    plainTextType: Type;
}
/**
 * Contains a set of markings that represents the max classification of this datasource.
 */
interface ClassificationConstraint {
    allowEmptyMarkings?: boolean | null | undefined;
    markings: Array<MarkingId>;
}
/**
 * A reference to a column in Foundry.
 */
interface ColumnLocator {
    columnName: string;
    datasetRid: string;
    writebackDatasetRid?: string | null | undefined;
}
/**
 * A string identifying a column name in a Foundry dataset. This is not safe to log as it is
 * user-inputted and may contain sensitive information.
 */
type ColumnName = string;
interface ComparisonCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    left: ConditionValue;
    operator: ComparisonOperator;
    right: ConditionValue;
}
interface ComparisonConditionModification {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    left: ConditionValueModification;
    operator: ComparisonOperator;
    right: ConditionValueModification;
}
type ComparisonOperator = "LESS_THAN_EQUALS" | "LESS_THAN" | "EQUALS" | "NOT_EQUALS" | "GREATER_THAN_EQUALS" | "GREATER_THAN" | "INTERSECTS" | "IS_OF_OBJECT_TYPE";
/**
 * ResourceIdentifier for a Compass Project.
 */
type CompassProjectRid = string;
interface Condition_true {
    type: "true";
    true: TrueCondition;
}
interface Condition_or {
    type: "or";
    or: OrCondition;
}
interface Condition_and {
    type: "and";
    and: AndCondition;
}
interface Condition_not {
    type: "not";
    not: NotCondition;
}
interface Condition_comparison {
    type: "comparison";
    comparison: ComparisonCondition;
}
interface Condition_markings {
    type: "markings";
    markings: MarkingsCondition;
}
interface Condition_regex {
    type: "regex";
    regex: RegexCondition;
}
interface Condition_redacted {
    type: "redacted";
    redacted: Redacted;
}
type Condition = Condition_true | Condition_or | Condition_and | Condition_not | Condition_comparison | Condition_markings | Condition_regex | Condition_redacted;
interface ConditionalOverride {
    condition: Condition;
    parameterBlockOverrides: Array<ParameterValidationBlockOverride>;
}
interface ConditionalOverrideModification {
    condition: ConditionModification;
    parameterBlockOverrides: Array<ParameterValidationBlockOverrideModification>;
}
interface ConditionalValidationBlock {
    conditionalOverrides: Array<ConditionalOverride>;
    defaultValidation: ParameterValidationBlock;
    structFieldValidations: Record<StructParameterFieldApiName, StructFieldConditionalValidationBlock>;
}
interface ConditionalValidationBlockModification {
    conditionalOverrides: Array<ConditionalOverrideModification>;
    defaultValidation: ParameterValidationBlockModification;
    structFieldValidations: Record<StructParameterFieldApiName, StructFieldConditionalValidationBlockModification>;
}
/**
 * Condititon Display Metadata. This is used in rendering the conditions in display.
 */
interface ConditionDisplayMetadata {
    index: ConditionIndex;
}
/**
 * The postition of the condition in an AND or OR condition set. Zero based.
 */
type ConditionIndex = number;
interface ConditionModification_true {
    type: "true";
    true: TrueCondition;
}
interface ConditionModification_or {
    type: "or";
    or: OrConditionModification;
}
interface ConditionModification_and {
    type: "and";
    and: AndConditionModification;
}
interface ConditionModification_not {
    type: "not";
    not: NotConditionModification;
}
interface ConditionModification_comparison {
    type: "comparison";
    comparison: ComparisonConditionModification;
}
interface ConditionModification_markings {
    type: "markings";
    markings: MarkingsConditionModification;
}
interface ConditionModification_regex {
    type: "regex";
    regex: RegexConditionModification;
}
interface ConditionModification_redacted {
    type: "redacted";
    redacted: Redacted;
}
type ConditionModification = ConditionModification_true | ConditionModification_or | ConditionModification_and | ConditionModification_not | ConditionModification_comparison | ConditionModification_markings | ConditionModification_regex | ConditionModification_redacted;
interface ConditionValue_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface ConditionValue_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface ConditionValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ConditionValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValue;
}
interface ConditionValue_userProperty {
    type: "userProperty";
    userProperty: UserProperty;
}
interface ConditionValue_parameterLength {
    type: "parameterLength";
    parameterLength: ParameterLength;
}
type ConditionValue = ConditionValue_parameterId | ConditionValue_staticValue | ConditionValue_objectParameterPropertyValue | ConditionValue_interfaceParameterPropertyValue | ConditionValue_userProperty | ConditionValue_parameterLength;
interface ConditionValueModification_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface ConditionValueModification_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface ConditionValueModification_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ConditionValueModification_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValueModification;
}
interface ConditionValueModification_userProperty {
    type: "userProperty";
    userProperty: UserProperty;
}
interface ConditionValueModification_parameterLength {
    type: "parameterLength";
    parameterLength: ParameterLength;
}
type ConditionValueModification = ConditionValueModification_parameterId | ConditionValueModification_staticValue | ConditionValueModification_objectParameterPropertyValue | ConditionValueModification_interfaceParameterPropertyValue | ConditionValueModification_userProperty | ConditionValueModification_parameterLength;
/**
 * The time that the user submits the Action will be used for this value.
 */
interface CurrentTime {
}
/**
 * The user executing the Action will be used for this value.
 */
interface CurrentUser {
}
interface DataConstraints {
    nullability?: DataNullability | null | undefined;
    nullabilityV2?: DataNullabilityV2 | null | undefined;
    propertyTypeConstraints: Array<PropertyTypeDataConstraintsWrapper>;
}
type DataNullability = "NO_EXPLICIT_NULLS";
interface DataNullabilityV2 {
    noEmptyCollections?: boolean | null | undefined;
    noNulls?: boolean | null | undefined;
}
/**
 * Contains information about the different security controls applied on data in this datasource. Note that
 * currently this is only allowed on Restricted View-like datasources.
 */
interface DataSecurity {
    classificationConstraint?: ClassificationConstraint | null | undefined;
    markingConstraint?: MandatoryMarkingConstraint | null | undefined;
}
/**
 * An rid identifying a Foundry dataset. This rid is a randomly generated identifier and is safe to log.
 */
type DatasetRid = string;
/**
 * Representing the rid and the branch of a foundry dataset.
 */
interface DatasetRidAndBranchId {
    branchId: BranchId;
    datasetRid: string;
}
/**
 * An rid identifying a dataset transaction. This rid is a randomly generated identifier and is safe to log.
 */
type DatasetTransactionRid = string;
interface DatasourceBackingRid_datasetRid {
    type: "datasetRid";
    datasetRid: DatasetRid;
}
interface DatasourceBackingRid_streamLocatorRid {
    type: "streamLocatorRid";
    streamLocatorRid: StreamLocatorRid;
}
interface DatasourceBackingRid_restrictedStreamRid {
    type: "restrictedStreamRid";
    restrictedStreamRid: RestrictedViewRid;
}
interface DatasourceBackingRid_restrictedViewRid {
    type: "restrictedViewRid";
    restrictedViewRid: RestrictedViewRid;
}
interface DatasourceBackingRid_timeSeriesSyncRid {
    type: "timeSeriesSyncRid";
    timeSeriesSyncRid: TimeSeriesSyncRid;
}
interface DatasourceBackingRid_mediaSetRid {
    type: "mediaSetRid";
    mediaSetRid: MediaSetRid;
}
interface DatasourceBackingRid_mediaSetViewRid {
    type: "mediaSetViewRid";
    mediaSetViewRid: MediaSetViewRid;
}
interface DatasourceBackingRid_geotimeSeriesIntegrationRid {
    type: "geotimeSeriesIntegrationRid";
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationRid;
}
interface DatasourceBackingRid_tableRid {
    type: "tableRid";
    tableRid: TableRid;
}
interface DatasourceBackingRid_editsOnlyRid {
    type: "editsOnlyRid";
    editsOnlyRid: EditsOnlyRid;
}
interface DatasourceBackingRid_directSourceRid {
    type: "directSourceRid";
    directSourceRid: DirectSourceRid;
}
interface DatasourceBackingRid_derivedPropertiesSourceRid {
    type: "derivedPropertiesSourceRid";
    derivedPropertiesSourceRid: DerivedPropertiesSourceRid;
}
/**
 * Union type to represent the different resource identifiers for Datasource(s) in load requests.
 */
type DatasourceBackingRid = DatasourceBackingRid_datasetRid | DatasourceBackingRid_streamLocatorRid | DatasourceBackingRid_restrictedStreamRid | DatasourceBackingRid_restrictedViewRid | DatasourceBackingRid_timeSeriesSyncRid | DatasourceBackingRid_mediaSetRid | DatasourceBackingRid_mediaSetViewRid | DatasourceBackingRid_geotimeSeriesIntegrationRid | DatasourceBackingRid_tableRid | DatasourceBackingRid_editsOnlyRid | DatasourceBackingRid_directSourceRid | DatasourceBackingRid_derivedPropertiesSourceRid;
interface DatasourceIdentifier_datasetRidAndBranchId {
    type: "datasetRidAndBranchId";
    datasetRidAndBranchId: DatasetRidAndBranchId;
}
interface DatasourceIdentifier_streamLocator {
    type: "streamLocator";
    streamLocator: StreamLocator;
}
interface DatasourceIdentifier_restrictedViewRid {
    type: "restrictedViewRid";
    restrictedViewRid: RestrictedViewRid;
}
interface DatasourceIdentifier_timeSeriesSyncRid {
    type: "timeSeriesSyncRid";
    timeSeriesSyncRid: TimeSeriesSyncRid;
}
interface DatasourceIdentifier_restrictedStream {
    type: "restrictedStream";
    restrictedStream: RestrictedViewRid;
}
interface DatasourceIdentifier_mediaSourceRids {
    type: "mediaSourceRids";
    mediaSourceRids: Array<MediaSourceRid>;
}
interface DatasourceIdentifier_mediaSetView {
    type: "mediaSetView";
    mediaSetView: MediaSetViewLocator;
}
interface DatasourceIdentifier_geotimeSeriesIntegrationRid {
    type: "geotimeSeriesIntegrationRid";
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationRid;
}
interface DatasourceIdentifier_table {
    type: "table";
    table: TableLocator;
}
interface DatasourceIdentifier_editsOnly {
    type: "editsOnly";
    editsOnly: EditsOnlyRid;
}
interface DatasourceIdentifier_directSourceRid {
    type: "directSourceRid";
    directSourceRid: DirectSourceRid;
}
interface DatasourceIdentifier_derivedPropertiesSourceRid {
    type: "derivedPropertiesSourceRid";
    derivedPropertiesSourceRid: DerivedPropertiesSourceRid;
}
/**
 * Union type to represent the different datasource identifiers
 */
type DatasourceIdentifier = DatasourceIdentifier_datasetRidAndBranchId | DatasourceIdentifier_streamLocator | DatasourceIdentifier_restrictedViewRid | DatasourceIdentifier_timeSeriesSyncRid | DatasourceIdentifier_restrictedStream | DatasourceIdentifier_mediaSourceRids | DatasourceIdentifier_mediaSetView | DatasourceIdentifier_geotimeSeriesIntegrationRid | DatasourceIdentifier_table | DatasourceIdentifier_editsOnly | DatasourceIdentifier_directSourceRid | DatasourceIdentifier_derivedPropertiesSourceRid;
/**
 * An rid identifying a datasource for an Ontology entity. This rid is a randomly generated identifier
 * and is safe to log.
 */
type DatasourceRid = string;
type DatasourceType = "DATASET" | "RESTRICTED_VIEW" | "TIME_SERIES" | "STREAM" | "STREAM_V2" | "STREAM_V3" | "DATASET_V2" | "RESTRICTED_VIEW_V2" | "RESTRICTED_STREAM" | "MEDIA" | "MEDIA_SET_VIEW" | "GEOTIME_SERIES" | "TABLE" | "EDITS_ONLY" | "DIRECT" | "DERIVED" | "DATASET_V3";
interface DataType_baseType {
    type: "baseType";
    baseType: BasePropertyType;
}
/**
 * Data type corresponding to `Type`. Differently from `Type` this only encodes the type of data, without
 * encoding e.g. analyzer settings. Prefer this to `Type` whenever e.g. type-checking against object properties.
 */
type DataType = DataType_baseType;
interface DateFormatter {
    format: DatetimeFormat;
}
interface DatePropertyType {
}
interface DateRangeValue_fixed {
    type: "fixed";
    fixed: ConditionValue;
}
interface DateRangeValue_relative {
    type: "relative";
    relative: RelativeDateRangeValue;
}
interface DateRangeValue_now {
    type: "now";
    now: NowValue;
}
type DateRangeValue = DateRangeValue_fixed | DateRangeValue_relative | DateRangeValue_now;
interface DateRangeValueModification_fixed {
    type: "fixed";
    fixed: ConditionValueModification;
}
interface DateRangeValueModification_relative {
    type: "relative";
    relative: RelativeDateRangeValue;
}
interface DateRangeValueModification_now {
    type: "now";
    now: NowValue;
}
type DateRangeValueModification = DateRangeValueModification_fixed | DateRangeValueModification_relative | DateRangeValueModification_now;
interface DatetimeFormat_stringFormat {
    type: "stringFormat";
    stringFormat: DatetimeStringFormat;
}
interface DatetimeFormat_localizedFormat {
    type: "localizedFormat";
    localizedFormat: DatetimeLocalizedFormat;
}
type DatetimeFormat = DatetimeFormat_stringFormat | DatetimeFormat_localizedFormat;
type DatetimeLocalizedFormat = "DATE_FORMAT_RELATIVE_TO_NOW" | "DATE_FORMAT_DATE" | "DATE_FORMAT_YEAR_AND_MONTH" | "DATE_FORMAT_DATE_TIME" | "DATE_FORMAT_DATE_TIME_SHORT" | "DATE_FORMAT_TIME" | "DATE_FORMAT_ISO_INSTANT";
/**
 * A valid format string composed of the following subset of patterns, taken from the java DateTimeFormatter docs:
 *
 * ```
 * Symbol  Meaning                     Presentation      Examples
 * ------  -------                     ------------      -------
 * y       year-of-era                 year              2004; 04
 * M       month-of-year               number/text       7; 07; Jul; July; J
 * d       day-of-month                number            10
 * E       day-of-week                 text              Tue; Tuesday; T
 * e       localized day-of-week       number/text       2; 02; Tue; Tuesday;
 *
 * a       am-pm-of-day                text              PM
 * h       clock-hour-of-am-pm (1-12)  number            12
 * H       hour-of-day (0-23)          number            0
 * m       minute-of-hour              number            30
 * s       second-of-minute            number            55
 * S       fraction-of-second          fraction          97
 *
 * z       time-zone name              zone-name         Pacific Standard Time; PST
 * Z       zone-offset                 offset-Z          +0000; -0800; -08:00
 * ```
 *
 * And the following separators: "/", ":", "-", "." and " " (single space).
 */
type DatetimeStringFormat = string;
interface DatetimeTimezone_static {
    type: "static";
    static: DatetimeTimezoneDefinition;
}
interface DatetimeTimezone_user {
    type: "user";
    user: UserTimezone;
}
type DatetimeTimezone = DatetimeTimezone_static | DatetimeTimezone_user;
interface DatetimeTimezoneDefinition_zoneId {
    type: "zoneId";
    zoneId: PropertyTypeReferenceOrStringConstant;
}
type DatetimeTimezoneDefinition = DatetimeTimezoneDefinition_zoneId;
interface DateTypeDataConstraints$1 {
    range: DateTypeRangeConstraint$1;
}
/**
 * ISO 8601 date.
 */
type DateTypeDataValue$1 = string;
interface DateTypeRangeConstraint$1 {
    max?: DateTypeDataValue$1 | null | undefined;
    min?: DateTypeDataValue$1 | null | undefined;
}
interface DecimalPropertyType {
    precision?: number | null | undefined;
    scale?: number | null | undefined;
}
interface DecimalTypeDataConstraints_range$1 {
    type: "range";
    range: DecimalTypeRangeConstraint$1;
}
interface DecimalTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfDecimalTypeConstraint$1;
}
type DecimalTypeDataConstraints$1 = DecimalTypeDataConstraints_range$1 | DecimalTypeDataConstraints_oneOf$1;
type DecimalTypeDataValue$1 = string;
interface DecimalTypeRangeConstraint$1 {
    max?: DecimalTypeDataValue$1 | null | undefined;
    min?: DecimalTypeDataValue$1 | null | undefined;
}
interface DelegateToAllowedStructFieldValues {
}
/**
 * The request to modify the ontology deletes LinkTypes that are still in use.
 */
interface DeletedLinkTypesStillInUseError {
    linkTypeReferences: Record<LinkTypeRid, Array<LinkTypeRid>>;
}
/**
 * The request to modify the ontology deletes LinkTypes that are still in use in the workflow.
 */
interface DeletedLinkTypesStillInUseInWorkflowError {
    linkTypeIds: Array<LinkTypeId>;
    workflowRid: WorkflowRid;
}
/**
 * The request to modify the ontology deletes ObjectTypes that are still in use.
 */
interface DeletedObjectTypesStillInUseError {
    linkTypeReferences: Record<ObjectTypeRid, Array<LinkTypeRid>>;
}
/**
 * The request to modify the ontology deletes ObjectTypes that are still in use in the workflow.
 */
interface DeletedObjectTypesStillInUseInWorkflowError {
    objectTypeIds: Array<ObjectTypeId>;
    workflowRid: WorkflowRid;
}
interface DeleteInterfaceLinkRule {
    interfaceLinkTypeRid: InterfaceLinkTypeRid;
    interfaceTypeRid: InterfaceTypeRid;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface DeleteInterfaceLinkRuleModification {
    interfaceLinkTypeRidOrIdInRequest: InterfaceLinkTypeRidOrIdInRequest;
    interfaceTypeRidOrIdInRequest: InterfaceTypeRidOrIdInRequest;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface DeleteLinkRule {
    linkTypeId: LinkTypeId;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface DeleteObjectRule {
    objectToDelete: ParameterId;
}
/**
 * Trying to simultaneously delete and edit an ActionType
 */
interface DeletingAndEditingTheSameActionTypeError {
    actionTypeRid: ActionTypeRid;
}
interface DeletionMetadata {
    isHardDeleted: boolean;
}
/**
 * Response for ActionTypeGetOrganizationsRequest. Please note that this will contain
 * OrganizationRid(s) only for ActionTypeRid(s) that are visible to the user.
 */
interface DeprecatedActionTypeGetOrganizationsResponse {
    organizationRidByActionTypeRid: Record<ActionTypeRid, OrganizationRid | null | undefined>;
}
/**
 * Request to associate given OrganizationRid(s) with the specified ActionTypeRid(s).
 * Users should have permissions to modify the specified ActionTypeRid(s) and also have
 * relevant permissions to apply the specified organizations' markings.
 */
interface DeprecatedActionTypeSetOrganizationsRequest {
    organizationRidByActionTypeRid: Record<ActionTypeRid, OrganizationRid>;
}
/**
 * This status indicates that the ActionType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface DeprecatedActionTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: ActionTypeRid | null | undefined;
}
/**
 * This status indicates that the interface is reaching the end of its life and will be removed as per the
 * deadline specified.
 */
interface DeprecatedInterfaceTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: InterfaceTypeRid | null | undefined;
}
/**
 * This status indicates that the LinkType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface DeprecatedLinkTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: LinkTypeRid | null | undefined;
}
/**
 * This status indicates that the ObjectType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface DeprecatedObjectTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: ObjectTypeRid | null | undefined;
}
/**
 * This status indicates that the PropertyType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface DeprecatedPropertyTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: PropertyTypeRid | null | undefined;
}
/**
 * A rid specifying a derived properties datasource. This will be the same as the datasource rid.
 */
type DerivedPropertiesSourceRid = string;
/**
 * A rid specifying a direct write datasource, such as an edge pipeline.
 */
type DirectSourceRid = string;
/**
 * Default layout that should be shown when interacting with action inline widget
 */
type DisplayMetadataConfigurationDefaultLayout = "FORM" | "TABLE";
/**
 * Separate configuration for each applicable layout
 */
interface DisplayMetadataConfigurationDisplayAndFormat {
    table: TableDisplayAndFormat;
}
interface DoublePropertyType {
}
interface DoubleTypeDataConstraints_range$1 {
    type: "range";
    range: DoubleTypeRangeConstraint$1;
}
interface DoubleTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfDoubleTypeConstraint$1;
}
type DoubleTypeDataConstraints$1 = DoubleTypeDataConstraints_range$1 | DoubleTypeDataConstraints_oneOf$1;
type DoubleTypeDataValue$1 = number | "NaN" | "Infinity" | "-Infinity";
interface DoubleTypeRangeConstraint$1 {
    max?: DoubleTypeDataValue$1 | null | undefined;
    min?: DoubleTypeDataValue$1 | null | undefined;
}
interface Duration {
    unit: TemporalUnit;
    value: number;
}
/**
 * Specifies the unit of the input duration value, ensuring that the formatter correctly interprets the number.
 */
type DurationBaseValue = "SECONDS" | "MILLISECONDS";
interface DurationFormatStyle_humanReadable {
    type: "humanReadable";
    humanReadable: HumanReadableFormat;
}
interface DurationFormatStyle_timecode {
    type: "timecode";
    timecode: TimeCodeFormat;
}
/**
 * The style in which the duration is formatted.
 */
type DurationFormatStyle = DurationFormatStyle_humanReadable | DurationFormatStyle_timecode;
/**
 * Specifies the maximum precision to apply when formatting a written duration.
 */
type DurationPrecision = "DAYS" | "HOURS" | "MINUTES" | "SECONDS" | "AUTO";
/**
 * An ObjectSet gotten as a result of performing a sequence of Transforms on a base ObjectSet.
 * Each transforms is either a PropertyFilter or a SearchAround.
 * There is a limit of 3 SearchArounds.
 */
interface DynamicObjectSet {
    startingObjectSet: DynamicObjectSetInput;
    transforms: Array<ObjectSetTransform>;
}
interface DynamicObjectSetInput_base {
    type: "base";
    base: DynamicObjectSetInputBase;
}
interface DynamicObjectSetInput_parameter {
    type: "parameter";
    parameter: DynamicObjectSetInputParameter;
}
interface DynamicObjectSetInput_unioned {
    type: "unioned";
    unioned: DynamicObjectSetInputUnioned;
}
/**
 * A wrapper used to reference an ObjectSet
 */
type DynamicObjectSetInput = DynamicObjectSetInput_base | DynamicObjectSetInput_parameter | DynamicObjectSetInput_unioned;
/**
 * Depicts an ObjectSet with all objects of this ObjectType
 */
interface DynamicObjectSetInputBase {
    objectTypeId: ObjectTypeId;
}
/**
 * A parameter holding an ObjectReference or ObjectReferenceList depicting a set of the specified Object(s).
 */
interface DynamicObjectSetInputParameter {
    parameterId: ParameterId;
}
/**
 * Depicts an ObjectSet which is a union of all ObjectSets provided.
 */
interface DynamicObjectSetInputUnioned {
    dynamicObjectSets: Array<DynamicObjectSet>;
}
/**
 * Request object to edit existing Action Types.
 */
interface EditActionTypeRequest {
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadataModification;
    logic: ActionLogic;
    notifications: Array<ActionNotification>;
    notificationSettings?: ActionNotificationSettings | null | undefined;
    parameterOrdering: Array<ParameterId>;
    parametersToAdd: Record<ParameterId, PutParameterRequest>;
    parametersToDelete: Array<ParameterRid>;
    parametersToEdit: Record<ParameterRid, EditParameterRequest>;
    revert?: ActionRevert | null | undefined;
    status?: ActionTypeStatus | null | undefined;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    validationsToAdd: Array<ValidationRule>;
    validationsToDelete: Array<ValidationRuleRid>;
    validationsToEdit: Record<ValidationRuleRid, EditValidationRuleRequest>;
    webhooks?: ActionWebhooks | null | undefined;
}
/**
 * A property type without a backing dataset column. It can only be populated via Actions.
 */
interface EditOnlyPropertyType {
}
/**
 * Request to edit an existing parameter
 */
interface EditParameterRequest {
    displayMetadata: ParameterDisplayMetadata;
    id: ParameterId;
    type: BaseParameterType;
    validation: ConditionalValidationBlock;
}
/**
 * Request to edit an existing parameter
 */
interface EditParameterRequestModification {
    displayMetadata: ParameterDisplayMetadata;
    id: ParameterId;
    type: BaseParameterTypeModification;
    validation: ConditionalValidationBlockModification;
}
/**
 * Contains configuration options for how edits behave in phonograph.
 */
interface EditsConfiguration {
    onlyAllowPrivilegedEdits: boolean;
}
/**
 * Request to edit an existing Section
 */
interface EditSectionRequest {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    id: SectionId;
    validation: SectionDisplayBlock;
}
/**
 * Request to edit an existing Section
 */
interface EditSectionRequestModification {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    id: SectionId;
    validation: SectionDisplayBlockModification;
}
/**
 * An rid identifying an object type used for storing edits history of another object type. Edit history object
 * types cannot be edited manually by users and are automatically maintained by OMS based on the edits history
 * settings in entity metadata of the main object type to track history for.
 */
type EditsHistoryObjectTypeRid = string;
/**
 * A RID representing an edits-only "datasource". If this RID is specified at datasource creation time, it
 * must be a valid Compass project RID. If one is not specified, DatasourceRid will be used.
 */
type EditsOnlyRid = string;
interface EditValidationRuleRequest {
    condition: Condition;
    displayMetadata: ValidationRuleDisplayMetadata;
}
interface EmailBody_basic {
    type: "basic";
    basic: BasicEmailBody;
}
/**
 * An action notification's email body. Uses Handlebars templating.
 */
type EmailBody = EmailBody_basic;
interface EmailBodyModification_basic {
    type: "basic";
    basic: BasicEmailBodyModification;
}
/**
 * An action notification's email body. Uses Handlebars templating.
 */
type EmailBodyModification = EmailBodyModification_basic;
interface EmbeddingModel_text {
    type: "text";
    text: TextEmbeddingModel;
}
type EmbeddingModel = EmbeddingModel_text;
interface Empty {
}
/**
 * This status indicates that the ObjectType is endorsed as a part of "core" ontology by ontology-level owners and provides even better guarantees than the Active status.
 */
interface EndorsedObjectTypeStatus {
}
/**
 * The rid for a Multipass Enrollment.
 */
type EnrollmentRid = string;
interface EntityLoadByDatasourceResponse_objectType {
    type: "objectType";
    objectType: ObjectTypeLoadResponse;
}
interface EntityLoadByDatasourceResponse_linkType {
    type: "linkType";
    linkType: LinkTypeLoadResponse;
}
/**
 * A union of ObjectTypeResponse and LinkTypeResponse.
 */
type EntityLoadByDatasourceResponse = EntityLoadByDatasourceResponse_objectType | EntityLoadByDatasourceResponse_linkType;
/**
 * Specifies how EntityMetadatas should be loaded.
 */
interface EntityMetadataLoadRequest {
    generateGothamMappings?: boolean | null | undefined;
}
/**
 * Status type corresponding to `ObjectType`/`LinkType`/`PropertyType`-statuses. Differently from them, this only
 * encodes the status itself, without encoding e.g. deprecation message. This is safe to log.
 */
type EntityStatus = "EXPERIMENTAL" | "ACTIVE" | "DEPRECATED" | "EXAMPLE" | "ENDORSED";
/**
 * Describes how to treat an object of this type as an event.
 */
interface EventMetadata {
    description?: PropertyTypeRid | null | undefined;
    endTimePropertyTypeRid: PropertyTypeRid;
    eventIdPropertyTypeRid: PropertyTypeRid;
    startTimePropertyTypeRid: PropertyTypeRid;
}
/**
 * ResourceIdentifier for events topics.
 */
type EventsTopicRid = string;
interface EveryoneTrustedRedactionOverride {
}
/**
 * This status indicates that the ActionType is an example. It is backed by notional data that should not be used for actual workflows, but can be used to test those workflows.
 */
interface ExampleActionTypeStatus {
}
/**
 * This status indicates that the interface is an example.
 * It is backed by notional data that should not be used for actual workflows, but can be used to test those workflows.
 */
interface ExampleInterfaceTypeStatus {
}
/**
 * This status indicates that the LinkType is an example. It is backed by notional data that should not be used for actual workflows, but can be used to test those workflows.
 */
interface ExampleLinkTypeStatus {
}
/**
 * This status indicates that the ObjectType is an example. It is backed by notional data that should not be used for actual workflows, but can be used to test those workflows.
 */
interface ExampleObjectTypeStatus {
}
/**
 * This status indicates that the PropertyType is an example. It is backed by notional data that should not be used for actual workflows, but can be used to test those workflows.
 */
interface ExamplePropertyTypeStatus {
}
/**
 * This status indicates that the ActionType is in development. Please refrain from using it in critical workflows as it may change/disappear at any time.
 */
interface ExperimentalActionTypeStatus {
}
interface ExperimentalDeclarativeEditInformation {
    objectSetRidParameter: FunctionInputName;
}
/**
 * This status indicates that the interface is in development. Please refrain from using it in critical workflows
 * as breaking changes can be made at anytime.
 */
interface ExperimentalInterfaceTypeStatus {
}
/**
 * This status indicates that the LinkType is in development. Please refrain from using it in critical workflows as it may change/disappear at any time.
 */
interface ExperimentalLinkTypeStatus {
}
/**
 * This status indicates that the ObjectType is in development. Please refrain from using it in critical workflows as it may change/disappear at any time.
 */
interface ExperimentalObjectTypeStatus {
}
/**
 * This status indicates that the PropertyType is in development. Please refrain from using it in critical workflows as it may change/disappear at any time.
 */
interface ExperimentalPropertyTypeStatus {
}
/**
 * Note this is experimental, should not be used without consulting the product team and format can
 * change/break without notice.
 */
interface ExperimentalTimeDependentPropertyTypeV1 {
    sensorLinkTypeId?: LinkTypeId | null | undefined;
    seriesValueMetadata: SeriesValueMetadata;
}
interface FailureMessage$1 {
    message: string;
}
interface FieldDisplayMetadata {
    displayName?: string | null | undefined;
    renderHints: Array<PropertyRenderHint>;
    visibility?: Visibility | null | undefined;
}
/**
 * General class for capturing column, local property, and global property common field metadata
 */
interface FieldMetadata {
    description?: string | null | undefined;
    displayMetadata?: FieldDisplayMetadata | null | undefined;
    metadata: Record<string, any | null | undefined>;
    typeclasses: Array<TypeClass>;
}
interface FloatPropertyType {
}
interface FloatTypeDataConstraints_range$1 {
    type: "range";
    range: FloatTypeRangeConstraint$1;
}
interface FloatTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfFloatTypeConstraint$1;
}
type FloatTypeDataConstraints$1 = FloatTypeDataConstraints_range$1 | FloatTypeDataConstraints_oneOf$1;
type FloatTypeDataValue$1 = number | "NaN" | "Infinity" | "-Infinity";
interface FloatTypeRangeConstraint$1 {
    max?: FloatTypeDataValue$1 | null | undefined;
    min?: FloatTypeDataValue$1 | null | undefined;
}
/**
 * Convert Multipass Ids into usernames.
 */
interface FormatterUserId {
}
interface FormContent_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface FormContent_sectionId {
    type: "sectionId";
    sectionId: SectionId;
}
/**
 * Items that we can place on the action form.
 */
type FormContent = FormContent_parameterId | FormContent_sectionId;
type FoundryFieldType = "ARRAY" | "DECIMAL" | "MAP" | "STRUCT" | "LONG" | "BINARY" | "BOOLEAN" | "BYTE" | "DATE" | "DOUBLE" | "FLOAT" | "INTEGER" | "SHORT" | "STRING" | "TIMESTAMP" | "UNKNOWN_TYPE";
interface FoundryLiveDeployment {
    inputParamName: string;
    outputParamName: string;
    rid: LiveDeploymentRid;
}
type FunctionApiName = string;
interface FunctionAtVersion {
    functionRid: FunctionRid;
    functionVersion: SemanticFunctionVersion;
}
interface FunctionExecutionWithRecipientInput_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValue;
}
interface FunctionExecutionWithRecipientInput_recipient {
    type: "recipient";
    recipient: NotificationRecipient;
}
/**
 * Encapsulates either a LogicRuleValue or a NotificationRecipient.
 */
type FunctionExecutionWithRecipientInput = FunctionExecutionWithRecipientInput_logicRuleValue | FunctionExecutionWithRecipientInput_recipient;
interface FunctionExecutionWithRecipientInputModification_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValueModification;
}
interface FunctionExecutionWithRecipientInputModification_recipient {
    type: "recipient";
    recipient: NotificationRecipient;
}
/**
 * Encapsulates either a LogicRuleValueModification or a NotificationRecipient.
 */
type FunctionExecutionWithRecipientInputModification = FunctionExecutionWithRecipientInputModification_logicRuleValue | FunctionExecutionWithRecipientInputModification_recipient;
/**
 * Notification recipients determined from a Function execution.
 */
interface FunctionGeneratedActionNotificationRecipients {
    functionExecution: FunctionRule;
}
/**
 * Notification recipients determined from a Function execution.
 */
interface FunctionGeneratedActionNotificationRecipientsModification {
    functionExecution: FunctionRuleModification;
}
/**
 * The body of a notification based on the result of a function execution.
 */
interface FunctionGeneratedNotificationBody {
    functionExecution: ActionNotificationBodyFunctionExecution;
}
/**
 * The body of a notification based on the result of a function execution.
 */
interface FunctionGeneratedNotificationBodyModification {
    functionExecution: ActionNotificationBodyFunctionExecutionModification;
}
/**
 * Name of an Input to a Function. Not safe to log.
 */
type FunctionInputName = string;
interface FunctionReference {
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
}
/**
 * The rid for a Function. Safe to log.
 */
type FunctionRid = string;
/**
 * A Function to be executed with action input parameters.
 */
interface FunctionRule {
    customExecutionMode?: FunctionRuleCustomExecutionMode | null | undefined;
    experimentalDeclarativeEditInformation?: ExperimentalDeclarativeEditInformation | null | undefined;
    functionInputValues: Record<FunctionInputName, LogicRuleValue>;
    functionRid: FunctionRid;
    functionVersion: SemanticFunctionVersion;
}
interface FunctionRuleCustomExecutionMode_bulkExecutionModeConfig {
    type: "bulkExecutionModeConfig";
    bulkExecutionModeConfig: BulkExecutionModeConfig;
}
type FunctionRuleCustomExecutionMode = FunctionRuleCustomExecutionMode_bulkExecutionModeConfig;
/**
 * A Function to be executed with action input parameters.
 */
interface FunctionRuleModification {
    customExecutionMode?: FunctionRuleCustomExecutionMode | null | undefined;
    experimentalDeclarativeEditInformation?: ExperimentalDeclarativeEditInformation | null | undefined;
    functionInputValues: Record<FunctionInputName, LogicRuleValueModification>;
    functionRid: FunctionRid;
    functionVersion: SemanticFunctionVersion;
}
/**
 * The version of a Function. Not safe to log.
 */
type FunctionVersion = string;
/**
 * Represents an unexpected OntologyMetadataError thrown during the creation of the Ontology Modification Context.
 */
interface GenericOntologyMetadataError {
    errorInstanceId: string;
    errorName: string;
    httpErrorCode: number;
    message: string;
    safeArgs: Array<SafeArg>;
    unsafeArgs: Array<UnsafeArg>;
}
interface GeohashPropertyType {
}
/**
 * The geo_shape data type facilitates the indexing of and searching with arbitrary geo shapes such as rectangles
 * and polygons.
 * Shapes must be represented as GeoJSON (see https://geojson.org for more information).
 * We support the following types of GeoJson shape:
 * - Point, A single geographic coordinate. Only WGS-84 coordinates are supported.
 * - LineString, An arbitrary line given two or more points.
 * - Polygon, A closed polygon whose first and last point must match, thus requiring n + 1 vertices to create an n-sided polygon and a minimum of 4 vertices.
 * - MultiPoint, An array of unconnected, but likely related points.
 * - MultiLineString, An array of separate linestrings.
 * - MultiPolygon, An array of separate polygons.
 * - GeometryCollection, A GeoJSON shape similar to the multi* shapes except that multiple types can coexist (e.g., a Point and a LineString).
 * Note: we do not support the GeoJSON types Feature and FeatureCollection
 * The underlying foundry type must be a string.
 */
interface GeoshapePropertyType {
}
/**
 * A rid identifying a Geotime integration, which parents one or more Geotime series. This rid is a randomly
 * generated identifier and is safe to log.
 */
type GeotimeSeriesIntegrationRid = string;
/**
 * Type for properties containing references to a Geotime series.
 */
interface GeotimeSeriesReferencePropertyType {
}
/**
 * A paging token used to fetch subsequent pages. Clients should not make any assumptions about the contents of
 * the token and it should not be parsed/modified.
 */
type GetActionTypesForInterfaceTypePageToken = string;
/**
 * Request to get ActionType(s) for an InterfaceType.
 */
interface GetActionTypesForInterfaceTypeRequest {
    interfaceType: InterfaceTypeRid;
    ontologyVersion?: OntologyVersion | null | undefined;
    pageSize?: number | null | undefined;
    pageToken?: GetActionTypesForInterfaceTypePageToken | null | undefined;
}
/**
 * Response to GetActionTypesForInterfaceTypeRequest.
 */
interface GetActionTypesForInterfaceTypeResponse {
    actionTypes: Array<ActionType>;
    nextPageToken?: GetActionTypesForInterfaceTypePageToken | null | undefined;
}
/**
 * A paging token used to fetch subsequent pages. Clients should not make any assumptions about the contents of
 * the token and it should not be parsed/modified.
 */
type GetActionTypesForObjectTypePageToken = string;
/**
 * Request to get ActionType(s) for an ObjectType.
 */
interface GetActionTypesForObjectTypeRequest {
    objectType: ObjectTypeRid;
    ontologyVersion?: OntologyVersion | null | undefined;
    pageSize?: number | null | undefined;
    pageToken?: GetActionTypesForObjectTypePageToken | null | undefined;
}
/**
 * Response to GetActionTypesForObjectTypeRequest.
 */
interface GetActionTypesForObjectTypeResponse {
    actionTypes: Array<ActionType>;
    nextPageToken?: GetActionTypesForObjectTypePageToken | null | undefined;
}
/**
 * Current configuration of some OMS features. Note that these configurations are stack-wide, which means they do not have granularity on org/enrollment/group level.
 */
interface GetFeatureConfigurationsResponse {
    allowGothamTypeMappingUsage: boolean;
    allowNonRoleEntitiesInProposals: boolean;
    allowSharedPropertyTypeUsage: boolean;
    allowTypeRegistryUsage: boolean;
    ontologyProposalsInDefaultOntologyWillBeOrgMarked: boolean;
}
/**
 * Request to get all kinds of links for the given ObjectTypes. The latest ontology version at potentially
 * multiple ontologies is considered.
 */
interface GetLinkMetadataForObjectTypesRequest {
    objectTypes: Array<ObjectTypeRid>;
}
/**
 * Response to GetLinkMetadataForObjectTypesRequest.
 */
interface GetLinkMetadataForObjectTypesResponse {
    links: Record<ObjectTypeRid, Array<LinkMetadata>>;
}
/**
 * Request to batch get LinkType(s) for ObjectType(s).
 */
interface GetLinkTypesForObjectTypesRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
    objectTypeBranches: Record<ObjectTypeRid, OntologyBranchRid | null | undefined>;
    objectTypeVersions: Record<ObjectTypeRid, OntologyVersion | null | undefined>;
}
/**
 * Response to GetLinkTypesForObjectTypesRequest.
 */
interface GetLinkTypesForObjectTypesResponse {
    linkTypes: Record<ObjectTypeRid, Array<LinkType>>;
}
/**
 * Request to get a map of interfaces to the set of object types that implement the interface, directly and
 * indirectly.
 */
interface GetObjectTypesForInterfaceTypesRequest {
    interfaceTypeRids: Array<InterfaceTypeRid>;
    ontologyVersion?: OntologyVersion | null | undefined;
}
/**
 * Response to GetObjectTypesForInterfaceTypesRequest.
 */
interface GetObjectTypesForInterfaceTypesResponse {
    objectTypeRidsByInterfaceTypeRid: Record<InterfaceTypeRid, Array<ObjectTypeRid>>;
}
/**
 * Request to get a map of SharedPropertyTypeRid to the set of ObjectTypeRids that use the SharedPropertyType.
 */
interface GetObjectTypesForSharedPropertyTypesRequest {
    ontologyVersion?: OntologyVersion | null | undefined;
    sharedPropertyTypeRids: Array<SharedPropertyTypeRid>;
}
/**
 * Response to GetObjectTypesForSharedPropertyTypesRequest.
 */
interface GetObjectTypesForSharedPropertyTypesResponse {
    objectTypeRidsBySharedPropertyTypeRid: Record<SharedPropertyTypeRid, Array<ObjectTypeRid>>;
}
/**
 * Request to get a map of TypeGroupRids to the set of ObjectTypeRids that use the TypeGroupRids.
 */
interface GetObjectTypesForTypeGroupsRequest {
    ontologyVersion?: OntologyVersion | null | undefined;
    typeGroupRids: Array<TypeGroupRid>;
}
/**
 * Response to GetObjectTypesForTypeGroupsRequest.
 */
interface GetObjectTypesForTypeGroupsResponse {
    objectTypeRidsByTypeGroupRids: Record<TypeGroupRid, Array<ObjectTypeRid>>;
}
/**
 * Request to get a map of TypeGroupRids to the rids of ontology entities that use the TypeGroupRids.
 */
interface GetOntologyEntitiesForTypeGroupsRequest {
    ontologyVersion?: OntologyVersion | null | undefined;
    typeGroupRids: Array<TypeGroupRid>;
}
/**
 * Response to GetOntologyEntitiesForTypeGroupsRequest.
 */
interface GetOntologyEntitiesForTypeGroupsResponse {
    ontologyEntitiesByTypeGroupRids: Record<TypeGroupRid, OntologyEntitiesUsedInTypeGroup>;
}
interface GetOntologySummaryRequest {
    ontologyBranchRid?: OntologyBranchRid | null | undefined;
}
interface GetOntologySummaryResponse {
    actionTypes: ActionTypesSummary;
    interfaces: InterfacesSummary;
    linkTypes: LinkTypesSummary;
    objectTypes: ObjectTypesSummary;
    sharedProperties: SharedPropertiesSummary;
    typeGroups: TypeGroupsSummary;
}
/**
 * Request to batch get BidirectionalRelations for ObjectTypes.
 *
 * Please note that this has been deprecated. Please switch to GetLinkTypesForObjectTypesRequest instead.
 */
interface GetRelationsForObjectTypesRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    partialObjectTypeVersions: Record<ObjectTypeId, OntologyVersion>;
}
interface GetRelationsForObjectTypesResponse {
    bidirectionalRelations: Record<ObjectTypeId, Array<BidirectionalRelation>>;
}
/**
 * A rid identifying a global branch of the Branch Service.
 */
type GlobalBranchRid = string;
/**
 * Unique Identifier for a Multipass group
 */
type GroupId = string;
/**
 * Represents a Handlebars template input value name. This value should only contain alphanumeric characters,
 * should contain at most 100 characters, and is case sensitive.
 */
type HandlebarsInputName = string;
interface HumanReadableFormat {
    showFullUnits?: boolean | null | undefined;
}
interface Icon_blueprint {
    type: "blueprint";
    blueprint: BlueprintIcon;
}
type Icon = Icon_blueprint;
interface IconReference {
    color?: string | null | undefined;
    locator: string;
    source: string;
}
interface ImportedOntologyEntitiesForProjectSpanOntologies {
    sourceOntologyEntities: Array<string>;
    targetOntologyEntities: Array<string>;
}
interface InlineActionDisplayOptions {
    displayErrors: boolean;
}
interface InlineActionType {
    displayOptions: InlineActionDisplayOptions;
    parameterId?: ParameterId | null | undefined;
    rid: ActionTypeRid;
}
/**
 * An Inline ActionType must be referenced by one and only one ObjectType.
 */
interface InlineActionTypeCannotBeReferencedByMultipleObjectTypesError {
    actionTypeRid: ActionTypeIdentifier;
    objectTypesWhichReferenceThisActionTypeAsInline: Array<ObjectTypeId>;
}
interface IntegerPropertyType {
}
interface IntegerTypeDataConstraints_range$1 {
    type: "range";
    range: IntegerTypeRangeConstraint$1;
}
interface IntegerTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfIntegerTypeConstraint$1;
}
type IntegerTypeDataConstraints$1 = IntegerTypeDataConstraints_range$1 | IntegerTypeDataConstraints_oneOf$1;
type IntegerTypeDataValue$1 = number;
interface IntegerTypeRangeConstraint$1 {
    max?: IntegerTypeDataValue$1 | null | undefined;
    min?: IntegerTypeDataValue$1 | null | undefined;
}
interface InterfaceLinkType {
    cardinality: InterfaceLinkTypeCardinality;
    linkedEntityTypeId: LinkedEntityTypeId;
    metadata: InterfaceLinkTypeMetadata;
    required: boolean;
    rid: InterfaceLinkTypeRid;
}
/**
 * A string indicating the API name to use for the interface link. This API name will be used to reference the
 * interface link in programming languages. The name should be given in lowerCamelCase and should be unique
 * across the interface and the superset of its parent interfaces.
 */
type InterfaceLinkTypeApiName = string;
/**
 * The cardinality of the link in the given direction. Cardinality can be "single", meaning an object can link
 * to zero or one other objects, or "many", meaning an object can link to any number of other objects.
 */
type InterfaceLinkTypeCardinality = "SINGLE" | "MANY";
/**
 * Reference to an InterfaceLinkType. Used to reference an InterfaceLinkType in the same request it is created
 * in.
 */
type InterfaceLinkTypeIdInRequest = string;
interface InterfaceLinkTypeMetadata {
    apiName: InterfaceLinkTypeApiName;
    description: string;
    displayName: string;
}
/**
 * ResourceIdentifier for an InterfaceLinkType.
 */
type InterfaceLinkTypeRid = string;
interface InterfaceLinkTypeRidOrIdInRequest_rid {
    type: "rid";
    rid: InterfaceLinkTypeRid;
}
interface InterfaceLinkTypeRidOrIdInRequest_idInRequest {
    type: "idInRequest";
    idInRequest: InterfaceLinkTypeIdInRequest;
}
type InterfaceLinkTypeRidOrIdInRequest = InterfaceLinkTypeRidOrIdInRequest_rid | InterfaceLinkTypeRidOrIdInRequest_idInRequest;
interface InterfaceParameterPropertyValue {
    parameterId: ParameterId;
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface InterfaceParameterPropertyValueModification {
    parameterId: ParameterId;
    sharedPropertyTypeRidOrIdInRequest: SharedPropertyTypeRidOrIdInRequest;
}
interface InterfacePropertyImplementation {
    propertyTypeRid: PropertyTypeRid;
}
/**
 * Reference to a InterfacePropertyType. Used when referencing an InterfacePropertyType in the same request it is
 * created in.
 */
type InterfacePropertyTypeIdInRequest = string;
/**
 * A rid identifying an InterfacePropertyType. This rid is generated randomly and is safe for logging purposes.
 * The InterfacePropertyTypeRid for an InterfacePropertyType is immutable.
 */
type InterfacePropertyTypeRid = string;
interface InterfacePropertyTypeRidOrIdInRequest_rid {
    type: "rid";
    rid: InterfacePropertyTypeRid;
}
interface InterfacePropertyTypeRidOrIdInRequest_idInRequest {
    type: "idInRequest";
    idInRequest: InterfacePropertyTypeIdInRequest;
}
type InterfacePropertyTypeRidOrIdInRequest = InterfacePropertyTypeRidOrIdInRequest_rid | InterfacePropertyTypeRidOrIdInRequest_idInRequest;
interface InterfaceSharedPropertyType {
    required: boolean;
    sharedPropertyType: SharedPropertyType;
}
interface InterfacesSummary {
    visibleEntities: number;
}
/**
 * Represents a collection of properties that object types can implement. If an object type implements an
 * interface, it is guaranteed to have the conform to the interface shape.
 */
interface InterfaceType {
    allExtendsInterfaces: Array<InterfaceTypeRid>;
    allLinks: Array<InterfaceLinkType>;
    allProperties: Array<SharedPropertyType>;
    allPropertiesV2: Record<SharedPropertyTypeRid, InterfaceSharedPropertyType>;
    apiName: InterfaceTypeApiName;
    displayMetadata: InterfaceTypeDisplayMetadata;
    extendsInterfaces: Array<InterfaceTypeRid>;
    links: Array<InterfaceLinkType>;
    properties: Array<SharedPropertyType>;
    propertiesV2: Record<SharedPropertyTypeRid, InterfaceSharedPropertyType>;
    rid: InterfaceTypeRid;
    status: InterfaceTypeStatus;
}
/**
 * A string indicating the API name to use for the interface. This API name will be used to reference the
 * interface in programming languages. Typically this is the name of the interface in pascal case. This must be
 * unique across all interfaces in an ontology.
 */
type InterfaceTypeApiName = string;
interface InterfaceTypeCreatedEvent {
    interfaceTypeRid: InterfaceTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface InterfaceTypeDeletedEvent {
    deletionMetadata?: DeletionMetadata | null | undefined;
    interfaceTypeRid: InterfaceTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * This includes metadata which can be used by front-ends when displaying an interface.
 */
interface InterfaceTypeDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
    icon?: Icon | null | undefined;
}
interface InterfaceTypeError_interfaceTypesNotFound {
    type: "interfaceTypesNotFound";
    interfaceTypesNotFound: InterfaceTypesNotFoundError;
}
interface InterfaceTypeError_interfaceTypesAlreadyExist {
    type: "interfaceTypesAlreadyExist";
    interfaceTypesAlreadyExist: InterfaceTypesAlreadyExistError;
}
type InterfaceTypeError = InterfaceTypeError_interfaceTypesNotFound | InterfaceTypeError_interfaceTypesAlreadyExist;
/**
 * Reference to an interface in a request. Used to reference an interface in the same request it is created in.
 */
type InterfaceTypeIdInRequest = string;
interface InterfaceTypeLoadRequest {
    rid: InterfaceTypeRid;
    versionReference?: VersionReference | null | undefined;
}
interface InterfaceTypeLoadResponse {
    interfaceType: InterfaceType;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * An immutable rid identifying the interface. This rid is generated randomly and is safe for logging purposes.
 */
type InterfaceTypeRid = string;
interface InterfaceTypeRidOrIdInRequest_rid {
    type: "rid";
    rid: InterfaceTypeRid;
}
interface InterfaceTypeRidOrIdInRequest_idInRequest {
    type: "idInRequest";
    idInRequest: InterfaceTypeIdInRequest;
}
type InterfaceTypeRidOrIdInRequest = InterfaceTypeRidOrIdInRequest_rid | InterfaceTypeRidOrIdInRequest_idInRequest;
/**
 * Cannot create InterfaceTypes that already exist.
 */
interface InterfaceTypesAlreadyExistError {
    interfaceTypeRids: Array<InterfaceTypeRid>;
}
/**
 * The InterfaceTypes were not found.
 */
interface InterfaceTypesNotFoundError {
    interfaceTypeRids: Array<InterfaceTypeRid>;
}
interface InterfaceTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalInterfaceTypeStatus;
}
interface InterfaceTypeStatus_active {
    type: "active";
    active: ActiveInterfaceTypeStatus;
}
interface InterfaceTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedInterfaceTypeStatus;
}
interface InterfaceTypeStatus_example {
    type: "example";
    example: ExampleInterfaceTypeStatus;
}
type InterfaceTypeStatus = InterfaceTypeStatus_experimental | InterfaceTypeStatus_active | InterfaceTypeStatus_deprecated | InterfaceTypeStatus_example;
interface InterfaceTypeUpdatedEvent {
    interfaceTypeRid: InterfaceTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * Represents a link between two ObjectTypes with an intermediary ObjectType acting as a bridge.
 * This LinkType can be used to jump from ObjectType A to B without specifying two separate search-arounds.
 * This LinkType can also be used to simulate a ManyToMany LinkType backed by an RV, or a ManyToMany LinkType
 * with properties.
 *
 * If any special interaction is required on the intermediary ObjectType (for example filtering) the two
 * connecting LinkTypes should be used instead.
 */
interface IntermediaryLinkDefinition {
    aToIntermediaryLinkTypeRid: LinkTypeRid;
    intermediaryObjectTypeRid: ObjectTypeRid;
    intermediaryToBLinkTypeRid: LinkTypeRid;
    objectTypeAToBLinkMetadata: LinkTypeMetadata;
    objectTypeBToALinkMetadata: LinkTypeMetadata;
    objectTypeRidA: ObjectTypeRid;
    objectTypeRidB: ObjectTypeRid;
}
interface JoinDefinition_singleKey {
    type: "singleKey";
    singleKey: SingleKeyJoinDefinition;
}
interface JoinDefinition_joinTable {
    type: "joinTable";
    joinTable: ManyToManyJoinDefinition;
}
/**
 * There are two types of JoinDefinitions - singleKey and joinTable. The singleKey definition should be used when defining a relationship that is ONE_TO_ONE or ONE_TO_MANY. MANY_TO_MANY relationships should be defined with a joinTable definition.
 */
type JoinDefinition = JoinDefinition_singleKey | JoinDefinition_joinTable;
interface KnownFormatter_artifactGidFormatter {
    type: "artifactGidFormatter";
    artifactGidFormatter: ArtifactGidFormatter;
}
interface KnownFormatter_userId {
    type: "userId";
    userId: FormatterUserId;
}
interface KnownFormatter_ridFormatter {
    type: "ridFormatter";
    ridFormatter: RidFormatter;
}
/**
 * Contains a known format that informs the Front-End consumer to use a specific formatter.
 */
type KnownFormatter = KnownFormatter_artifactGidFormatter | KnownFormatter_userId | KnownFormatter_ridFormatter;
interface LabelledValue {
    label: string;
    value: StaticValue;
}
/**
 * A language-specific analyzer. Since some aren't provided natively with Elasticsearch, ontology-metadata cannot
 * guarantee that a given language-specific analyzer will be available for use.
 */
type LanguageAnalyzer = "FRENCH" | "JAPANESE" | "ARABIC" | "COMBINED_ARABIC_ENGLISH";
/**
 * ResourceIdentifier for lime indexes.
 */
type LimeIndexRid = string;
interface LinkDefinition_manyToMany {
    type: "manyToMany";
    manyToMany: ManyToManyLinkDefinition;
}
interface LinkDefinition_oneToMany {
    type: "oneToMany";
    oneToMany: OneToManyLinkDefinition;
}
interface LinkDefinition_intermediary {
    type: "intermediary";
    intermediary: IntermediaryLinkDefinition;
}
type LinkDefinition = LinkDefinition_manyToMany | LinkDefinition_oneToMany | LinkDefinition_intermediary;
interface LinkedEntityTypeId_objectType {
    type: "objectType";
    objectType: ObjectTypeId;
}
interface LinkedEntityTypeId_interfaceType {
    type: "interfaceType";
    interfaceType: InterfaceTypeRid;
}
/**
 * A reference to a linked entity in InterfaceLinkTypes.
 */
type LinkedEntityTypeId = LinkedEntityTypeId_objectType | LinkedEntityTypeId_interfaceType;
interface LinkedEntityTypeRidOrIdInRequest_objectType {
    type: "objectType";
    objectType: ObjectTypeId;
}
interface LinkedEntityTypeRidOrIdInRequest_interfaceType {
    type: "interfaceType";
    interfaceType: InterfaceTypeRidOrIdInRequest;
}
type LinkedEntityTypeRidOrIdInRequest = LinkedEntityTypeRidOrIdInRequest_objectType | LinkedEntityTypeRidOrIdInRequest_interfaceType;
interface LinkMetadata_linkType {
    type: "linkType";
    linkType: LinkType;
}
interface LinkMetadata_softLink {
    type: "softLink";
    softLink: SoftLink;
}
/**
 * Representation of all types of links that can be traversed in the ontology
 */
type LinkMetadata = LinkMetadata_linkType | LinkMetadata_softLink;
/**
 * LinkType(s) are models for relationships between ObjectType(s).
 */
interface LinkType {
    definition: LinkDefinition;
    id: LinkTypeId;
    redacted?: boolean | null | undefined;
    rid: LinkTypeRid;
    status: LinkTypeStatus;
}
interface LinkTypeCreatedEvent {
    linkTypeRid: LinkTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface LinkTypeDeletedEvent {
    deletionMetadata?: DeletionMetadata | null | undefined;
    linkTypeRid: LinkTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface LinkTypeDisplayMetadata {
    displayName: string;
    groupDisplayName?: string | null | undefined;
    pluralDisplayName: string;
    visibility: Visibility;
}
interface LinkTypeError_linkTypesAlreadyExist {
    type: "linkTypesAlreadyExist";
    linkTypesAlreadyExist: LinkTypesAlreadyExistError;
}
interface LinkTypeError_linkTypesNotFound {
    type: "linkTypesNotFound";
    linkTypesNotFound: LinkTypesNotFoundError;
}
interface LinkTypeError_linkTypeRidsNotFound {
    type: "linkTypeRidsNotFound";
    linkTypeRidsNotFound: LinkTypeRidsNotFoundError;
}
interface LinkTypeError_referencedObjectTypesNotFound {
    type: "referencedObjectTypesNotFound";
    referencedObjectTypesNotFound: ReferencedObjectTypesNotFoundError;
}
interface LinkTypeError_referencedLinkTypesNotFound {
    type: "referencedLinkTypesNotFound";
    referencedLinkTypesNotFound: ReferencedLinkTypesNotFoundError;
}
interface LinkTypeError_deletedObjectsStillInUse {
    type: "deletedObjectsStillInUse";
    deletedObjectsStillInUse: DeletedObjectTypesStillInUseError;
}
interface LinkTypeError_deletedLinkTypesStillInUse {
    type: "deletedLinkTypesStillInUse";
    deletedLinkTypesStillInUse: DeletedLinkTypesStillInUseError;
}
type LinkTypeError = LinkTypeError_linkTypesAlreadyExist | LinkTypeError_linkTypesNotFound | LinkTypeError_linkTypeRidsNotFound | LinkTypeError_referencedObjectTypesNotFound | LinkTypeError_referencedLinkTypesNotFound | LinkTypeError_deletedObjectsStillInUse | LinkTypeError_deletedLinkTypesStillInUse;
/**
 * This is a human readable id for the LinkType. LinkTypeIds can be made up of lower case letters,
 * numbers and dashes, but they should start with an alphabet. The LinkTypeId is immutable for now.
 * To change the LinkTypeId you need to delete the LinkType and re-create it. In future we plan to
 * make it mutable, hence you should use the LinkTypeRid for cases where you need to rely on an
 * immutable identifier.
 *
 * Please note that this is not safe to log as it is user-inputted and may contain sensitive information.
 */
type LinkTypeId = string;
interface LinkTypeIdentifier_linkTypeId {
    type: "linkTypeId";
    linkTypeId: LinkTypeId;
}
interface LinkTypeIdentifier_linkTypeRid {
    type: "linkTypeRid";
    linkTypeRid: LinkTypeRid;
}
/**
 * Union type to represent the different identifiers for LinkType(s) in load requests.
 */
type LinkTypeIdentifier = LinkTypeIdentifier_linkTypeId | LinkTypeIdentifier_linkTypeRid;
/**
 * ResourceIdentifier for the link type input manager.
 */
type LinkTypeInputManagerRid = string;
/**
 * An input spec for a link type input.
 */
interface LinkTypeInputSpec {
    linkTypeRid: LinkTypeRid;
    ontologyRidAndBranch: OntologyRidAndBranch;
}
/**
 * Request to load an LinkType.
 */
interface LinkTypeLoadRequest {
    identifier: LinkTypeIdentifier;
    versionReference?: VersionReference | null | undefined;
}
/**
 * Response to LinkTypeLoadRequest.
 */
interface LinkTypeLoadResponse {
    datasources: Array<ManyToManyLinkTypeDatasource>;
    entityMetadata?: LinkTypeEntityMetadata | null | undefined;
    linkType: LinkType;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface LinkTypeMetadata {
    apiName?: ObjectTypeFieldApiName | null | undefined;
    displayMetadata: LinkTypeDisplayMetadata;
    typeClasses: Array<TypeClass>;
}
/**
 * ResourceIdentifier for the link type metadata input manager.
 */
type LinkTypeMetadataInputManagerRid = string;
interface LinkTypePeeringMetadata_v1 {
    type: "v1";
    v1: LinkTypePeeringMetadataV1;
}
type LinkTypePeeringMetadata = LinkTypePeeringMetadata_v1;
interface LinkTypePeeringMetadataV1 {
    enabled: boolean;
    peeringRid: LinkTypePeeringRid;
}
/**
 * An identifier for a peered LinkType used for establishing a mapping between local LinkTypes and remote
 * LinkTypes for Peering. Before a link can be peered, a user must configure a mapping between the local and
 * remote LinkType for that link. If the local and remote LinkType share the same LinkTypePeeringRid, Peering
 * will suggest forming a mapping between those types.
 *
 * LinkTypePeeringRids are preserved in Marketplace blocks, so LinkTypes installed from the same Marketplace
 * definition on different stacks will share a LinkTypePeeringRid if the original LinkType packaged in
 * Marketplace has a LinkTypePeeringRid.
 */
type LinkTypePeeringRid = string;
/**
 * An rid identifying the LinkType. This rid is generated randomly and is safe for logging purposes. The
 * LinkTypeRid for a LinkType is immutable. If a LinkType is deleted and recreated with the same LinkTypeId,
 * the LinkTypeRid will be different.
 */
type LinkTypeRid = string;
/**
 * The LinkTypesRids were not found in the current ontology.
 */
interface LinkTypeRidsNotFoundError {
    linkTypeRids: Array<LinkTypeRid>;
}
/**
 * There was an attempt to create LinkTypes that already exist.
 */
interface LinkTypesAlreadyExistError {
    linkTypeIds: Array<LinkTypeId>;
}
/**
 * The LinkTypes were not found.
 */
interface LinkTypesNotFoundError {
    linkTypeIds: Array<LinkTypeId>;
}
interface LinkTypesSummary {
    maximumNumberOfManyToManyLinkTypes: number;
    maximumNumberOfOneToManyLinkTypes: number;
    visibleEntities: number;
}
interface LinkTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalLinkTypeStatus;
}
interface LinkTypeStatus_active {
    type: "active";
    active: ActiveLinkTypeStatus;
}
interface LinkTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedLinkTypeStatus;
}
interface LinkTypeStatus_example {
    type: "example";
    example: ExampleLinkTypeStatus;
}
/**
 * The status to indicate whether the LinkType is either Experimental, Active, Deprecated, or Example.
 */
type LinkTypeStatus = LinkTypeStatus_experimental | LinkTypeStatus_active | LinkTypeStatus_deprecated | LinkTypeStatus_example;
interface LinkTypeUpdatedEvent {
    linkTypeRid: LinkTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
type LiveDeploymentRid = string;
type LmsEmbeddingModel = "OPENAI_TEXT_EMBEDDING_ADA_002" | "TEXT_EMBEDDING_3_SMALL" | "SNOWFLAKE_ARCTIC_EMBED_M" | "INSTRUCTOR_LARGE" | "BGE_BASE_EN_V1_5";
interface LoadActionTypesFromOntologyRequest {
    actionTypes: Array<OntologyActionTypeLoadRequest>;
}
interface LoadActionTypesFromOntologyResponse {
    actionTypes: Array<ActionType | null | undefined>;
}
/**
 * A type to represent the request to load all the viewable ActionTypes in an Ontology.
 */
interface LoadAllActionTypesFromOntologyRequest {
    ontologyVersion?: OntologyVersion | null | undefined;
}
/**
 * A single entry in the LoadAllActionTypesPageResponse.
 */
interface LoadAllActionTypesPageItem {
    actionType: ActionType;
}
/**
 * Request to load a page of all ActionTypes visible to the user in an Ontology.
 */
interface LoadAllActionTypesPageRequest {
    pageSizeLimit: number;
    pageToken?: LoadAllActionTypesPageToken | null | undefined;
}
/**
 * Response to LoadAllActionTypesPageRequest.
 */
interface LoadAllActionTypesPageResponse {
    actionTypes: Array<LoadAllActionTypesPageItem>;
    nextPageToken?: LoadAllActionTypesPageToken | null | undefined;
}
/**
 * A paging token used to retrieve further pages of a load response. Clients shouldn't make any assumptions about
 * the content of the token and it should not be parsed/modified. This is safe to log.
 */
type LoadAllActionTypesPageToken = string;
interface LoadAllInterfaceTypesPageItem {
    interfaceType: InterfaceType;
}
/**
 * Request to load a page of all interfaces visible to the user in an ontology.
 */
interface LoadAllInterfaceTypesPageRequest {
    pageSize?: number | null | undefined;
    pageToken?: LoadAllInterfaceTypesPageToken | null | undefined;
}
interface LoadAllInterfaceTypesPageResponse {
    interfaceTypes: Array<LoadAllInterfaceTypesPageItem>;
    nextPageToken?: LoadAllInterfaceTypesPageToken | null | undefined;
}
/**
 * A paging token used to retrieve further pages of a load response. Clients should not make any assumptions
 * about the content of the token and it should not be parsed/modified. This is safe to log.
 */
type LoadAllInterfaceTypesPageToken = string;
/**
 * Request to load a page of all ObjectTypes visible to the user in an Ontology.
 */
interface LoadAllObjectTypesFromOntologyPageRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
    ontologyRid: OntologyRid;
    pageSizeLimit: number;
    pageToken?: LoadAllObjectTypesPageToken | null | undefined;
    versionReference: VersionReference;
}
/**
 * Response to LoadAllObjectTypesPageRequest.
 */
interface LoadAllObjectTypesFromOntologyPageResponse {
    nextPageToken?: LoadAllObjectTypesPageToken | null | undefined;
    objectTypes: Array<LoadAllObjectTypesPageItem>;
}
/**
 * A single entry in the LoadAllObjectTypesPageResponse.
 */
interface LoadAllObjectTypesPageItem {
    objectType: ObjectType;
}
/**
 * Request to load a page of all ObjectTypes visible to the user in an Ontology.
 */
interface LoadAllObjectTypesPageRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
    pageSizeLimit: number;
    pageToken?: LoadAllObjectTypesPageToken | null | undefined;
}
/**
 * Response to LoadAllObjectTypesPageRequest.
 */
interface LoadAllObjectTypesPageResponse {
    nextPageToken?: LoadAllObjectTypesPageToken | null | undefined;
    objectTypes: Array<LoadAllObjectTypesPageItem>;
}
/**
 * A paging token used to retrieve further pages of a load response. Clients shouldn't make any assumptions about
 * the content of the token and it should not be parsed/modified. This is safe to log.
 */
type LoadAllObjectTypesPageToken = string;
/**
 * Request to load all visible Ontologies.
 */
interface LoadAllOntologiesRequest {
    includeEmptyDefaultOntology?: boolean | null | undefined;
}
/**
 * Response to LoadAllOntologiesRequest. This includes information
 * about the Ontologies where the user has the "ontology:view-ontology"
 * permission on the OntologyRid.
 */
interface LoadAllOntologiesResponse {
    ontologies: Record<OntologyRid, OntologyInformation>;
}
/**
 * A single entry in the LoadAllSharedPropertyTypesPageResponse.
 */
interface LoadAllSharedPropertyTypesPageItem {
    sharedPropertyType: SharedPropertyType;
}
/**
 * Request to load a page of all SharedPropertyTypes visible to the user in an Ontology.
 */
interface LoadAllSharedPropertyTypesPageRequest {
    pageSize?: number | null | undefined;
    pageToken?: LoadAllSharedPropertyTypesPageToken | null | undefined;
}
/**
 * Response to LoadAllSharedPropertyTypesPageRequest.
 */
interface LoadAllSharedPropertyTypesPageResponse {
    nextPageToken?: LoadAllSharedPropertyTypesPageToken | null | undefined;
    sharedPropertyTypes: Array<LoadAllSharedPropertyTypesPageItem>;
}
/**
 * A paging token used to retrieve further pages of a load response. Clients shouldnt make any assumptions about
 * the content of the token and it should not be parsed/modified. This is safe to log.
 */
type LoadAllSharedPropertyTypesPageToken = string;
interface LoadAllTypeGroupsPageItem {
    numberOfActionTypes?: number | null | undefined;
    numberOfObjectTypes?: number | null | undefined;
    typeGroup: TypeGroup;
}
/**
 * Request to load a page of all type groups visible to the user in an ontology.
 */
interface LoadAllTypeGroupsPageRequest {
    includeObjectTypeCount?: boolean | null | undefined;
    includeTypeGroupEntitiesCount?: boolean | null | undefined;
    pageSize?: number | null | undefined;
    pageToken?: LoadAllTypeGroupsPageToken | null | undefined;
}
interface LoadAllTypeGroupsPageResponse {
    nextPageToken?: LoadAllTypeGroupsPageToken | null | undefined;
    typeGroups: Array<LoadAllTypeGroupsPageItem>;
}
/**
 * A paging token used to retrieve further pages of a load response. Clients should not make any assumptions
 * about the content of the token and it should not be parsed/modified. This is safe to log.
 */
type LoadAllTypeGroupsPageToken = string;
interface LogicRule_addObjectRule {
    type: "addObjectRule";
    addObjectRule: AddObjectRule;
}
interface LogicRule_addOrModifyObjectRule {
    type: "addOrModifyObjectRule";
    addOrModifyObjectRule: AddOrModifyObjectRule;
}
interface LogicRule_addOrModifyObjectRuleV2 {
    type: "addOrModifyObjectRuleV2";
    addOrModifyObjectRuleV2: AddOrModifyObjectRuleV2;
}
interface LogicRule_modifyObjectRule {
    type: "modifyObjectRule";
    modifyObjectRule: ModifyObjectRule;
}
interface LogicRule_deleteObjectRule {
    type: "deleteObjectRule";
    deleteObjectRule: DeleteObjectRule;
}
interface LogicRule_addInterfaceRule {
    type: "addInterfaceRule";
    addInterfaceRule: AddInterfaceRule;
}
interface LogicRule_modifyInterfaceRule {
    type: "modifyInterfaceRule";
    modifyInterfaceRule: ModifyInterfaceRule;
}
interface LogicRule_addLinkRule {
    type: "addLinkRule";
    addLinkRule: AddLinkRule;
}
interface LogicRule_deleteLinkRule {
    type: "deleteLinkRule";
    deleteLinkRule: DeleteLinkRule;
}
interface LogicRule_addInterfaceLinkRule {
    type: "addInterfaceLinkRule";
    addInterfaceLinkRule: AddInterfaceLinkRule;
}
interface LogicRule_deleteInterfaceLinkRule {
    type: "deleteInterfaceLinkRule";
    deleteInterfaceLinkRule: DeleteInterfaceLinkRule;
}
interface LogicRule_functionRule {
    type: "functionRule";
    functionRule: FunctionRule;
}
interface LogicRule_batchedFunctionRule {
    type: "batchedFunctionRule";
    batchedFunctionRule: BatchedFunctionRule;
}
type LogicRule = LogicRule_addObjectRule | LogicRule_addOrModifyObjectRule | LogicRule_addOrModifyObjectRuleV2 | LogicRule_modifyObjectRule | LogicRule_deleteObjectRule | LogicRule_addInterfaceRule | LogicRule_modifyInterfaceRule | LogicRule_addLinkRule | LogicRule_deleteLinkRule | LogicRule_addInterfaceLinkRule | LogicRule_deleteInterfaceLinkRule | LogicRule_functionRule | LogicRule_batchedFunctionRule;
interface LogicRuleModification_addObjectRule {
    type: "addObjectRule";
    addObjectRule: AddObjectRuleModification;
}
interface LogicRuleModification_addOrModifyObjectRule {
    type: "addOrModifyObjectRule";
    addOrModifyObjectRule: AddOrModifyObjectRuleModification;
}
interface LogicRuleModification_addOrModifyObjectRuleV2 {
    type: "addOrModifyObjectRuleV2";
    addOrModifyObjectRuleV2: AddOrModifyObjectRuleModificationV2;
}
interface LogicRuleModification_modifyObjectRule {
    type: "modifyObjectRule";
    modifyObjectRule: ModifyObjectRuleModification;
}
interface LogicRuleModification_deleteObjectRule {
    type: "deleteObjectRule";
    deleteObjectRule: DeleteObjectRule;
}
interface LogicRuleModification_addInterfaceRule {
    type: "addInterfaceRule";
    addInterfaceRule: AddInterfaceRuleModification;
}
interface LogicRuleModification_modifyInterfaceRule {
    type: "modifyInterfaceRule";
    modifyInterfaceRule: ModifyInterfaceRuleModification;
}
interface LogicRuleModification_addLinkRule {
    type: "addLinkRule";
    addLinkRule: AddLinkRule;
}
interface LogicRuleModification_deleteLinkRule {
    type: "deleteLinkRule";
    deleteLinkRule: DeleteLinkRule;
}
interface LogicRuleModification_addInterfaceLinkRule {
    type: "addInterfaceLinkRule";
    addInterfaceLinkRule: AddInterfaceLinkRuleModification;
}
interface LogicRuleModification_deleteInterfaceLinkRule {
    type: "deleteInterfaceLinkRule";
    deleteInterfaceLinkRule: DeleteInterfaceLinkRuleModification;
}
interface LogicRuleModification_functionRule {
    type: "functionRule";
    functionRule: FunctionRuleModification;
}
interface LogicRuleModification_batchedFunctionRule {
    type: "batchedFunctionRule";
    batchedFunctionRule: BatchedFunctionRuleModification;
}
type LogicRuleModification = LogicRuleModification_addObjectRule | LogicRuleModification_addOrModifyObjectRule | LogicRuleModification_addOrModifyObjectRuleV2 | LogicRuleModification_modifyObjectRule | LogicRuleModification_deleteObjectRule | LogicRuleModification_addInterfaceRule | LogicRuleModification_modifyInterfaceRule | LogicRuleModification_addLinkRule | LogicRuleModification_deleteLinkRule | LogicRuleModification_addInterfaceLinkRule | LogicRuleModification_deleteInterfaceLinkRule | LogicRuleModification_functionRule | LogicRuleModification_batchedFunctionRule;
interface LogicRuleValue_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface LogicRuleValue_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface LogicRuleValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface LogicRuleValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValue;
}
interface LogicRuleValue_currentUser {
    type: "currentUser";
    currentUser: CurrentUser;
}
interface LogicRuleValue_currentTime {
    type: "currentTime";
    currentTime: CurrentTime;
}
interface LogicRuleValue_uniqueIdentifier {
    type: "uniqueIdentifier";
    uniqueIdentifier: UniqueIdentifier;
}
interface LogicRuleValue_synchronousWebhookOutput {
    type: "synchronousWebhookOutput";
    synchronousWebhookOutput: WebhookOutputParamName;
}
/**
 * These are the possible values that can be passed into LogicRules as well as Notification and Webhook side
 * effects.
 */
type LogicRuleValue = LogicRuleValue_parameterId | LogicRuleValue_staticValue | LogicRuleValue_objectParameterPropertyValue | LogicRuleValue_interfaceParameterPropertyValue | LogicRuleValue_currentUser | LogicRuleValue_currentTime | LogicRuleValue_uniqueIdentifier | LogicRuleValue_synchronousWebhookOutput;
interface LogicRuleValueModification_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface LogicRuleValueModification_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface LogicRuleValueModification_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface LogicRuleValueModification_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValueModification;
}
interface LogicRuleValueModification_currentUser {
    type: "currentUser";
    currentUser: CurrentUser;
}
interface LogicRuleValueModification_currentTime {
    type: "currentTime";
    currentTime: CurrentTime;
}
interface LogicRuleValueModification_uniqueIdentifier {
    type: "uniqueIdentifier";
    uniqueIdentifier: UniqueIdentifier;
}
interface LogicRuleValueModification_synchronousWebhookOutput {
    type: "synchronousWebhookOutput";
    synchronousWebhookOutput: WebhookOutputParamName;
}
/**
 * These are the possible values that can be passed into LogicRules as well as Notification and Webhook side
 * effects.
 */
type LogicRuleValueModification = LogicRuleValueModification_parameterId | LogicRuleValueModification_staticValue | LogicRuleValueModification_objectParameterPropertyValue | LogicRuleValueModification_interfaceParameterPropertyValue | LogicRuleValueModification_currentUser | LogicRuleValueModification_currentTime | LogicRuleValueModification_uniqueIdentifier | LogicRuleValueModification_synchronousWebhookOutput;
interface LongPropertyType {
}
interface LongTypeDataConstraints_range$1 {
    type: "range";
    range: LongTypeRangeConstraint$1;
}
interface LongTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfLongTypeConstraint$1;
}
type LongTypeDataConstraints$1 = LongTypeDataConstraints_range$1 | LongTypeDataConstraints_oneOf$1;
type LongTypeDataValue$1 = number;
interface LongTypeRangeConstraint$1 {
    max?: LongTypeDataValue$1 | null | undefined;
    min?: LongTypeDataValue$1 | null | undefined;
}
/**
 * All mandatory marking properties linked to this datasource must only contain values within this set. It must have at least one marking specified. Note that Organization MarkingIds are not allowed in this set.
 */
interface MandatoryMarkingConstraint {
    markingIds: Array<MarkingId>;
}
interface ManyToManyJoinDefinition {
    editsConfiguration?: EditsConfiguration | null | undefined;
    joinTableDatasetRid: string;
    joinTableWritebackDatasetRid?: string | null | undefined;
    sourceIdColumnName: string;
    sourceObjectTypeId: ObjectTypeId;
    targetIdColumnName: string;
    targetObjectTypeId: ObjectTypeId;
}
interface ManyToManyLinkDefinition {
    objectTypeAPrimaryKeyPropertyMapping: Record<PropertyTypeRid, PropertyTypeRid>;
    objectTypeAToBLinkMetadata: LinkTypeMetadata;
    objectTypeBPrimaryKeyPropertyMapping: Record<PropertyTypeRid, PropertyTypeRid>;
    objectTypeBToALinkMetadata: LinkTypeMetadata;
    objectTypeRidA: ObjectTypeRid;
    objectTypeRidB: ObjectTypeRid;
    peeringMetadata?: LinkTypePeeringMetadata | null | undefined;
}
/**
 * Many to many link type datasource that is backed by a dataset in foundry, uniquely identified by its rid and
 * branch.
 */
interface ManyToManyLinkTypeDatasetDatasource {
    branchId: BranchId;
    datasetRid: DatasetRid;
    objectTypeAPrimaryKeyMapping: Record<PropertyTypeRid, ColumnName>;
    objectTypeBPrimaryKeyMapping: Record<PropertyTypeRid, ColumnName>;
    writebackDatasetRid?: DatasetRid | null | undefined;
}
interface ManyToManyLinkTypeDatasource {
    datasource: ManyToManyLinkTypeDatasourceDefinition;
    editsConfiguration?: EditsConfiguration | null | undefined;
    redacted?: boolean | null | undefined;
    rid: DatasourceRid;
}
interface ManyToManyLinkTypeDatasourceDefinition_dataset {
    type: "dataset";
    dataset: ManyToManyLinkTypeDatasetDatasource;
}
interface ManyToManyLinkTypeDatasourceDefinition_stream {
    type: "stream";
    stream: ManyToManyLinkTypeStreamDatasource;
}
/**
 * Wrapper type for all supported many to many link type datasource types.
 */
type ManyToManyLinkTypeDatasourceDefinition = ManyToManyLinkTypeDatasourceDefinition_dataset | ManyToManyLinkTypeDatasourceDefinition_stream;
/**
 * Many to many link type datasource that is backed by a stream, uniquely identified by its StreamLocator.
 */
interface ManyToManyLinkTypeStreamDatasource {
    objectTypeAPrimaryKeyMapping: Record<PropertyTypeRid, ColumnName>;
    objectTypeBPrimaryKeyMapping: Record<PropertyTypeRid, ColumnName>;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamLocator;
}
interface MarkingFilter_markingTypes {
    type: "markingTypes";
    markingTypes: MarkingTypesFilter;
}
/**
 * A filter on what user markings to process in the Marking condition.
 */
type MarkingFilter = MarkingFilter_markingTypes;
/**
 * A Cbac, Mandatory or Organization marking ID
 */
type MarkingId = string;
interface MarkingPropertyType {
    markingType: MarkingType;
}
/**
 * True if the user satisfies the markings represented by the value field.
 * This follows com.palantir.gps.api.policy.MarkingsCondition
 */
interface MarkingsCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    filters: MarkingFilter;
    value: ConditionValue;
}
/**
 * True if the user satisfies the markings represented by the value field.
 * This follows com.palantir.gps.api.policy.MarkingsCondition
 */
interface MarkingsConditionModification {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    filters: MarkingFilter;
    value: ConditionValueModification;
}
/**
 * MarkingSubtype specifies the marking type of this marking parameter
 */
interface MarkingSubtype {
    markingType: MarkingType;
}
/**
 * This follows com.palantir.gps.api.policy.MarkingType
 */
type MarkingType = "MANDATORY" | "CBAC";
/**
 * The type of user markings to use in the markings condition check. This can be the users CBAC or
 * MANDATORY markings.
 */
interface MarkingTypesFilter {
    markingTypes: Array<MarkingType>;
}
/**
 * An rid identifying a specific item within a media set. This rid is a randomly generated identifier and is
 * safe to log.
 */
type MediaItemRid = string;
/**
 * This follows com.palantir.media.MediaReference
 */
interface MediaReferencePropertyType {
}
/**
 * An rid identifying a media set branch. This rid is a randomly generated identifier and is safe to log.
 */
type MediaSetBranchRid = string;
/**
 * An rid identifying a media set. This rid is a randomly generated identifier and is safe to log.
 */
type MediaSetRid = string;
/**
 * A locator for a media set view. This is a combination of the media set rid, view rid and the branch rid.
 */
interface MediaSetViewLocator {
    mediaSetBranchRid: MediaSetBranchRid;
    mediaSetRid: MediaSetRid;
    mediaSetViewRid: MediaSetViewRid;
}
/**
 * An rid identifying a media set view. This rid is a randomly generated identifier and is safe to log.
 */
type MediaSetViewRid = string;
interface MediaSourceRid_mediaSetRid {
    type: "mediaSetRid";
    mediaSetRid: MediaSetRid;
}
interface MediaSourceRid_datasetRid {
    type: "datasetRid";
    datasetRid: DatasetRid;
}
/**
 * A rid identifying the resource backing a media reference.
 */
type MediaSourceRid = MediaSourceRid_mediaSetRid | MediaSourceRid_datasetRid;
interface MissingAffectedObjectTypesForFunctionRule {
    functionRid: FunctionRid;
    functionVersion: SemanticFunctionVersion;
    missingAffectedObjectTypes: Array<ObjectTypeRid>;
}
interface ModifyInterfaceRule {
    interfaceObjectToModify: ParameterId;
    sharedPropertyValues: Record<SharedPropertyTypeRid, LogicRuleValue>;
    structFieldValues: Record<SharedPropertyTypeRid, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface ModifyInterfaceRuleModification {
    interfaceObjectToModify: ParameterId;
    sharedPropertyTypeLogicRuleValueModifications: Array<SharedPropertyTypeLogicRuleValueModification>;
    sharedPropertyTypeStructFieldLogicRuleValueModifications: Array<SharedPropertyTypeStructFieldLogicRuleValueModification>;
}
interface ModifyObjectRule {
    objectToModify: ParameterId;
    propertyValues: Record<PropertyTypeId, LogicRuleValue>;
    structFieldValues: Record<PropertyTypeId, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface ModifyObjectRuleModification {
    objectToModify: ParameterId;
    propertyValues: Record<PropertyTypeId, LogicRuleValueModification>;
    structFieldValues: Record<PropertyTypeId, Record<ObjectTypeFieldApiName, StructFieldLogicRuleValueModification>>;
    structFieldValuesV2: Record<PropertyTypeId, Array<StructFieldLogicRuleValueMappingModification>>;
}
/**
 * ResourceIdentifier for a Workshop Module.
 */
type ModuleRid = string;
interface MultipassUserFilter_groupFilter {
    type: "groupFilter";
    groupFilter: MultipassUserInGroupFilter;
}
type MultipassUserFilter = MultipassUserFilter_groupFilter;
interface MultipassUserFilterModification_groupFilter {
    type: "groupFilter";
    groupFilter: MultipassUserInGroupFilterModification;
}
type MultipassUserFilterModification = MultipassUserFilterModification_groupFilter;
interface MultipassUserInGroupFilter {
    groupId: ConditionValue;
}
interface MultipassUserInGroupFilterModification {
    groupId: ConditionValueModification;
}
interface MustBeEmpty {
}
interface NestedStructFieldApiNameMapping {
    apiName: ObjectTypeFieldApiName;
    mappings: Record<StructFieldName, NestedStructFieldApiNameMapping>;
}
/**
 * A URL target for a newly created object.
 */
interface NewObjectUrlTarget {
    keys: Record<PropertyId, LogicRuleValue>;
    objectTypeId: ObjectTypeId;
}
/**
 * A URL target for a newly created object.
 */
interface NewObjectUrlTargetModification {
    keys: Record<PropertyId, LogicRuleValueModification>;
    objectTypeId: ObjectTypeId;
}
interface NoneEntityProvenance {
}
/**
 * Some ParameterPrefill(s) are referencing ParameterId(s) that do not exist on the ActionType.
 */
interface NonExistentParametersUsedInParameterPrefillError {
    actionTypeIdentifier: ActionTypeIdentifier;
    parameterIds: Array<ParameterId>;
}
/**
 * How to infer series values between adjacent data points.
 */
type NonNumericInternalInterpolation = "NEAREST" | "PREVIOUS" | "NEXT" | "NONE";
/**
 * Configuration for non-numeric series.
 */
interface NonNumericSeriesValueMetadata {
    defaultInternalInterpolation: PropertyTypeReferenceOrNonNumericInternalInterpolation;
}
/**
 * The unit to accompany the non-numeric value of a Time Dependent property. Can be provided by a property or a
 * user-inputted constant.
 */
interface NonNumericSeriesValueUnit {
    customUnit: PropertyTypeReferenceOrStringConstant;
}
/**
 * All data will be retained.
 */
interface NoRetentionPolicy {
}
/**
 * This indicates that the StringPropertyType should not be analyzed for full text search. Only
 * exact match queries can be made on such StringPropertyType(s).
 */
interface NotAnalyzedAnalyzer {
}
interface NotCondition {
    condition: Condition;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface NotConditionModification {
    condition: ConditionModification;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface NotepadReference {
    notepadRid: NotepadRid;
}
/**
 * The rid for a Notepad document.
 */
type NotepadRid = string;
/**
 * The representation of a notification's recipient.
 */
interface NotificationRecipient {
}
interface NotificationResultTypeLink {
    message: string;
    url: UrlTarget;
}
interface NotificationResultTypeLinkModification {
    message: string;
    url: UrlTargetModification;
}
interface NotificationTemplateInputValue_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValue;
}
interface NotificationTemplateInputValue_recipientValue {
    type: "recipientValue";
    recipientValue: UserValue;
}
interface NotificationTemplateInputValue_actionTriggererValue {
    type: "actionTriggererValue";
    actionTriggererValue: UserValue;
}
/**
 * All the types that can be used as a value for a Notification template's inputs.
 */
type NotificationTemplateInputValue = NotificationTemplateInputValue_logicRuleValue | NotificationTemplateInputValue_recipientValue | NotificationTemplateInputValue_actionTriggererValue;
interface NotificationTemplateInputValueModification_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValueModification;
}
interface NotificationTemplateInputValueModification_recipientValue {
    type: "recipientValue";
    recipientValue: UserValue;
}
interface NotificationTemplateInputValueModification_actionTriggererValue {
    type: "actionTriggererValue";
    actionTriggererValue: UserValue;
}
/**
 * All the types that can be used as a value for a Notification template's inputs.
 */
type NotificationTemplateInputValueModification = NotificationTemplateInputValueModification_logicRuleValue | NotificationTemplateInputValueModification_recipientValue | NotificationTemplateInputValueModification_actionTriggererValue;
/**
 * Configure standard rendering of numbers, informed by the locale. Heavily inspired by browser Intl APIs.
 */
interface NumberFormatBase {
    convertNegativeToParenthesis?: boolean | null | undefined;
    maximumFractionDigits?: number | null | undefined;
    maximumSignificantDigits?: number | null | undefined;
    minimumFractionDigits?: number | null | undefined;
    minimumIntegerDigits?: number | null | undefined;
    minimumSignificantDigits?: number | null | undefined;
    notation?: NumberFormatNotation | null | undefined;
    roundingMode?: NumberRoundingMode | null | undefined;
    useGrouping?: boolean | null | undefined;
}
/**
 * Display the value as basis points, multiplying by 10,000 and append "bps" suffix. For example, 0.01 will be displayed as "100bps".
 */
interface NumberFormatBasisPoint {
    base: NumberFormatBase;
}
/**
 * Scale the numeric value to billions and append a suffix. For example, 1500000000 will be displayed as "1.5B".
 */
interface NumberFormatBillions {
    base: NumberFormatBase;
}
/**
 * Note that non-visual features e.g. sorting & histograms, are not guaranteed to be currency-aware. They can
 * group the same number together even if they have different currencies.
 */
interface NumberFormatCurrency {
    base: NumberFormatBase;
    currencyCode: PropertyTypeReferenceOrStringConstant;
    style: NumberFormatCurrencyStyle;
}
/**
 * Currency rendering hints.
 *
 * - STANDARD: Render the number as-is
 * - COMPACT: Locale/currency-aware compact notation (e.g. 42000000$ -> 42M$)
 */
type NumberFormatCurrencyStyle = "STANDARD" | "COMPACT";
/**
 * For units that aren't accepted by NumberFormatUnit.
 * No auto-conversion will ever be attempted.
 * This is mostly a label providing instruction on which values can share an axis.
 */
interface NumberFormatCustomUnit {
    base: NumberFormatBase;
    unit: PropertyTypeReferenceOrStringConstant;
}
/**
 * Formatter applied to numeric properties representing time durations.
 */
interface NumberFormatDuration {
    base: NumberFormatBase;
    baseValue: DurationBaseValue;
    formatStyle: DurationFormatStyle;
    precision?: DurationPrecision | null | undefined;
}
/**
 * Scale the numeric value to millions and append a suffix. For example, 1500000 will be displayed as "1.5M".
 */
interface NumberFormatMillions {
    base: NumberFormatBase;
}
type NumberFormatNotation = "STANDARD" | "SCIENTIFIC" | "ENGINEERING" | "COMPACT";
/**
 * Map integer to human-interpretable values. For example:
 * - 0 -> Not assigned
 * - 1 -> Assigned
 * - 2 -> Closed
 *
 * Ontology design note: string enums are preferable. Like any formatter that changes the rendered values, this
 * can behave strangely for certain features (e.g. sorting won't be alphabetic, but on the underlying ordering).
 */
interface NumberFormatOrdinal {
    values: Record<number, string>;
}
/**
 * Render number as a percentage. Will multiply the number by 100 before displaying & attach a "%" suffix. For
 * example, `0.15` corresponds to `15%`.
 */
interface NumberFormatPercentage {
    base: NumberFormatBase;
}
/**
 * Render number as a per mille. Will multiply the number by 1000 before displaying & attach a "‰" suffix. For
 * example, `0.015` corresponds to `15‰`.
 */
interface NumberFormatPerMille {
    base: NumberFormatBase;
}
/**
 * Consider using currency/unit instead of this formatter.
 *
 * Attach an arbitrary constant pre/post-fix.
 */
interface NumberFormatPrePostFix {
    base: NumberFormatBase;
    prePostFix: PrePostFix;
}
interface NumberFormatter_base {
    type: "base";
    base: NumberFormatBase;
}
interface NumberFormatter_percentage {
    type: "percentage";
    percentage: NumberFormatPercentage;
}
interface NumberFormatter_perMille {
    type: "perMille";
    perMille: NumberFormatPerMille;
}
interface NumberFormatter_ordinal {
    type: "ordinal";
    ordinal: NumberFormatOrdinal;
}
interface NumberFormatter_currency {
    type: "currency";
    currency: NumberFormatCurrency;
}
interface NumberFormatter_unit {
    type: "unit";
    unit: NumberFormatUnit;
}
interface NumberFormatter_customUnit {
    type: "customUnit";
    customUnit: NumberFormatCustomUnit;
}
interface NumberFormatter_prePost {
    type: "prePost";
    prePost: NumberFormatPrePostFix;
}
interface NumberFormatter_duration {
    type: "duration";
    duration: NumberFormatDuration;
}
interface NumberFormatter_thousands {
    type: "thousands";
    thousands: NumberFormatThousands;
}
interface NumberFormatter_millions {
    type: "millions";
    millions: NumberFormatMillions;
}
interface NumberFormatter_billions {
    type: "billions";
    billions: NumberFormatBillions;
}
interface NumberFormatter_basisPoint {
    type: "basisPoint";
    basisPoint: NumberFormatBasisPoint;
}
type NumberFormatter = NumberFormatter_base | NumberFormatter_percentage | NumberFormatter_perMille | NumberFormatter_ordinal | NumberFormatter_currency | NumberFormatter_unit | NumberFormatter_customUnit | NumberFormatter_prePost | NumberFormatter_duration | NumberFormatter_thousands | NumberFormatter_millions | NumberFormatter_billions | NumberFormatter_basisPoint;
/**
 * Scale the numeric value to thousands and append a suffix. For example, 1500 will be displayed as "1.5K".
 */
interface NumberFormatThousands {
    base: NumberFormatBase;
}
/**
 * Note that this formatter breaks e.g. sorting features if used in combination with auto-conversion.
 */
interface NumberFormatUnit {
    base: NumberFormatBase;
    unit: PropertyTypeReferenceOrStringConstant;
}
/**
 * Specifies how to round numbers. Only applicable when needing to round decimal places
 */
type NumberRoundingMode = "CEIL" | "FLOOR" | "ROUND_CLOSEST";
/**
 * How to infer series values between adjacent data points.
 */
type NumericInternalInterpolation = "LINEAR" | "NEAREST" | "PREVIOUS" | "NEXT" | "NONE";
/**
 * Configuration for a sensor time series property that can contain either numeric or non-numeric data at the
 * sensor level.
 */
interface NumericOrNonNumericSeriesValueMetadata {
}
/**
 * Configuration for a time series property that can contain either numeric or non-numeric data. A boolean property
 * reference is required to determine if the series is numeric or non-numeric.
 */
interface NumericOrNonNumericSeriesValueMetadataV2 {
    isNonNumericPropertyTypeId: PropertyTypeId;
}
/**
 * Configuration for numeric series.
 */
interface NumericSeriesValueMetadata {
    defaultInternalInterpolation: PropertyTypeReferenceOrNumericInternalInterpolation;
}
interface NumericSeriesValueUnit_standardUnit {
    type: "standardUnit";
    standardUnit: NumberFormatUnit;
}
interface NumericSeriesValueUnit_customUnit {
    type: "customUnit";
    customUnit: NumberFormatCustomUnit;
}
/**
 * The unit to accompany the numeric value of a Time Dependent property. Can be a standardized NumberFormatUnit
 * or a user-inputted NumberFormatCustomUnit for Numeric series. Either can be provided by a property or a
 * user-inputted constant.
 */
type NumericSeriesValueUnit = NumericSeriesValueUnit_standardUnit | NumericSeriesValueUnit_customUnit;
/**
 * Identifier for an ObjectDb
 *
 * The maximum size of the objects database rid is 80 bytes, when encoded in UTF-8.
 */
type ObjectDbRid = string;
/**
 * Identifier for a sync to an ObjectDb
 */
type ObjectDbSyncRid = string;
interface ObjectDisplayMetadata {
    displayName?: string | null | undefined;
    groupDisplayName?: string | null | undefined;
    icon?: IconReference | null | undefined;
    pluralDisplayName?: string | null | undefined;
    visibility?: Visibility | null | undefined;
}
interface ObjectMonitoringFrontendConsumer {
}
interface ObjectParameterPropertyValue {
    parameterId: ParameterId;
    propertyTypeId: PropertyTypeId;
}
/**
 * Reference to a struct field of a struct property.
 */
interface ObjectParameterStructFieldValue {
    parameterId: ParameterId;
    propertyTypeId: PropertyTypeId;
    structFieldRid: StructFieldRid;
}
interface ObjectParameterStructFieldValueModification {
    parameterId: ParameterId;
    propertyTypeId: PropertyTypeId;
    structFieldApiName?: ObjectTypeFieldApiName | null | undefined;
    structFieldApiNameOrRid?: StructFieldApiNameOrRid | null | undefined;
}
/**
 * Reference to a struct field of a struct list property.
 */
interface ObjectParameterStructListFieldValue {
    parameterId: ParameterId;
    propertyTypeId: PropertyTypeId;
    structFieldRid: StructFieldRid;
}
interface ObjectParameterStructListFieldValueModification {
    parameterId: ParameterId;
    propertyTypeId: PropertyTypeId;
    structFieldApiName?: ObjectTypeFieldApiName | null | undefined;
    structFieldApiNameOrRid?: StructFieldApiNameOrRid | null | undefined;
}
/**
 * Computes the result of an ObjectSet and suggests the value(s) to the user for a parameter.
 */
interface ObjectQueryPrefill {
    objectSet: ActionsObjectSet;
}
/**
 * Computes the result of an ObjectSet and suggests the value(s) to the user for a parameter.
 */
interface ObjectQueryPrefillModification {
    objectSet: ActionsObjectSetModification;
}
/**
 * Suggests the property value of the object set to the user for a parameter.
 */
interface ObjectQueryPropertyValue {
    objectSet: ActionsObjectSet;
    propertyTypeId: PropertyTypeId;
}
/**
 * Suggests the property value of the object set to the user for a parameter.
 */
interface ObjectQueryPropertyValueModification {
    objectSet: ActionsObjectSetModification;
    propertyTypeId: PropertyTypeId;
}
/**
 * The rid for an Object. Safe to log.
 */
type ObjectRid = string;
/**
 * Generates an ObjectSetRid, from the provided ObjectSet definition, that would be used as the default value
 * for a ObjectSetRidParameter.
 */
interface ObjectSetRidPrefill {
    objectSet: ActionsObjectSet;
}
/**
 * Generates an ObjectSetRid, from the provided ObjectSet definition, that would be used as the default value
 * for a ObjectSetRidParameter.
 */
interface ObjectSetRidPrefillModification {
    objectSet: ActionsObjectSetModification;
}
/**
 * Transforms objects in the ObjectSet to all objects on the other end of the specified Relation.
 */
interface ObjectSetSearchAround {
    objectTypeId: ObjectTypeId;
    relationId: LinkTypeId;
    relationSide: RelationSide;
}
interface ObjectSetTransform_propertyFilter {
    type: "propertyFilter";
    propertyFilter: ObjectSetFilter;
}
interface ObjectSetTransform_searchAround {
    type: "searchAround";
    searchAround: ObjectSetSearchAround;
}
/**
 * Transforms an ObjectSet by Filtering or performing a SearchAround.
 */
type ObjectSetTransform = ObjectSetTransform_propertyFilter | ObjectSetTransform_searchAround;
/**
 * Convert only Resource Identifiers with vetted/good interactions within the objects ecosystem to
 * human-readable format (e.g object set name). This ensures objects/carbon-only users are not
 * accidentally sent to workspace.
 */
interface ObjectsPlatformRids {
}
/**
 * An ObjectType is a model that represents a real world concept. For example, there could be
 * an Employees ObjectType to represent the employees in a business organization.
 */
interface ObjectType {
    allImplementsInterfaces: Record<InterfaceTypeRid, ObjectTypeInterfaceImplementation>;
    apiName?: ObjectTypeApiName | null | undefined;
    displayMetadata: ObjectTypeDisplayMetadata;
    id: ObjectTypeId;
    implementsInterfaces: Array<InterfaceTypeRid>;
    implementsInterfaces2: Array<ObjectTypeInterfaceImplementation>;
    primaryKeys: Array<PropertyTypeRid>;
    propertyTypes: Record<PropertyTypeRid, PropertyType>;
    redacted?: boolean | null | undefined;
    rid: ObjectTypeRid;
    status: ObjectTypeStatus;
    titlePropertyTypeRid: PropertyTypeRid;
    traits: ObjectTypeTraits;
    typeGroups: Array<TypeGroupRid>;
}
/**
 * A string indicating the API Name to use for the given ObjectType. This API name will be used to access the
 * ObjectType in programming languages.
 * It must adhere to the following rules:
 * - Match the unicode identifier syntax: https://unicode.org/reports/tr31/
 * - Contain at most 100 characters.
 */
type ObjectTypeApiName = string;
interface ObjectTypeCreatedEvent {
    objectTypeRid: ObjectTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * Object type datasource that is backed by a dataset in foundry, uniquely identified by its rid and
 * branch.
 * Deprecated in favor of ObjectTypeDatasetDatasourceV2
 */
interface ObjectTypeDatasetDatasource {
    branchId: BranchId;
    datasetRid: DatasetRid;
    propertyMapping: Record<PropertyTypeRid, ColumnName>;
    writebackDatasetRid?: DatasetRid | null | undefined;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a dataset in foundry,
 * uniquely identified by its rid and branch. It is only compatible with object storage v2, hence does not
 * have a writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface ObjectTypeDatasetDatasourceV2 {
    branchId: BranchId;
    datasetRid: DatasetRid;
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a dataset in foundry,
 * uniquely identified by its rid and branch, and uses PropertySecurityGroups to allow grouping those properties
 * into different security levels. It is only compatible with object storage v2, hence does not have a
 * writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface ObjectTypeDatasetDatasourceV3 {
    branchId: BranchId;
    datasetRid: DatasetRid;
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
    propertySecurityGroups?: PropertySecurityGroups | null | undefined;
}
interface ObjectTypeDatasource {
    dataSecurity?: DataSecurity | null | undefined;
    datasource: ObjectTypeDatasourceDefinition;
    editsConfiguration?: EditsConfiguration | null | undefined;
    redacted?: boolean | null | undefined;
    rid: DatasourceRid;
}
interface ObjectTypeDatasourceDefinition_dataset {
    type: "dataset";
    dataset: ObjectTypeDatasetDatasource;
}
interface ObjectTypeDatasourceDefinition_stream {
    type: "stream";
    stream: ObjectTypeStreamDatasource;
}
interface ObjectTypeDatasourceDefinition_streamV2 {
    type: "streamV2";
    streamV2: ObjectTypeStreamDatasourceV2;
}
interface ObjectTypeDatasourceDefinition_streamV3 {
    type: "streamV3";
    streamV3: ObjectTypeStreamDatasourceV3;
}
interface ObjectTypeDatasourceDefinition_restrictedView {
    type: "restrictedView";
    restrictedView: ObjectTypeRestrictedViewDatasource;
}
interface ObjectTypeDatasourceDefinition_timeSeries {
    type: "timeSeries";
    timeSeries: ObjectTypeTimeSeriesDatasource;
}
interface ObjectTypeDatasourceDefinition_datasetV2 {
    type: "datasetV2";
    datasetV2: ObjectTypeDatasetDatasourceV2;
}
interface ObjectTypeDatasourceDefinition_datasetV3 {
    type: "datasetV3";
    datasetV3: ObjectTypeDatasetDatasourceV3;
}
interface ObjectTypeDatasourceDefinition_restrictedViewV2 {
    type: "restrictedViewV2";
    restrictedViewV2: ObjectTypeRestrictedViewDatasourceV2;
}
interface ObjectTypeDatasourceDefinition_restrictedStream {
    type: "restrictedStream";
    restrictedStream: ObjectTypeRestrictedStreamDatasource;
}
interface ObjectTypeDatasourceDefinition_media {
    type: "media";
    media: ObjectTypeMediaDatasource;
}
interface ObjectTypeDatasourceDefinition_mediaSetView {
    type: "mediaSetView";
    mediaSetView: ObjectTypeMediaSetViewDatasource;
}
interface ObjectTypeDatasourceDefinition_geotimeSeries {
    type: "geotimeSeries";
    geotimeSeries: ObjectTypeGeotimeSeriesDatasource;
}
interface ObjectTypeDatasourceDefinition_table {
    type: "table";
    table: ObjectTypeTableDatasource;
}
interface ObjectTypeDatasourceDefinition_editsOnly {
    type: "editsOnly";
    editsOnly: ObjectTypeEditsOnlyDatasource;
}
interface ObjectTypeDatasourceDefinition_direct {
    type: "direct";
    direct: ObjectTypeDirectDatasource;
}
interface ObjectTypeDatasourceDefinition_derived {
    type: "derived";
    derived: ObjectTypeDerivedPropertiesDatasource;
}
/**
 * Wrapper type for all supported object type datasource types.
 */
type ObjectTypeDatasourceDefinition = ObjectTypeDatasourceDefinition_dataset | ObjectTypeDatasourceDefinition_stream | ObjectTypeDatasourceDefinition_streamV2 | ObjectTypeDatasourceDefinition_streamV3 | ObjectTypeDatasourceDefinition_restrictedView | ObjectTypeDatasourceDefinition_timeSeries | ObjectTypeDatasourceDefinition_datasetV2 | ObjectTypeDatasourceDefinition_datasetV3 | ObjectTypeDatasourceDefinition_restrictedViewV2 | ObjectTypeDatasourceDefinition_restrictedStream | ObjectTypeDatasourceDefinition_media | ObjectTypeDatasourceDefinition_mediaSetView | ObjectTypeDatasourceDefinition_geotimeSeries | ObjectTypeDatasourceDefinition_table | ObjectTypeDatasourceDefinition_editsOnly | ObjectTypeDatasourceDefinition_direct | ObjectTypeDatasourceDefinition_derived;
interface ObjectTypeDeletedEvent {
    deletionMetadata?: DeletionMetadata | null | undefined;
    objectTypeRid: ObjectTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * Object type datasource which is backed by derived properties definition.
 *
 * This source provides property values that are derived from property types on other object type(s)
 * via links or additional aggregations and computations.
 *
 * Note: if a property type is backed by an ObjectTypeDerivedPropertiesDatasource, the Type of the property
 * type will be resolved by OMS automatically. The TypeForModification will be ignored for that property type.
 *
 * This type is only compatible with object storage v2.
 */
interface ObjectTypeDerivedPropertiesDatasource {
    definition: DerivedPropertiesDefinition;
}
/**
 * Object type datasource which is backed by a "direct write" source, such as an edge pipeline. This type
 * of a datasource uses PropertySecurityGroups to allow grouping its properties into different security levels.
 * This type is only compatible with object storage v2.
 */
interface ObjectTypeDirectDatasource {
    directSourceRid: DirectSourceRid;
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
    propertySecurityGroups: PropertySecurityGroups;
}
/**
 * This includes metadata which can be used by front-ends when displaying the ObjectType.
 */
interface ObjectTypeDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
    groupDisplayName?: string | null | undefined;
    icon: Icon;
    pluralDisplayName: string;
    visibility: Visibility;
}
/**
 * Object type datasource which is not backed by any dataset or restricted view. This type of a "datasource"
 * only supports edits-only properties, and uses PropertySecurityGroups to allow grouping those properties into
 * different security levels.
 *
 * This type is only compatible with object storage v2.
 */
interface ObjectTypeEditsOnlyDatasource {
    editsOnlyRid?: EditsOnlyRid | null | undefined;
    properties: Array<PropertyTypeRid>;
    propertySecurityGroups: PropertySecurityGroups;
}
/**
 * A string representation of an Object Type used for embedding generation.
 */
type ObjectTypeEmbeddingInput = string;
interface ObjectTypeError_objectTypesAlreadyExist {
    type: "objectTypesAlreadyExist";
    objectTypesAlreadyExist: ObjectTypesAlreadyExistError;
}
interface ObjectTypeError_objectTypesNotFound {
    type: "objectTypesNotFound";
    objectTypesNotFound: ObjectTypesNotFoundError;
}
interface ObjectTypeError_objectTypeRidsNotFound {
    type: "objectTypeRidsNotFound";
    objectTypeRidsNotFound: ObjectTypeRidsNotFoundError;
}
interface ObjectTypeError_patchBackupInitializationConfigurationSourceDoesNotExist {
    type: "patchBackupInitializationConfigurationSourceDoesNotExist";
    patchBackupInitializationConfigurationSourceDoesNotExist: PatchBackupInitializationConfigurationSourceDoesNotExistError;
}
type ObjectTypeError = ObjectTypeError_objectTypesAlreadyExist | ObjectTypeError_objectTypesNotFound | ObjectTypeError_objectTypeRidsNotFound | ObjectTypeError_patchBackupInitializationConfigurationSourceDoesNotExist;
/**
 * A string indicating the API Name to use for the given entity that will be a field of an ObjectType.
 * This API name will be used to access the entity in programming languages.
 * It must adhere to the following rules:
 * - Match the unicode identifier syntax: https://unicode.org/reports/tr31/
 * - Contain at most 100 characters.
 */
type ObjectTypeFieldApiName = string;
/**
 * Object type datasource that is backed by a Geotime integration, uniquely identified by its rid.
 */
interface ObjectTypeGeotimeSeriesDatasource {
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationRid;
    properties: Array<PropertyTypeRid>;
}
/**
 * This is a human readable id for the ObjectType. ObjectTypeIds can be made up of lower case letters,
 * numbers and dashes, but they should start with an alphabet. Once you create an ObjectType, the
 * ObjectTypeId is immutable. To change the ObjectTypeId you need to delete the ObjectType and re-create
 * it. In future we plan to make it mutable, hence you should use the ObjectTypeRid for cases where
 * you need to rely on on an immutable identifier.
 *
 * Please note that this is not safe to log as it is user-inputted and may contain sensitive information.
 */
type ObjectTypeId = string;
interface ObjectTypeIdentifier_objectTypeId {
    type: "objectTypeId";
    objectTypeId: ObjectTypeId;
}
interface ObjectTypeIdentifier_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid;
}
/**
 * Union type to represent the different identifiers for ObjectType(s) in load requests.
 */
type ObjectTypeIdentifier = ObjectTypeIdentifier_objectTypeId | ObjectTypeIdentifier_objectTypeRid;
/**
 * A wrapping of ObjectType ids and InterfaceType rids, used when returning information from API name conflict
 * checks.
 */
interface ObjectTypeIdsAndInterfaceTypeRids {
    interfaceTypeRids: Array<InterfaceTypeRid>;
    objectTypeIds: Array<ObjectTypeId>;
}
/**
 * Object type input manager properties.
 */
interface ObjectTypeInputManagerProperties {
    datasources: Array<DatasourceRid>;
}
/**
 * ResourceIdentifier for the object type input manager.
 */
type ObjectTypeInputManagerRid = string;
/**
 * An input spec for an object type input.
 */
interface ObjectTypeInputSpec {
    objectTypeRid: ObjectTypeRid;
    ontologyRidAndBranch: OntologyRidAndBranch;
}
/**
 * An interface that an object type implements and metadata on how it implements it.
 */
interface ObjectTypeInterfaceImplementation {
    interfaceTypeApiName: InterfaceTypeApiName;
    interfaceTypeRid: InterfaceTypeRid;
    links: Record<InterfaceLinkTypeRid, Array<LinkTypeId>>;
    properties: Record<SharedPropertyTypeRid, InterfacePropertyImplementation>;
}
/**
 * Request to load an ObjectType.
 */
interface ObjectTypeLoadRequest {
    identifier: ObjectTypeIdentifier;
    versionReference?: VersionReference | null | undefined;
}
/**
 * Response to ObjectTypeLoadRequest.
 */
interface ObjectTypeLoadResponse {
    datasources: Array<ObjectTypeDatasource>;
    entityMetadata?: ObjectTypeEntityMetadata | null | undefined;
    objectType: ObjectType;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
/**
 * Object type datasource that is backed by media, uniquely identified by its rid.
 */
interface ObjectTypeMediaDatasource {
    mediaSourceRids: Array<MediaSourceRid>;
    properties: Array<PropertyTypeRid>;
}
/**
 * Object type datasource that is backed by a media set view, uniquely identified by its rid. This datasource
 * differs from ObjectTypeMediaDatasource in that fully controls access to the media items it provides. If a user
 * has access to a property backed by this datasource, they will be able to see the media item it references.
 */
interface ObjectTypeMediaSetViewDatasource {
    assumedMarkings: Array<MarkingId>;
    mediaSetViewLocator: MediaSetViewLocator;
    properties: Array<PropertyTypeRid>;
}
/**
 * ResourceIdentifier for the object type metadata input manager.
 */
type ObjectTypeMetadataInputManagerRid = string;
interface ObjectTypePeeringMetadata_v1 {
    type: "v1";
    v1: ObjectTypePeeringMetadataV1;
}
type ObjectTypePeeringMetadata = ObjectTypePeeringMetadata_v1;
interface ObjectTypePeeringMetadataV1 {
    enabled: boolean;
    peeringRid: ObjectTypePeeringRid;
}
/**
 * An identifier for a peered ObjectType used for establishing a mapping between local ObjectTypes and remote
 * ObjectTypes for Peering. Before a Object can be peered, a user must configure a mapping between the local and
 * remote ObjectType for that Object. If the local and remote ObjectType share the same ObjectTypePeeringRid,
 * Peering will suggest forming a mapping between those types.
 *
 * ObjectTypePeeringRids are preserved in Marketplace blocks, so ObjectTypes installed from the same Marketplace
 * definition on different stacks will share a ObjectTypePeeringRid if the original ObjectType packaged in
 * Marketplace has a ObjectTypePeeringRid.
 */
type ObjectTypePeeringRid = string;
/**
 * Object type datasource representing a restricted view on top of a stream.
 */
interface ObjectTypeRestrictedStreamDatasource {
    policyVersion: PolicyVersion;
    propertyMapping: Record<PropertyTypeRid, ColumnName>;
    restrictedViewRid: RestrictedViewRid;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamLocator;
}
/**
 * Object type datasource that is backed by a restricted view in foundry, uniquely identified by its rid.
 * Deprecated in favor of ObjectTypeRestrictedViewDatasourceV2
 */
interface ObjectTypeRestrictedViewDatasource {
    propertyMapping: Record<PropertyTypeRid, ColumnName>;
    restrictedViewRid: RestrictedViewRid;
    writebackDatasetRid?: DatasetRid | null | undefined;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a restricted view in foundry,
 * uniquely identified by its rid. It is only compatible with object storage v2, hence does not
 * have a writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface ObjectTypeRestrictedViewDatasourceV2 {
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
    restrictedViewRid: RestrictedViewRid;
}
/**
 * An rid identifying the ObjectType. This rid is generated randomly and is safe for logging purposes. Access
 * to the ObjectType is also controlled by checking operations on this rid. The ObjectTypeRid for an
 * ObjectType is immutable. If an ObjectType is deleted and recreated with the same ObjectTypeId, the
 * ObjectTypeRid will be different.
 */
type ObjectTypeRid = string;
/**
 * A wrapping of ObjectType rids and InterfaceType rids, used when returning information from API name conflict
 * checks.
 */
interface ObjectTypeRidsAndInterfaceTypeRids {
    interfaceTypeRids: Array<InterfaceTypeRid>;
    objectTypeRids: Array<ObjectTypeRid>;
}
/**
 * The ObjectTypesRids were not found in the current ontology.
 */
interface ObjectTypeRidsNotFoundError {
    objectTypeRids: Array<ObjectTypeRid>;
}
/**
 * There was an attempt to create ObjectTypes that already exist.
 */
interface ObjectTypesAlreadyExistError {
    objectTypeIds: Array<ObjectTypeId>;
}
/**
 * The ObjectTypes were not found.
 */
interface ObjectTypesNotFoundError {
    objectTypeIds: Array<ObjectTypeId>;
}
interface ObjectTypesSummary {
    maximumNumberOfObjectTypes: number;
    maxVectorDimensionality: number;
    visibleObjectTypes: number;
}
interface ObjectTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalObjectTypeStatus;
}
interface ObjectTypeStatus_active {
    type: "active";
    active: ActiveObjectTypeStatus;
}
interface ObjectTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedObjectTypeStatus;
}
interface ObjectTypeStatus_example {
    type: "example";
    example: ExampleObjectTypeStatus;
}
interface ObjectTypeStatus_endorsed {
    type: "endorsed";
    endorsed: EndorsedObjectTypeStatus;
}
/**
 * The status to indicate whether the ObjectType is either Experimental, Active, Deprecated, Example or Endorsed.
 */
type ObjectTypeStatus = ObjectTypeStatus_experimental | ObjectTypeStatus_active | ObjectTypeStatus_deprecated | ObjectTypeStatus_example | ObjectTypeStatus_endorsed;
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 */
interface ObjectTypeStreamDatasource {
    propertyMapping: Record<PropertyTypeRid, ColumnName>;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamLocator;
}
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 * Supports property security groups and should be used instead of ObjectTypeRestrictedStreamDatasource
 * when granular policies are needed.
 */
interface ObjectTypeStreamDatasourceV2 {
    propertyMapping: Record<PropertyTypeRid, ColumnName>;
    propertySecurityGroups?: PropertySecurityGroups | null | undefined;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamLocator;
}
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 * Supports property security groups and struct property mappings, and should be used instead of
 * ObjectTypeRestrictedStreamDatasourceV2, as that will be deprecated in the near future.
 */
interface ObjectTypeStreamDatasourceV3 {
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
    propertySecurityGroups?: PropertySecurityGroups | null | undefined;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamLocator;
}
/**
 * Object type datasource that is backed by a table in foundry, uniquely identified by its locator.
 * Supports edit only property types through PropertyTypeMappingInfo.
 */
interface ObjectTypeTableDatasource {
    branchId: BranchId;
    propertyMapping: Record<PropertyTypeRid, PropertyTypeMappingInfo>;
    tableRid: TableRid;
}
/**
 * Object type datasource that is backed by a time series sync, uniquely identified by its rid.
 */
interface ObjectTypeTimeSeriesDatasource {
    assumedMarkings: Array<MarkingId>;
    properties: Array<PropertyTypeRid>;
    timeSeriesSyncRid: TimeSeriesSyncRid;
}
/**
 * Specifications to be enforced on all the `PropertyType`(s) derived from the trait.
 */
interface ObjectTypeTraitPropertySpecification {
    enforcedDataTypes: Array<BasePropertyType>;
    required: boolean;
}
interface ObjectTypeTraits {
    actionLogMetadata?: ActionLogMetadata | null | undefined;
    eventMetadata?: EventMetadata | null | undefined;
    peeringMetadata?: ObjectTypePeeringMetadata | null | undefined;
    sensorTrait?: SensorTrait | null | undefined;
    timeSeriesMetadata?: TimeSeriesMetadata | null | undefined;
    workflowObjectTypeTraits: Record<WorkflowObjectTypeTraitId, Record<WorkflowObjectTypeTraitVersion, WorkflowObjectTypeTraitImpl>>;
}
interface ObjectTypeUpdatedEvent {
    objectTypeRid: ObjectTypeRid;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
}
interface ObjectTypeWithRestrictedViewWithGpsPolicyColumnsNotMappedAsPropertyTypes {
    missingGpsPolicyColumnsPerRestrictedView: Record<string, Array<string>>;
    objectTypeRid: ObjectTypeRid;
}
interface OneOfDecimalTypeConstraint$1 {
    values: Array<DecimalTypeDataValue$1>;
}
interface OneOfDoubleTypeConstraint$1 {
    values: Array<DoubleTypeDataValue$1>;
}
interface OneOfFloatTypeConstraint$1 {
    values: Array<FloatTypeDataValue$1>;
}
interface OneOfIntegerTypeConstraint$1 {
    values: Array<IntegerTypeDataValue$1>;
}
interface OneOfLongTypeConstraint$1 {
    values: Array<LongTypeDataValue$1>;
}
interface OneOfShortTypeConstraint$1 {
    values: Array<ShortTypeDataValue$1>;
}
interface OneOfStringTypeConstraint$1 {
    useIgnoreCase?: boolean | null | undefined;
    values: Array<StringTypeDataValue$1>;
}
/**
 * This hint can be used to inform consumers whether the number of links on the many side of a
 * OneToManyLinkDefinition is intended to be one or more.
 */
type OneToManyLinkCardinalityHint = "ONE_TO_ONE" | "ONE_TO_MANY";
interface OneToManyLinkDefinition {
    cardinalityHint: OneToManyLinkCardinalityHint;
    manyToOneLinkMetadata: LinkTypeMetadata;
    objectTypeRidManySide: ObjectTypeRid;
    objectTypeRidOneSide: ObjectTypeRid;
    oneSidePrimaryKeyToManySidePropertyMapping: Record<PropertyTypeRid, PropertyTypeRid>;
    oneToManyLinkMetadata: LinkTypeMetadata;
}
interface OntologyActionTypeLoadRequest {
    actionTypeRid: ActionTypeRid;
    ontologyVersion?: OntologyVersion | null | undefined;
}
/**
 * A string indicating the API Name to use for the given Ontology. This API name will be used to access the
 * Ontology in programming languages. It is not guaranteed to be unique across Ontologies. It must adhere
 * to the following rules:
 * - Must only contain the following ASCII characters: a-z and 0-9.
 * - Must not start with a number.
 * - Must have a maximum length of 100.
 * - Must be kebab-case.
 * - Must not be one of the reserved keywords: "ontology", "object", "property", "link", "relation", "rid", "primarykey", "typeid", "ontologyobject".
 */
type OntologyApiName = string;
interface OntologyBranch {
    isDefaultBranch: boolean;
    ontologyBranchRid: OntologyBranchRid;
}
/**
 * An rid identifying a branch of a particular Ontology. This rid is a randomly generated identifier
 * and is safe to log. Access to the Ontology is also controlled by checking operations on this rid.
 */
type OntologyBranchRid = string;
/**
 * Request to batch load Ontology entities by their backing datasource rids. If any of the requested
 * entities are not available in the latest version of any Ontology or the user is
 * missing permissions to see them, the corresponding entry in the
 * response will be empty. Upper limit for number of datasource rids is 500 for this request.
 */
interface OntologyBulkLoadEntitiesByDatasourcesRequest {
    datasourceBackingRids: Array<DatasourceBackingRid>;
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
}
/**
 * Response to OntologyBulkLoadEntitiesByDatasourcesRequest. If any of the requested
 * entities are not available in the latest version of any Ontology or the user is
 * missing permissions to see them, the corresponding entry in the
 * response will be empty.
 */
interface OntologyBulkLoadEntitiesByDatasourcesResponse {
    entities: Array<Array<EntityLoadByDatasourceResponse>>;
}
/**
 * Request to batch load Ontology entities. If any of the requested
 * entities are not available in the specified version or the user is
 * missing permissions to see them, the corresponding entry in the
 * response will be empty.
 */
interface OntologyBulkLoadEntitiesRequest {
    actionTypes: Array<ActionTypeLoadRequestV2>;
    datasourceTypes: Array<DatasourceType>;
    entityMetadata?: EntityMetadataLoadRequest | null | undefined;
    includeEntityMetadata?: boolean | null | undefined;
    includeObjectTypeCount?: boolean | null | undefined;
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    includeTypeGroupEntitiesCount?: boolean | null | undefined;
    interfaceTypes: Array<InterfaceTypeLoadRequest>;
    linkTypes: Array<LinkTypeLoadRequest>;
    loadRedacted?: boolean | null | undefined;
    objectTypes: Array<ObjectTypeLoadRequest>;
    sharedPropertyTypes: Array<SharedPropertyTypeLoadRequest>;
    typeGroups: Array<TypeGroupLoadRequest>;
}
/**
 * Response to OntologyBulkLoadEntitiesRequest. If any of the requested
 * entities are not available in the specified version or the user is
 * missing permissions to see them, the corresponding entry in the
 * response will be empty.
 */
interface OntologyBulkLoadEntitiesResponse {
    actionTypes: Array<ActionTypeLoadResponseV2 | null | undefined>;
    interfaceTypes: Array<InterfaceTypeLoadResponse | null | undefined>;
    linkTypes: Array<LinkTypeLoadResponse | null | undefined>;
    objectTypes: Array<ObjectTypeLoadResponse | null | undefined>;
    sharedPropertyTypes: Array<SharedPropertyTypeLoadResponse | null | undefined>;
    typeGroups: Array<TypeGroupLoadResponse | null | undefined>;
}
type OntologyDatasetType = "DATASOURCE" | "MATERIALIZATION";
/**
 * A collection of all the entities that use a TypeGroup.
 */
interface OntologyEntitiesUsedInTypeGroup {
    actionTypeRids: Array<ActionTypeRid>;
    objectTypeRids: Array<ObjectTypeRid>;
}
/**
 * Information about an Ontology.
 */
interface OntologyInformation {
    apiName: OntologyApiName;
    currentOntologyVersion: OntologyVersion;
    defaultBranchRid: OntologyBranchRid;
    description: string;
    displayName: string;
}
/**
 * The ActionLogic in an ActionType map the Parameters to what edits should be made in Phonograph. It employs
 * LogicRules for the core Action logic and, optionally, an ActionLogRule for capturing a record of the Action
 * execution. We don't allow the mixing of FunctionRule with other LogicRules in the same ActionType.
 */
interface OntologyIrActionLogic {
    rules: Array<OntologyIrLogicRule>;
}
/**
 * This signals to OMA that the Object Type will be regenerated as the Action Type changes, rather than modified
 * directly by the user. Also, OMA should not validate that the backing dataset has the required columns, as
 * these will instead be generated on save.
 */
interface OntologyIrActionLogMetadata {
    actionTypeRids: Array<ActionTypeApiName>;
}
/**
 * Users can optionally configure an ActionLogicRule for their ActionType that defines how Action parameters and
 * their properties should be mapped to properties of their Action Log Object Type.
 */
interface OntologyIrActionLogRule {
    actionLogObjectTypeId: ObjectTypeApiName;
    editedObjectRelations: Record<ObjectTypeApiName, LinkTypeId>;
    enabled: boolean;
    propertyValues: Record<ObjectTypeFieldApiName, OntologyIrActionLogValue>;
    reasonCodes: Array<ObjectTypeFieldApiName>;
}
interface OntologyIrActionLogValue_parameterValue {
    type: "parameterValue";
    parameterValue: ParameterId;
}
interface OntologyIrActionLogValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: OntologyIrObjectParameterPropertyValue;
}
interface OntologyIrActionLogValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: OntologyIrInterfaceParameterPropertyValue;
}
interface OntologyIrActionLogValue_editedObjects {
    type: "editedObjects";
    editedObjects: ObjectTypeApiName;
}
interface OntologyIrActionLogValue_allEditedObjects {
    type: "allEditedObjects";
    allEditedObjects: OntologyIrAllEditedObjectsFieldMapping;
}
interface OntologyIrActionLogValue_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: Empty;
}
interface OntologyIrActionLogValue_actionRid {
    type: "actionRid";
    actionRid: Empty;
}
interface OntologyIrActionLogValue_actionTypeVersion {
    type: "actionTypeVersion";
    actionTypeVersion: Empty;
}
interface OntologyIrActionLogValue_actionTimestamp {
    type: "actionTimestamp";
    actionTimestamp: Empty;
}
interface OntologyIrActionLogValue_actionUser {
    type: "actionUser";
    actionUser: Empty;
}
interface OntologyIrActionLogValue_isReverted {
    type: "isReverted";
    isReverted: Empty;
}
interface OntologyIrActionLogValue_revertUser {
    type: "revertUser";
    revertUser: Empty;
}
interface OntologyIrActionLogValue_revertTimestamp {
    type: "revertTimestamp";
    revertTimestamp: Empty;
}
interface OntologyIrActionLogValue_synchronousWebhookInstanceId {
    type: "synchronousWebhookInstanceId";
    synchronousWebhookInstanceId: Empty;
}
interface OntologyIrActionLogValue_asynchronousWebhookInstanceIds {
    type: "asynchronousWebhookInstanceIds";
    asynchronousWebhookInstanceIds: Empty;
}
interface OntologyIrActionLogValue_notifiedUsers {
    type: "notifiedUsers";
    notifiedUsers: Empty;
}
interface OntologyIrActionLogValue_notificationIds {
    type: "notificationIds";
    notificationIds: Empty;
}
interface OntologyIrActionLogValue_scenarioRid {
    type: "scenarioRid";
    scenarioRid: Empty;
}
interface OntologyIrActionLogValue_summary {
    type: "summary";
    summary: Array<OntologyIrActionTypeRichTextComponent>;
}
type OntologyIrActionLogValue = OntologyIrActionLogValue_parameterValue | OntologyIrActionLogValue_objectParameterPropertyValue | OntologyIrActionLogValue_interfaceParameterPropertyValue | OntologyIrActionLogValue_editedObjects | OntologyIrActionLogValue_allEditedObjects | OntologyIrActionLogValue_actionTypeRid | OntologyIrActionLogValue_actionRid | OntologyIrActionLogValue_actionTypeVersion | OntologyIrActionLogValue_actionTimestamp | OntologyIrActionLogValue_actionUser | OntologyIrActionLogValue_isReverted | OntologyIrActionLogValue_revertUser | OntologyIrActionLogValue_revertTimestamp | OntologyIrActionLogValue_synchronousWebhookInstanceId | OntologyIrActionLogValue_asynchronousWebhookInstanceIds | OntologyIrActionLogValue_notifiedUsers | OntologyIrActionLogValue_notificationIds | OntologyIrActionLogValue_scenarioRid | OntologyIrActionLogValue_summary;
/**
 * A notification that will be triggered on successful completion of an action.
 */
interface OntologyIrActionNotification {
    body: OntologyIrActionNotificationBody;
    toRecipients: OntologyIrActionNotificationRecipients;
}
interface OntologyIrActionNotificationBody_templateNotification {
    type: "templateNotification";
    templateNotification: OntologyIrTemplateNotificationBody;
}
interface OntologyIrActionNotificationBody_functionGenerated {
    type: "functionGenerated";
    functionGenerated: OntologyIrFunctionGeneratedNotificationBody;
}
/**
 * The body of an action's notification
 */
type OntologyIrActionNotificationBody = OntologyIrActionNotificationBody_templateNotification | OntologyIrActionNotificationBody_functionGenerated;
/**
 * A Function to be executed with action input parameters or the recipient of the notification.
 */
interface OntologyIrActionNotificationBodyFunctionExecution {
    functionInputValues: Record<FunctionInputName, OntologyIrFunctionExecutionWithRecipientInput>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
}
interface OntologyIrActionNotificationRecipients_parameter {
    type: "parameter";
    parameter: OntologyIrParameterActionNotificationRecipients;
}
interface OntologyIrActionNotificationRecipients_functionGenerated {
    type: "functionGenerated";
    functionGenerated: OntologyIrFunctionGeneratedActionNotificationRecipients;
}
/**
 * A notification's recipients.
 */
type OntologyIrActionNotificationRecipients = OntologyIrActionNotificationRecipients_parameter | OntologyIrActionNotificationRecipients_functionGenerated;
/**
 * A wrapper for DynamicObjectSet that includes a ConditionValueMap
 */
interface OntologyIrActionsObjectSet {
    conditionValues: Record<ConditionValueId, OntologyIrConditionValue>;
    objectSet: OntologyIrDynamicObjectSet;
}
interface OntologyIrActionType {
    actionTypeLogic: OntologyIrActionTypeLogic;
    metadata: OntologyIrActionTypeMetadata;
}
/**
 * DisplayMetadata shape used in responses
 */
interface OntologyIrActionTypeDisplayMetadata {
    configuration: ActionTypeDisplayMetadataConfiguration;
    description: string;
    displayName: string;
    icon?: Icon | null | undefined;
    submitButtonDisplayMetadata?: ButtonDisplayMetadata | null | undefined;
    successMessage: Array<OntologyIrActionTypeRichTextComponent>;
    typeClasses: Array<TypeClass>;
    undoButtonConfiguration?: boolean | null | undefined;
}
interface OntologyIrActionTypeEntities {
    affectedInterfaceTypes: Array<InterfaceTypeApiName>;
    affectedLinkTypes: Array<LinkTypeId>;
    affectedObjectTypes: Array<ObjectTypeApiName>;
    typeGroups: Array<TypeGroupRid>;
}
interface OntologyIrActionTypeLevelValidation {
    rules: Record<ValidationRuleIndex, OntologyIrValidationRule>;
}
interface OntologyIrActionTypeLogic {
    logic: OntologyIrActionLogic;
    validation: OntologyIrActionValidation;
}
/**
 * An ActionType defines the schema of the edits that can be made to Phonograph.
 */
interface OntologyIrActionTypeMetadata {
    apiName: ActionTypeApiName;
    displayMetadata: OntologyIrActionTypeDisplayMetadata;
    entities?: OntologyIrActionTypeEntities | null | undefined;
    formContentOrdering: Array<OntologyIrFormContent>;
    parameterOrdering: Array<ParameterId>;
    parameters: Record<ParameterId, OntologyIrParameter>;
    sections: Record<SectionId, OntologyIrSection>;
    status: OntologyIrActionTypeStatus;
}
interface OntologyIrActionTypeRichTextComponent_message {
    type: "message";
    message: ActionTypeRichTextMessage;
}
interface OntologyIrActionTypeRichTextComponent_parameter {
    type: "parameter";
    parameter: ActionTypeRichTextParameterReference;
}
interface OntologyIrActionTypeRichTextComponent_parameterProperty {
    type: "parameterProperty";
    parameterProperty: OntologyIrActionTypeRichTextParameterPropertyReference;
}
/**
 * Generic type that can used to define a string that should have Action execution details injected into it when
 * it is rendered.
 */
type OntologyIrActionTypeRichTextComponent = OntologyIrActionTypeRichTextComponent_message | OntologyIrActionTypeRichTextComponent_parameter | OntologyIrActionTypeRichTextComponent_parameterProperty;
/**
 * Indicates that this value in the rendered string should be replaced with the specified Object Parameter's
 * property value.
 */
type OntologyIrActionTypeRichTextParameterPropertyReference = OntologyIrObjectParameterPropertyValue;
interface OntologyIrActionTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalActionTypeStatus;
}
interface OntologyIrActionTypeStatus_active {
    type: "active";
    active: ActiveActionTypeStatus;
}
interface OntologyIrActionTypeStatus_deprecated {
    type: "deprecated";
    deprecated: OntologyIrDeprecatedActionTypeStatus;
}
interface OntologyIrActionTypeStatus_example {
    type: "example";
    example: ExampleActionTypeStatus;
}
/**
 * The status to indicate whether the ActionType is either Experimental, Active, Deprecated, or Example.
 */
type OntologyIrActionTypeStatus = OntologyIrActionTypeStatus_experimental | OntologyIrActionTypeStatus_active | OntologyIrActionTypeStatus_deprecated | OntologyIrActionTypeStatus_example;
interface OntologyIrActionValidation {
    actionTypeLevelValidation: OntologyIrActionTypeLevelValidation;
    parameterValidations: Record<ParameterId, OntologyIrConditionalValidationBlock>;
}
/**
 * ActionWebhooks contains the definition for webhooks that are executed as part of running an Action.
 */
interface OntologyIrActionWebhooks {
    asynchronousPostWritebackWebhooks: Array<OntologyIrAsynchronousPostWritebackWebhook>;
    synchronousPreWritebackWebhook?: OntologyIrSynchronousPreWritebackWebhook | null | undefined;
}
interface OntologyIrAddInterfaceLinkRule {
    interfaceLinkTypeRid: InterfaceLinkTypeApiName;
    interfaceTypeRid: InterfaceTypeApiName;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
interface OntologyIrAddInterfaceRule {
    interfaceApiName: InterfaceTypeApiName;
    objectTypeParameter: ParameterId;
    sharedPropertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
}
interface OntologyIrAddObjectRule {
    objectTypeId: ObjectTypeApiName;
    propertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
    structFieldValues: Record<ObjectTypeFieldApiName, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface OntologyIrAddOrModifyObjectRule {
    objectTypeId: ObjectTypeApiName;
    propertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
    structFieldValues: Record<ObjectTypeFieldApiName, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface OntologyIrAddOrModifyObjectRuleV2 {
    objectToModify: ParameterId;
    propertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
    structFieldValues: Record<ObjectTypeFieldApiName, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
/**
 * The mapping which designated what struct fields will get which values in the all edited properties log.
 */
interface OntologyIrAllEditedObjectsFieldMapping {
    objectTypeRid: StructFieldRid;
    primaryKeyType: StructFieldRid;
    primaryKeyValue: StructFieldRid;
}
interface OntologyIrAllowedParameterValues_oneOf {
    type: "oneOf";
    oneOf: OntologyIrParameterValueOneOfOrEmpty;
}
interface OntologyIrAllowedParameterValues_range {
    type: "range";
    range: OntologyIrParameterRangeOrEmpty;
}
interface OntologyIrAllowedParameterValues_objectQuery {
    type: "objectQuery";
    objectQuery: OntologyIrParameterObjectQueryOrEmpty;
}
interface OntologyIrAllowedParameterValues_interfaceObjectQuery {
    type: "interfaceObjectQuery";
    interfaceObjectQuery: ParameterInterfaceObjectQueryOrEmpty;
}
interface OntologyIrAllowedParameterValues_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: OntologyIrParameterObjectPropertyValueOrEmpty;
}
interface OntologyIrAllowedParameterValues_interfacePropertyValue {
    type: "interfacePropertyValue";
    interfacePropertyValue: ParameterInterfacePropertyValueOrEmpty;
}
interface OntologyIrAllowedParameterValues_objectList {
    type: "objectList";
    objectList: ParameterObjectListOrEmpty;
}
interface OntologyIrAllowedParameterValues_user {
    type: "user";
    user: OntologyIrParameterMultipassUserOrEmpty;
}
interface OntologyIrAllowedParameterValues_multipassGroup {
    type: "multipassGroup";
    multipassGroup: ParameterMultipassGroupOrEmpty;
}
interface OntologyIrAllowedParameterValues_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface OntologyIrAllowedParameterValues_datetime {
    type: "datetime";
    datetime: OntologyIrParameterDateTimeRangeOrEmpty;
}
interface OntologyIrAllowedParameterValues_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface OntologyIrAllowedParameterValues_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ParameterObjectSetRidOrEmpty;
}
interface OntologyIrAllowedParameterValues_attachment {
    type: "attachment";
    attachment: ParameterAttachmentOrEmpty;
}
interface OntologyIrAllowedParameterValues_cbacMarking {
    type: "cbacMarking";
    cbacMarking: OntologyIrParameterCbacMarkingOrEmpty;
}
interface OntologyIrAllowedParameterValues_mandatoryMarking {
    type: "mandatoryMarking";
    mandatoryMarking: ParameterMandatoryMarkingOrEmpty;
}
interface OntologyIrAllowedParameterValues_mediaReference {
    type: "mediaReference";
    mediaReference: ParameterMediaReferenceOrEmpty;
}
interface OntologyIrAllowedParameterValues_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: OntologyIrParameterObjectTypeReferenceOrEmpty;
}
interface OntologyIrAllowedParameterValues_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: ParameterTimeSeriesReferenceOrEmpty;
}
interface OntologyIrAllowedParameterValues_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
interface OntologyIrAllowedParameterValues_geoshape {
    type: "geoshape";
    geoshape: ParameterGeoshapeOrEmpty;
}
interface OntologyIrAllowedParameterValues_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: ParameterGeotimeSeriesReferenceOrEmpty;
}
interface OntologyIrAllowedParameterValues_redacted {
    type: "redacted";
    redacted: Redacted;
}
interface OntologyIrAllowedParameterValues_valueType {
    type: "valueType";
    valueType: ParameterValueTypeOrEmpty;
}
type OntologyIrAllowedParameterValues = OntologyIrAllowedParameterValues_oneOf | OntologyIrAllowedParameterValues_range | OntologyIrAllowedParameterValues_objectQuery | OntologyIrAllowedParameterValues_interfaceObjectQuery | OntologyIrAllowedParameterValues_objectPropertyValue | OntologyIrAllowedParameterValues_interfacePropertyValue | OntologyIrAllowedParameterValues_objectList | OntologyIrAllowedParameterValues_user | OntologyIrAllowedParameterValues_multipassGroup | OntologyIrAllowedParameterValues_text | OntologyIrAllowedParameterValues_datetime | OntologyIrAllowedParameterValues_boolean | OntologyIrAllowedParameterValues_objectSetRid | OntologyIrAllowedParameterValues_attachment | OntologyIrAllowedParameterValues_cbacMarking | OntologyIrAllowedParameterValues_mandatoryMarking | OntologyIrAllowedParameterValues_mediaReference | OntologyIrAllowedParameterValues_objectTypeReference | OntologyIrAllowedParameterValues_timeSeriesReference | OntologyIrAllowedParameterValues_geohash | OntologyIrAllowedParameterValues_geoshape | OntologyIrAllowedParameterValues_geotimeSeriesReference | OntologyIrAllowedParameterValues_redacted | OntologyIrAllowedParameterValues_valueType;
interface OntologyIrAllowedStructFieldValues_oneOf {
    type: "oneOf";
    oneOf: OntologyIrParameterValueOneOfOrEmpty;
}
interface OntologyIrAllowedStructFieldValues_range {
    type: "range";
    range: OntologyIrParameterRangeOrEmpty;
}
interface OntologyIrAllowedStructFieldValues_text {
    type: "text";
    text: ParameterFreeTextOrEmpty;
}
interface OntologyIrAllowedStructFieldValues_datetime {
    type: "datetime";
    datetime: OntologyIrParameterDateTimeRangeOrEmpty;
}
interface OntologyIrAllowedStructFieldValues_boolean {
    type: "boolean";
    boolean: ParameterBooleanOrEmpty;
}
interface OntologyIrAllowedStructFieldValues_geohash {
    type: "geohash";
    geohash: ParameterGeohashOrEmpty;
}
type OntologyIrAllowedStructFieldValues = OntologyIrAllowedStructFieldValues_oneOf | OntologyIrAllowedStructFieldValues_range | OntologyIrAllowedStructFieldValues_text | OntologyIrAllowedStructFieldValues_datetime | OntologyIrAllowedStructFieldValues_boolean | OntologyIrAllowedStructFieldValues_geohash;
interface OntologyIrAllowedStructFieldValuesOverride {
    allowedValues: OntologyIrAllowedStructFieldValues;
}
interface OntologyIrAllowedValuesOverride {
    allowedValues: OntologyIrAllowedParameterValues;
}
interface OntologyIrAndCondition {
    conditions: Array<OntologyIrCondition>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface OntologyIrArrayPropertyType {
    subtype: OntologyIrType;
}
interface OntologyIrAsynchronousPostWritebackWebhook_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: OntologyIrStaticWebhookWithDirectInput;
}
interface OntologyIrAsynchronousPostWritebackWebhook_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: OntologyIrStaticWebhookWithFunctionResultInput;
}
/**
 * Union wrapping the various options available for configuring webhook(s) which will be executed asynchronously,
 * post writeback. If any fail, this is not surfaced during the apply Action call.
 */
type OntologyIrAsynchronousPostWritebackWebhook = OntologyIrAsynchronousPostWritebackWebhook_staticDirectInput | OntologyIrAsynchronousPostWritebackWebhook_staticFunctionInput;
interface OntologyIrBaseFormatter_knownFormatter {
    type: "knownFormatter";
    knownFormatter: KnownFormatter;
}
interface OntologyIrBaseFormatter_number {
    type: "number";
    number: OntologyIrNumberFormatter;
}
interface OntologyIrBaseFormatter_timestamp {
    type: "timestamp";
    timestamp: OntologyIrTimestampFormatter;
}
interface OntologyIrBaseFormatter_date {
    type: "date";
    date: DateFormatter;
}
interface OntologyIrBaseFormatter_string {
    type: "string";
    string: StringFormatter;
}
interface OntologyIrBaseFormatter_timeDependent {
    type: "timeDependent";
    timeDependent: OntologyIrTimeDependentFormatter;
}
interface OntologyIrBaseFormatter_boolean {
    type: "boolean";
    boolean: BooleanFormatter;
}
/**
 * The basic formatting behavior.
 */
type OntologyIrBaseFormatter = OntologyIrBaseFormatter_knownFormatter | OntologyIrBaseFormatter_number | OntologyIrBaseFormatter_timestamp | OntologyIrBaseFormatter_date | OntologyIrBaseFormatter_string | OntologyIrBaseFormatter_timeDependent | OntologyIrBaseFormatter_boolean;
/**
 * A basic action notification's email body. Uses Handlebars templating.
 */
interface OntologyIrBasicEmailBody {
    emailContent: string;
    links: Array<OntologyIrNotificationResultTypeLink>;
    subject: string;
}
interface OntologyIrBatchedFunctionRule {
    functionDetails: OntologyIrFunctionRule;
    objectSetRidInputName: FunctionInputName;
}
interface OntologyIrCarbonWorkspaceComponentUrlTarget_rid {
    type: "rid";
    rid: OntologyIrRidUrlTarget;
}
/**
 * The second part of a carbon workspace Url target.
 */
type OntologyIrCarbonWorkspaceComponentUrlTarget = OntologyIrCarbonWorkspaceComponentUrlTarget_rid;
/**
 * A URL target for a carbon workspace.
 */
interface OntologyIrCarbonWorkspaceUrlTarget {
    resource?: OntologyIrCarbonWorkspaceComponentUrlTarget | null | undefined;
}
interface OntologyIrCipherTextPropertyType {
    defaultCipherChannelRid?: string | null | undefined;
    plainTextType: OntologyIrType;
}
interface OntologyIrComparisonCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    left: OntologyIrConditionValue;
    operator: ComparisonOperator;
    right: OntologyIrConditionValue;
}
interface OntologyIrCondition_true {
    type: "true";
    true: TrueCondition;
}
interface OntologyIrCondition_or {
    type: "or";
    or: OntologyIrOrCondition;
}
interface OntologyIrCondition_and {
    type: "and";
    and: OntologyIrAndCondition;
}
interface OntologyIrCondition_not {
    type: "not";
    not: OntologyIrNotCondition;
}
interface OntologyIrCondition_comparison {
    type: "comparison";
    comparison: OntologyIrComparisonCondition;
}
interface OntologyIrCondition_markings {
    type: "markings";
    markings: OntologyIrMarkingsCondition;
}
interface OntologyIrCondition_regex {
    type: "regex";
    regex: OntologyIrRegexCondition;
}
interface OntologyIrCondition_redacted {
    type: "redacted";
    redacted: Redacted;
}
type OntologyIrCondition = OntologyIrCondition_true | OntologyIrCondition_or | OntologyIrCondition_and | OntologyIrCondition_not | OntologyIrCondition_comparison | OntologyIrCondition_markings | OntologyIrCondition_regex | OntologyIrCondition_redacted;
interface OntologyIrConditionalOverride {
    condition: OntologyIrCondition;
    parameterBlockOverrides: Array<OntologyIrParameterValidationBlockOverride>;
}
interface OntologyIrConditionalValidationBlock {
    defaultValidation: OntologyIrParameterValidationBlock;
}
interface OntologyIrConditionValue_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface OntologyIrConditionValue_staticValue {
    type: "staticValue";
    staticValue: OntologyIrStaticValue;
}
interface OntologyIrConditionValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: OntologyIrObjectParameterPropertyValue;
}
interface OntologyIrConditionValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: OntologyIrInterfaceParameterPropertyValue;
}
interface OntologyIrConditionValue_userProperty {
    type: "userProperty";
    userProperty: UserProperty;
}
interface OntologyIrConditionValue_parameterLength {
    type: "parameterLength";
    parameterLength: ParameterLength;
}
type OntologyIrConditionValue = OntologyIrConditionValue_parameterId | OntologyIrConditionValue_staticValue | OntologyIrConditionValue_objectParameterPropertyValue | OntologyIrConditionValue_interfaceParameterPropertyValue | OntologyIrConditionValue_userProperty | OntologyIrConditionValue_parameterLength;
interface OntologyIrDateRangeValue_fixed {
    type: "fixed";
    fixed: OntologyIrConditionValue;
}
interface OntologyIrDateRangeValue_relative {
    type: "relative";
    relative: RelativeDateRangeValue;
}
interface OntologyIrDateRangeValue_now {
    type: "now";
    now: NowValue;
}
type OntologyIrDateRangeValue = OntologyIrDateRangeValue_fixed | OntologyIrDateRangeValue_relative | OntologyIrDateRangeValue_now;
interface OntologyIrDatetimeTimezone_static {
    type: "static";
    static: OntologyIrDatetimeTimezoneDefinition;
}
interface OntologyIrDatetimeTimezone_user {
    type: "user";
    user: UserTimezone;
}
type OntologyIrDatetimeTimezone = OntologyIrDatetimeTimezone_static | OntologyIrDatetimeTimezone_user;
interface OntologyIrDatetimeTimezoneDefinition_zoneId {
    type: "zoneId";
    zoneId: OntologyIrPropertyTypeReferenceOrStringConstant;
}
type OntologyIrDatetimeTimezoneDefinition = OntologyIrDatetimeTimezoneDefinition_zoneId;
interface OntologyIrDeleteInterfaceLinkRule {
    interfaceLinkTypeRid: InterfaceLinkTypeApiName;
    interfaceTypeRid: InterfaceTypeApiName;
    sourceObject: ParameterId;
    targetObject: ParameterId;
}
/**
 * This status indicates that the ActionType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface OntologyIrDeprecatedActionTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: ActionTypeApiName | null | undefined;
}
/**
 * This status indicates that the interface is reaching the end of its life and will be removed as per the
 * deadline specified.
 */
interface OntologyIrDeprecatedInterfaceTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: InterfaceTypeApiName | null | undefined;
}
/**
 * This status indicates that the LinkType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface OntologyIrDeprecatedLinkTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: LinkTypeId | null | undefined;
}
/**
 * This status indicates that the ObjectType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface OntologyIrDeprecatedObjectTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: ObjectTypeApiName | null | undefined;
}
/**
 * This status indicates that the PropertyType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface OntologyIrDeprecatedPropertyTypeStatus {
    deadline: string;
    message: string;
    replacedBy?: ObjectTypeFieldApiName | null | undefined;
}
/**
 * An ObjectSet gotten as a result of performing a sequence of Transforms on a base ObjectSet.
 * Each transforms is either a PropertyFilter or a SearchAround.
 * There is a limit of 3 SearchArounds.
 */
interface OntologyIrDynamicObjectSet {
    startingObjectSet: OntologyIrDynamicObjectSetInput;
    transforms: Array<OntologyIrObjectSetTransform>;
}
interface OntologyIrDynamicObjectSetInput_base {
    type: "base";
    base: OntologyIrDynamicObjectSetInputBase;
}
interface OntologyIrDynamicObjectSetInput_parameter {
    type: "parameter";
    parameter: DynamicObjectSetInputParameter;
}
interface OntologyIrDynamicObjectSetInput_unioned {
    type: "unioned";
    unioned: OntologyIrDynamicObjectSetInputUnioned;
}
/**
 * A wrapper used to reference an ObjectSet
 */
type OntologyIrDynamicObjectSetInput = OntologyIrDynamicObjectSetInput_base | OntologyIrDynamicObjectSetInput_parameter | OntologyIrDynamicObjectSetInput_unioned;
/**
 * Depicts an ObjectSet with all objects of this ObjectType
 */
interface OntologyIrDynamicObjectSetInputBase {
    objectTypeId: ObjectTypeApiName;
}
/**
 * Depicts an ObjectSet which is a union of all ObjectSets provided.
 */
interface OntologyIrDynamicObjectSetInputUnioned {
    dynamicObjectSets: Array<OntologyIrDynamicObjectSet>;
}
interface OntologyIrEmailBody_basic {
    type: "basic";
    basic: OntologyIrBasicEmailBody;
}
/**
 * An action notification's email body. Uses Handlebars templating.
 */
type OntologyIrEmailBody = OntologyIrEmailBody_basic;
/**
 * Describes how to treat an object of this type as an event.
 */
interface OntologyIrEventMetadata {
    description?: ObjectTypeFieldApiName | null | undefined;
    endTimePropertyTypeRid: ObjectTypeFieldApiName;
    eventIdPropertyTypeRid: ObjectTypeFieldApiName;
    startTimePropertyTypeRid: ObjectTypeFieldApiName;
}
/**
 * Note this is experimental, should not be used without consulting the product team and format can
 * change/break without notice.
 */
interface OntologyIrExperimentalTimeDependentPropertyTypeV1 {
    sensorLinkTypeId?: LinkTypeId | null | undefined;
    seriesValueMetadata: OntologyIrSeriesValueMetadata;
}
interface OntologyIrFormContent_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface OntologyIrFormContent_sectionId {
    type: "sectionId";
    sectionId: SectionId;
}
/**
 * Items that we can place on the action form.
 */
type OntologyIrFormContent = OntologyIrFormContent_parameterId | OntologyIrFormContent_sectionId;
interface OntologyIrFunctionExecutionWithRecipientInput_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: OntologyIrLogicRuleValue;
}
interface OntologyIrFunctionExecutionWithRecipientInput_recipient {
    type: "recipient";
    recipient: NotificationRecipient;
}
/**
 * Encapsulates either a LogicRuleValue or a NotificationRecipient.
 */
type OntologyIrFunctionExecutionWithRecipientInput = OntologyIrFunctionExecutionWithRecipientInput_logicRuleValue | OntologyIrFunctionExecutionWithRecipientInput_recipient;
/**
 * Notification recipients determined from a Function execution.
 */
interface OntologyIrFunctionGeneratedActionNotificationRecipients {
    functionExecution: OntologyIrFunctionRule;
}
/**
 * The body of a notification based on the result of a function execution.
 */
interface OntologyIrFunctionGeneratedNotificationBody {
    functionExecution: OntologyIrActionNotificationBodyFunctionExecution;
}
/**
 * A Function to be executed with action input parameters.
 */
interface OntologyIrFunctionRule {
    customExecutionMode?: FunctionRuleCustomExecutionMode | null | undefined;
    experimentalDeclarativeEditInformation?: ExperimentalDeclarativeEditInformation | null | undefined;
    functionInputValues: Record<FunctionInputName, OntologyIrLogicRuleValue>;
    functionRid: FunctionRid;
    functionVersion: SemanticFunctionVersion;
}
interface OntologyIrInlineActionType {
    displayOptions: InlineActionDisplayOptions;
    parameterId?: ParameterId | null | undefined;
    rid: ActionTypeApiName;
}
interface OntologyIrInterfaceLinkType {
    cardinality: InterfaceLinkTypeCardinality;
    linkedEntityTypeId: OntologyIrLinkedEntityTypeId;
    metadata: InterfaceLinkTypeMetadata;
    required: boolean;
}
interface OntologyIrInterfaceParameterPropertyValue {
    parameterId: ParameterId;
    sharedPropertyTypeRid: ObjectTypeFieldApiName;
}
interface OntologyIrInterfacePropertyImplementation {
    propertyTypeRid: ObjectTypeFieldApiName;
}
interface OntologyIrInterfaceSharedPropertyType {
    required: boolean;
    sharedPropertyType: OntologyIrSharedPropertyType;
}
/**
 * Represents a collection of properties that object types can implement. If an object type implements an
 * interface, it is guaranteed to have the conform to the interface shape.
 */
interface OntologyIrInterfaceType {
    allExtendsInterfaces: Array<InterfaceTypeApiName>;
    allLinks: Array<OntologyIrInterfaceLinkType>;
    allProperties: Array<OntologyIrSharedPropertyType>;
    allPropertiesV2: Record<ObjectTypeFieldApiName, OntologyIrInterfaceSharedPropertyType>;
    apiName: InterfaceTypeApiName;
    displayMetadata: InterfaceTypeDisplayMetadata;
    extendsInterfaces: Array<InterfaceTypeApiName>;
    links: Array<OntologyIrInterfaceLinkType>;
    properties: Array<OntologyIrSharedPropertyType>;
    propertiesV2: Record<ObjectTypeFieldApiName, OntologyIrInterfaceSharedPropertyType>;
    status: OntologyIrInterfaceTypeStatus;
}
interface OntologyIrInterfaceTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalInterfaceTypeStatus;
}
interface OntologyIrInterfaceTypeStatus_active {
    type: "active";
    active: ActiveInterfaceTypeStatus;
}
interface OntologyIrInterfaceTypeStatus_deprecated {
    type: "deprecated";
    deprecated: OntologyIrDeprecatedInterfaceTypeStatus;
}
interface OntologyIrInterfaceTypeStatus_example {
    type: "example";
    example: ExampleInterfaceTypeStatus;
}
type OntologyIrInterfaceTypeStatus = OntologyIrInterfaceTypeStatus_experimental | OntologyIrInterfaceTypeStatus_active | OntologyIrInterfaceTypeStatus_deprecated | OntologyIrInterfaceTypeStatus_example;
/**
 * Represents a link between two ObjectTypes with an intermediary ObjectType acting as a bridge.
 * This LinkType can be used to jump from ObjectType A to B without specifying two separate search-arounds.
 * This LinkType can also be used to simulate a ManyToMany LinkType backed by an RV, or a ManyToMany LinkType
 * with properties.
 *
 * If any special interaction is required on the intermediary ObjectType (for example filtering) the two
 * connecting LinkTypes should be used instead.
 */
interface OntologyIrIntermediaryLinkDefinition {
    aToIntermediaryLinkTypeRid: LinkTypeId;
    intermediaryObjectTypeRid: ObjectTypeApiName;
    intermediaryToBLinkTypeRid: LinkTypeId;
    objectTypeAToBLinkMetadata: LinkTypeMetadata;
    objectTypeBToALinkMetadata: LinkTypeMetadata;
    objectTypeRidA: ObjectTypeApiName;
    objectTypeRidB: ObjectTypeApiName;
}
interface OntologyIrLabelledValue {
    label: string;
    value: OntologyIrStaticValue;
}
interface OntologyIrLinkDefinition_manyToMany {
    type: "manyToMany";
    manyToMany: OntologyIrManyToManyLinkDefinition;
}
interface OntologyIrLinkDefinition_oneToMany {
    type: "oneToMany";
    oneToMany: OntologyIrOneToManyLinkDefinition;
}
type OntologyIrLinkDefinition = OntologyIrLinkDefinition_manyToMany | OntologyIrLinkDefinition_oneToMany;
interface OntologyIrLinkedEntityTypeId_objectType {
    type: "objectType";
    objectType: ObjectTypeApiName;
}
interface OntologyIrLinkedEntityTypeId_interfaceType {
    type: "interfaceType";
    interfaceType: InterfaceTypeApiName;
}
/**
 * A reference to a linked entity in InterfaceLinkTypes.
 */
type OntologyIrLinkedEntityTypeId = OntologyIrLinkedEntityTypeId_objectType | OntologyIrLinkedEntityTypeId_interfaceType;
/**
 * LinkType(s) are models for relationships between ObjectType(s).
 */
interface OntologyIrLinkType {
    definition: OntologyIrLinkDefinition;
    id: LinkTypeId;
    redacted?: boolean | null | undefined;
    status: OntologyIrLinkTypeStatus;
}
interface OntologyIrLinkTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalLinkTypeStatus;
}
interface OntologyIrLinkTypeStatus_active {
    type: "active";
    active: ActiveLinkTypeStatus;
}
interface OntologyIrLinkTypeStatus_deprecated {
    type: "deprecated";
    deprecated: OntologyIrDeprecatedLinkTypeStatus;
}
interface OntologyIrLinkTypeStatus_example {
    type: "example";
    example: ExampleLinkTypeStatus;
}
/**
 * The status to indicate whether the LinkType is either Experimental, Active, Deprecated, or Example.
 */
type OntologyIrLinkTypeStatus = OntologyIrLinkTypeStatus_experimental | OntologyIrLinkTypeStatus_active | OntologyIrLinkTypeStatus_deprecated | OntologyIrLinkTypeStatus_example;
interface OntologyIrLogicRule_addObjectRule {
    type: "addObjectRule";
    addObjectRule: OntologyIrAddObjectRule;
}
interface OntologyIrLogicRule_addOrModifyObjectRuleV2 {
    type: "addOrModifyObjectRuleV2";
    addOrModifyObjectRuleV2: OntologyIrAddOrModifyObjectRuleV2;
}
interface OntologyIrLogicRule_modifyObjectRule {
    type: "modifyObjectRule";
    modifyObjectRule: OntologyIrModifyObjectRule;
}
interface OntologyIrLogicRule_deleteObjectRule {
    type: "deleteObjectRule";
    deleteObjectRule: DeleteObjectRule;
}
interface OntologyIrLogicRule_addInterfaceRule {
    type: "addInterfaceRule";
    addInterfaceRule: OntologyIrAddInterfaceRule;
}
interface OntologyIrLogicRule_modifyInterfaceRule {
    type: "modifyInterfaceRule";
    modifyInterfaceRule: OntologyIrModifyInterfaceRule;
}
interface OntologyIrLogicRule_addLinkRule {
    type: "addLinkRule";
    addLinkRule: AddLinkRule;
}
interface OntologyIrLogicRule_deleteLinkRule {
    type: "deleteLinkRule";
    deleteLinkRule: DeleteLinkRule;
}
type OntologyIrLogicRule = OntologyIrLogicRule_addObjectRule | OntologyIrLogicRule_addOrModifyObjectRuleV2 | OntologyIrLogicRule_modifyObjectRule | OntologyIrLogicRule_deleteObjectRule | OntologyIrLogicRule_addInterfaceRule | OntologyIrLogicRule_modifyInterfaceRule | OntologyIrLogicRule_addLinkRule | OntologyIrLogicRule_deleteLinkRule;
interface OntologyIrLogicRuleValue_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
interface OntologyIrLogicRuleValue_staticValue {
    type: "staticValue";
    staticValue: OntologyIrStaticValue;
}
interface OntologyIrLogicRuleValue_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: OntologyIrObjectParameterPropertyValue;
}
interface OntologyIrLogicRuleValue_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: OntologyIrInterfaceParameterPropertyValue;
}
interface OntologyIrLogicRuleValue_currentUser {
    type: "currentUser";
    currentUser: CurrentUser;
}
interface OntologyIrLogicRuleValue_currentTime {
    type: "currentTime";
    currentTime: CurrentTime;
}
interface OntologyIrLogicRuleValue_uniqueIdentifier {
    type: "uniqueIdentifier";
    uniqueIdentifier: UniqueIdentifier;
}
interface OntologyIrLogicRuleValue_synchronousWebhookOutput {
    type: "synchronousWebhookOutput";
    synchronousWebhookOutput: WebhookOutputParamName;
}
/**
 * These are the possible values that can be passed into LogicRules as well as Notification and Webhook side
 * effects.
 */
type OntologyIrLogicRuleValue = OntologyIrLogicRuleValue_parameterId | OntologyIrLogicRuleValue_staticValue | OntologyIrLogicRuleValue_objectParameterPropertyValue | OntologyIrLogicRuleValue_interfaceParameterPropertyValue | OntologyIrLogicRuleValue_currentUser | OntologyIrLogicRuleValue_currentTime | OntologyIrLogicRuleValue_uniqueIdentifier | OntologyIrLogicRuleValue_synchronousWebhookOutput;
interface OntologyIrManyToManyLinkDefinition {
    objectTypeAPrimaryKeyPropertyMapping: Array<OntologyIrPropertyToPropertyMapping>;
    objectTypeAToBLinkMetadata: LinkTypeMetadata;
    objectTypeBPrimaryKeyPropertyMapping: Array<OntologyIrPropertyToPropertyMapping>;
    objectTypeBToALinkMetadata: LinkTypeMetadata;
    objectTypeRidA: ObjectTypeApiName;
    objectTypeRidB: ObjectTypeApiName;
    peeringMetadata?: LinkTypePeeringMetadata | null | undefined;
}
/**
 * Many to many link type datasource that is backed by a dataset in foundry, uniquely identified by its rid and
 * branch.
 */
interface OntologyIrManyToManyLinkTypeDatasetDatasource {
    datasetRid: DataSetName;
    objectTypeAPrimaryKeyMapping: Array<OntologyIrPropertyToColumnMapping>;
    objectTypeBPrimaryKeyMapping: Array<OntologyIrPropertyToColumnMapping>;
    writebackDatasetRid?: DataSetName | null | undefined;
}
interface OntologyIrManyToManyLinkTypeDatasource {
    datasource: OntologyIrManyToManyLinkTypeDatasourceDefinition;
    editsConfiguration?: EditsConfiguration | null | undefined;
    redacted?: boolean | null | undefined;
    rid: DatasourceRid;
}
interface OntologyIrManyToManyLinkTypeDatasourceDefinition_dataset {
    type: "dataset";
    dataset: OntologyIrManyToManyLinkTypeDatasetDatasource;
}
/**
 * Wrapper type for all supported many to many link type datasource types.
 */
type OntologyIrManyToManyLinkTypeDatasourceDefinition = OntologyIrManyToManyLinkTypeDatasourceDefinition_dataset;
/**
 * Many to many link type datasource that is backed by a stream, uniquely identified by its StreamLocator.
 */
interface OntologyIrManyToManyLinkTypeStreamDatasource {
    objectTypeAPrimaryKeyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    objectTypeBPrimaryKeyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamName;
}
/**
 * True if the user satisfies the markings represented by the value field.
 * This follows com.palantir.gps.api.policy.MarkingsCondition
 */
interface OntologyIrMarkingsCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    filters: MarkingFilter;
    value: OntologyIrConditionValue;
}
interface OntologyIrMediaSourceRid_mediaSetRid {
    type: "mediaSetRid";
    mediaSetRid: MediaSetRid;
}
interface OntologyIrMediaSourceRid_datasetRid {
    type: "datasetRid";
    datasetRid: DataSetName;
}
/**
 * A rid identifying the resource backing a media reference.
 */
type OntologyIrMediaSourceRid = OntologyIrMediaSourceRid_mediaSetRid | OntologyIrMediaSourceRid_datasetRid;
interface OntologyIrModifyInterfaceRule {
    interfaceObjectToModifyParameter: ParameterId;
    sharedPropertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
}
interface OntologyIrModifyObjectRule {
    objectToModify: ParameterId;
    propertyValues: Record<ObjectTypeFieldApiName, OntologyIrLogicRuleValue>;
    structFieldValues: Record<ObjectTypeFieldApiName, Record<StructFieldRid, StructFieldLogicRuleValue>>;
}
interface OntologyIrMultipassUserFilter_groupFilter {
    type: "groupFilter";
    groupFilter: OntologyIrMultipassUserInGroupFilter;
}
type OntologyIrMultipassUserFilter = OntologyIrMultipassUserFilter_groupFilter;
interface OntologyIrMultipassUserInGroupFilter {
    groupId: OntologyIrConditionValue;
}
/**
 * A URL target for a newly created object.
 */
interface OntologyIrNewObjectUrlTarget {
    keys: Record<PropertyId, OntologyIrLogicRuleValue>;
    objectTypeId: ObjectTypeApiName;
}
/**
 * Configuration for non-numeric series.
 */
interface OntologyIrNonNumericSeriesValueMetadata {
    defaultInternalInterpolation: OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation;
}
/**
 * The unit to accompany the non-numeric value of a Time Dependent property. Can be provided by a property or a
 * user-inputted constant.
 */
interface OntologyIrNonNumericSeriesValueUnit {
    customUnit: OntologyIrPropertyTypeReferenceOrStringConstant;
}
interface OntologyIrNotCondition {
    condition: OntologyIrCondition;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface OntologyIrNotificationResultTypeLink {
    message: string;
    url: OntologyIrUrlTarget;
}
interface OntologyIrNotificationTemplateInputValue_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: OntologyIrLogicRuleValue;
}
interface OntologyIrNotificationTemplateInputValue_recipientValue {
    type: "recipientValue";
    recipientValue: UserValue;
}
interface OntologyIrNotificationTemplateInputValue_actionTriggererValue {
    type: "actionTriggererValue";
    actionTriggererValue: UserValue;
}
/**
 * All the types that can be used as a value for a Notification template's inputs.
 */
type OntologyIrNotificationTemplateInputValue = OntologyIrNotificationTemplateInputValue_logicRuleValue | OntologyIrNotificationTemplateInputValue_recipientValue | OntologyIrNotificationTemplateInputValue_actionTriggererValue;
/**
 * Note that non-visual features e.g. sorting & histograms, are not guaranteed to be currency-aware. They can
 * group the same number together even if they have different currencies.
 */
interface OntologyIrNumberFormatCurrency {
    base: NumberFormatBase;
    currencyCode: OntologyIrPropertyTypeReferenceOrStringConstant;
    style: NumberFormatCurrencyStyle;
}
/**
 * For units that aren't accepted by NumberFormatUnit.
 * No auto-conversion will ever be attempted.
 * This is mostly a label providing instruction on which values can share an axis.
 */
interface OntologyIrNumberFormatCustomUnit {
    base: NumberFormatBase;
    unit: OntologyIrPropertyTypeReferenceOrStringConstant;
}
/**
 * Consider using currency/unit instead of this formatter.
 *
 * Attach an arbitrary constant pre/post-fix.
 */
interface OntologyIrNumberFormatPrePostFix {
    base: NumberFormatBase;
    prePostFix: OntologyIrPrePostFix;
}
interface OntologyIrNumberFormatter_base {
    type: "base";
    base: NumberFormatBase;
}
interface OntologyIrNumberFormatter_percentage {
    type: "percentage";
    percentage: NumberFormatPercentage;
}
interface OntologyIrNumberFormatter_perMille {
    type: "perMille";
    perMille: NumberFormatPerMille;
}
interface OntologyIrNumberFormatter_ordinal {
    type: "ordinal";
    ordinal: NumberFormatOrdinal;
}
interface OntologyIrNumberFormatter_currency {
    type: "currency";
    currency: OntologyIrNumberFormatCurrency;
}
interface OntologyIrNumberFormatter_unit {
    type: "unit";
    unit: OntologyIrNumberFormatUnit;
}
interface OntologyIrNumberFormatter_customUnit {
    type: "customUnit";
    customUnit: OntologyIrNumberFormatCustomUnit;
}
interface OntologyIrNumberFormatter_prePost {
    type: "prePost";
    prePost: OntologyIrNumberFormatPrePostFix;
}
interface OntologyIrNumberFormatter_duration {
    type: "duration";
    duration: NumberFormatDuration;
}
interface OntologyIrNumberFormatter_thousands {
    type: "thousands";
    thousands: NumberFormatThousands;
}
interface OntologyIrNumberFormatter_millions {
    type: "millions";
    millions: NumberFormatMillions;
}
interface OntologyIrNumberFormatter_billions {
    type: "billions";
    billions: NumberFormatBillions;
}
interface OntologyIrNumberFormatter_basisPoint {
    type: "basisPoint";
    basisPoint: NumberFormatBasisPoint;
}
type OntologyIrNumberFormatter = OntologyIrNumberFormatter_base | OntologyIrNumberFormatter_percentage | OntologyIrNumberFormatter_perMille | OntologyIrNumberFormatter_ordinal | OntologyIrNumberFormatter_currency | OntologyIrNumberFormatter_unit | OntologyIrNumberFormatter_customUnit | OntologyIrNumberFormatter_prePost | OntologyIrNumberFormatter_duration | OntologyIrNumberFormatter_thousands | OntologyIrNumberFormatter_millions | OntologyIrNumberFormatter_billions | OntologyIrNumberFormatter_basisPoint;
/**
 * Note that this formatter breaks e.g. sorting features if used in combination with auto-conversion.
 */
interface OntologyIrNumberFormatUnit {
    base: NumberFormatBase;
    unit: OntologyIrPropertyTypeReferenceOrStringConstant;
}
/**
 * Configuration for a time series property that can contain either numeric or non-numeric data. A boolean property
 * reference is required to determine if the series is numeric or non-numeric.
 */
interface OntologyIrNumericOrNonNumericSeriesValueMetadataV2 {
    isNonNumericPropertyTypeId: ObjectTypeFieldApiName;
}
/**
 * Configuration for numeric series.
 */
interface OntologyIrNumericSeriesValueMetadata {
    defaultInternalInterpolation: OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation;
}
interface OntologyIrNumericSeriesValueUnit_standardUnit {
    type: "standardUnit";
    standardUnit: OntologyIrNumberFormatUnit;
}
interface OntologyIrNumericSeriesValueUnit_customUnit {
    type: "customUnit";
    customUnit: OntologyIrNumberFormatCustomUnit;
}
/**
 * The unit to accompany the numeric value of a Time Dependent property. Can be a standardized NumberFormatUnit
 * or a user-inputted NumberFormatCustomUnit for Numeric series. Either can be provided by a property or a
 * user-inputted constant.
 */
type OntologyIrNumericSeriesValueUnit = OntologyIrNumericSeriesValueUnit_standardUnit | OntologyIrNumericSeriesValueUnit_customUnit;
interface OntologyIrObjectParameterPropertyValue {
    parameterId: ParameterId;
    propertyTypeId: ObjectTypeFieldApiName;
}
/**
 * Reference to a struct field of a struct property.
 */
interface OntologyIrObjectParameterStructFieldValue {
    parameterId: ParameterId;
    propertyTypeId: ObjectTypeFieldApiName;
    structFieldRid: StructFieldRid;
}
/**
 * Reference to a struct field of a struct list property.
 */
interface OntologyIrObjectParameterStructListFieldValue {
    parameterId: ParameterId;
    propertyTypeId: ObjectTypeFieldApiName;
    structFieldRid: StructFieldRid;
}
/**
 * Computes the result of an ObjectSet and suggests the value(s) to the user for a parameter.
 */
interface OntologyIrObjectQueryPrefill {
    objectSet: OntologyIrActionsObjectSet;
}
/**
 * Suggests the property value of the object set to the user for a parameter.
 */
interface OntologyIrObjectQueryPropertyValue {
    objectSet: OntologyIrActionsObjectSet;
    propertyTypeId: ObjectTypeFieldApiName;
}
/**
 * Generates an ObjectSetRid, from the provided ObjectSet definition, that would be used as the default value
 * for a ObjectSetRidParameter.
 */
interface OntologyIrObjectSetRidPrefill {
    objectSet: OntologyIrActionsObjectSet;
}
/**
 * Transforms objects in the ObjectSet to all objects on the other end of the specified Relation.
 */
interface OntologyIrObjectSetSearchAround {
    objectTypeId: ObjectTypeApiName;
    relationId: LinkTypeId;
    relationSide: RelationSide;
}
interface OntologyIrObjectSetTransform_propertyFilter {
    type: "propertyFilter";
    propertyFilter: OntologyIrObjectSetFilter;
}
interface OntologyIrObjectSetTransform_searchAround {
    type: "searchAround";
    searchAround: OntologyIrObjectSetSearchAround;
}
/**
 * Transforms an ObjectSet by Filtering or performing a SearchAround.
 */
type OntologyIrObjectSetTransform = OntologyIrObjectSetTransform_propertyFilter | OntologyIrObjectSetTransform_searchAround;
/**
 * An ObjectType is a model that represents a real world concept. For example, there could be
 * an Employees ObjectType to represent the employees in a business organization.
 */
interface OntologyIrObjectType {
    allImplementsInterfaces: Record<InterfaceTypeApiName, OntologyIrObjectTypeInterfaceImplementation>;
    apiName: ObjectTypeApiName;
    displayMetadata: ObjectTypeDisplayMetadata;
    implementsInterfaces2: Array<OntologyIrObjectTypeInterfaceImplementation>;
    primaryKeys: Array<ObjectTypeFieldApiName>;
    propertyTypes: Record<ObjectTypeFieldApiName, OntologyIrPropertyType>;
    redacted?: boolean | null | undefined;
    status: OntologyIrObjectTypeStatus;
    titlePropertyTypeRid: ObjectTypeFieldApiName;
}
/**
 * Object type datasource that is backed by a dataset in foundry, uniquely identified by its rid and
 * branch.
 * Deprecated in favor of ObjectTypeDatasetDatasourceV2
 */
interface OntologyIrObjectTypeDatasetDatasource {
    branchId: BranchId;
    datasetRid: DataSetName;
    propertyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    writebackDatasetRid?: DataSetName | null | undefined;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a dataset in foundry,
 * uniquely identified by its rid and branch. It is only compatible with object storage v2, hence does not
 * have a writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface OntologyIrObjectTypeDatasetDatasourceV2 {
    datasetRid: DataSetName;
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a dataset in foundry,
 * uniquely identified by its rid and branch, and uses PropertySecurityGroups to allow grouping those properties
 * into different security levels. It is only compatible with object storage v2, hence does not have a
 * writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface OntologyIrObjectTypeDatasetDatasourceV3 {
    branchId: BranchId;
    datasetRid: DataSetName;
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
    propertySecurityGroups?: OntologyIrPropertySecurityGroups | null | undefined;
}
interface OntologyIrObjectTypeDatasource {
    datasource: OntologyIrObjectTypeDatasourceDefinition;
    editsConfiguration?: EditsConfiguration | null | undefined;
    redacted?: boolean | null | undefined;
    rid: DatasourceRid;
}
interface OntologyIrObjectTypeDatasourceDefinition_streamV2 {
    type: "streamV2";
    streamV2: OntologyIrObjectTypeStreamDatasourceV2;
}
interface OntologyIrObjectTypeDatasourceDefinition_streamV3 {
    type: "streamV3";
    streamV3: OntologyIrObjectTypeStreamDatasourceV3;
}
interface OntologyIrObjectTypeDatasourceDefinition_timeSeries {
    type: "timeSeries";
    timeSeries: OntologyIrObjectTypeTimeSeriesDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_datasetV2 {
    type: "datasetV2";
    datasetV2: OntologyIrObjectTypeDatasetDatasourceV2;
}
interface OntologyIrObjectTypeDatasourceDefinition_datasetV3 {
    type: "datasetV3";
    datasetV3: OntologyIrObjectTypeDatasetDatasourceV3;
}
interface OntologyIrObjectTypeDatasourceDefinition_restrictedViewV2 {
    type: "restrictedViewV2";
    restrictedViewV2: OntologyIrObjectTypeRestrictedViewDatasourceV2;
}
interface OntologyIrObjectTypeDatasourceDefinition_restrictedStream {
    type: "restrictedStream";
    restrictedStream: OntologyIrObjectTypeRestrictedStreamDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_mediaSetView {
    type: "mediaSetView";
    mediaSetView: OntologyIrObjectTypeMediaSetViewDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_geotimeSeries {
    type: "geotimeSeries";
    geotimeSeries: OntologyIrObjectTypeGeotimeSeriesDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_table {
    type: "table";
    table: OntologyIrObjectTypeTableDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_editsOnly {
    type: "editsOnly";
    editsOnly: OntologyIrObjectTypeEditsOnlyDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_direct {
    type: "direct";
    direct: OntologyIrObjectTypeDirectDatasource;
}
interface OntologyIrObjectTypeDatasourceDefinition_derived {
    type: "derived";
    derived: OntologyIrObjectTypeDerivedPropertiesDatasource;
}
/**
 * Wrapper type for all supported object type datasource types.
 */
type OntologyIrObjectTypeDatasourceDefinition = OntologyIrObjectTypeDatasourceDefinition_streamV2 | OntologyIrObjectTypeDatasourceDefinition_streamV3 | OntologyIrObjectTypeDatasourceDefinition_timeSeries | OntologyIrObjectTypeDatasourceDefinition_datasetV2 | OntologyIrObjectTypeDatasourceDefinition_datasetV3 | OntologyIrObjectTypeDatasourceDefinition_restrictedViewV2 | OntologyIrObjectTypeDatasourceDefinition_restrictedStream | OntologyIrObjectTypeDatasourceDefinition_mediaSetView | OntologyIrObjectTypeDatasourceDefinition_geotimeSeries | OntologyIrObjectTypeDatasourceDefinition_table | OntologyIrObjectTypeDatasourceDefinition_editsOnly | OntologyIrObjectTypeDatasourceDefinition_direct | OntologyIrObjectTypeDatasourceDefinition_derived;
/**
 * Object type datasource which is backed by derived properties definition.
 *
 * This source provides property values that are derived from property types on other object type(s)
 * via links or additional aggregations and computations.
 *
 * Note: if a property type is backed by an ObjectTypeDerivedPropertiesDatasource, the Type of the property
 * type will be resolved by OMS automatically. The TypeForModification will be ignored for that property type.
 *
 * This type is only compatible with object storage v2.
 */
interface OntologyIrObjectTypeDerivedPropertiesDatasource {
    definition: OntologyIrDerivedPropertiesDefinition;
}
/**
 * Object type datasource which is backed by a "direct write" source, such as an edge pipeline. This type
 * of a datasource uses PropertySecurityGroups to allow grouping its properties into different security levels.
 * This type is only compatible with object storage v2.
 */
interface OntologyIrObjectTypeDirectDatasource {
    directSourceRid: DirectSourceRid;
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
    propertySecurityGroups: OntologyIrPropertySecurityGroups;
}
/**
 * Object type datasource which is not backed by any dataset or restricted view. This type of a "datasource"
 * only supports edits-only properties, and uses PropertySecurityGroups to allow grouping those properties into
 * different security levels.
 *
 * This type is only compatible with object storage v2.
 */
interface OntologyIrObjectTypeEditsOnlyDatasource {
    editsOnlyRid?: EditsOnlyRid | null | undefined;
    properties: Array<ObjectTypeFieldApiName>;
    propertySecurityGroups: OntologyIrPropertySecurityGroups;
}
/**
 * Object type datasource that is backed by a Geotime integration, uniquely identified by its rid.
 */
interface OntologyIrObjectTypeGeotimeSeriesDatasource {
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationName;
    properties: Array<ObjectTypeFieldApiName>;
}
/**
 * An interface that an object type implements and metadata on how it implements it.
 */
interface OntologyIrObjectTypeInterfaceImplementation {
    interfaceTypeApiName: InterfaceTypeApiName;
    properties: Record<ObjectTypeFieldApiName, OntologyIrInterfacePropertyImplementation>;
}
/**
 * Object type datasource that is backed by media, uniquely identified by its rid.
 */
interface OntologyIrObjectTypeMediaDatasource {
    mediaSourceRids: Array<OntologyIrMediaSourceRid>;
    properties: Array<ObjectTypeFieldApiName>;
}
/**
 * Object type datasource that is backed by a media set view, uniquely identified by its rid. This datasource
 * differs from ObjectTypeMediaDatasource in that fully controls access to the media items it provides. If a user
 * has access to a property backed by this datasource, they will be able to see the media item it references.
 */
interface OntologyIrObjectTypeMediaSetViewDatasource {
    assumedMarkings: Array<MarkingId>;
    mediaSetViewLocator: MediaSetViewName;
    properties: Array<ObjectTypeFieldApiName>;
}
/**
 * Object type datasource representing a restricted view on top of a stream.
 */
interface OntologyIrObjectTypeRestrictedStreamDatasource {
    policyVersion: PolicyVersion;
    propertyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    restrictedViewRid: RestrictedViewName;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamName;
}
/**
 * Object type datasource that is backed by a restricted view in foundry, uniquely identified by its rid.
 * Deprecated in favor of ObjectTypeRestrictedViewDatasourceV2
 */
interface OntologyIrObjectTypeRestrictedViewDatasource {
    propertyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    restrictedViewRid: RestrictedViewName;
    writebackDatasetRid?: DataSetName | null | undefined;
}
/**
 * Object type datasource supporting edit only property types, that is backed by a restricted view in foundry,
 * uniquely identified by its rid. It is only compatible with object storage v2, hence does not
 * have a writeback dataset. Its property types are mapped to PropertyTypeMappingInfo instead of column names.
 */
interface OntologyIrObjectTypeRestrictedViewDatasourceV2 {
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
    restrictedViewRid: RestrictedViewName;
}
interface OntologyIrObjectTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalObjectTypeStatus;
}
interface OntologyIrObjectTypeStatus_active {
    type: "active";
    active: ActiveObjectTypeStatus;
}
interface OntologyIrObjectTypeStatus_deprecated {
    type: "deprecated";
    deprecated: OntologyIrDeprecatedObjectTypeStatus;
}
interface OntologyIrObjectTypeStatus_example {
    type: "example";
    example: ExampleObjectTypeStatus;
}
interface OntologyIrObjectTypeStatus_endorsed {
    type: "endorsed";
    endorsed: EndorsedObjectTypeStatus;
}
/**
 * The status to indicate whether the ObjectType is either Experimental, Active, Deprecated, Example or Endorsed.
 */
type OntologyIrObjectTypeStatus = OntologyIrObjectTypeStatus_experimental | OntologyIrObjectTypeStatus_active | OntologyIrObjectTypeStatus_deprecated | OntologyIrObjectTypeStatus_example | OntologyIrObjectTypeStatus_endorsed;
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 */
interface OntologyIrObjectTypeStreamDatasource {
    propertyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamName;
}
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 * Supports property security groups and should be used instead of ObjectTypeRestrictedStreamDatasource
 * when granular policies are needed.
 */
interface OntologyIrObjectTypeStreamDatasourceV2 {
    propertyMapping: Record<ObjectTypeFieldApiName, ColumnName>;
    propertySecurityGroups?: OntologyIrPropertySecurityGroups | null | undefined;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamName;
}
/**
 * Object type datasource that is backed by a stream in foundry, uniquely identified by its locator.
 * Supports property security groups and struct property mappings, and should be used instead of
 * ObjectTypeRestrictedStreamDatasourceV2, as that will be deprecated in the near future.
 */
interface OntologyIrObjectTypeStreamDatasourceV3 {
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
    propertySecurityGroups?: OntologyIrPropertySecurityGroups | null | undefined;
    retentionPolicy: RetentionPolicy;
    streamLocator: StreamName;
}
/**
 * Object type datasource that is backed by a table in foundry, uniquely identified by its locator.
 * Supports edit only property types through PropertyTypeMappingInfo.
 */
interface OntologyIrObjectTypeTableDatasource {
    branchId: BranchId;
    propertyMapping: Record<ObjectTypeFieldApiName, PropertyTypeMappingInfo>;
    tableRid: TableRid;
}
/**
 * Object type datasource that is backed by a time series sync, uniquely identified by its rid.
 */
interface OntologyIrObjectTypeTimeSeriesDatasource {
    properties: Array<ObjectTypeFieldApiName>;
    timeSeriesSyncRid: TimeSeriesSyncName;
}
interface OntologyIrObjectTypeTraits {
    actionLogMetadata?: OntologyIrActionLogMetadata | null | undefined;
    eventMetadata?: OntologyIrEventMetadata | null | undefined;
    peeringMetadata?: ObjectTypePeeringMetadata | null | undefined;
    sensorTrait?: OntologyIrSensorTrait | null | undefined;
    timeSeriesMetadata?: OntologyIrTimeSeriesMetadata | null | undefined;
    workflowObjectTypeTraits: Record<WorkflowObjectTypeTraitId, Record<WorkflowObjectTypeTraitVersion, OntologyIrWorkflowObjectTypeTraitImpl>>;
}
interface OntologyIrOneToManyLinkDefinition {
    cardinalityHint: OneToManyLinkCardinalityHint;
    manyToOneLinkMetadata: LinkTypeMetadata;
    objectTypeRidManySide: ObjectTypeApiName;
    objectTypeRidOneSide: ObjectTypeApiName;
    oneSidePrimaryKeyToManySidePropertyMapping: Array<OntologyIrPropertyToPropertyMapping>;
    oneToManyLinkMetadata: LinkTypeMetadata;
}
interface OntologyIrOrCondition {
    conditions: Array<OntologyIrCondition>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
/**
 * Parameters of an ActionType represent what inputs the ActionType requires.
 */
interface OntologyIrParameter {
    displayMetadata: OntologyIrParameterDisplayMetadata;
    id: ParameterId;
    type: OntologyIrBaseParameterType;
}
/**
 * Notification recipients determined from Action's inputs.
 */
interface OntologyIrParameterActionNotificationRecipients {
    principalIds: OntologyIrLogicRuleValue;
}
/**
 * Contains a non-empty MarkingList Value that represent the max classification of this parameter.
 * It must be present and must contain a valid set of cbac markings.
 */
interface OntologyIrParameterCbacConstraint {
    markingsValue?: OntologyIrConditionValue | null | undefined;
}
interface OntologyIrParameterCbacMarking {
    classificationConstraint?: OntologyIrParameterCbacConstraint | null | undefined;
}
interface OntologyIrParameterCbacMarkingOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterCbacMarkingOrEmpty_cbacMarking {
    type: "cbacMarking";
    cbacMarking: OntologyIrParameterCbacMarking;
}
/**
 * Allows values that satisfy the cbacMarking max classification. If empty, it will only allow empty values.
 */
type OntologyIrParameterCbacMarkingOrEmpty = OntologyIrParameterCbacMarkingOrEmpty_empty | OntologyIrParameterCbacMarkingOrEmpty_cbacMarking;
interface OntologyIrParameterDateRangeValue {
    inclusive: boolean;
    value: OntologyIrDateRangeValue;
}
interface OntologyIrParameterDateTimeRange {
    maximum?: OntologyIrParameterDateRangeValue | null | undefined;
    minimum?: OntologyIrParameterDateRangeValue | null | undefined;
}
interface OntologyIrParameterDateTimeRangeOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterDateTimeRangeOrEmpty_datetime {
    type: "datetime";
    datetime: OntologyIrParameterDateTimeRange;
}
type OntologyIrParameterDateTimeRangeOrEmpty = OntologyIrParameterDateTimeRangeOrEmpty_empty | OntologyIrParameterDateTimeRangeOrEmpty_datetime;
interface OntologyIrParameterDisplayMetadata {
    description: string;
    displayName: string;
    typeClasses: Array<TypeClass>;
}
interface OntologyIrParameterMultipassUser {
    filter: Array<OntologyIrMultipassUserFilter>;
}
interface OntologyIrParameterMultipassUserOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterMultipassUserOrEmpty_user {
    type: "user";
    user: OntologyIrParameterMultipassUser;
}
type OntologyIrParameterMultipassUserOrEmpty = OntologyIrParameterMultipassUserOrEmpty_empty | OntologyIrParameterMultipassUserOrEmpty_user;
/**
 * Generates a set of allowed values from the specified property of the objects in the objectSet.
 * For example All the names from the `assignedTo` property of tickets in an objectSet.
 */
interface OntologyIrParameterObjectPropertyValue {
    objectSet: OntologyIrActionsObjectSet;
    otherValueAllowed?: OtherValueAllowed | null | undefined;
    propertyTypeId: ObjectTypeFieldApiName;
}
interface OntologyIrParameterObjectPropertyValueOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterObjectPropertyValueOrEmpty_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: OntologyIrParameterObjectPropertyValue;
}
/**
 * Allows values that satisfy the objectPropertyValue. If empty, it will only allow empty values.
 */
type OntologyIrParameterObjectPropertyValueOrEmpty = OntologyIrParameterObjectPropertyValueOrEmpty_empty | OntologyIrParameterObjectPropertyValueOrEmpty_objectPropertyValue;
/**
 * Only allows Objects that are in this Dynamic Object Set at Execution time.
 */
interface OntologyIrParameterObjectQuery {
    objectSet?: OntologyIrActionsObjectSet | null | undefined;
}
interface OntologyIrParameterObjectQueryOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterObjectQueryOrEmpty_objectQuery {
    type: "objectQuery";
    objectQuery: OntologyIrParameterObjectQuery;
}
/**
 * Allows values that satisfy the objectQuery. If empty, it will only allow empty values.
 */
type OntologyIrParameterObjectQueryOrEmpty = OntologyIrParameterObjectQueryOrEmpty_empty | OntologyIrParameterObjectQueryOrEmpty_objectQuery;
/**
 * Allows ObjectTypeReference values where the object type implements the specified interfaces.
 */
interface OntologyIrParameterObjectTypeReference {
    interfaceTypeRids: Array<InterfaceTypeApiName>;
}
interface OntologyIrParameterObjectTypeReferenceOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterObjectTypeReferenceOrEmpty_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: OntologyIrParameterObjectTypeReference;
}
type OntologyIrParameterObjectTypeReferenceOrEmpty = OntologyIrParameterObjectTypeReferenceOrEmpty_empty | OntologyIrParameterObjectTypeReferenceOrEmpty_objectTypeReference;
interface OntologyIrParameterPrefill_staticValue {
    type: "staticValue";
    staticValue: OntologyIrStaticValue;
}
interface OntologyIrParameterPrefill_staticObject {
    type: "staticObject";
    staticObject: StaticObjectPrefill;
}
interface OntologyIrParameterPrefill_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: OntologyIrObjectParameterPropertyValue;
}
interface OntologyIrParameterPrefill_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: OntologyIrInterfaceParameterPropertyValue;
}
interface OntologyIrParameterPrefill_objectQueryPrefill {
    type: "objectQueryPrefill";
    objectQueryPrefill: OntologyIrObjectQueryPrefill;
}
interface OntologyIrParameterPrefill_objectQueryPropertyValue {
    type: "objectQueryPropertyValue";
    objectQueryPropertyValue: OntologyIrObjectQueryPropertyValue;
}
interface OntologyIrParameterPrefill_objectSetRidPrefill {
    type: "objectSetRidPrefill";
    objectSetRidPrefill: OntologyIrObjectSetRidPrefill;
}
interface OntologyIrParameterPrefill_redacted {
    type: "redacted";
    redacted: Redacted;
}
/**
 * ParameterPrefill specifies what should initially suggested to users for this Parameter.
 */
type OntologyIrParameterPrefill = OntologyIrParameterPrefill_staticValue | OntologyIrParameterPrefill_staticObject | OntologyIrParameterPrefill_objectParameterPropertyValue | OntologyIrParameterPrefill_interfaceParameterPropertyValue | OntologyIrParameterPrefill_objectQueryPrefill | OntologyIrParameterPrefill_objectQueryPropertyValue | OntologyIrParameterPrefill_objectSetRidPrefill | OntologyIrParameterPrefill_redacted;
interface OntologyIrParameterPrefillOverride {
    prefill: OntologyIrParameterPrefill;
}
interface OntologyIrParameterRange {
    maximum?: OntologyIrParameterRangeValue | null | undefined;
    minimum?: OntologyIrParameterRangeValue | null | undefined;
}
interface OntologyIrParameterRangeOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterRangeOrEmpty_range {
    type: "range";
    range: OntologyIrParameterRange;
}
type OntologyIrParameterRangeOrEmpty = OntologyIrParameterRangeOrEmpty_empty | OntologyIrParameterRangeOrEmpty_range;
interface OntologyIrParameterRangeValue {
    inclusive: boolean;
    value: OntologyIrConditionValue;
}
interface OntologyIrParameterValidation {
    allowedValues: OntologyIrAllowedParameterValues;
    required: ParameterRequiredConfiguration;
}
interface OntologyIrParameterValidationBlock {
    display: OntologyIrParameterValidationDisplayMetadata;
    validation: OntologyIrParameterValidation;
}
interface OntologyIrParameterValidationBlockOverride_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface OntologyIrParameterValidationBlockOverride_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface OntologyIrParameterValidationBlockOverride_allowedValues {
    type: "allowedValues";
    allowedValues: OntologyIrAllowedValuesOverride;
}
interface OntologyIrParameterValidationBlockOverride_prefill {
    type: "prefill";
    prefill: OntologyIrParameterPrefillOverride;
}
type OntologyIrParameterValidationBlockOverride = OntologyIrParameterValidationBlockOverride_parameterRequired | OntologyIrParameterValidationBlockOverride_visibility | OntologyIrParameterValidationBlockOverride_allowedValues | OntologyIrParameterValidationBlockOverride_prefill;
/**
 * These values provide details about how parameter fields should be displayed in the form. They are not used to
 * evaluate correctness of submitted parameters.
 */
interface OntologyIrParameterValidationDisplayMetadata {
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
interface OntologyIrParameterValueOneOf {
    labelledValues: Array<OntologyIrLabelledValue>;
    otherValueAllowed: OtherValueAllowed;
}
interface OntologyIrParameterValueOneOfOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface OntologyIrParameterValueOneOfOrEmpty_oneOf {
    type: "oneOf";
    oneOf: OntologyIrParameterValueOneOf;
}
type OntologyIrParameterValueOneOfOrEmpty = OntologyIrParameterValueOneOfOrEmpty_empty | OntologyIrParameterValueOneOfOrEmpty_oneOf;
interface OntologyIrPrePostFix {
    postfix?: OntologyIrPropertyTypeReferenceOrStringConstant | null | undefined;
    prefix?: OntologyIrPropertyTypeReferenceOrStringConstant | null | undefined;
}
/**
 * Defines a grouping of properties sharing the same security.
 *
 * One and exactly one of the specified groups must contain the primary key property(ies). If there
 * are multiple primary key properties, they must belong to the same property group. The security of the
 * property group that includes the primary key also specifies overall object visibility: if the user does not
 * pass this property group's security, the entire object is invisible, regardless of visibility of other
 * property groups.
 */
interface OntologyIrPropertySecurityGroup {
    properties: Array<ObjectTypeFieldApiName>;
    rid: PropertySecurityGroupRid;
    security: OntologyIrSecurityGroupSecurityDefinition;
    type?: PropertySecurityGroupType | null | undefined;
}
/**
 * Groupings of properties into different security "buckets." Every property of the entity type must belong
 * to one and only one property security group.
 */
interface OntologyIrPropertySecurityGroups {
    groups: Array<OntologyIrPropertySecurityGroup>;
}
/**
 * A PropertyType is a typed attribute of an ObjectType.
 */
interface OntologyIrPropertyType {
    apiName: ObjectTypeFieldApiName;
    baseFormatter?: OntologyIrBaseFormatter | null | undefined;
    dataConstraints?: DataConstraints | null | undefined;
    displayMetadata: PropertyTypeDisplayMetadata;
    indexedForSearch: boolean;
    inlineAction?: OntologyIrInlineActionType | null | undefined;
    ruleSetBinding?: OntologyIrRuleSetBinding | null | undefined;
    sharedPropertyTypeApiName?: ObjectTypeFieldApiName | null | undefined;
    sharedPropertyTypeRid?: ObjectTypeFieldApiName | null | undefined;
    status: OntologyIrPropertyTypeStatus;
    type: OntologyIrType;
    typeClasses: Array<TypeClass>;
    valueType?: ValueTypeApiNameReference | null | undefined;
}
interface OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType {
    type: "propertyType";
    propertyType: ObjectTypeFieldApiName;
}
interface OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation {
    type: "internalInterpolation";
    internalInterpolation: NonNumericInternalInterpolation;
}
type OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation = OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType | OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation;
interface OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_propertyType {
    type: "propertyType";
    propertyType: ObjectTypeFieldApiName;
}
interface OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation {
    type: "internalInterpolation";
    internalInterpolation: NumericInternalInterpolation;
}
type OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation = OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_propertyType | OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation;
interface OntologyIrPropertyTypeReferenceOrStringConstant_constant {
    type: "constant";
    constant: string;
}
interface OntologyIrPropertyTypeReferenceOrStringConstant_propertyType {
    type: "propertyType";
    propertyType: ObjectTypeFieldApiName;
}
type OntologyIrPropertyTypeReferenceOrStringConstant = OntologyIrPropertyTypeReferenceOrStringConstant_constant | OntologyIrPropertyTypeReferenceOrStringConstant_propertyType;
interface OntologyIrPropertyTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalPropertyTypeStatus;
}
interface OntologyIrPropertyTypeStatus_active {
    type: "active";
    active: ActivePropertyTypeStatus;
}
interface OntologyIrPropertyTypeStatus_deprecated {
    type: "deprecated";
    deprecated: OntologyIrDeprecatedPropertyTypeStatus;
}
interface OntologyIrPropertyTypeStatus_example {
    type: "example";
    example: ExamplePropertyTypeStatus;
}
/**
 * The status to indicate whether the PropertyType is either Experimental, Active, Deprecated, or Example.
 */
type OntologyIrPropertyTypeStatus = OntologyIrPropertyTypeStatus_experimental | OntologyIrPropertyTypeStatus_active | OntologyIrPropertyTypeStatus_deprecated | OntologyIrPropertyTypeStatus_example;
/**
 * Codex seriesId qualified with a time series syncRid
 */
interface OntologyIrQualifiedSeriesIdPropertyValue {
    seriesId: SeriesIdPropertyValue;
    syncRid: TimeSeriesSyncName;
}
interface OntologyIrRegexCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    regex: string;
    value: OntologyIrConditionValue;
}
/**
 * A URL target for a Foundry rid with query params.
 */
interface OntologyIrRidUrlTarget {
    queryParams: Record<string, OntologyIrLogicRuleValue>;
    rid: OntologyIrLogicRuleValue;
}
/**
 * Bind a rule set to a practical use. This enables re-use of rule sets in various contexts (e.g. values can
 * be bound to properties, or to actions). The `it` value is considered special & have semantic meaning at the
 * binding point (e.g. the property to which the rule set is bound).
 */
interface OntologyIrRuleSetBinding {
    bindings: Record<ValueReferenceId, OntologyIrValueReferenceSource>;
    ruleSetRid: RuleSetRid;
}
/**
 * A physical and logical grouping of parameters on the action form.
 */
interface OntologyIrSection {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    id: SectionId;
}
/**
 * This block contains a conditional override for a section.
 * This includes the condition to test and the new display parameters to use if the condition passes.
 */
interface OntologyIrSectionConditionalOverride {
    condition: OntologyIrCondition;
    sectionBlockOverrides: Array<SectionDisplayBlockOverride>;
}
/**
 * Contains information about the section display and any conditional overrides set on the section.
 * If more than one conditional override is passed. The first one with a passing condition will take priority.
 */
interface OntologyIrSectionDisplayBlock {
    conditionalOverrides: Array<OntologyIrSectionConditionalOverride>;
    defaultDisplayMetadata: SectionValidationDisplayMetadata;
}
interface OntologyIrSecurityGroupAndCondition {
    conditions: Array<OntologyIrSecurityGroupGranularCondition>;
}
interface OntologyIrSecurityGroupComparisonCondition {
    left: OntologyIrSecurityGroupComparisonValue;
    operator: SecurityGroupComparisonOperator;
    right: OntologyIrSecurityGroupComparisonValue;
}
interface OntologyIrSecurityGroupComparisonValue_constant {
    type: "constant";
    constant: SecurityGroupComparisonConstant;
}
interface OntologyIrSecurityGroupComparisonValue_property {
    type: "property";
    property: ObjectTypeFieldApiName;
}
interface OntologyIrSecurityGroupComparisonValue_userProperty {
    type: "userProperty";
    userProperty: SecurityGroupComparisonUserProperty;
}
type OntologyIrSecurityGroupComparisonValue = OntologyIrSecurityGroupComparisonValue_constant | OntologyIrSecurityGroupComparisonValue_property | OntologyIrSecurityGroupComparisonValue_userProperty;
interface OntologyIrSecurityGroupGranularCondition_not {
    type: "not";
    not: OntologyIrSecurityGroupNotCondition;
}
interface OntologyIrSecurityGroupGranularCondition_true {
    type: "true";
    true: SecurityGroupTrueCondition;
}
interface OntologyIrSecurityGroupGranularCondition_and {
    type: "and";
    and: OntologyIrSecurityGroupAndCondition;
}
interface OntologyIrSecurityGroupGranularCondition_or {
    type: "or";
    or: OntologyIrSecurityGroupOrCondition;
}
interface OntologyIrSecurityGroupGranularCondition_markings {
    type: "markings";
    markings: OntologyIrSecurityGroupMarkingsCondition;
}
interface OntologyIrSecurityGroupGranularCondition_comparison {
    type: "comparison";
    comparison: OntologyIrSecurityGroupComparisonCondition;
}
/**
 * This definition is a subset of the full GPS policy definition language. It contains minimal supported conditions.
 * Note that more conditions can and will be added in the future, as the need arises.
 */
type OntologyIrSecurityGroupGranularCondition = OntologyIrSecurityGroupGranularCondition_not | OntologyIrSecurityGroupGranularCondition_true | OntologyIrSecurityGroupGranularCondition_and | OntologyIrSecurityGroupGranularCondition_or | OntologyIrSecurityGroupGranularCondition_markings | OntologyIrSecurityGroupGranularCondition_comparison;
/**
 * Ontology-managed granular security applied to the properties in the group. User must also first satisfy the
 * additionalMandatory security markings, if any are specified, to have visibility to the properties within
 * this group that are allowed by the granular policy.
 *
 * The granular policy specified must be authorized by the overall ObjectTypeDatasource's dataSecurity for
 * every "row" (object or relation).
 */
interface OntologyIrSecurityGroupGranularPolicy {
    additionalMandatory: SecurityGroupMandatoryPolicy;
    granularPolicyCondition: OntologyIrSecurityGroupGranularCondition;
}
/**
 * Ontology-managed granular policy applied to the properties in the group.
 */
interface OntologyIrSecurityGroupGranularSecurityDefinition {
    viewPolicy: OntologyIrSecurityGroupGranularPolicy;
}
/**
 * Condition that specifies that user's markings must be evaluated against the marking(s) contained on each
 * object's 'property'.
 *
 * Note that the specified property's propertyType must be of type MarkingPropertyType or ArrayPropertyType
 * of MarkingPropertyTypes.
 */
interface OntologyIrSecurityGroupMarkingsCondition {
    property: ObjectTypeFieldApiName;
}
/**
 * True if the condition is false. This condition cannot have an empty property type.
 */
interface OntologyIrSecurityGroupNotCondition {
    condition: OntologyIrSecurityGroupGranularCondition;
}
interface OntologyIrSecurityGroupOrCondition {
    conditions: Array<OntologyIrSecurityGroupGranularCondition>;
}
interface OntologyIrSecurityGroupSecurityDefinition_mandatoryOnly {
    type: "mandatoryOnly";
    mandatoryOnly: SecurityGroupMandatoryOnlySecurityDefinition;
}
interface OntologyIrSecurityGroupSecurityDefinition_granular {
    type: "granular";
    granular: OntologyIrSecurityGroupGranularSecurityDefinition;
}
type OntologyIrSecurityGroupSecurityDefinition = OntologyIrSecurityGroupSecurityDefinition_mandatoryOnly | OntologyIrSecurityGroupSecurityDefinition_granular;
interface OntologyIrSensorTrait {
    readingPropertyTypeRid: ObjectTypeFieldApiName;
}
interface OntologyIrSeriesValueMetadata_numeric {
    type: "numeric";
    numeric: OntologyIrNumericSeriesValueMetadata;
}
interface OntologyIrSeriesValueMetadata_enum {
    type: "enum";
    enum: OntologyIrNonNumericSeriesValueMetadata;
}
interface OntologyIrSeriesValueMetadata_numericOrNonNumeric {
    type: "numericOrNonNumeric";
    numericOrNonNumeric: NumericOrNonNumericSeriesValueMetadata;
}
interface OntologyIrSeriesValueMetadata_numericOrNonNumericV2 {
    type: "numericOrNonNumericV2";
    numericOrNonNumericV2: OntologyIrNumericOrNonNumericSeriesValueMetadataV2;
}
type OntologyIrSeriesValueMetadata = OntologyIrSeriesValueMetadata_numeric | OntologyIrSeriesValueMetadata_enum | OntologyIrSeriesValueMetadata_numericOrNonNumeric | OntologyIrSeriesValueMetadata_numericOrNonNumericV2;
/**
 * A property type that can be shared across object types.
 */
interface OntologyIrSharedPropertyType {
    aliases: Array<SharedPropertyTypeAlias>;
    apiName: ObjectTypeFieldApiName;
    baseFormatter?: OntologyIrBaseFormatter | null | undefined;
    dataConstraints?: DataConstraints | null | undefined;
    displayMetadata: SharedPropertyTypeDisplayMetadata;
    gothamMapping?: SharedPropertyTypeGothamMapping | null | undefined;
    indexedForSearch: boolean;
    type: OntologyIrType;
    typeClasses: Array<TypeClass>;
    valueType?: ValueTypeApiNameReference | null | undefined;
}
interface OntologyIrShortBody_basic {
    type: "basic";
    basic: OntologyIrStructuredShortBody;
}
/**
 * An action notification's short body. Generally used for in-platform notifications. Uses Handlebars
 * templating.
 */
type OntologyIrShortBody = OntologyIrShortBody_basic;
type OntologyIrStaticValue = OntologyIrDataValue;
/**
 * This webhook config will run the webhook given the input mapping provided. The webhook input parameters map
 * to Action logic rule values, such as parameters.
 */
interface OntologyIrStaticWebhookWithDirectInput {
    webhookInputValues: Record<WebhookInputParamName, OntologyIrLogicRuleValue>;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
/**
 * This webhook config will run the function given the input mapping provided. It will then run the webhook given
 * the result of the function as input. It expects a custom type containing all the expected webhook inputs.
 * e.g. An example of the expected return type from the Function:
 * ```
 * export interface WebhookResult {
 * arg1: string;
 * arg2: string;
 * }
 * export class MyFunctions {
 * @Function()
 * public createWebhookRequest(person: Person): WebhookResult {
 * return {
 * arg1: person.someProperty,
 * arg2: person.someOtherProperty,
 * };
 * }
 * }
 * If one of the Webhook inputs is a RecordType, it must have expectedFields defined and match exactly the custom
 * type.
 * ```
 */
interface OntologyIrStaticWebhookWithFunctionResultInput {
    functionInputValues: Record<FunctionInputName, OntologyIrLogicRuleValue>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
interface OntologyIrStructFieldConditionalOverride {
    condition: OntologyIrCondition;
    structFieldBlockOverrides: Array<OntologyIrStructFieldValidationBlockOverride>;
}
interface OntologyIrStructFieldConditionalValidationBlock {
    conditionalOverrides: Array<OntologyIrStructFieldConditionalOverride>;
    defaultValidation: OntologyIrStructFieldValidationBlock;
}
interface OntologyIrStructFieldPrefill_objectParameterStructFieldValue {
    type: "objectParameterStructFieldValue";
    objectParameterStructFieldValue: OntologyIrObjectParameterStructFieldValue;
}
interface OntologyIrStructFieldPrefill_objectParameterStructListFieldValue {
    type: "objectParameterStructListFieldValue";
    objectParameterStructListFieldValue: OntologyIrObjectParameterStructListFieldValue;
}
/**
 * StructFieldPrefill specifies what should initially suggested to users for a struct parameter's field.
 */
type OntologyIrStructFieldPrefill = OntologyIrStructFieldPrefill_objectParameterStructFieldValue | OntologyIrStructFieldPrefill_objectParameterStructListFieldValue;
interface OntologyIrStructFieldPrefillOverride {
    prefill: OntologyIrStructFieldPrefill;
}
/**
 * Represents an ordered set of fields and values.
 */
interface OntologyIrStructFieldType {
    aliases: Array<StructFieldAlias>;
    apiName: ObjectTypeFieldApiName;
    displayMetadata: StructFieldDisplayMetadata;
    fieldType: OntologyIrType;
    typeClasses: Array<TypeClass>;
}
interface OntologyIrStructFieldValidation {
    allowedValues: OntologyIrAllowedStructFieldValues;
    required: ParameterRequiredConfiguration;
}
interface OntologyIrStructFieldValidationBlock {
    display: OntologyIrStructFieldValidationDisplayMetadata;
    validation: OntologyIrStructFieldValidation;
}
interface OntologyIrStructFieldValidationBlockOverride_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface OntologyIrStructFieldValidationBlockOverride_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface OntologyIrStructFieldValidationBlockOverride_allowedValues {
    type: "allowedValues";
    allowedValues: OntologyIrAllowedStructFieldValuesOverride;
}
interface OntologyIrStructFieldValidationBlockOverride_prefill {
    type: "prefill";
    prefill: OntologyIrStructFieldPrefillOverride;
}
type OntologyIrStructFieldValidationBlockOverride = OntologyIrStructFieldValidationBlockOverride_parameterRequired | OntologyIrStructFieldValidationBlockOverride_visibility | OntologyIrStructFieldValidationBlockOverride_allowedValues | OntologyIrStructFieldValidationBlockOverride_prefill;
/**
 * These values provide details about how struct parameter nested fields should be displayed in the form.
 */
interface OntologyIrStructFieldValidationDisplayMetadata {
    prefill?: OntologyIrStructFieldPrefill | null | undefined;
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
interface OntologyIrStructPropertyType {
    structFields: Array<OntologyIrStructFieldType>;
}
/**
 * An action notification's structured short body.
 */
interface OntologyIrStructuredShortBody {
    content: string;
    heading: string;
    links: Array<OntologyIrNotificationResultTypeLink>;
}
interface OntologyIrSynchronousPreWritebackWebhook_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: OntologyIrStaticWebhookWithDirectInput;
}
interface OntologyIrSynchronousPreWritebackWebhook_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: OntologyIrStaticWebhookWithFunctionResultInput;
}
/**
 * Union wrapping the various options available for configuring a webhook which will be executed synchronously,
 * prior to writeback. If it fails, the Foundry writeback will be cancelled. This webhook is executed after
 * validations run and pass successfully.
 */
type OntologyIrSynchronousPreWritebackWebhook = OntologyIrSynchronousPreWritebackWebhook_staticDirectInput | OntologyIrSynchronousPreWritebackWebhook_staticFunctionInput;
/**
 * The body of a notification based on a template.
 */
interface OntologyIrTemplateNotificationBody {
    emailBody: OntologyIrEmailBody;
    inputs: Record<HandlebarsInputName, OntologyIrNotificationTemplateInputValue>;
    shortBody: OntologyIrShortBody;
}
/**
 * Formatter applied to TIME DEPENDENT properties.
 */
interface OntologyIrTimeDependentFormatter {
    timeDependentSeriesFormat: OntologyIrTimeDependentSeriesFormat;
}
/**
 * Configuration for non-numeric series.
 */
interface OntologyIrTimeDependentNonNumericSeriesFormat {
    defaultInternalInterpolation: OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation;
    unit?: OntologyIrNonNumericSeriesValueUnit | null | undefined;
}
/**
 * Configuration for either numeric or non-numeric series.
 */
interface OntologyIrTimeDependentNumericOrNonNumericSeriesFormat {
    defaultInternalInterpolationPropertyTypeId: ObjectTypeFieldApiName;
    isNonNumericPropertyTypeId: ObjectTypeFieldApiName;
    unitPropertyTypeId: ObjectTypeFieldApiName;
}
/**
 * Configuration for either numeric or non-numeric series.
 */
interface OntologyIrTimeDependentNumericOrNonNumericSeriesFormatV2 {
    defaultInternalInterpolationPropertyTypeId?: ObjectTypeFieldApiName | null | undefined;
    unitPropertyTypeId?: ObjectTypeFieldApiName | null | undefined;
}
/**
 * Configuration for numeric series.
 */
interface OntologyIrTimeDependentNumericSeriesFormat {
    defaultInternalInterpolation: OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation;
    unit?: OntologyIrNumericSeriesValueUnit | null | undefined;
}
interface OntologyIrTimeDependentSeriesFormat_numeric {
    type: "numeric";
    numeric: OntologyIrTimeDependentNumericSeriesFormat;
}
interface OntologyIrTimeDependentSeriesFormat_nonNumeric {
    type: "nonNumeric";
    nonNumeric: OntologyIrTimeDependentNonNumericSeriesFormat;
}
interface OntologyIrTimeDependentSeriesFormat_numericOrNonNumeric {
    type: "numericOrNonNumeric";
    numericOrNonNumeric: OntologyIrTimeDependentNumericOrNonNumericSeriesFormat;
}
interface OntologyIrTimeDependentSeriesFormat_numericOrNonNumericV2 {
    type: "numericOrNonNumericV2";
    numericOrNonNumericV2: OntologyIrTimeDependentNumericOrNonNumericSeriesFormatV2;
}
type OntologyIrTimeDependentSeriesFormat = OntologyIrTimeDependentSeriesFormat_numeric | OntologyIrTimeDependentSeriesFormat_nonNumeric | OntologyIrTimeDependentSeriesFormat_numericOrNonNumeric | OntologyIrTimeDependentSeriesFormat_numericOrNonNumericV2;
/**
 * Describes how to treat an object of this type as a time series.
 */
interface OntologyIrTimeSeriesMetadata {
    measurePropertyTypeRid?: ObjectTypeFieldApiName | null | undefined;
    timeSeriesIdPropertyTypeRid: ObjectTypeFieldApiName;
    valueUnitsPropertyTypeRid?: ObjectTypeFieldApiName | null | undefined;
}
interface OntologyIrTimestampFormatter {
    displayTimezone: OntologyIrDatetimeTimezone;
    format: DatetimeFormat;
}
interface OntologyIrType_array {
    type: "array";
    array: OntologyIrArrayPropertyType;
}
interface OntologyIrType_boolean {
    type: "boolean";
    boolean: BooleanPropertyType;
}
interface OntologyIrType_byte {
    type: "byte";
    byte: BytePropertyType;
}
interface OntologyIrType_date {
    type: "date";
    date: DatePropertyType;
}
interface OntologyIrType_decimal {
    type: "decimal";
    decimal: DecimalPropertyType;
}
interface OntologyIrType_double {
    type: "double";
    double: DoublePropertyType;
}
interface OntologyIrType_float {
    type: "float";
    float: FloatPropertyType;
}
interface OntologyIrType_geohash {
    type: "geohash";
    geohash: GeohashPropertyType;
}
interface OntologyIrType_geoshape {
    type: "geoshape";
    geoshape: GeoshapePropertyType;
}
interface OntologyIrType_integer {
    type: "integer";
    integer: IntegerPropertyType;
}
interface OntologyIrType_long {
    type: "long";
    long: LongPropertyType;
}
interface OntologyIrType_short {
    type: "short";
    short: ShortPropertyType;
}
interface OntologyIrType_string {
    type: "string";
    string: StringPropertyType;
}
interface OntologyIrType_experimentalTimeDependentV1 {
    type: "experimentalTimeDependentV1";
    experimentalTimeDependentV1: OntologyIrExperimentalTimeDependentPropertyTypeV1;
}
interface OntologyIrType_timestamp {
    type: "timestamp";
    timestamp: TimestampPropertyType;
}
interface OntologyIrType_attachment {
    type: "attachment";
    attachment: AttachmentPropertyType;
}
interface OntologyIrType_marking {
    type: "marking";
    marking: MarkingPropertyType;
}
interface OntologyIrType_cipherText {
    type: "cipherText";
    cipherText: OntologyIrCipherTextPropertyType;
}
interface OntologyIrType_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferencePropertyType;
}
interface OntologyIrType_vector {
    type: "vector";
    vector: VectorPropertyType;
}
interface OntologyIrType_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferencePropertyType;
}
interface OntologyIrType_struct {
    type: "struct";
    struct: OntologyIrStructPropertyType;
}
/**
 * Wrapper type for the various supported property types.
 *
 * Note: this type also encodes information on how to store the property. Use `DataType` if only the raw type
 * information matters (e.g. this format condition input must be a string).
 */
type OntologyIrType = OntologyIrType_array | OntologyIrType_boolean | OntologyIrType_byte | OntologyIrType_date | OntologyIrType_decimal | OntologyIrType_double | OntologyIrType_float | OntologyIrType_geohash | OntologyIrType_geoshape | OntologyIrType_integer | OntologyIrType_long | OntologyIrType_short | OntologyIrType_string | OntologyIrType_experimentalTimeDependentV1 | OntologyIrType_timestamp | OntologyIrType_attachment | OntologyIrType_marking | OntologyIrType_cipherText | OntologyIrType_mediaReference | OntologyIrType_vector | OntologyIrType_geotimeSeriesReference | OntologyIrType_struct;
interface OntologyIrUrlTarget_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: OntologyIrLogicRuleValue;
}
interface OntologyIrUrlTarget_rid {
    type: "rid";
    rid: OntologyIrRidUrlTarget;
}
interface OntologyIrUrlTarget_relativeUrlString {
    type: "relativeUrlString";
    relativeUrlString: string;
}
interface OntologyIrUrlTarget_newObject {
    type: "newObject";
    newObject: OntologyIrNewObjectUrlTarget;
}
interface OntologyIrUrlTarget_carbonWorkspace {
    type: "carbonWorkspace";
    carbonWorkspace: OntologyIrCarbonWorkspaceUrlTarget;
}
/**
 * The target for generating a URL.
 */
type OntologyIrUrlTarget = OntologyIrUrlTarget_logicRuleValue | OntologyIrUrlTarget_rid | OntologyIrUrlTarget_relativeUrlString | OntologyIrUrlTarget_newObject | OntologyIrUrlTarget_carbonWorkspace;
interface OntologyIrValidationRule {
    condition: OntologyIrCondition;
    displayMetadata: ValidationRuleDisplayMetadata;
}
interface OntologyIrValueReferenceSource_propertyTypeRid {
    type: "propertyTypeRid";
    propertyTypeRid: ObjectTypeFieldApiName;
}
type OntologyIrValueReferenceSource = OntologyIrValueReferenceSource_propertyTypeRid;
/**
 * A mapping between the `WorkflowObjectTypeTraitPropertyId` of the `WorkflowObjectTypeTrait` to the `PropertyRid` of the `ObjectType` it is to be associated with.
 */
interface OntologyIrWorkflowObjectTypeTraitImpl {
    mapping: Record<WorkflowObjectTypeTraitPropertyId, ObjectTypeFieldApiName>;
    reference: WorkflowObjectTypeTraitReference;
}
/**
 * Request to load all Ontology entities.
 */
interface OntologyLoadAllEntitiesRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
    ontologyVersion?: OntologyVersion | null | undefined;
}
/**
 * This has been deprecated. Please refer to documentation of the `loadAllOntology` endpoint for
 * the recommended alternative.
 */
interface OntologyLoadAllRequest {
    ontologyVersion?: OntologyVersion | null | undefined;
}
/**
 * Request to load datasources for the specified Ontology entities.
 */
interface OntologyLoadDatasourcesRequest {
    datasourceTypes: Array<DatasourceType>;
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    loadRedacted?: boolean | null | undefined;
    manyToManyLinkTypes: Record<LinkTypeRid, OntologyVersion | null | undefined>;
    objectTypes: Record<ObjectTypeRid, OntologyVersion | null | undefined>;
}
/**
 * Response to OntologyLoadDatasourcesRequest.
 */
interface OntologyLoadDatasourcesResponse {
    manyToManyLinkTypes: Record<LinkTypeRid, Array<ManyToManyLinkTypeDatasource>>;
    objectTypes: Record<ObjectTypeRid, Array<ObjectTypeDatasource>>;
}
/**
 * Request to batch load Ontology entities. If any of the requested entities are not available
 * in the specified OntologyVersion (or latest if not specified), they will not be present in the
 * response.
 */
interface OntologyLoadEntitiesRequest {
    includeObjectTypesWithoutSearchableDatasources?: boolean | null | undefined;
    linkTypeVersions: Record<LinkTypeRid, OntologyVersion | null | undefined>;
    loadRedacted?: boolean | null | undefined;
    objectTypeVersions: Record<ObjectTypeRid, OntologyVersion | null | undefined>;
}
/**
 * Response to OntologyLoadEntitiesRequest or OntologyLoadAllEntitiesRequest. If any of the requested entities
 * are not available in the specified OntologyVersion (or latest if not specified),
 * they will not be present in the response.
 */
interface OntologyLoadEntitiesResponse {
    currentOntologyVersion?: OntologyVersion | null | undefined;
    linkTypes: Record<LinkTypeRid, LinkType>;
    objectTypes: Record<ObjectTypeRid, ObjectType>;
}
/**
 * Request to batch load Ontology entities. If any of the requested entities are not available
 * in the specified OntologyVersion (or latest if not specified), they will not be present in the
 * response.
 *
 * Please note that this has been deprecated. Please switch to the OntologyBulkLoadEntitiesRequest
 * instead.
 */
interface OntologyLoadRequest {
    bidirectionalRelationVersions: Record<RelationId, OntologyVersion | null | undefined>;
    partialObjectTypeVersions: Record<ObjectTypeId, OntologyVersion | null | undefined>;
}
/**
 * Response to OntologyLoadRequest.
 */
interface OntologyLoadResponse {
    bidirectionalRelations: Record<RelationId, BidirectionalRelation>;
    currentOntologyVersion?: OntologyVersion | null | undefined;
    partialObjectTypes: Record<ObjectTypeId, PartialObjectType>;
}
interface OntologyMetadataValidationError_objectType {
    type: "objectType";
    objectType: ObjectTypeError;
}
interface OntologyMetadataValidationError_linkType {
    type: "linkType";
    linkType: LinkTypeError;
}
interface OntologyMetadataValidationError_ruleSet {
    type: "ruleSet";
    ruleSet: RuleSetError;
}
interface OntologyMetadataValidationError_workflow {
    type: "workflow";
    workflow: WorkflowError;
}
interface OntologyMetadataValidationError_actionType {
    type: "actionType";
    actionType: ActionTypeError;
}
interface OntologyMetadataValidationError_sharedPropertyType {
    type: "sharedPropertyType";
    sharedPropertyType: SharedPropertyTypeError;
}
interface OntologyMetadataValidationError_interfaceType {
    type: "interfaceType";
    interfaceType: InterfaceTypeError;
}
interface OntologyMetadataValidationError_typeGroup {
    type: "typeGroup";
    typeGroup: TypeGroupError;
}
type OntologyMetadataValidationError = OntologyMetadataValidationError_objectType | OntologyMetadataValidationError_linkType | OntologyMetadataValidationError_ruleSet | OntologyMetadataValidationError_workflow | OntologyMetadataValidationError_actionType | OntologyMetadataValidationError_sharedPropertyType | OntologyMetadataValidationError_interfaceType | OntologyMetadataValidationError_typeGroup;
interface OntologyModificationEvent_objectTypeCreated {
    type: "objectTypeCreated";
    objectTypeCreated: ObjectTypeCreatedEvent;
}
interface OntologyModificationEvent_objectTypeUpdated {
    type: "objectTypeUpdated";
    objectTypeUpdated: ObjectTypeUpdatedEvent;
}
interface OntologyModificationEvent_objectTypeDeleted {
    type: "objectTypeDeleted";
    objectTypeDeleted: ObjectTypeDeletedEvent;
}
interface OntologyModificationEvent_linkTypeCreated {
    type: "linkTypeCreated";
    linkTypeCreated: LinkTypeCreatedEvent;
}
interface OntologyModificationEvent_linkTypeUpdated {
    type: "linkTypeUpdated";
    linkTypeUpdated: LinkTypeUpdatedEvent;
}
interface OntologyModificationEvent_linkTypeDeleted {
    type: "linkTypeDeleted";
    linkTypeDeleted: LinkTypeDeletedEvent;
}
interface OntologyModificationEvent_actionTypeCreated {
    type: "actionTypeCreated";
    actionTypeCreated: ActionTypeCreatedEvent;
}
interface OntologyModificationEvent_actionTypeUpdated {
    type: "actionTypeUpdated";
    actionTypeUpdated: ActionTypeUpdatedEvent;
}
interface OntologyModificationEvent_actionTypeDeleted {
    type: "actionTypeDeleted";
    actionTypeDeleted: ActionTypeDeletedEvent;
}
interface OntologyModificationEvent_sharedPropertyTypeCreated {
    type: "sharedPropertyTypeCreated";
    sharedPropertyTypeCreated: SharedPropertyTypeCreatedEvent;
}
interface OntologyModificationEvent_sharedPropertyTypeUpdated {
    type: "sharedPropertyTypeUpdated";
    sharedPropertyTypeUpdated: SharedPropertyTypeUpdatedEvent;
}
interface OntologyModificationEvent_sharedPropertyTypeDeleted {
    type: "sharedPropertyTypeDeleted";
    sharedPropertyTypeDeleted: SharedPropertyTypeDeletedEvent;
}
interface OntologyModificationEvent_interfaceTypeCreated {
    type: "interfaceTypeCreated";
    interfaceTypeCreated: InterfaceTypeCreatedEvent;
}
interface OntologyModificationEvent_interfaceTypeUpdated {
    type: "interfaceTypeUpdated";
    interfaceTypeUpdated: InterfaceTypeUpdatedEvent;
}
interface OntologyModificationEvent_interfaceTypeDeleted {
    type: "interfaceTypeDeleted";
    interfaceTypeDeleted: InterfaceTypeDeletedEvent;
}
interface OntologyModificationEvent_branchClosed {
    type: "branchClosed";
    branchClosed: BranchClosedEvent;
}
interface OntologyModificationEvent_branchMerged {
    type: "branchMerged";
    branchMerged: BranchMergedEvent;
}
interface OntologyModificationEvent_branchDeleted {
    type: "branchDeleted";
    branchDeleted: BranchDeletedEvent;
}
type OntologyModificationEvent = OntologyModificationEvent_objectTypeCreated | OntologyModificationEvent_objectTypeUpdated | OntologyModificationEvent_objectTypeDeleted | OntologyModificationEvent_linkTypeCreated | OntologyModificationEvent_linkTypeUpdated | OntologyModificationEvent_linkTypeDeleted | OntologyModificationEvent_actionTypeCreated | OntologyModificationEvent_actionTypeUpdated | OntologyModificationEvent_actionTypeDeleted | OntologyModificationEvent_sharedPropertyTypeCreated | OntologyModificationEvent_sharedPropertyTypeUpdated | OntologyModificationEvent_sharedPropertyTypeDeleted | OntologyModificationEvent_interfaceTypeCreated | OntologyModificationEvent_interfaceTypeUpdated | OntologyModificationEvent_interfaceTypeDeleted | OntologyModificationEvent_branchClosed | OntologyModificationEvent_branchMerged | OntologyModificationEvent_branchDeleted;
interface OntologyModifyRequest {
    bidirectionalRelations: Record<RelationId, BidirectionalRelationModifyRequest>;
    expectedOntologyVersion?: OntologyVersion | null | undefined;
    partialObjectTypes: Record<ObjectTypeId, PartialObjectTypeModifyRequest>;
}
interface OntologyModifyResponse {
}
/**
 * ResourceIdentifier for an Ontology Package.
 */
type OntologyPackageRid = string;
interface OntologyProposalIdentifier_ontologyVersion {
    type: "ontologyVersion";
    ontologyVersion: OntologyVersion;
}
type OntologyProposalIdentifier = OntologyProposalIdentifier_ontologyVersion;
/**
 * A rid identifying an Ontology Proposal V2.
 */
type OntologyProposalRid = string;
/**
 * An rid identifying an Ontology. This rid is generated randomly and is safe for logging purposes. Access
 * to the Ontology is also controlled by checking operations on this rid. The OntologyRid for an
 * Ontology is immutable.
 */
type OntologyRid = string;
/**
 * Dataset properties for ontology inputs.
 */
interface OntologyRidAndBranch {
    branchRid: OntologyBranchRid;
    ontologyRid: OntologyRid;
}
/**
 * Request to get ontology rids for the given ontology entities. If any of the requested
 * entities are not available in the latest version of any Ontology or if the user is
 * missing permissions to view its Ontology, the corresponding entry will be missing in the response.
 */
interface OntologyRidsForEntitiesRequest {
    entityRids: Array<string>;
}
interface OntologyRidsForEntitiesResponse {
    ontologyRids: Record<string, OntologyRid>;
}
/**
 * ResourceIdentifier for the ontology spark input manager.
 */
type OntologySparkInputManagerRid = string;
/**
 * Resolved properties to read an ontology entity through a delegate dataset in spark.
 */
interface OntologySparkInputProperties {
    datasetRid: DatasetRid;
    endTransactionRid: string;
    ontologyDatasetType: OntologyDatasetType;
    ontologyVersion: OntologyVersion;
    schemaBranchId: string;
    schemaVersionId: string;
}
/**
 * The version of an Ontology.
 */
type OntologyVersion = string;
interface OrCondition {
    conditions: Array<Condition>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface OrConditionModification {
    conditions: Array<ConditionModification>;
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
/**
 * Identifier for an Organization Marking
 */
type OrganizationMarkingId = string;
/**
 * The rid for a Multipass Organization.
 */
type OrganizationRid = string;
/**
 * A set of organization rids and the corresponding ontology entities that have those organization markings.
 */
interface OrganizationRidsAndEntityResourceIdentifiers {
    entityResourceIdentifiers: Array<string>;
    organizationRids: Array<OrganizationRid>;
}
interface OrganizationRidsForOntologyResponse {
    organizationRids: Array<OrganizationRid>;
}
interface OtherValueAllowed {
    allowed: boolean;
}
interface PackagedEntityRid_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid;
}
interface PackagedEntityRid_linkTypeRid {
    type: "linkTypeRid";
    linkTypeRid: LinkTypeRid;
}
interface PackagedEntityRid_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: ActionTypeRid;
}
interface PackagedEntityRid_sharedPropertyTypeRid {
    type: "sharedPropertyTypeRid";
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface PackagedEntityRid_interfaceTypeRid {
    type: "interfaceTypeRid";
    interfaceTypeRid: InterfaceTypeRid;
}
type PackagedEntityRid = PackagedEntityRid_objectTypeRid | PackagedEntityRid_linkTypeRid | PackagedEntityRid_actionTypeRid | PackagedEntityRid_sharedPropertyTypeRid | PackagedEntityRid_interfaceTypeRid;
/**
 * Parameters of an ActionType represent what inputs the ActionType requires.
 */
interface Parameter {
    displayMetadata: ParameterDisplayMetadata;
    id: ParameterId;
    rid: ParameterRid;
    type: BaseParameterType;
}
/**
 * Notification recipients determined from Action's inputs.
 */
interface ParameterActionNotificationRecipients {
    principalIds: LogicRuleValue;
}
/**
 * Notification recipients determined from Action's inputs.
 */
interface ParameterActionNotificationRecipientsModification {
    principalIds: LogicRuleValueModification;
}
interface ParameterAttachment {
    maxSizeBytes?: number | null | undefined;
}
interface ParameterAttachmentOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterAttachmentOrEmpty_attachment {
    type: "attachment";
    attachment: ParameterAttachment;
}
type ParameterAttachmentOrEmpty = ParameterAttachmentOrEmpty_empty | ParameterAttachmentOrEmpty_attachment;
interface ParameterBoolean {
}
interface ParameterBooleanOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterBooleanOrEmpty_boolean {
    type: "boolean";
    boolean: ParameterBoolean;
}
type ParameterBooleanOrEmpty = ParameterBooleanOrEmpty_empty | ParameterBooleanOrEmpty_boolean;
/**
 * Contains a non-empty MarkingList Value that represent the max classification of this parameter.
 * It must be present and must contain a valid set of cbac markings.
 */
interface ParameterCbacConstraint {
    markingsValue?: ConditionValue | null | undefined;
}
/**
 * Contains a non-empty MarkingList Value that represent the max classification of this parameter.
 * It must be present and must contain a valid set of cbac markings.
 */
interface ParameterCbacConstraintModification {
    markingsValue?: ConditionValueModification | null | undefined;
}
interface ParameterCbacMarking {
    classificationConstraint?: ParameterCbacConstraint | null | undefined;
}
interface ParameterCbacMarkingModification {
    classificationConstraint?: ParameterCbacConstraintModification | null | undefined;
}
interface ParameterCbacMarkingOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterCbacMarkingOrEmpty_cbacMarking {
    type: "cbacMarking";
    cbacMarking: ParameterCbacMarking;
}
/**
 * Allows values that satisfy the cbacMarking max classification. If empty, it will only allow empty values.
 */
type ParameterCbacMarkingOrEmpty = ParameterCbacMarkingOrEmpty_empty | ParameterCbacMarkingOrEmpty_cbacMarking;
interface ParameterCbacMarkingOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterCbacMarkingOrEmptyModification_cbacMarking {
    type: "cbacMarking";
    cbacMarking: ParameterCbacMarkingModification;
}
/**
 * Allows values that satisfy the cbacMarking max classification. If empty, it will only allow empty values.
 */
type ParameterCbacMarkingOrEmptyModification = ParameterCbacMarkingOrEmptyModification_empty | ParameterCbacMarkingOrEmptyModification_cbacMarking;
interface ParameterDateRangeValue {
    inclusive: boolean;
    value: DateRangeValue;
}
interface ParameterDateRangeValueModification {
    inclusive: boolean;
    value: DateRangeValueModification;
}
interface ParameterDateTimeRange {
    maximum?: ParameterDateRangeValue | null | undefined;
    minimum?: ParameterDateRangeValue | null | undefined;
}
interface ParameterDateTimeRangeModification {
    maximum?: ParameterDateRangeValueModification | null | undefined;
    minimum?: ParameterDateRangeValueModification | null | undefined;
}
interface ParameterDateTimeRangeOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterDateTimeRangeOrEmpty_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRange;
}
type ParameterDateTimeRangeOrEmpty = ParameterDateTimeRangeOrEmpty_empty | ParameterDateTimeRangeOrEmpty_datetime;
interface ParameterDateTimeRangeOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterDateTimeRangeOrEmptyModification_datetime {
    type: "datetime";
    datetime: ParameterDateTimeRangeModification;
}
type ParameterDateTimeRangeOrEmptyModification = ParameterDateTimeRangeOrEmptyModification_empty | ParameterDateTimeRangeOrEmptyModification_datetime;
interface ParameterDisplayMetadata {
    description: string;
    displayName: string;
    structFields: Record<StructParameterFieldApiName, StructParameterFieldDisplayMetadata>;
    structFieldsV2: Array<StructParameterFieldDisplayMetadataV2>;
    typeClasses: Array<TypeClass>;
}
interface ParameterFreeText {
    maxLength?: number | null | undefined;
    minLength?: number | null | undefined;
    regex?: ParameterTextRegex | null | undefined;
}
interface ParameterFreeTextOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterFreeTextOrEmpty_text {
    type: "text";
    text: ParameterFreeText;
}
type ParameterFreeTextOrEmpty = ParameterFreeTextOrEmpty_empty | ParameterFreeTextOrEmpty_text;
interface ParameterGeohash {
}
interface ParameterGeohashOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterGeohashOrEmpty_geohash {
    type: "geohash";
    geohash: ParameterGeohash;
}
type ParameterGeohashOrEmpty = ParameterGeohashOrEmpty_empty | ParameterGeohashOrEmpty_geohash;
interface ParameterGeoshape {
}
interface ParameterGeoshapeOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterGeoshapeOrEmpty_geoshape {
    type: "geoshape";
    geoshape: ParameterGeoshape;
}
type ParameterGeoshapeOrEmpty = ParameterGeoshapeOrEmpty_empty | ParameterGeoshapeOrEmpty_geoshape;
interface ParameterGeotimeSeriesReference {
}
interface ParameterGeotimeSeriesReferenceOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterGeotimeSeriesReferenceOrEmpty_geotimeSeries {
    type: "geotimeSeries";
    geotimeSeries: ParameterGeotimeSeriesReference;
}
type ParameterGeotimeSeriesReferenceOrEmpty = ParameterGeotimeSeriesReferenceOrEmpty_empty | ParameterGeotimeSeriesReferenceOrEmpty_geotimeSeries;
/**
 * The id for a Parameter which uniquely identifies the Parameter per ActionType.
 */
type ParameterId = string;
/**
 * This is a WIP and will be extended to only allow objects in a dynamic interface object set once interfaces
 * are supported in OSS.
 */
interface ParameterInterfaceObjectQuery {
}
/**
 * This is a WIP and will be extended to only allow objects in a dynamic interface object set once interfaces
 * are supported in OSS.
 */
interface ParameterInterfaceObjectQueryModification {
}
interface ParameterInterfaceObjectQueryOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterInterfaceObjectQueryOrEmpty_interfaceObjectQuery {
    type: "interfaceObjectQuery";
    interfaceObjectQuery: ParameterInterfaceObjectQuery;
}
/**
 * [WIP] Allows any values for now until interfaces are supported in OSS. If empty, it will only allow empty
 * values.
 */
type ParameterInterfaceObjectQueryOrEmpty = ParameterInterfaceObjectQueryOrEmpty_empty | ParameterInterfaceObjectQueryOrEmpty_interfaceObjectQuery;
interface ParameterInterfaceObjectQueryOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterInterfaceObjectQueryOrEmptyModification_interfaceObjectQuery {
    type: "interfaceObjectQuery";
    interfaceObjectQuery: ParameterInterfaceObjectQueryModification;
}
/**
 * [WIP] Allows any values for now until interfaces are supported in OSS. If empty, it will only allow empty
 * values.
 */
type ParameterInterfaceObjectQueryOrEmptyModification = ParameterInterfaceObjectQueryOrEmptyModification_empty | ParameterInterfaceObjectQueryOrEmptyModification_interfaceObjectQuery;
interface ParameterInterfacePropertyValueOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterInterfacePropertyValueOrEmpty_unrestricted {
    type: "unrestricted";
    unrestricted: UnrestrictedParameterInterfacePropertyValue;
}
/**
 * [WIP] Allows any values for now until interfaces are supported in OSS. If empty, it will only allow empty
 * values.
 */
type ParameterInterfacePropertyValueOrEmpty = ParameterInterfacePropertyValueOrEmpty_empty | ParameterInterfacePropertyValueOrEmpty_unrestricted;
interface ParameterInterfacePropertyValueOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterInterfacePropertyValueOrEmptyModification_unrestricted {
    type: "unrestricted";
    unrestricted: UnrestrictedParameterInterfacePropertyValue;
}
/**
 * [WIP] Allows any values for now until interfaces are supported in OSS. If empty, it will only allow empty
 * values.
 */
type ParameterInterfacePropertyValueOrEmptyModification = ParameterInterfacePropertyValueOrEmptyModification_empty | ParameterInterfacePropertyValueOrEmptyModification_unrestricted;
interface ParameterLength_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
/**
 * This is used to inspect the size of collection types.
 */
type ParameterLength = ParameterLength_parameterId;
interface ParameterMandatoryMarking {
}
interface ParameterMandatoryMarkingOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterMandatoryMarkingOrEmpty_mandatoryMarking {
    type: "mandatoryMarking";
    mandatoryMarking: ParameterMandatoryMarking;
}
type ParameterMandatoryMarkingOrEmpty = ParameterMandatoryMarkingOrEmpty_empty | ParameterMandatoryMarkingOrEmpty_mandatoryMarking;
interface ParameterMediaReference {
}
interface ParameterMediaReferenceOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterMediaReferenceOrEmpty_mediaReference {
    type: "mediaReference";
    mediaReference: ParameterMediaReference;
}
type ParameterMediaReferenceOrEmpty = ParameterMediaReferenceOrEmpty_empty | ParameterMediaReferenceOrEmpty_mediaReference;
interface ParameterMultipassGroup {
}
interface ParameterMultipassGroupOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterMultipassGroupOrEmpty_group {
    type: "group";
    group: ParameterMultipassGroup;
}
type ParameterMultipassGroupOrEmpty = ParameterMultipassGroupOrEmpty_empty | ParameterMultipassGroupOrEmpty_group;
interface ParameterMultipassUser {
    filter: Array<MultipassUserFilter>;
}
interface ParameterMultipassUserModification {
    filter: Array<MultipassUserFilterModification>;
}
interface ParameterMultipassUserOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterMultipassUserOrEmpty_user {
    type: "user";
    user: ParameterMultipassUser;
}
type ParameterMultipassUserOrEmpty = ParameterMultipassUserOrEmpty_empty | ParameterMultipassUserOrEmpty_user;
interface ParameterMultipassUserOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterMultipassUserOrEmptyModification_user {
    type: "user";
    user: ParameterMultipassUserModification;
}
type ParameterMultipassUserOrEmptyModification = ParameterMultipassUserOrEmptyModification_empty | ParameterMultipassUserOrEmptyModification_user;
interface ParameterObjectList {
}
interface ParameterObjectListOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectListOrEmpty_objectList {
    type: "objectList";
    objectList: ParameterObjectList;
}
type ParameterObjectListOrEmpty = ParameterObjectListOrEmpty_empty | ParameterObjectListOrEmpty_objectList;
/**
 * Generates a set of allowed values from the specified property of the objects in the objectSet.
 * For example All the names from the `assignedTo` property of tickets in an objectSet.
 */
interface ParameterObjectPropertyValue {
    objectSet: ActionsObjectSet;
    otherValueAllowed?: OtherValueAllowed | null | undefined;
    propertyTypeId: PropertyTypeId;
}
/**
 * Generates a set of allowed values from the specified property of the objects in the objectSet.
 * For example All the names from the `assignedTo` property of tickets in an objectSet.
 */
interface ParameterObjectPropertyValueModification {
    objectSet: ActionsObjectSetModification;
    otherValueAllowed?: OtherValueAllowed | null | undefined;
    propertyTypeId: PropertyTypeId;
}
interface ParameterObjectPropertyValueOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectPropertyValueOrEmpty_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: ParameterObjectPropertyValue;
}
/**
 * Allows values that satisfy the objectPropertyValue. If empty, it will only allow empty values.
 */
type ParameterObjectPropertyValueOrEmpty = ParameterObjectPropertyValueOrEmpty_empty | ParameterObjectPropertyValueOrEmpty_objectPropertyValue;
interface ParameterObjectPropertyValueOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectPropertyValueOrEmptyModification_objectPropertyValue {
    type: "objectPropertyValue";
    objectPropertyValue: ParameterObjectPropertyValueModification;
}
/**
 * Allows values that satisfy the objectPropertyValue. If empty, it will only allow empty values.
 */
type ParameterObjectPropertyValueOrEmptyModification = ParameterObjectPropertyValueOrEmptyModification_empty | ParameterObjectPropertyValueOrEmptyModification_objectPropertyValue;
/**
 * Only allows Objects that are in this Dynamic Object Set at Execution time.
 */
interface ParameterObjectQuery {
    objectSet?: ActionsObjectSet | null | undefined;
}
/**
 * Only allows Objects that are in this Dynamic Object Set at Execution time.
 */
interface ParameterObjectQueryModification {
    objectSet?: ActionsObjectSetModification | null | undefined;
}
interface ParameterObjectQueryOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectQueryOrEmpty_objectQuery {
    type: "objectQuery";
    objectQuery: ParameterObjectQuery;
}
/**
 * Allows values that satisfy the objectQuery. If empty, it will only allow empty values.
 */
type ParameterObjectQueryOrEmpty = ParameterObjectQueryOrEmpty_empty | ParameterObjectQueryOrEmpty_objectQuery;
interface ParameterObjectQueryOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectQueryOrEmptyModification_objectQuery {
    type: "objectQuery";
    objectQuery: ParameterObjectQueryModification;
}
/**
 * Allows values that satisfy the objectQuery. If empty, it will only allow empty values.
 */
type ParameterObjectQueryOrEmptyModification = ParameterObjectQueryOrEmptyModification_empty | ParameterObjectQueryOrEmptyModification_objectQuery;
/**
 * In future ObjectSetRid validations may be added.
 */
interface ParameterObjectSetRid {
}
interface ParameterObjectSetRidOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectSetRidOrEmpty_objectSetRid {
    type: "objectSetRid";
    objectSetRid: ParameterObjectSetRid;
}
type ParameterObjectSetRidOrEmpty = ParameterObjectSetRidOrEmpty_empty | ParameterObjectSetRidOrEmpty_objectSetRid;
/**
 * Allows ObjectTypeReference values where the object type implements the specified interfaces.
 */
interface ParameterObjectTypeReference {
    interfaceTypeRids: Array<InterfaceTypeRid>;
}
/**
 * Allows ObjectTypeReference values where the object type implements the specified interfaces.
 */
interface ParameterObjectTypeReferenceModification {
    interfaceTypeRidOrIdInRequests: Array<InterfaceTypeRidOrIdInRequest>;
}
interface ParameterObjectTypeReferenceOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectTypeReferenceOrEmpty_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ParameterObjectTypeReference;
}
type ParameterObjectTypeReferenceOrEmpty = ParameterObjectTypeReferenceOrEmpty_empty | ParameterObjectTypeReferenceOrEmpty_objectTypeReference;
interface ParameterObjectTypeReferenceOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterObjectTypeReferenceOrEmptyModification_objectTypeReference {
    type: "objectTypeReference";
    objectTypeReference: ParameterObjectTypeReferenceModification;
}
type ParameterObjectTypeReferenceOrEmptyModification = ParameterObjectTypeReferenceOrEmptyModification_empty | ParameterObjectTypeReferenceOrEmptyModification_objectTypeReference;
interface ParameterPrefill_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface ParameterPrefill_staticObject {
    type: "staticObject";
    staticObject: StaticObjectPrefill;
}
interface ParameterPrefill_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ParameterPrefill_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValue;
}
interface ParameterPrefill_objectQueryPrefill {
    type: "objectQueryPrefill";
    objectQueryPrefill: ObjectQueryPrefill;
}
interface ParameterPrefill_objectQueryPropertyValue {
    type: "objectQueryPropertyValue";
    objectQueryPropertyValue: ObjectQueryPropertyValue;
}
interface ParameterPrefill_objectSetRidPrefill {
    type: "objectSetRidPrefill";
    objectSetRidPrefill: ObjectSetRidPrefill;
}
interface ParameterPrefill_redacted {
    type: "redacted";
    redacted: Redacted;
}
/**
 * ParameterPrefill specifies what should initially suggested to users for this Parameter.
 */
type ParameterPrefill = ParameterPrefill_staticValue | ParameterPrefill_staticObject | ParameterPrefill_objectParameterPropertyValue | ParameterPrefill_interfaceParameterPropertyValue | ParameterPrefill_objectQueryPrefill | ParameterPrefill_objectQueryPropertyValue | ParameterPrefill_objectSetRidPrefill | ParameterPrefill_redacted;
interface ParameterPrefillModification_staticValue {
    type: "staticValue";
    staticValue: StaticValue;
}
interface ParameterPrefillModification_staticObject {
    type: "staticObject";
    staticObject: StaticObjectPrefill;
}
interface ParameterPrefillModification_objectParameterPropertyValue {
    type: "objectParameterPropertyValue";
    objectParameterPropertyValue: ObjectParameterPropertyValue;
}
interface ParameterPrefillModification_interfaceParameterPropertyValue {
    type: "interfaceParameterPropertyValue";
    interfaceParameterPropertyValue: InterfaceParameterPropertyValueModification;
}
interface ParameterPrefillModification_objectQueryPrefill {
    type: "objectQueryPrefill";
    objectQueryPrefill: ObjectQueryPrefillModification;
}
interface ParameterPrefillModification_objectQueryPropertyValue {
    type: "objectQueryPropertyValue";
    objectQueryPropertyValue: ObjectQueryPropertyValueModification;
}
interface ParameterPrefillModification_objectSetRidPrefill {
    type: "objectSetRidPrefill";
    objectSetRidPrefill: ObjectSetRidPrefillModification;
}
interface ParameterPrefillModification_redacted {
    type: "redacted";
    redacted: Redacted;
}
/**
 * ParameterPrefillModification specifies what should initially suggested to users for this Parameter.
 */
type ParameterPrefillModification = ParameterPrefillModification_staticValue | ParameterPrefillModification_staticObject | ParameterPrefillModification_objectParameterPropertyValue | ParameterPrefillModification_interfaceParameterPropertyValue | ParameterPrefillModification_objectQueryPrefill | ParameterPrefillModification_objectQueryPropertyValue | ParameterPrefillModification_objectSetRidPrefill | ParameterPrefillModification_redacted;
interface ParameterPrefillOverride {
    prefill: ParameterPrefill;
}
interface ParameterPrefillOverrideModification {
    prefill: ParameterPrefillModification;
}
interface ParameterRange {
    maximum?: ParameterRangeValue | null | undefined;
    minimum?: ParameterRangeValue | null | undefined;
}
interface ParameterRangeModification {
    maximum?: ParameterRangeValueModification | null | undefined;
    minimum?: ParameterRangeValueModification | null | undefined;
}
interface ParameterRangeOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterRangeOrEmpty_range {
    type: "range";
    range: ParameterRange;
}
type ParameterRangeOrEmpty = ParameterRangeOrEmpty_empty | ParameterRangeOrEmpty_range;
interface ParameterRangeOrEmptyModification_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterRangeOrEmptyModification_range {
    type: "range";
    range: ParameterRangeModification;
}
type ParameterRangeOrEmptyModification = ParameterRangeOrEmptyModification_empty | ParameterRangeOrEmptyModification_range;
interface ParameterRangeValue {
    inclusive: boolean;
    value: ConditionValue;
}
interface ParameterRangeValueModification {
    inclusive: boolean;
    value: ConditionValueModification;
}
interface ParameterRequiredOverride {
    required: ParameterRequiredConfiguration;
}
/**
 * The rid for a Parameter, autogenerated by Ontology-Metadata-Service and used for permissioning and logging.
 */
type ParameterRid = string;
/**
 * Some ParameterIds are not matching between ActionType and ParameterOrdering
 */
interface ParametersDoNotMatchParameterOrderingError {
    actionTypeIdentifier: ActionTypeIdentifier;
    mismatchedParameterIds: Array<ParameterId>;
}
interface ParameterStructOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterStructOrEmpty_delegateToAllowedStructFieldValues {
    type: "delegateToAllowedStructFieldValues";
    delegateToAllowedStructFieldValues: DelegateToAllowedStructFieldValues;
}
/**
 * Allowed values that satisfy struct parameters. If empty, it will only allow empty values. Otherwise, indicates
 * that AllowedStructFieldValues for each struct field should be checked.
 */
type ParameterStructOrEmpty = ParameterStructOrEmpty_empty | ParameterStructOrEmpty_delegateToAllowedStructFieldValues;
interface ParameterTextRegex {
    failureMessage: string;
    regex: string;
}
interface ParameterTimeSeriesReference {
}
interface ParameterTimeSeriesReferenceOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterTimeSeriesReferenceOrEmpty_timeSeriesReference {
    type: "timeSeriesReference";
    timeSeriesReference: ParameterTimeSeriesReference;
}
type ParameterTimeSeriesReferenceOrEmpty = ParameterTimeSeriesReferenceOrEmpty_empty | ParameterTimeSeriesReferenceOrEmpty_timeSeriesReference;
interface ParameterValidation {
    allowedValues: AllowedParameterValues;
    required: ParameterRequiredConfiguration;
}
interface ParameterValidationBlock {
    display: ParameterValidationDisplayMetadata;
    validation: ParameterValidation;
}
interface ParameterValidationBlockModification {
    display: ParameterValidationDisplayMetadataModification;
    validation: ParameterValidationModification;
}
interface ParameterValidationBlockOverride_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface ParameterValidationBlockOverride_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface ParameterValidationBlockOverride_allowedValues {
    type: "allowedValues";
    allowedValues: AllowedValuesOverride;
}
interface ParameterValidationBlockOverride_prefill {
    type: "prefill";
    prefill: ParameterPrefillOverride;
}
type ParameterValidationBlockOverride = ParameterValidationBlockOverride_parameterRequired | ParameterValidationBlockOverride_visibility | ParameterValidationBlockOverride_allowedValues | ParameterValidationBlockOverride_prefill;
interface ParameterValidationBlockOverrideModification_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface ParameterValidationBlockOverrideModification_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface ParameterValidationBlockOverrideModification_allowedValues {
    type: "allowedValues";
    allowedValues: AllowedValuesOverrideModification;
}
interface ParameterValidationBlockOverrideModification_prefill {
    type: "prefill";
    prefill: ParameterPrefillOverrideModification;
}
type ParameterValidationBlockOverrideModification = ParameterValidationBlockOverrideModification_parameterRequired | ParameterValidationBlockOverrideModification_visibility | ParameterValidationBlockOverrideModification_allowedValues | ParameterValidationBlockOverrideModification_prefill;
/**
 * These values provide details about how parameter fields should be displayed in the form. They are not used to
 * evaluate correctness of submitted parameters.
 */
interface ParameterValidationDisplayMetadata {
    prefill?: ParameterPrefill | null | undefined;
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
/**
 * These values provide details about how parameter fields should be displayed in the form. They are not used to
 * evaluate correctness of submitted parameters.
 */
interface ParameterValidationDisplayMetadataModification {
    prefill?: ParameterPrefillModification | null | undefined;
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
interface ParameterValidationModification {
    allowedValues: AllowedParameterValuesModification;
    required: ParameterRequiredConfiguration;
}
/**
 * Parameter validation not found for the specified ParameterId
 */
interface ParameterValidationNotFoundError {
    actionTypeIdentifier: ActionTypeIdentifier;
    parameterId: ParameterId;
}
interface ParameterValidationReferencesLaterParametersError {
    actionTypeIdentifier: ActionTypeIdentifier;
    idsToIdsReferencedTooEarly: Record<ParameterId, Array<ParameterId>>;
}
interface ParameterValueOneOf {
    labelledValues: Array<LabelledValue>;
    otherValueAllowed: OtherValueAllowed;
}
interface ParameterValueOneOfOrEmpty_empty {
    type: "empty";
    empty: MustBeEmpty;
}
interface ParameterValueOneOfOrEmpty_oneOf {
    type: "oneOf";
    oneOf: ParameterValueOneOf;
}
type ParameterValueOneOfOrEmpty = ParameterValueOneOfOrEmpty_empty | ParameterValueOneOfOrEmpty_oneOf;
interface ParameterValueType {
    valueType: ValueType;
}
interface ParameterValueTypeOrEmpty_valueType {
    type: "valueType";
    valueType: ParameterValueType;
}
type ParameterValueTypeOrEmpty = ParameterValueTypeOrEmpty_valueType;
interface PartialObjectType {
    authorizationRidColumnLocator?: ColumnLocator | null | undefined;
    description?: string | null | undefined;
    displayMetadata?: ObjectDisplayMetadata | null | undefined;
    editsConfiguration: EditsConfiguration;
    id: ObjectTypeId;
    metadata: Record<string, any | null | undefined>;
    primaryKey: PropertyId;
    properties: Array<Property>;
    rid: ObjectTypeRid;
    titlePropertyId: PropertyId;
}
interface PartialObjectTypeCreateRequest {
    partialObjectType: PartialObjectTypeWithoutRids;
}
interface PartialObjectTypeDeleteRequest {
}
interface PartialObjectTypeModifyRequest_create {
    type: "create";
    create: PartialObjectTypeCreateRequest;
}
interface PartialObjectTypeModifyRequest_update {
    type: "update";
    update: PartialObjectTypeUpdateRequest;
}
interface PartialObjectTypeModifyRequest_delete {
    type: "delete";
    delete: PartialObjectTypeDeleteRequest;
}
type PartialObjectTypeModifyRequest = PartialObjectTypeModifyRequest_create | PartialObjectTypeModifyRequest_update | PartialObjectTypeModifyRequest_delete;
interface PartialObjectTypeUpdateRequest {
    partialObjectType: PartialObjectTypeWithoutRids;
}
interface PartialObjectTypeWithoutRids {
    authorizationRidColumnLocator?: ColumnLocator | null | undefined;
    description?: string | null | undefined;
    displayMetadata?: ObjectDisplayMetadata | null | undefined;
    editsConfiguration?: EditsConfiguration | null | undefined;
    id: ObjectTypeId;
    metadata: Record<string, any | null | undefined>;
    primaryKey: PropertyId;
    properties: Array<PropertyWithoutRid>;
    titlePropertyId: PropertyId;
}
/**
 * The object type patch backup initialization configuration source does not exist.
 */
interface PatchBackupInitializationConfigurationSourceDoesNotExistError {
    objectTypes: Array<VersionedObjectTypeRid>;
}
/**
 * The version of a GPS Policy.
 */
type PolicyVersion = string;
interface PrePostFix {
    postfix?: PropertyTypeReferenceOrStringConstant | null | undefined;
    prefix?: PropertyTypeReferenceOrStringConstant | null | undefined;
}
interface PrimaryKeyPropertySecurityGroupType {
}
/**
 * The id of a Multipass Principal(Everyone/User/Group)
 */
type PrincipalId = string;
interface ProjectEntityRid_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid;
}
interface ProjectEntityRid_linkTypeRid {
    type: "linkTypeRid";
    linkTypeRid: LinkTypeRid;
}
interface ProjectEntityRid_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: ActionTypeRid;
}
interface ProjectEntityRid_sharedPropertyTypeRid {
    type: "sharedPropertyTypeRid";
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface ProjectEntityRid_interfaceTypeRid {
    type: "interfaceTypeRid";
    interfaceTypeRid: InterfaceTypeRid;
}
interface ProjectEntityRid_typeGroupRid {
    type: "typeGroupRid";
    typeGroupRid: TypeGroupRid;
}
type ProjectEntityRid = ProjectEntityRid_objectTypeRid | ProjectEntityRid_linkTypeRid | ProjectEntityRid_actionTypeRid | ProjectEntityRid_sharedPropertyTypeRid | ProjectEntityRid_interfaceTypeRid | ProjectEntityRid_typeGroupRid;
interface PropertiesReferenceDuplicateColumnNameWrapper {
    columnName: string;
    datasourceAuthorizationRid: Array<string>;
    propertyIds: Array<PropertyTypeId>;
}
/**
 * Local property declaration.
 */
interface Property {
    authorizationRid?: string | null | undefined;
    column: ColumnLocator;
    fieldMetadata?: FieldMetadata | null | undefined;
    id: PropertyId;
    rid: PropertyTypeRid;
    type: PropertyTypeReference;
}
/**
 * The id for a Property.
 */
type PropertyId = string;
interface PropertyPropertySecurityGroupType {
    name: PropertySecurityGroupName;
}
/**
 * Render hints provide additional information about the shape of the data to improve the default way the object is presented
 */
type PropertyRenderHint = "LONG_TEXT" | "LOW_CARDINALITY" | "IDENTIFIER" | "DISABLE_FORMATTING" | "KEYWORDS" | "SORTABLE" | "SELECTABLE";
/**
 * Defines a grouping of properties sharing the same security.
 *
 * One and exactly one of the specified groups must contain the primary key property(ies). If there
 * are multiple primary key properties, they must belong to the same property group. The security of the
 * property group that includes the primary key also specifies overall object visibility: if the user does not
 * pass this property group's security, the entire object is invisible, regardless of visibility of other
 * property groups.
 */
interface PropertySecurityGroup {
    properties: Array<PropertyTypeRid>;
    rid: PropertySecurityGroupRid;
    security: SecurityGroupSecurityDefinition;
    type?: PropertySecurityGroupType | null | undefined;
}
/**
 * Modification of PropertySecurityGroup. A globally unique identifier will be generated for each unique
 * SecurityGroupSecurityDefinitionModification specification.
 *
 * When modifying an existing PropertySecurityGroup, the existing PropertySecurityGroupRid is preserved if the
 * actual security remains unchanged from the existing security definition.
 *
 * The caller issuing a security group modification request must have ontology:edit-property-security-group
 * permission, and to satisfy current and proposed (if being changed) mandatory security.
 */
interface PropertySecurityGroupModification {
    properties: Array<PropertyTypeId>;
    security: SecurityGroupSecurityDefinitionModification;
    type?: PropertySecurityGroupType | null | undefined;
}
/**
 * A user-defined name that labels a PropertySecurityGroup.
 */
type PropertySecurityGroupName = string;
/**
 * A randomly generated rid that identifies a unique PropertySecurityGroup.
 */
type PropertySecurityGroupRid = string;
/**
 * Groupings of properties into different security "buckets." Every property of the entity type must belong
 * to one and only one property security group.
 */
interface PropertySecurityGroups {
    groups: Array<PropertySecurityGroup>;
}
interface PropertySecurityGroupsModification {
    groups: Array<PropertySecurityGroupModification>;
}
interface PropertySecurityGroupType_primaryKey {
    type: "primaryKey";
    primaryKey: PrimaryKeyPropertySecurityGroupType;
}
interface PropertySecurityGroupType_property {
    type: "property";
    property: PropertyPropertySecurityGroupType;
}
type PropertySecurityGroupType = PropertySecurityGroupType_primaryKey | PropertySecurityGroupType_property;
/**
 * A PropertyType is a typed attribute of an ObjectType.
 */
interface PropertyType {
    apiName?: ObjectTypeFieldApiName | null | undefined;
    baseFormatter?: BaseFormatter | null | undefined;
    dataConstraints?: DataConstraints | null | undefined;
    displayMetadata: PropertyTypeDisplayMetadata;
    id: PropertyTypeId;
    indexedForSearch: boolean;
    inlineAction?: InlineActionType | null | undefined;
    rid: PropertyTypeRid;
    ruleSetBinding?: RuleSetBinding | null | undefined;
    sharedPropertyTypeApiName?: ObjectTypeFieldApiName | null | undefined;
    sharedPropertyTypeRid?: SharedPropertyTypeRid | null | undefined;
    status: PropertyTypeStatus;
    type: Type;
    typeClasses: Array<TypeClass>;
    valueType?: ValueTypeReference$1 | null | undefined;
}
interface PropertyTypeDataConstraints_array {
    type: "array";
    array: ArrayTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_boolean {
    type: "boolean";
    boolean: BooleanTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_date {
    type: "date";
    date: DateTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_decimal {
    type: "decimal";
    decimal: DecimalTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_double {
    type: "double";
    double: DoubleTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_float {
    type: "float";
    float: FloatTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_integer {
    type: "integer";
    integer: IntegerTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_long {
    type: "long";
    long: LongTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_short {
    type: "short";
    short: ShortTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_string {
    type: "string";
    string: StringTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_struct {
    type: "struct";
    struct: StructTypeDataConstraints$1;
}
interface PropertyTypeDataConstraints_timestamp {
    type: "timestamp";
    timestamp: TimestampTypeDataConstraints$1;
}
type PropertyTypeDataConstraints = PropertyTypeDataConstraints_array | PropertyTypeDataConstraints_boolean | PropertyTypeDataConstraints_date | PropertyTypeDataConstraints_decimal | PropertyTypeDataConstraints_double | PropertyTypeDataConstraints_float | PropertyTypeDataConstraints_integer | PropertyTypeDataConstraints_long | PropertyTypeDataConstraints_short | PropertyTypeDataConstraints_string | PropertyTypeDataConstraints_struct | PropertyTypeDataConstraints_timestamp;
interface PropertyTypeDataConstraintsWrapper {
    constraints: PropertyTypeDataConstraints;
    failureMessage?: FailureMessage$1 | null | undefined;
}
interface PropertyTypeDataValue_array {
    type: "array";
    array: ArrayTypeDataValue$1;
}
interface PropertyTypeDataValue_boolean {
    type: "boolean";
    boolean: BooleanTypeDataValue$1;
}
interface PropertyTypeDataValue_byte {
    type: "byte";
    byte: ByteTypeDataValue$1;
}
interface PropertyTypeDataValue_date {
    type: "date";
    date: DateTypeDataValue$1;
}
interface PropertyTypeDataValue_decimal {
    type: "decimal";
    decimal: DecimalTypeDataValue$1;
}
interface PropertyTypeDataValue_double {
    type: "double";
    double: DoubleTypeDataValue$1;
}
interface PropertyTypeDataValue_float {
    type: "float";
    float: FloatTypeDataValue$1;
}
interface PropertyTypeDataValue_integer {
    type: "integer";
    integer: IntegerTypeDataValue$1;
}
interface PropertyTypeDataValue_long {
    type: "long";
    long: LongTypeDataValue$1;
}
interface PropertyTypeDataValue_short {
    type: "short";
    short: ShortTypeDataValue$1;
}
interface PropertyTypeDataValue_string {
    type: "string";
    string: StringTypeDataValue$1;
}
interface PropertyTypeDataValue_timestamp {
    type: "timestamp";
    timestamp: TimestampTypeDataValue$1;
}
/**
 * Data values representation of the base types used in the data constraints.
 */
type PropertyTypeDataValue = PropertyTypeDataValue_array | PropertyTypeDataValue_boolean | PropertyTypeDataValue_byte | PropertyTypeDataValue_date | PropertyTypeDataValue_decimal | PropertyTypeDataValue_double | PropertyTypeDataValue_float | PropertyTypeDataValue_integer | PropertyTypeDataValue_long | PropertyTypeDataValue_short | PropertyTypeDataValue_string | PropertyTypeDataValue_timestamp;
/**
 * This includes metadata which can be used by front-ends when displaying the PropertyType.
 */
interface PropertyTypeDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
    visibility: Visibility;
}
/**
 * This is a human readable id for the PropertyType. ids.PropertyTypeIds can be made up of lower or upper case
 * letters, numbers, dashes and underscores. ids.PropertyTypeId(s) are mutable at the moment. However, changing
 * it has the same effect as deleting and creating a new PropertyType. You should be careful when changing
 * it as there may be consumers (Hubble object views, plugins) that may be referencing it.
 *
 * Please note that this is not safe to log as it is user-inputted and may contain sensitive information.
 */
type PropertyTypeId = string;
interface PropertyTypeIdentifier_id {
    type: "id";
    id: PropertyTypeId;
}
interface PropertyTypeIdentifier_rid {
    type: "rid";
    rid: PropertyTypeRid;
}
type PropertyTypeIdentifier = PropertyTypeIdentifier_id | PropertyTypeIdentifier_rid;
/**
 * An locator of a PropertyType including the ObjectTypeRid it belongs to.
 */
interface PropertyTypeLocator {
    objectTypeRid: ObjectTypeRid;
    propertyTypeRid: PropertyTypeRid;
}
interface PropertyTypeMappingInfo_column {
    type: "column";
    column: ColumnName;
}
interface PropertyTypeMappingInfo_editOnly {
    type: "editOnly";
    editOnly: EditOnlyPropertyType;
}
interface PropertyTypeMappingInfo_struct {
    type: "struct";
    struct: StructFieldApiNameMapping;
}
/**
 * This indicates whether the property type is backed by a dataset column, or is unbacked and hence an
 * edit only property type.
 */
type PropertyTypeMappingInfo = PropertyTypeMappingInfo_column | PropertyTypeMappingInfo_editOnly | PropertyTypeMappingInfo_struct;
interface PropertyTypeReference_baseType {
    type: "baseType";
    baseType: BasePropertyType;
}
/**
 * A reference to a base type.
 */
type PropertyTypeReference = PropertyTypeReference_baseType;
interface PropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType {
    type: "propertyType";
    propertyType: PropertyTypeId;
}
interface PropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation {
    type: "internalInterpolation";
    internalInterpolation: NonNumericInternalInterpolation;
}
type PropertyTypeReferenceOrNonNumericInternalInterpolation = PropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType | PropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation;
interface PropertyTypeReferenceOrNumericInternalInterpolation_propertyType {
    type: "propertyType";
    propertyType: PropertyTypeId;
}
interface PropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation {
    type: "internalInterpolation";
    internalInterpolation: NumericInternalInterpolation;
}
type PropertyTypeReferenceOrNumericInternalInterpolation = PropertyTypeReferenceOrNumericInternalInterpolation_propertyType | PropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation;
interface PropertyTypeReferenceOrStringConstant_constant {
    type: "constant";
    constant: string;
}
interface PropertyTypeReferenceOrStringConstant_propertyType {
    type: "propertyType";
    propertyType: PropertyTypeId;
}
type PropertyTypeReferenceOrStringConstant = PropertyTypeReferenceOrStringConstant_constant | PropertyTypeReferenceOrStringConstant_propertyType;
/**
 * An rid identifying the PropertyType. This rid is generated randomly and is safe for logging purposes.
 * The PropertyTypeRid for a PropertyType is immutable.
 */
type PropertyTypeRid = string;
interface PropertyTypeStatus_experimental {
    type: "experimental";
    experimental: ExperimentalPropertyTypeStatus;
}
interface PropertyTypeStatus_active {
    type: "active";
    active: ActivePropertyTypeStatus;
}
interface PropertyTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedPropertyTypeStatus;
}
interface PropertyTypeStatus_example {
    type: "example";
    example: ExamplePropertyTypeStatus;
}
/**
 * The status to indicate whether the PropertyType is either Experimental, Active, Deprecated, or Example.
 */
type PropertyTypeStatus = PropertyTypeStatus_experimental | PropertyTypeStatus_active | PropertyTypeStatus_deprecated | PropertyTypeStatus_example;
/**
 * Local property declaration.
 */
interface PropertyWithoutRid {
    arrayNestingLevel?: number | null | undefined;
    authorizationRid?: string | null | undefined;
    column: ColumnLocator;
    fieldMetadata?: FieldMetadata | null | undefined;
    id: PropertyId;
    type: PropertyTypeReference;
}
/**
 * A PutActionTypeRequest is used to create or modify Action Types.
 */
interface PutActionTypeRequest {
    actionLogConfiguration?: ActionLogConfiguration | null | undefined;
    apiName: ActionTypeApiName;
    displayMetadata: ActionTypeDisplayMetadataModification;
    logic: ActionLogic;
    notifications: Array<ActionNotification>;
    notificationSettings?: ActionNotificationSettings | null | undefined;
    parameterOrdering: Array<ParameterId>;
    parameters: Record<ParameterId, PutParameterRequest>;
    revert?: ActionRevert | null | undefined;
    status?: ActionTypeStatus | null | undefined;
    submissionConfiguration?: ActionSubmissionConfiguration | null | undefined;
    validation: Array<ValidationRule>;
    webhooks?: ActionWebhooks | null | undefined;
}
/**
 * A PutParameterRequest is used to create or modify Parameters.
 */
interface PutParameterRequest {
    displayMetadata: ParameterDisplayMetadata;
    type: BaseParameterType;
    validation: ConditionalValidationBlock;
}
/**
 * A PutParameterRequestModification is used to create or modify Parameters.
 */
interface PutParameterRequestModification {
    displayMetadata: ParameterDisplayMetadata;
    type: BaseParameterTypeModification;
    validation: ConditionalValidationBlockModification;
}
/**
 * A PutSectionRequest is used to create or modify Sections.
 */
interface PutSectionRequest {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    validation: SectionDisplayBlock;
}
/**
 * A PutSectionRequest is used to create or modify Sections.
 */
interface PutSectionRequestModification {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    validation: SectionDisplayBlockModification;
}
/**
 * Codex seriesId qualified with a time series syncRid
 */
interface QualifiedSeriesIdPropertyValue {
    seriesId: SeriesIdPropertyValue;
    syncRid: TimeSeriesSyncRid;
}
interface QuiverDashboardReference {
    quiverDashboardRid: QuiverDashboardRid;
    quiverDashboardVersion: QuiverDashboardVersion;
}
/**
 * ResourceIdentifier for a Quiver Dashboard.
 */
type QuiverDashboardRid = string;
/**
 * Version for a Quiver Dashboard.
 */
type QuiverDashboardVersion = string;
interface RangeSizeConstraint$1 {
    maxSize?: number | null | undefined;
    minSize?: number | null | undefined;
}
/**
 * The user does not have permission to view this part of the Action Type.
 */
interface Redacted {
}
interface RedactionOverrideOptions_everyoneTrusted {
    type: "everyoneTrusted";
    everyoneTrusted: EveryoneTrustedRedactionOverride;
}
type RedactionOverrideOptions = RedactionOverrideOptions_everyoneTrusted;
/**
 * Some of the referenced linkTypes in the Workflow do not exist.
 */
interface ReferencedLinkTypesInWorkflowNotFoundError {
    linkTypeIds: Array<LinkTypeId>;
    workflowRid: WorkflowRid;
}
/**
 * The request to modify the ontology references some missing LinkTypes.
 */
interface ReferencedLinkTypesNotFoundError {
    linkTypeReferences: Record<LinkTypeId, Array<LinkTypeId>>;
}
interface ReferencedObjectTypesChange {
    newObjectTypeIdA: ObjectTypeId;
    newObjectTypeIdB: ObjectTypeId;
    previousObjectTypeRidA: ObjectTypeRid;
    previousObjectTypeRidB: ObjectTypeRid;
}
/**
 * Some of the referenced objectTypes in the Workflow do not exist.
 */
interface ReferencedObjectTypesInWorkflowNotFoundError {
    objectTypeIds: Array<ObjectTypeId>;
    workflowRid: WorkflowRid;
}
/**
 * The request to modify the ontology references some missing ObjectTypes.
 */
interface ReferencedObjectTypesNotFoundError {
    linkTypeReferences: Record<ObjectTypeId, Array<LinkTypeId>>;
}
interface RegexCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    regex: string;
    value: ConditionValue;
}
interface RegexConditionModification {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
    regex: string;
    value: ConditionValueModification;
}
interface RegexConstraint$1 {
    regexPattern: string;
    usePartialMatch?: boolean | null | undefined;
}
/**
 * The cardinality of the given relationship.
 */
type RelationCardinality = "ONE_TO_MANY" | "MANY_TO_ONE" | "ONE_TO_ONE" | "MANY_TO_MANY";
interface RelationDisplayMetadata {
    displayName?: string | null | undefined;
    groupDisplayName?: string | null | undefined;
    pluralDisplayName?: string | null | undefined;
    typeclasses: Array<TypeClass>;
    visibility?: Visibility | null | undefined;
}
/**
 * The id for a Relation or BidirectionalRelation.
 */
type RelationId = string;
/**
 * The rid for a Relation or BidirectionalRelation. This rid is generated randomly and is safe for logging
 * purposes. The RelationRid for a Relation or BidirectionalRelation is immutable.
 */
type RelationRid = string;
type RelativeDateRangeTense = "FUTURE" | "PAST";
interface RelativeDateRangeValue {
    duration: number;
    tense: RelativeDateRangeTense;
    unit: TemporalUnit;
}
interface RenderingSettings_allNotificationRenderingMustSucceed {
    type: "allNotificationRenderingMustSucceed";
    allNotificationRenderingMustSucceed: AllNotificationRenderingMustSucceed;
}
interface RenderingSettings_anyNotificationRenderingCanFail {
    type: "anyNotificationRenderingCanFail";
    anyNotificationRenderingCanFail: AnyNotificationRenderingCanFail;
}
/**
 * Settings that determine the rendering behaviour for notifications in current ActionType
 */
type RenderingSettings = RenderingSettings_allNotificationRenderingMustSucceed | RenderingSettings_anyNotificationRenderingCanFail;
/**
 * An rid identifying a Foundry restricted view. This rid is a randomly generated identifier and is safe to log.
 */
type RestrictedViewRid = string;
/**
 * An rid identifying a restricted view transaction. This rid is a randomly generated identifier and is safe to
 * log.
 */
type RestrictedViewTransactionRid = string;
interface RetentionPolicy_time {
    type: "time";
    time: TimeBasedRetentionPolicy;
}
interface RetentionPolicy_none {
    type: "none";
    none: NoRetentionPolicy;
}
type RetentionPolicy = RetentionPolicy_time | RetentionPolicy_none;
interface RidFormatter_objectsPlatformRids {
    type: "objectsPlatformRids";
    objectsPlatformRids: ObjectsPlatformRids;
}
interface RidFormatter_allFoundryRids {
    type: "allFoundryRids";
    allFoundryRids: AllFoundryRids;
}
/**
 * Convert Resource Identifiers into human-readable format. For example,
 * show the display name of an Object Set as opposed to its Rid.
 */
type RidFormatter = RidFormatter_objectsPlatformRids | RidFormatter_allFoundryRids;
/**
 * A URL target for a Foundry rid with query params.
 */
interface RidUrlTarget {
    queryParams: Record<string, LogicRuleValue>;
    rid: LogicRuleValue;
}
/**
 * A URL target for a Foundry rid with query params.
 */
interface RidUrlTargetModification {
    queryParams: Record<string, LogicRuleValueModification>;
    rid: LogicRuleValueModification;
}
/**
 * The id of a role
 */
type RoleId = string;
/**
 * The id of a role set
 */
type RoleSetId = string;
/**
 * Bind a rule set to a practical use. This enables re-use of rule sets in various contexts (e.g. values can
 * be bound to properties, or to actions). The `it` value is considered special & have semantic meaning at the
 * binding point (e.g. the property to which the rule set is bound).
 */
interface RuleSetBinding {
    bindings: Record<ValueReferenceId, ValueReferenceSource>;
    ruleSetRid: RuleSetRid;
}
interface RuleSetError_ruleSetsNotFound {
    type: "ruleSetsNotFound";
    ruleSetsNotFound: RuleSetsNotFoundError;
}
interface RuleSetError_ruleSetsAlreadyExist {
    type: "ruleSetsAlreadyExist";
    ruleSetsAlreadyExist: RuleSetsAlreadyExistError;
}
type RuleSetError = RuleSetError_ruleSetsNotFound | RuleSetError_ruleSetsAlreadyExist;
/**
 * Reference to a rule set rid.
 */
type RuleSetRid = string;
/**
 * There was an attempt to create RuleSets that already exist.
 */
interface RuleSetsAlreadyExistError {
    ruleSetRids: Array<RuleSetRid>;
}
/**
 * The RuleSets were not found.
 */
interface RuleSetsNotFoundError {
    ruleSetRids: Array<RuleSetRid>;
}
interface SafeArg {
    name: string;
    value: string;
}
interface SafeDatasourceIdentifier_datasetRid {
    type: "datasetRid";
    datasetRid: DatasetRid;
}
interface SafeDatasourceIdentifier_streamLocatorRid {
    type: "streamLocatorRid";
    streamLocatorRid: StreamLocatorRid;
}
interface SafeDatasourceIdentifier_restrictedViewRid {
    type: "restrictedViewRid";
    restrictedViewRid: RestrictedViewRid;
}
interface SafeDatasourceIdentifier_timeSeriesSyncRid {
    type: "timeSeriesSyncRid";
    timeSeriesSyncRid: TimeSeriesSyncRid;
}
interface SafeDatasourceIdentifier_restrictedStream {
    type: "restrictedStream";
    restrictedStream: RestrictedViewRid;
}
interface SafeDatasourceIdentifier_mediaSourceRids {
    type: "mediaSourceRids";
    mediaSourceRids: Array<MediaSourceRid>;
}
interface SafeDatasourceIdentifier_mediaSetView {
    type: "mediaSetView";
    mediaSetView: MediaSetViewLocator;
}
interface SafeDatasourceIdentifier_geotimeSeriesIntegrationRid {
    type: "geotimeSeriesIntegrationRid";
    geotimeSeriesIntegrationRid: GeotimeSeriesIntegrationRid;
}
interface SafeDatasourceIdentifier_editsOnly {
    type: "editsOnly";
    editsOnly: EditsOnlyRid;
}
interface SafeDatasourceIdentifier_directSourceRid {
    type: "directSourceRid";
    directSourceRid: DirectSourceRid;
}
interface SafeDatasourceIdentifier_derivedPropertiesSourceRid {
    type: "derivedPropertiesSourceRid";
    derivedPropertiesSourceRid: DerivedPropertiesSourceRid;
}
interface SafeDatasourceIdentifier_tableRid {
    type: "tableRid";
    tableRid: TableRid;
}
/**
 * Union type representing safe parts of different datasource identifiers
 */
type SafeDatasourceIdentifier = SafeDatasourceIdentifier_datasetRid | SafeDatasourceIdentifier_streamLocatorRid | SafeDatasourceIdentifier_restrictedViewRid | SafeDatasourceIdentifier_timeSeriesSyncRid | SafeDatasourceIdentifier_restrictedStream | SafeDatasourceIdentifier_mediaSourceRids | SafeDatasourceIdentifier_mediaSetView | SafeDatasourceIdentifier_geotimeSeriesIntegrationRid | SafeDatasourceIdentifier_editsOnly | SafeDatasourceIdentifier_directSourceRid | SafeDatasourceIdentifier_derivedPropertiesSourceRid | SafeDatasourceIdentifier_tableRid;
/**
 * Identifier for a schema migration.
 */
type SchemaMigrationRid = string;
/**
 * The schema version of an entity. Is automatically increased when a new schema migration is added.
 */
type SchemaVersion = number;
/**
 * A physical and logical grouping of parameters on the action form.
 */
interface Section {
    content: Array<SectionContent>;
    displayMetadata: SectionDisplayMetadata;
    id: SectionId;
    rid: SectionRid;
}
/**
 * This block contains a conditional override for a section.
 * This includes the condition to test and the new display parameters to use if the condition passes.
 */
interface SectionConditionalOverride {
    condition: Condition;
    sectionBlockOverrides: Array<SectionDisplayBlockOverride>;
}
/**
 * This block contains a conditional override for a section.
 * This includes the condition to test and the new display parameters to use if the condition passes.
 */
interface SectionConditionalOverrideModification {
    condition: ConditionModification;
    sectionBlockOverrides: Array<SectionDisplayBlockOverride>;
}
interface SectionContent_parameterId {
    type: "parameterId";
    parameterId: ParameterId;
}
/**
 * Items that we can place in a section.
 */
type SectionContent = SectionContent_parameterId;
/**
 * Contains information about the section display and any conditional overrides set on the section.
 * If more than one conditional override is passed. The first one with a passing condition will take priority.
 */
interface SectionDisplayBlock {
    conditionalOverrides: Array<SectionConditionalOverride>;
    defaultDisplayMetadata: SectionValidationDisplayMetadata;
}
/**
 * Contains information about the section display and any conditional overrides set on the section.
 * If more than one conditional override is passed. The first one with a passing condition will take priority.
 */
interface SectionDisplayBlockModification {
    conditionalOverrides: Array<SectionConditionalOverrideModification>;
    defaultDisplayMetadata: SectionValidationDisplayMetadata;
}
interface SectionDisplayBlockOverride_visibility {
    type: "visibility";
    visibility: SectionVisibilityOverride;
}
/**
 * The display parameters for a section override
 */
type SectionDisplayBlockOverride = SectionDisplayBlockOverride_visibility;
/**
 * Additional Section Metadata. This is used in rendering the section display.
 */
interface SectionDisplayMetadata {
    collapsedByDefault: boolean;
    columnCount: number;
    description: string;
    displayName: string;
    showTitleBar: boolean;
    style?: SectionStyle | null | undefined;
}
/**
 * The id for a Section which uniquely identifies the Section per ActionType. The size limit for the section id is 30 characters. Not safe for logging.
 */
type SectionId = string;
/**
 * The rid for a Section, autogenerated by Ontology-Metadata-Service and used for permissioning and logging.
 */
type SectionRid = string;
interface SectionStyle_box {
    type: "box";
    box: Empty;
}
interface SectionStyle_minimal {
    type: "minimal";
    minimal: Empty;
}
/**
 * Visual rendering style of the Section within an Action Form
 */
type SectionStyle = SectionStyle_box | SectionStyle_minimal;
/**
 * Information about how the section and its content should be displayed in the form.
 */
interface SectionValidationDisplayMetadata {
    visibility: SectionVisibility;
}
/**
 * Information about how the section and its content should be displayed in the form.
 */
interface SectionVisibilityOverride {
    visibility: SectionVisibility;
}
interface SecurityGroupAndCondition {
    conditions: Array<SecurityGroupGranularCondition>;
}
interface SecurityGroupAndConditionModification {
    conditions: Array<SecurityGroupGranularConditionModification>;
}
interface SecurityGroupComparisonCondition {
    left: SecurityGroupComparisonValue;
    operator: SecurityGroupComparisonOperator;
    right: SecurityGroupComparisonValue;
}
interface SecurityGroupComparisonConditionModification {
    left: SecurityGroupComparisonValueModification;
    operator: SecurityGroupComparisonOperator;
    right: SecurityGroupComparisonValueModification;
}
interface SecurityGroupComparisonConstant_string {
    type: "string";
    string: string;
}
interface SecurityGroupComparisonConstant_boolean {
    type: "boolean";
    boolean: boolean;
}
interface SecurityGroupComparisonConstant_strings {
    type: "strings";
    strings: Array<string>;
}
/**
 * A value represented by a constant.
 */
type SecurityGroupComparisonConstant = SecurityGroupComparisonConstant_string | SecurityGroupComparisonConstant_boolean | SecurityGroupComparisonConstant_strings;
type SecurityGroupComparisonOperator = "EQUAL" | "INTERSECTS" | "SUPERSET_OF" | "SUBSET_OF";
interface SecurityGroupComparisonUserProperty_userId {
    type: "userId";
    userId: SecurityGroupUserIdUserProperty;
}
interface SecurityGroupComparisonUserProperty_username {
    type: "username";
    username: SecurityGroupUsernameUserProperty;
}
interface SecurityGroupComparisonUserProperty_groupIds {
    type: "groupIds";
    groupIds: SecurityGroupGroupIdsUserProperty;
}
interface SecurityGroupComparisonUserProperty_groupNames {
    type: "groupNames";
    groupNames: SecurityGroupGroupNamesUserProperty;
}
interface SecurityGroupComparisonUserProperty_userAttributes {
    type: "userAttributes";
    userAttributes: SecurityGroupUserAttributesUserProperty;
}
/**
 * A value represented by a property of a user.
 */
type SecurityGroupComparisonUserProperty = SecurityGroupComparisonUserProperty_userId | SecurityGroupComparisonUserProperty_username | SecurityGroupComparisonUserProperty_groupIds | SecurityGroupComparisonUserProperty_groupNames | SecurityGroupComparisonUserProperty_userAttributes;
interface SecurityGroupComparisonValue_constant {
    type: "constant";
    constant: SecurityGroupComparisonConstant;
}
interface SecurityGroupComparisonValue_property {
    type: "property";
    property: PropertyTypeRid;
}
interface SecurityGroupComparisonValue_userProperty {
    type: "userProperty";
    userProperty: SecurityGroupComparisonUserProperty;
}
type SecurityGroupComparisonValue = SecurityGroupComparisonValue_constant | SecurityGroupComparisonValue_property | SecurityGroupComparisonValue_userProperty;
interface SecurityGroupComparisonValueModification_constant {
    type: "constant";
    constant: SecurityGroupComparisonConstant;
}
interface SecurityGroupComparisonValueModification_property {
    type: "property";
    property: PropertyTypeId;
}
interface SecurityGroupComparisonValueModification_userProperty {
    type: "userProperty";
    userProperty: SecurityGroupComparisonUserProperty;
}
type SecurityGroupComparisonValueModification = SecurityGroupComparisonValueModification_constant | SecurityGroupComparisonValueModification_property | SecurityGroupComparisonValueModification_userProperty;
interface SecurityGroupGranularCondition_not {
    type: "not";
    not: SecurityGroupNotCondition;
}
interface SecurityGroupGranularCondition_true {
    type: "true";
    true: SecurityGroupTrueCondition;
}
interface SecurityGroupGranularCondition_and {
    type: "and";
    and: SecurityGroupAndCondition;
}
interface SecurityGroupGranularCondition_or {
    type: "or";
    or: SecurityGroupOrCondition;
}
interface SecurityGroupGranularCondition_markings {
    type: "markings";
    markings: SecurityGroupMarkingsCondition;
}
interface SecurityGroupGranularCondition_comparison {
    type: "comparison";
    comparison: SecurityGroupComparisonCondition;
}
/**
 * This definition is a subset of the full GPS policy definition language. It contains minimal supported conditions.
 * Note that more conditions can and will be added in the future, as the need arises.
 */
type SecurityGroupGranularCondition = SecurityGroupGranularCondition_not | SecurityGroupGranularCondition_true | SecurityGroupGranularCondition_and | SecurityGroupGranularCondition_or | SecurityGroupGranularCondition_markings | SecurityGroupGranularCondition_comparison;
interface SecurityGroupGranularConditionModification_not {
    type: "not";
    not: SecurityGroupNotConditionModification;
}
interface SecurityGroupGranularConditionModification_true {
    type: "true";
    true: SecurityGroupTrueConditionModification;
}
interface SecurityGroupGranularConditionModification_and {
    type: "and";
    and: SecurityGroupAndConditionModification;
}
interface SecurityGroupGranularConditionModification_or {
    type: "or";
    or: SecurityGroupOrConditionModification;
}
interface SecurityGroupGranularConditionModification_markings {
    type: "markings";
    markings: SecurityGroupMarkingsConditionModification;
}
interface SecurityGroupGranularConditionModification_comparison {
    type: "comparison";
    comparison: SecurityGroupComparisonConditionModification;
}
type SecurityGroupGranularConditionModification = SecurityGroupGranularConditionModification_not | SecurityGroupGranularConditionModification_true | SecurityGroupGranularConditionModification_and | SecurityGroupGranularConditionModification_or | SecurityGroupGranularConditionModification_markings | SecurityGroupGranularConditionModification_comparison;
/**
 * Ontology-managed granular security applied to the properties in the group. User must also first satisfy the
 * additionalMandatory security markings, if any are specified, to have visibility to the properties within
 * this group that are allowed by the granular policy.
 *
 * The granular policy specified must be authorized by the overall ObjectTypeDatasource's dataSecurity for
 * every "row" (object or relation).
 */
interface SecurityGroupGranularPolicy {
    additionalMandatory: SecurityGroupMandatoryPolicy;
    granularPolicyCondition: SecurityGroupGranularCondition;
}
interface SecurityGroupGranularPolicyModification {
    additionalMandatory: SecurityGroupMandatoryPolicy;
    granularPolicyCondition: SecurityGroupGranularConditionModification;
}
/**
 * Ontology-managed granular policy applied to the properties in the group.
 */
interface SecurityGroupGranularSecurityDefinition {
    viewPolicy: SecurityGroupGranularPolicy;
}
interface SecurityGroupGranularSecurityDefinitionModification {
    viewPolicy: SecurityGroupGranularPolicyModification;
}
/**
 * Specifies a comparison against the user's multipass groupIds.
 */
interface SecurityGroupGroupIdsUserProperty {
    parentGroupId?: GroupId | null | undefined;
}
/**
 * The user's group IDs
 */
interface SecurityGroupGroupNamesUserProperty {
    parentGroupId?: string | null | undefined;
    realm: string;
}
/**
 * Ontology-managed mandatory security applied to the properties in the security group.
 */
interface SecurityGroupMandatoryOnlySecurityDefinition {
    policy: SecurityGroupMandatoryPolicy;
}
interface SecurityGroupMandatoryOnlySecurityDefinitionModification {
    policy: SecurityGroupMandatoryPolicy;
}
interface SecurityGroupMandatoryPolicy {
    assumedMarkings: Array<MarkingId>;
    markings: Array<MarkingId>;
}
/**
 * Condition that specifies that user's markings must be evaluated against the marking(s) contained on each
 * object's 'property'.
 *
 * Note that the specified property's propertyType must be of type MarkingPropertyType or ArrayPropertyType
 * of MarkingPropertyTypes.
 */
interface SecurityGroupMarkingsCondition {
    property: PropertyTypeRid;
}
interface SecurityGroupMarkingsConditionModification {
    property: PropertyTypeId;
}
/**
 * True if the condition is false. This condition cannot have an empty property type.
 */
interface SecurityGroupNotCondition {
    condition: SecurityGroupGranularCondition;
}
interface SecurityGroupNotConditionModification {
    condition: SecurityGroupGranularConditionModification;
}
interface SecurityGroupOrCondition {
    conditions: Array<SecurityGroupGranularCondition>;
}
interface SecurityGroupOrConditionModification {
    conditions: Array<SecurityGroupGranularConditionModification>;
}
interface SecurityGroupSecurityDefinition_mandatoryOnly {
    type: "mandatoryOnly";
    mandatoryOnly: SecurityGroupMandatoryOnlySecurityDefinition;
}
interface SecurityGroupSecurityDefinition_granular {
    type: "granular";
    granular: SecurityGroupGranularSecurityDefinition;
}
type SecurityGroupSecurityDefinition = SecurityGroupSecurityDefinition_mandatoryOnly | SecurityGroupSecurityDefinition_granular;
interface SecurityGroupSecurityDefinitionModification_mandatoryOnly {
    type: "mandatoryOnly";
    mandatoryOnly: SecurityGroupMandatoryOnlySecurityDefinitionModification;
}
interface SecurityGroupSecurityDefinitionModification_granular {
    type: "granular";
    granular: SecurityGroupGranularSecurityDefinitionModification;
}
type SecurityGroupSecurityDefinitionModification = SecurityGroupSecurityDefinitionModification_mandatoryOnly | SecurityGroupSecurityDefinitionModification_granular;
/**
 * Always evaluates to true.
 */
interface SecurityGroupTrueCondition {
}
/**
 * Always evaluates to true.
 */
interface SecurityGroupTrueConditionModification {
}
/**
 * The user's attributes.
 */
interface SecurityGroupUserAttributesUserProperty {
    attributeKey: string;
}
/**
 * Specifies a comparison against the user's multipass userId.
 */
interface SecurityGroupUserIdUserProperty {
}
/**
 * The user's username
 */
interface SecurityGroupUsernameUserProperty {
    realm: string;
}
/**
 * A semantic version for a Function. This can be a static version or a range.
 */
type SemanticFunctionVersion = string;
interface SensorTrait {
    readingPropertyTypeRid: PropertyTypeRid;
}
/**
 * Codex seriesId.
 */
type SeriesIdPropertyValue = string;
interface SeriesValueMetadata_numeric {
    type: "numeric";
    numeric: NumericSeriesValueMetadata;
}
interface SeriesValueMetadata_enum {
    type: "enum";
    enum: NonNumericSeriesValueMetadata;
}
interface SeriesValueMetadata_numericOrNonNumeric {
    type: "numericOrNonNumeric";
    numericOrNonNumeric: NumericOrNonNumericSeriesValueMetadata;
}
interface SeriesValueMetadata_numericOrNonNumericV2 {
    type: "numericOrNonNumericV2";
    numericOrNonNumericV2: NumericOrNonNumericSeriesValueMetadataV2;
}
type SeriesValueMetadata = SeriesValueMetadata_numeric | SeriesValueMetadata_enum | SeriesValueMetadata_numericOrNonNumeric | SeriesValueMetadata_numericOrNonNumericV2;
interface SharedPropertiesSummary {
    visibleEntities: number;
}
/**
 * A property type that can be shared across object types.
 */
interface SharedPropertyType {
    aliases: Array<SharedPropertyTypeAlias>;
    apiName: ObjectTypeFieldApiName;
    baseFormatter?: BaseFormatter | null | undefined;
    dataConstraints?: DataConstraints | null | undefined;
    displayMetadata: SharedPropertyTypeDisplayMetadata;
    gothamMapping?: SharedPropertyTypeGothamMapping | null | undefined;
    indexedForSearch: boolean;
    provenance?: EntityProvenance | null | undefined;
    rid: SharedPropertyTypeRid;
    type: Type;
    typeClasses: Array<TypeClass>;
    valueType?: ValueTypeReference$1 | null | undefined;
}
interface SharedPropertyTypeCreatedEvent {
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface SharedPropertyTypeDeletedEvent {
    deletionMetadata?: DeletionMetadata | null | undefined;
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
/**
 * This includes metadata which can be used by front-ends when displaying the SharedPropertyType.
 */
interface SharedPropertyTypeDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
    visibility: Visibility;
}
interface SharedPropertyTypeError_sharedPropertyTypesNotFound {
    type: "sharedPropertyTypesNotFound";
    sharedPropertyTypesNotFound: SharedPropertyTypesNotFoundError;
}
interface SharedPropertyTypeError_sharedPropertyTypesAlreadyExist {
    type: "sharedPropertyTypesAlreadyExist";
    sharedPropertyTypesAlreadyExist: SharedPropertyTypesAlreadyExistError;
}
type SharedPropertyTypeError = SharedPropertyTypeError_sharedPropertyTypesNotFound | SharedPropertyTypeError_sharedPropertyTypesAlreadyExist;
/**
 * Reference to a SharedPropertyType. Used when referencing an SharedPropertyType in the same request it is
 * created in.
 */
type SharedPropertyTypeIdInRequest = string;
/**
 * Request to load a SharedPropertyType.
 */
interface SharedPropertyTypeLoadRequest {
    rid: SharedPropertyTypeRid;
    versionReference?: VersionReference | null | undefined;
}
/**
 * Response to a SharedPropertyTypeLoadRequest.
 */
interface SharedPropertyTypeLoadResponse {
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
    sharedPropertyType: SharedPropertyType;
}
/**
 * A pair of SharedPropertyTypeRidOrIdInRequest and the associated LogicRuleValueModification.
 */
interface SharedPropertyTypeLogicRuleValueModification {
    logicRuleValueModification: LogicRuleValueModification;
    sharedPropertyTypeRidOrIdInRequest: SharedPropertyTypeRidOrIdInRequest;
}
/**
 * A rid identifying the SharedPropertyType. This rid is generated randomly and is safe for logging purposes.
 * The SharedPropertyTypeRid for a SharedPropertyType is immutable.
 */
type SharedPropertyTypeRid = string;
interface SharedPropertyTypeRidOrIdInRequest_rid {
    type: "rid";
    rid: SharedPropertyTypeRid;
}
interface SharedPropertyTypeRidOrIdInRequest_idInRequest {
    type: "idInRequest";
    idInRequest: SharedPropertyTypeIdInRequest;
}
type SharedPropertyTypeRidOrIdInRequest = SharedPropertyTypeRidOrIdInRequest_rid | SharedPropertyTypeRidOrIdInRequest_idInRequest;
/**
 * There was an attempt to create SharedPropertyTypes that already exist.
 */
interface SharedPropertyTypesAlreadyExistError {
    sharedPropertyTypeRids: Array<SharedPropertyTypeRid>;
}
/**
 * SharedPropertyTypes were not found.
 */
interface SharedPropertyTypesNotFoundError {
    sharedPropertyTypeRids: Array<SharedPropertyTypeRid>;
}
/**
 * The SoftLink is generated by a SharedPropertyType that the two ObjectTypes have in common.
 */
interface SharedPropertyTypeSoftLinkType {
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
/**
 * A StructFieldRid or StructFieldApiName, the SharedPropertyTypeRidOrIdInRequest of the struct property, and the
 * associated StructFieldLogicRuleValueModification.
 */
interface SharedPropertyTypeStructFieldLogicRuleValueModification {
    sharedPropertyTypeRidOrIdInRequest: SharedPropertyTypeRidOrIdInRequest;
    structFieldApiName?: ObjectTypeFieldApiName | null | undefined;
    structFieldApiNameOrRid?: StructFieldApiNameOrRid | null | undefined;
    structFieldLogicRuleValueModification: StructFieldLogicRuleValueModification;
}
interface SharedPropertyTypeUpdatedEvent {
    ontologyBranch: OntologyBranch;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface ShortBody_basic {
    type: "basic";
    basic: StructuredShortBody;
}
/**
 * An action notification's short body. Generally used for in-platform notifications. Uses Handlebars
 * templating.
 */
type ShortBody = ShortBody_basic;
interface ShortBodyModification_basic {
    type: "basic";
    basic: StructuredShortBodyModification;
}
/**
 * An action notification's short body. Generally used for in-platform notifications. Uses Handlebars
 * templating.
 */
type ShortBodyModification = ShortBodyModification_basic;
interface ShortPropertyType {
}
interface ShortTypeDataConstraints_range$1 {
    type: "range";
    range: ShortTypeRangeConstraint$1;
}
interface ShortTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfShortTypeConstraint$1;
}
type ShortTypeDataConstraints$1 = ShortTypeDataConstraints_range$1 | ShortTypeDataConstraints_oneOf$1;
type ShortTypeDataValue$1 = number;
interface ShortTypeRangeConstraint$1 {
    max?: ShortTypeDataValue$1 | null | undefined;
    min?: ShortTypeDataValue$1 | null | undefined;
}
/**
 * The simple analyzer breaks text into terms whenever it encounters a character which is not a letter
 * and also lower cases it.
 */
interface SimpleAnalyzer {
}
interface SingleKeyJoinDefinition {
    foreignKeyObjectTypeId: ObjectTypeId;
    foreignKeyPropertyId: PropertyId;
    primaryKeyObjectTypeId: ObjectTypeId;
}
/**
 * A mapping from a property of the given ObjectType to the property of another.
 */
interface SoftLink {
    fromProperty: PropertyTypeLocator;
    softLinkType: SoftLinkType;
    toProperty: PropertyTypeLocator;
}
interface SoftLinkType_sharedPropertyType {
    type: "sharedPropertyType";
    sharedPropertyType: SharedPropertyTypeSoftLinkType;
}
/**
 * The type of SoftLink. Information on what is generating the relationship between the two properties.
 */
type SoftLinkType = SoftLinkType_sharedPropertyType;
/**
 * This is the default analyzer which is used when no analyzerOverride is specified. It tokenizes the
 * text based on grammar and also lower cases it. This is expected to work well for most purposes.
 */
interface StandardAnalyzer {
}
/**
 * StaticObjectPrefill specifies the Object that should be suggested to the user for a parameter.
 */
type StaticObjectPrefill = ObjectRid;
type StaticValue = DataValue;
/**
 * This webhook config will run the webhook given the input mapping provided. The webhook input parameters map
 * to Action logic rule values, such as parameters.
 */
interface StaticWebhookWithDirectInput {
    webhookInputValues: Record<WebhookInputParamName, LogicRuleValue>;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
/**
 * Modification type for LogicRuleValueModification, otherwise same as StaticWebhookWithDirectInput.
 */
interface StaticWebhookWithDirectInputModification {
    webhookInputValues: Record<WebhookInputParamName, LogicRuleValueModification>;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
/**
 * This webhook config will run the function given the input mapping provided. It will then run the webhook given
 * the result of the function as input. It expects a custom type containing all the expected webhook inputs.
 * e.g. An example of the expected return type from the Function:
 * ```
 * export interface WebhookResult {
 * arg1: string;
 * arg2: string;
 * }
 * export class MyFunctions {
 * @Function()
 * public createWebhookRequest(person: Person): WebhookResult {
 * return {
 * arg1: person.someProperty,
 * arg2: person.someOtherProperty,
 * };
 * }
 * }
 * If one of the Webhook inputs is a RecordType, it must have expectedFields defined and match exactly the custom
 * type.
 * ```
 */
interface StaticWebhookWithFunctionResultInput {
    functionInputValues: Record<FunctionInputName, LogicRuleValue>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
/**
 * Modification type for LogicRuleValueModification, otherwise same as StaticWebhookWithFunctionResultInput.
 */
interface StaticWebhookWithFunctionResultInputModification {
    functionInputValues: Record<FunctionInputName, LogicRuleValueModification>;
    functionRid: FunctionRid;
    functionVersion: FunctionVersion;
    webhookRid: WebhookRid;
    webhookVersion: WebhookVersion;
}
/**
 * Representing a stream locator which is uniquely defined by its rid and branch id.
 */
interface StreamLocator {
    branchId: BranchId;
    streamLocatorRid: StreamLocatorRid;
}
/**
 * An rid identifying a Foundry stream. This rid is a randomly generated identifier and is safe to log.
 */
type StreamLocatorRid = string;
/**
 * An rid identifying a stream view. This rid is a randomly generated identifier and is safe to log.
 */
type StreamViewRid = string;
/**
 * Formatter applied to STRING properties. Currently only used for labeling, e.g. on chart axes —
 * does not change the displayed string.
 */
interface StringFormatter {
    valueTypeLabel: ValueTypeLabel;
}
interface StringPropertyType {
    analyzerOverride?: Analyzer | null | undefined;
    enableAsciiFolding?: boolean | null | undefined;
    isLongText: boolean;
    supportsEfficientLeadingWildcard?: boolean | null | undefined;
    supportsExactMatching: boolean;
}
interface StringTypeDataConstraints_regex$1 {
    type: "regex";
    regex: RegexConstraint$1;
}
interface StringTypeDataConstraints_oneOf$1 {
    type: "oneOf";
    oneOf: OneOfStringTypeConstraint$1;
}
interface StringTypeDataConstraints_length$1 {
    type: "length";
    length: StringTypeLengthConstraint$1;
}
interface StringTypeDataConstraints_isUuid$1 {
    type: "isUuid";
    isUuid: StringTypeIsUuidConstraint$1;
}
interface StringTypeDataConstraints_isRid$1 {
    type: "isRid";
    isRid: StringTypeIsRidConstraint$1;
}
type StringTypeDataConstraints$1 = StringTypeDataConstraints_regex$1 | StringTypeDataConstraints_oneOf$1 | StringTypeDataConstraints_length$1 | StringTypeDataConstraints_isUuid$1 | StringTypeDataConstraints_isRid$1;
type StringTypeDataValue$1 = string;
interface StringTypeIsRidConstraint$1 {
}
interface StringTypeIsUuidConstraint$1 {
}
type StringTypeLengthConstraint$1 = RangeSizeConstraint$1;
type StructFieldAlias = Alias;
/**
 * A mapping from the backing column struct field names to the struct property type field api names. Optionally
 * allows specifying nested fields, although OMS will throw in practice since this is only to avoid an API break
 * in the future if we want to support nested structs.
 */
interface StructFieldApiNameMapping {
    column: ColumnName;
    mapping: Record<StructFieldName, NestedStructFieldApiNameMapping>;
}
interface StructFieldApiNameOrRid_rid {
    type: "rid";
    rid: StructFieldRid;
}
interface StructFieldApiNameOrRid_apiName {
    type: "apiName";
    apiName: ObjectTypeFieldApiName;
}
type StructFieldApiNameOrRid = StructFieldApiNameOrRid_rid | StructFieldApiNameOrRid_apiName;
interface StructFieldConditionalOverride {
    condition: Condition;
    structFieldBlockOverrides: Array<StructFieldValidationBlockOverride>;
}
interface StructFieldConditionalOverrideModification {
    condition: ConditionModification;
    structFieldBlockOverrides: Array<StructFieldValidationBlockOverrideModification>;
}
interface StructFieldConditionalValidationBlock {
    conditionalOverrides: Array<StructFieldConditionalOverride>;
    defaultValidation: StructFieldValidationBlock;
}
interface StructFieldConditionalValidationBlockModification {
    conditionalOverrides: Array<StructFieldConditionalOverrideModification>;
    defaultValidation: StructFieldValidationBlockModification;
}
/**
 * This includes metadata which can be used by front-ends when displaying a struct property type field.
 */
interface StructFieldDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
}
interface StructFieldLogicRuleValue_structParameterFieldValue {
    type: "structParameterFieldValue";
    structParameterFieldValue: StructParameterFieldValue;
}
interface StructFieldLogicRuleValue_structListParameterFieldValue {
    type: "structListParameterFieldValue";
    structListParameterFieldValue: StructListParameterFieldValue;
}
/**
 * LogicRuleValues that are allowed for struct fields.
 */
type StructFieldLogicRuleValue = StructFieldLogicRuleValue_structParameterFieldValue | StructFieldLogicRuleValue_structListParameterFieldValue;
interface StructFieldLogicRuleValueMappingModification {
    apiNameOrRid: StructFieldApiNameOrRid;
    structFieldLogicRuleValueModification: StructFieldLogicRuleValueModification;
}
interface StructFieldLogicRuleValueModification_structParameterFieldValue {
    type: "structParameterFieldValue";
    structParameterFieldValue: StructParameterFieldValue;
}
interface StructFieldLogicRuleValueModification_structListParameterFieldValue {
    type: "structListParameterFieldValue";
    structListParameterFieldValue: StructListParameterFieldValue;
}
/**
 * Modification objects for LogicRuleValues that are allowed for struct fields.
 */
type StructFieldLogicRuleValueModification = StructFieldLogicRuleValueModification_structParameterFieldValue | StructFieldLogicRuleValueModification_structListParameterFieldValue;
type StructFieldName = string;
interface StructFieldPrefill_objectParameterStructFieldValue {
    type: "objectParameterStructFieldValue";
    objectParameterStructFieldValue: ObjectParameterStructFieldValue;
}
interface StructFieldPrefill_objectParameterStructListFieldValue {
    type: "objectParameterStructListFieldValue";
    objectParameterStructListFieldValue: ObjectParameterStructListFieldValue;
}
/**
 * StructFieldPrefill specifies what should initially suggested to users for a struct parameter's field.
 */
type StructFieldPrefill = StructFieldPrefill_objectParameterStructFieldValue | StructFieldPrefill_objectParameterStructListFieldValue;
interface StructFieldPrefillModification_objectParameterStructFieldValue {
    type: "objectParameterStructFieldValue";
    objectParameterStructFieldValue: ObjectParameterStructFieldValueModification;
}
interface StructFieldPrefillModification_objectParameterStructListFieldValue {
    type: "objectParameterStructListFieldValue";
    objectParameterStructListFieldValue: ObjectParameterStructListFieldValueModification;
}
/**
 * StructFieldPrefillModification specifies what should initially suggested to users for a struct parameter's field.
 */
type StructFieldPrefillModification = StructFieldPrefillModification_objectParameterStructFieldValue | StructFieldPrefillModification_objectParameterStructListFieldValue;
interface StructFieldPrefillOverride {
    prefill: StructFieldPrefill;
}
interface StructFieldPrefillOverrideModification {
    prefill: StructFieldPrefillModification;
}
/**
 * A rid identifying a field of a struct property type. This rid is generated randomly and is safe for logging purposes.
 */
type StructFieldRid = string;
/**
 * Represents an ordered set of fields and values.
 */
interface StructFieldType {
    aliases: Array<StructFieldAlias>;
    apiName: ObjectTypeFieldApiName;
    displayMetadata: StructFieldDisplayMetadata;
    fieldType: Type;
    structFieldRid: StructFieldRid;
    typeClasses: Array<TypeClass>;
}
interface StructFieldValidation {
    allowedValues: AllowedStructFieldValues;
    required: ParameterRequiredConfiguration;
}
interface StructFieldValidationBlock {
    display: StructFieldValidationDisplayMetadata;
    validation: StructFieldValidation;
}
interface StructFieldValidationBlockModification {
    display: StructFieldValidationDisplayMetadataModification;
    validation: StructFieldValidationModification;
}
interface StructFieldValidationBlockOverride_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface StructFieldValidationBlockOverride_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface StructFieldValidationBlockOverride_allowedValues {
    type: "allowedValues";
    allowedValues: AllowedStructFieldValuesOverride;
}
interface StructFieldValidationBlockOverride_prefill {
    type: "prefill";
    prefill: StructFieldPrefillOverride;
}
type StructFieldValidationBlockOverride = StructFieldValidationBlockOverride_parameterRequired | StructFieldValidationBlockOverride_visibility | StructFieldValidationBlockOverride_allowedValues | StructFieldValidationBlockOverride_prefill;
interface StructFieldValidationBlockOverrideModification_parameterRequired {
    type: "parameterRequired";
    parameterRequired: ParameterRequiredOverride;
}
interface StructFieldValidationBlockOverrideModification_visibility {
    type: "visibility";
    visibility: VisibilityOverride;
}
interface StructFieldValidationBlockOverrideModification_allowedValues {
    type: "allowedValues";
    allowedValues: AllowedStructFieldValuesOverrideModification;
}
interface StructFieldValidationBlockOverrideModification_prefill {
    type: "prefill";
    prefill: StructFieldPrefillOverrideModification;
}
type StructFieldValidationBlockOverrideModification = StructFieldValidationBlockOverrideModification_parameterRequired | StructFieldValidationBlockOverrideModification_visibility | StructFieldValidationBlockOverrideModification_allowedValues | StructFieldValidationBlockOverrideModification_prefill;
/**
 * These values provide details about how struct parameter nested fields should be displayed in the form.
 */
interface StructFieldValidationDisplayMetadata {
    prefill?: StructFieldPrefill | null | undefined;
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
/**
 * These values provide details about how struct parameter nested fields should be displayed in the form.
 */
interface StructFieldValidationDisplayMetadataModification {
    prefill?: StructFieldPrefillModification | null | undefined;
    renderHint: ParameterRenderHint;
    visibility: ParameterVisibility;
}
interface StructFieldValidationModification {
    allowedValues: AllowedStructFieldValuesModification;
    required: ParameterRequiredConfiguration;
}
interface StructListParameterFieldValue {
    parameterId: ParameterId;
    structFieldApiName: StructParameterFieldApiName;
}
interface StructParameterFieldDisplayMetadata {
    displayName: string;
}
interface StructParameterFieldDisplayMetadataV2 {
    apiName: StructParameterFieldApiName;
    displayName: string;
}
interface StructParameterFieldValue {
    parameterId: ParameterId;
    structFieldApiName: StructParameterFieldApiName;
}
interface StructPropertyFieldType_boolean {
    type: "boolean";
    boolean: BooleanPropertyType;
}
interface StructPropertyFieldType_date {
    type: "date";
    date: DatePropertyType;
}
interface StructPropertyFieldType_double {
    type: "double";
    double: DoublePropertyType;
}
interface StructPropertyFieldType_geohash {
    type: "geohash";
    geohash: GeohashPropertyType;
}
interface StructPropertyFieldType_integer {
    type: "integer";
    integer: IntegerPropertyType;
}
interface StructPropertyFieldType_long {
    type: "long";
    long: LongPropertyType;
}
interface StructPropertyFieldType_string {
    type: "string";
    string: StringPropertyType;
}
interface StructPropertyFieldType_timestamp {
    type: "timestamp";
    timestamp: TimestampPropertyType;
}
/**
 * Wrapper type for the various supported struct property field types.
 */
type StructPropertyFieldType = StructPropertyFieldType_boolean | StructPropertyFieldType_date | StructPropertyFieldType_double | StructPropertyFieldType_geohash | StructPropertyFieldType_integer | StructPropertyFieldType_long | StructPropertyFieldType_string | StructPropertyFieldType_timestamp;
interface StructPropertyType {
    structFields: Array<StructFieldType>;
}
interface StructTypeDataConstraints$1 {
    elementConstraints: StructTypeElementsConstraint$1;
}
/**
 * Map of constraints declared on struct elements keyed by the struct field identifier.
 */
type StructTypeElementsConstraint$1 = Record<StructFieldIdentifier$1, DataConstraints>;
/**
 * An action notification's structured short body.
 */
interface StructuredShortBody {
    content: string;
    heading: string;
    links: Array<NotificationResultTypeLink>;
}
/**
 * An action notification's structured short body.
 */
interface StructuredShortBodyModification {
    content: string;
    heading: string;
    links: Array<NotificationResultTypeLinkModification>;
}
/**
 * In this mode, all apply action requests need to be valid (also considered as the collection) in order for the
 * submission to go through. In other words, this mode respects the atomicity property, i.e. actions are applied
 * either completely, or none at all. It also mirrors the V1 endpoint behaviour.
 */
interface SubmitAllValidOrNothingThrowingMode {
}
/**
 * Submits the set of all valid apply action requests defined in the parent request order until the first invalid
 * apply action request or the first request which makes the overall parent request container invalid, e.g.
 * duplicate conflicting edits on the same object. Subsequent requests will not be processed and returned
 * as unattempted.
 */
interface SubmitValidEntriesInOrderUntilFirstFailureMode {
}
interface SynchronousPreWritebackWebhook_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: StaticWebhookWithDirectInput;
}
interface SynchronousPreWritebackWebhook_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: StaticWebhookWithFunctionResultInput;
}
/**
 * Union wrapping the various options available for configuring a webhook which will be executed synchronously,
 * prior to writeback. If it fails, the Foundry writeback will be cancelled. This webhook is executed after
 * validations run and pass successfully.
 */
type SynchronousPreWritebackWebhook = SynchronousPreWritebackWebhook_staticDirectInput | SynchronousPreWritebackWebhook_staticFunctionInput;
interface SynchronousPreWritebackWebhookModification_staticDirectInput {
    type: "staticDirectInput";
    staticDirectInput: StaticWebhookWithDirectInputModification;
}
interface SynchronousPreWritebackWebhookModification_staticFunctionInput {
    type: "staticFunctionInput";
    staticFunctionInput: StaticWebhookWithFunctionResultInputModification;
}
/**
 * Uses modification types for nested LogicRuleValueModification, otherwise same as
 * SynchronousPreWritebackWebhook.
 */
type SynchronousPreWritebackWebhookModification = SynchronousPreWritebackWebhookModification_staticDirectInput | SynchronousPreWritebackWebhookModification_staticFunctionInput;
/**
 * Various settings for the table layout
 */
interface TableDisplayAndFormat {
    columnWidthByParameterRid: Record<ParameterRid, number>;
    enableFileImport: boolean;
    fitHorizontally: boolean;
    frozenColumnCount: number;
    rowHeightInLines: number;
}
/**
 * A locator for a table. This is a combination of the table rid and branch rid.
 */
interface TableLocator {
    branchId: BranchId;
    tableRid: TableRid;
}
/**
 * A rid identifying a table. This rid is a randomly generated identifier and is safe to log.
 */
type TableRid = string;
/**
 * The body of a notification based on a template.
 */
interface TemplateNotificationBody {
    emailBody: EmailBody;
    inputs: Record<HandlebarsInputName, NotificationTemplateInputValue>;
    shortBody: ShortBody;
}
/**
 * The body of a notification based on a template.
 */
interface TemplateNotificationBodyModification {
    emailBody: EmailBodyModification;
    inputs: Record<HandlebarsInputName, NotificationTemplateInputValueModification>;
    shortBody: ShortBodyModification;
}
/**
 * A unique identifier of a codex template and optionally a codex template version which resolves to a derived
 * series. If no version is provided, the latest version is used.
 */
interface TemplateRidPropertyValue {
    templateRid: string;
    templateVersion?: string | null | undefined;
}
interface TextEmbeddingModel_lms {
    type: "lms";
    lms: LmsEmbeddingModel;
}
interface TextEmbeddingModel_foundryLiveDeployment {
    type: "foundryLiveDeployment";
    foundryLiveDeployment: FoundryLiveDeployment;
}
type TextEmbeddingModel = TextEmbeddingModel_lms | TextEmbeddingModel_foundryLiveDeployment;
/**
 * A retention policy where the datasource will contain at least data from the specified time window.
 */
interface TimeBasedRetentionPolicy {
    window: string;
}
interface TimeCodeFormat {
}
/**
 * Formatter applied to TIME DEPENDENT properties.
 */
interface TimeDependentFormatter {
    timeDependentSeriesFormat: TimeDependentSeriesFormat;
}
/**
 * Configuration for non-numeric series.
 */
interface TimeDependentNonNumericSeriesFormat {
    defaultInternalInterpolation: PropertyTypeReferenceOrNonNumericInternalInterpolation;
    unit?: NonNumericSeriesValueUnit | null | undefined;
}
/**
 * Configuration for either numeric or non-numeric series.
 */
interface TimeDependentNumericOrNonNumericSeriesFormat {
    defaultInternalInterpolationPropertyTypeId: PropertyTypeId;
    isNonNumericPropertyTypeId: PropertyTypeId;
    unitPropertyTypeId: PropertyTypeId;
}
/**
 * Configuration for either numeric or non-numeric series.
 */
interface TimeDependentNumericOrNonNumericSeriesFormatV2 {
    defaultInternalInterpolationPropertyTypeId?: PropertyTypeId | null | undefined;
    unitPropertyTypeId?: PropertyTypeId | null | undefined;
}
/**
 * Configuration for numeric series.
 */
interface TimeDependentNumericSeriesFormat {
    defaultInternalInterpolation: PropertyTypeReferenceOrNumericInternalInterpolation;
    unit?: NumericSeriesValueUnit | null | undefined;
}
interface TimeDependentSeriesFormat_numeric {
    type: "numeric";
    numeric: TimeDependentNumericSeriesFormat;
}
interface TimeDependentSeriesFormat_nonNumeric {
    type: "nonNumeric";
    nonNumeric: TimeDependentNonNumericSeriesFormat;
}
interface TimeDependentSeriesFormat_numericOrNonNumeric {
    type: "numericOrNonNumeric";
    numericOrNonNumeric: TimeDependentNumericOrNonNumericSeriesFormat;
}
interface TimeDependentSeriesFormat_numericOrNonNumericV2 {
    type: "numericOrNonNumericV2";
    numericOrNonNumericV2: TimeDependentNumericOrNonNumericSeriesFormatV2;
}
type TimeDependentSeriesFormat = TimeDependentSeriesFormat_numeric | TimeDependentSeriesFormat_nonNumeric | TimeDependentSeriesFormat_numericOrNonNumeric | TimeDependentSeriesFormat_numericOrNonNumericV2;
/**
 * Describes how to treat an object of this type as a time series.
 */
interface TimeSeriesMetadata {
    measurePropertyTypeRid?: PropertyTypeRid | null | undefined;
    timeSeriesIdPropertyTypeRid: PropertyTypeRid;
    valueUnitsPropertyTypeRid?: PropertyTypeRid | null | undefined;
}
/**
 * An rid identifying a time series sync. This rid is a randomly generated identifier and is safe to log.
 */
type TimeSeriesSyncRid = string;
/**
 * An rid identifying a time series sync view. This rid is a randomly generated identifier and is safe to log.
 */
type TimeSeriesSyncViewRid = string;
interface TimestampFormatter {
    displayTimezone: DatetimeTimezone;
    format: DatetimeFormat;
}
interface TimestampPropertyType {
}
interface TimestampTypeDataConstraints$1 {
    range: TimestampTypeRangeConstraint$1;
}
type TimestampTypeDataValue$1 = string;
interface TimestampTypeRangeConstraint$1 {
    max?: TimestampTypeDataValue$1 | null | undefined;
    min?: TimestampTypeDataValue$1 | null | undefined;
}
interface TrueCondition {
    displayMetadata?: ConditionDisplayMetadata | null | undefined;
}
interface Type_array {
    type: "array";
    array: ArrayPropertyType;
}
interface Type_boolean {
    type: "boolean";
    boolean: BooleanPropertyType;
}
interface Type_byte {
    type: "byte";
    byte: BytePropertyType;
}
interface Type_date {
    type: "date";
    date: DatePropertyType;
}
interface Type_decimal {
    type: "decimal";
    decimal: DecimalPropertyType;
}
interface Type_double {
    type: "double";
    double: DoublePropertyType;
}
interface Type_float {
    type: "float";
    float: FloatPropertyType;
}
interface Type_geohash {
    type: "geohash";
    geohash: GeohashPropertyType;
}
interface Type_geoshape {
    type: "geoshape";
    geoshape: GeoshapePropertyType;
}
interface Type_integer {
    type: "integer";
    integer: IntegerPropertyType;
}
interface Type_long {
    type: "long";
    long: LongPropertyType;
}
interface Type_short {
    type: "short";
    short: ShortPropertyType;
}
interface Type_string {
    type: "string";
    string: StringPropertyType;
}
interface Type_experimentalTimeDependentV1 {
    type: "experimentalTimeDependentV1";
    experimentalTimeDependentV1: ExperimentalTimeDependentPropertyTypeV1;
}
interface Type_timestamp {
    type: "timestamp";
    timestamp: TimestampPropertyType;
}
interface Type_attachment {
    type: "attachment";
    attachment: AttachmentPropertyType;
}
interface Type_marking {
    type: "marking";
    marking: MarkingPropertyType;
}
interface Type_cipherText {
    type: "cipherText";
    cipherText: CipherTextPropertyType;
}
interface Type_mediaReference {
    type: "mediaReference";
    mediaReference: MediaReferencePropertyType;
}
interface Type_vector {
    type: "vector";
    vector: VectorPropertyType;
}
interface Type_geotimeSeriesReference {
    type: "geotimeSeriesReference";
    geotimeSeriesReference: GeotimeSeriesReferencePropertyType;
}
interface Type_struct {
    type: "struct";
    struct: StructPropertyType;
}
/**
 * Wrapper type for the various supported property types.
 *
 * Note: this type also encodes information on how to store the property. Use `DataType` if only the raw type
 * information matters (e.g. this format condition input must be a string).
 */
type Type = Type_array | Type_boolean | Type_byte | Type_date | Type_decimal | Type_double | Type_float | Type_geohash | Type_geoshape | Type_integer | Type_long | Type_short | Type_string | Type_experimentalTimeDependentV1 | Type_timestamp | Type_attachment | Type_marking | Type_cipherText | Type_mediaReference | Type_vector | Type_geotimeSeriesReference | Type_struct;
/**
 * Type Classes comprise a kind and name field, where the kind field can provide a useful namespace for
 * the TypeClass. Type Classes are normally used to store additional metadata on the properties which
 * may be used by Hubble and various plugins when rendering the property in the front-end.
 */
interface TypeClass {
    kind: string;
    name: string;
}
interface TypeClassEntityIdentifier_sharedPropertyTypeRid {
    type: "sharedPropertyTypeRid";
    sharedPropertyTypeRid: SharedPropertyTypeRid;
}
interface TypeClassEntityIdentifier_objectTypeRid {
    type: "objectTypeRid";
    objectTypeRid: ObjectTypeRid;
}
interface TypeClassEntityIdentifier_linkTypeRid {
    type: "linkTypeRid";
    linkTypeRid: LinkTypeRid;
}
interface TypeClassEntityIdentifier_actionTypeRid {
    type: "actionTypeRid";
    actionTypeRid: ActionTypeRid;
}
type TypeClassEntityIdentifier = TypeClassEntityIdentifier_sharedPropertyTypeRid | TypeClassEntityIdentifier_objectTypeRid | TypeClassEntityIdentifier_linkTypeRid | TypeClassEntityIdentifier_actionTypeRid;
/**
 * A type group is a collection of entities that are related to each other. Type groups are used to organize
 * entities into logical groups. This is useful for displaying entities in the UI, or for querying entities
 * within a certain scope.
 */
interface TypeGroup {
    displayMetadata: TypeGroupDisplayMetadata;
    rid: TypeGroupRid;
}
/**
 * This includes metadata which can be used by front-ends when displaying a type group.
 */
interface TypeGroupDisplayMetadata {
    description?: string | null | undefined;
    displayName: string;
    iconColors: TypeGroupIconColors;
}
interface TypeGroupError_typeGroupsNotFound {
    type: "typeGroupsNotFound";
    typeGroupsNotFound: TypeGroupsNotFoundError;
}
interface TypeGroupError_typeGroupsAlreadyExist {
    type: "typeGroupsAlreadyExist";
    typeGroupsAlreadyExist: TypeGroupsAlreadyExistError;
}
type TypeGroupError = TypeGroupError_typeGroupsNotFound | TypeGroupError_typeGroupsAlreadyExist;
/**
 * Request to get the associated OrganizationRid(s) for given TypeGroupRid(s).
 */
interface TypeGroupGetOrganizationsRequest {
    typeGroupRids: Array<TypeGroupRid>;
}
/**
 * Response for TypeGroupGetOrganizationsRequest. Please note that this will contain
 * OrganizationRid(s) only for TypeGroupRid(s) that are visible to the user.
 */
interface TypeGroupGetOrganizationsResponse {
    organizationRidByTypeGroupRid: Record<TypeGroupRid, Array<OrganizationRid>>;
}
/**
 * The colors used to render the icon for the type group. All colors are expected to be in hex format.
 */
interface TypeGroupIconColors {
    firstColor?: string | null | undefined;
    fourthColor?: string | null | undefined;
    secondColor?: string | null | undefined;
    thirdColor?: string | null | undefined;
}
/**
 * Reference to a type group in a request. Used to reference an type group in the same request it is created in.
 */
type TypeGroupIdInRequest = string;
interface TypeGroupLoadRequest {
    rid: TypeGroupRid;
    versionReference?: VersionReference | null | undefined;
}
interface TypeGroupLoadResponse {
    numberOfActionTypes?: number | null | undefined;
    numberOfObjectTypes?: number | null | undefined;
    ontologyRid: OntologyRid;
    ontologyVersion: OntologyVersion;
    typeGroup: TypeGroup;
}
/**
 * ResourceIdentifier for a TypeGroup.
 */
type TypeGroupRid = string;
interface TypeGroupRidOrIdInRequest_rid {
    type: "rid";
    rid: TypeGroupRid;
}
interface TypeGroupRidOrIdInRequest_idInRequest {
    type: "idInRequest";
    idInRequest: TypeGroupIdInRequest;
}
type TypeGroupRidOrIdInRequest = TypeGroupRidOrIdInRequest_rid | TypeGroupRidOrIdInRequest_idInRequest;
/**
 * Cannot create TypeGroups that already exist.
 */
interface TypeGroupsAlreadyExistError {
    typeGroupRids: Array<TypeGroupRid>;
}
/**
 * Request to associate given set of OrganizationRids with the specified TypeGroupRid(s).
 * Users should have permissions to modify the specified TypeGroupRid(s) and also have
 * relevant permissions to apply the specified organizations' markings.
 * An empty set of organizations is not permissible.
 */
interface TypeGroupSetOrganizationsRequest {
    organizationRidByTypeGroupRid: Record<TypeGroupRid, Array<OrganizationRid>>;
}
/**
 * The TypeGroups were not found.
 */
interface TypeGroupsNotFoundError {
    typeGroupRids: Array<TypeGroupRid>;
}
interface TypeGroupsSummary {
    visibleEntities: number;
}
/**
 * An auto generated UUID will be used for this value.
 */
interface UniqueIdentifier {
    linkId?: string | null | undefined;
}
/**
 * Unresolved properties provided in an ontology spark read.
 */
interface UnresolvedOntologySparkInputProperties {
    datasources: Array<DatasetRid>;
}
/**
 * This is a temporary type and will only be supported for a short time until interfaces are available in OSS.
 */
interface UnrestrictedParameterInterfacePropertyValue {
}
interface UnsafeArg {
    name: string;
    value: string;
}
interface UrlTarget_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValue;
}
interface UrlTarget_rid {
    type: "rid";
    rid: RidUrlTarget;
}
interface UrlTarget_relativeUrlString {
    type: "relativeUrlString";
    relativeUrlString: string;
}
interface UrlTarget_newObject {
    type: "newObject";
    newObject: NewObjectUrlTarget;
}
interface UrlTarget_carbonWorkspace {
    type: "carbonWorkspace";
    carbonWorkspace: CarbonWorkspaceUrlTarget;
}
/**
 * The target for generating a URL.
 */
type UrlTarget = UrlTarget_logicRuleValue | UrlTarget_rid | UrlTarget_relativeUrlString | UrlTarget_newObject | UrlTarget_carbonWorkspace;
interface UrlTargetModification_logicRuleValue {
    type: "logicRuleValue";
    logicRuleValue: LogicRuleValueModification;
}
interface UrlTargetModification_rid {
    type: "rid";
    rid: RidUrlTargetModification;
}
interface UrlTargetModification_relativeUrlString {
    type: "relativeUrlString";
    relativeUrlString: string;
}
interface UrlTargetModification_newObject {
    type: "newObject";
    newObject: NewObjectUrlTargetModification;
}
interface UrlTargetModification_carbonWorkspace {
    type: "carbonWorkspace";
    carbonWorkspace: CarbonWorkspaceUrlTarget;
}
/**
 * The target for generating a URL.
 */
type UrlTargetModification = UrlTargetModification_logicRuleValue | UrlTargetModification_rid | UrlTargetModification_relativeUrlString | UrlTargetModification_newObject | UrlTargetModification_carbonWorkspace;
/**
 * ResourceIdentifier for a UseCase.
 */
type UseCaseRid = string;
/**
 * The user's attributes
 */
interface UserAttributes {
    attributeKey: string;
}
/**
 * The id of a Multipass user.
 */
type UserId = string;
interface UserOrGroupId_userId {
    type: "userId";
    userId: UserId;
}
interface UserOrGroupId_groupId {
    type: "groupId";
    groupId: GroupId;
}
type UserOrGroupId = UserOrGroupId_userId | UserOrGroupId_groupId;
interface UserProperty {
    propertyValue: UserPropertyValue;
    userId: UserPropertyId;
}
interface UserPropertyId_currentUser {
    type: "currentUser";
    currentUser: Empty;
}
type UserPropertyId = UserPropertyId_currentUser;
interface UserPropertyValue_userId {
    type: "userId";
    userId: Empty;
}
interface UserPropertyValue_groupIds {
    type: "groupIds";
    groupIds: Empty;
}
interface UserPropertyValue_userName {
    type: "userName";
    userName: Empty;
}
interface UserPropertyValue_groupNames {
    type: "groupNames";
    groupNames: Empty;
}
interface UserPropertyValue_userAttributes {
    type: "userAttributes";
    userAttributes: UserAttributes;
}
interface UserPropertyValue_organizationMarkingIds {
    type: "organizationMarkingIds";
    organizationMarkingIds: Empty;
}
type UserPropertyValue = UserPropertyValue_userId | UserPropertyValue_groupIds | UserPropertyValue_userName | UserPropertyValue_groupNames | UserPropertyValue_userAttributes | UserPropertyValue_organizationMarkingIds;
interface UserTimezone {
}
/**
 * A value related to a user.
 */
type UserValue = "USERNAME" | "FIRST_NAME" | "LAST_NAME";
interface ValidationRule {
    condition: Condition;
    displayMetadata: ValidationRuleDisplayMetadata;
}
interface ValidationRuleDisplayMetadata {
    failureMessage: string;
    typeClasses: Array<TypeClass>;
}
interface ValidationRuleIdentifier_rid {
    type: "rid";
    rid: ValidationRuleRid;
}
interface ValidationRuleIdentifier_validationRuleIdInRequest {
    type: "validationRuleIdInRequest";
    validationRuleIdInRequest: ValidationRuleIdInRequest;
}
/**
 * A type to uniquely identify a validation rule in an ActionType.
 */
type ValidationRuleIdentifier = ValidationRuleIdentifier_rid | ValidationRuleIdentifier_validationRuleIdInRequest;
/**
 * Reference to a ValidationRule. Used when referencing a ValidationRule in the same request it is created in.
 */
type ValidationRuleIdInRequest = string;
interface ValidationRuleModification {
    condition: Condition;
    displayMetadata: ValidationRuleDisplayMetadata;
}
type ValidationRuleRid = string;
/**
 * Reference to a value source. This is bound to e.g. a property.
 */
type ValueReferenceId = string;
interface ValueReferenceSource_propertyTypeRid {
    type: "propertyTypeRid";
    propertyTypeRid: PropertyTypeRid;
}
type ValueReferenceSource = ValueReferenceSource_propertyTypeRid;
interface ValueType {
    valueTypeRid: ValueTypeRid$1;
}
interface ValueTypeApiNameReference {
    apiName: string;
    version: string;
}
type ValueTypeIdInRequest = string;
/**
 * ResourceIdentifier for the value type input manager.
 */
type ValueTypeInputManagerRid = string;
/**
 * Similar to a unit, but for non-numeric properties. For example, two properties which both represent
 * severities might share the same set of possible values, say 'HIGH', 'MEDIUM' or 'LOW'. You could then
 * plot these together on the same axis on a chart with "Severity" as the label by specifying "Severity"
 * as the `valueTypeLabel` for both properties.
 *
 * This can be a maximum of 50 characters.
 */
type ValueTypeLabel = string;
interface ValueTypeReference$1 {
    rid: ValueTypeRid$1;
    versionId: ValueTypeVersionId$1;
}
type ValueTypeRid$1 = string;
type ValueTypeVersionId$1 = string;
/**
 * Represents a fixed size vector of floats. These can be used for vector similarity searches.
 */
interface VectorPropertyType {
    dimension: number;
    embeddingModel?: EmbeddingModel | null | undefined;
    supportsSearchWith: Array<VectorSimilarityFunction>;
}
type VectorSimilarityFunction = "COSINE_SIMILARITY" | "DOT_PRODUCT" | "EUCLIDEAN_DISTANCE";
/**
 * ActionTypeRid with ActionTypeVersion.
 */
interface VersionedActionTypeRid {
    rid: ActionTypeRid;
    version: ActionTypeVersion;
}
/**
 * ActionTypes were not found.
 */
interface VersionedActionTypesNotFoundError {
    versionedActionTypeRids: Array<VersionedActionTypeRid>;
}
/**
 * A {@link LinkTypeRid} with the {@link OntologyVersion}.
 */
interface VersionedLinkTypeRid {
    linkTypeRid: LinkTypeRid;
    ontologyVersion: OntologyVersion;
}
/**
 * An {@link ObjectTypeRid} with the {@link OntologyVersion}.
 */
interface VersionedObjectTypeRid {
    objectTypeRid: ObjectTypeRid;
    ontologyVersion: OntologyVersion;
}
interface VersionReference_ontologyVersion {
    type: "ontologyVersion";
    ontologyVersion: OntologyVersion;
}
interface VersionReference_ontologyBranch {
    type: "ontologyBranch";
    ontologyBranch: OntologyBranchRid;
}
/**
 * Union type to represent various ways to reference the version of an Ontology entity.
 */
type VersionReference = VersionReference_ontologyVersion | VersionReference_ontologyBranch;
/**
 * Indicates the level of visibility for ObjectType(s), LinkType(s) and PropertyType(s). This
 * may be used by Hubble and various plugins when rendering those Ontology entities in the front-end.
 */
type Visibility = "PROMINENT" | "NORMAL" | "HIDDEN";
interface VisibilityOverride {
    visibility: ParameterVisibility;
}
/**
 * Name of a parameter input to a Webhook. Not safe to log.
 */
type WebhookInputParamName = string;
/**
 * Name of a parameter output to a Webhook. Not safe to log.
 */
type WebhookOutputParamName = string;
/**
 * The rid for a Webhook, autogenerated by Webhook-Service and used for permissioning and logging.
 */
type WebhookRid = string;
/**
 * The version of a Webhook. Safe to log.
 */
type WebhookVersion = number;
/**
 * The whitespace analyzer breaks the text into terms whenever it encounters a whitespace character.
 * Please note that it does not change the casing of the text.
 */
interface WhitespaceAnalyzer {
}
interface WorkflowError_workflowsNotFound {
    type: "workflowsNotFound";
    workflowsNotFound: WorkflowsNotFoundError;
}
interface WorkflowError_workflowsAlreadyExist {
    type: "workflowsAlreadyExist";
    workflowsAlreadyExist: WorkflowsAlreadyExistError;
}
interface WorkflowError_referencedObjectTypesInWorkflowNotFound {
    type: "referencedObjectTypesInWorkflowNotFound";
    referencedObjectTypesInWorkflowNotFound: ReferencedObjectTypesInWorkflowNotFoundError;
}
interface WorkflowError_referencedLinkTypesInWorkflowNotFound {
    type: "referencedLinkTypesInWorkflowNotFound";
    referencedLinkTypesInWorkflowNotFound: ReferencedLinkTypesInWorkflowNotFoundError;
}
interface WorkflowError_deletedObjectTypesStillInUseInWorkflow {
    type: "deletedObjectTypesStillInUseInWorkflow";
    deletedObjectTypesStillInUseInWorkflow: DeletedObjectTypesStillInUseInWorkflowError;
}
interface WorkflowError_deletedLinkTypesStillInUseInWorkflow {
    type: "deletedLinkTypesStillInUseInWorkflow";
    deletedLinkTypesStillInUseInWorkflow: DeletedLinkTypesStillInUseInWorkflowError;
}
type WorkflowError = WorkflowError_workflowsNotFound | WorkflowError_workflowsAlreadyExist | WorkflowError_referencedObjectTypesInWorkflowNotFound | WorkflowError_referencedLinkTypesInWorkflowNotFound | WorkflowError_deletedObjectTypesStillInUseInWorkflow | WorkflowError_deletedLinkTypesStillInUseInWorkflow;
/**
 * A `WorkflowObjectTypeTrait` is a model that represents a template for an ObjectType(s). For example, there could
 * be an Alert WorkflowObjectTypeTrait and multiple alert ObjectType(s) can adhere to it.
 */
interface WorkflowObjectTypeTrait {
    description?: WorkflowObjectTypeTraitDescription | null | undefined;
    displayName: WorkflowObjectTypeTraitDisplayName;
    id: WorkflowObjectTypeTraitId;
    properties: Record<WorkflowObjectTypeTraitPropertyId, WorkflowObjectTypeTraitProperty>;
    version: WorkflowObjectTypeTraitVersion;
}
/**
 * A human readable string representing description of the `WorkflowObjectTypeTrait`. This is human readable and is
 * safe to log. The maximum allowed size is 500 characters.
 */
type WorkflowObjectTypeTraitDescription = string;
/**
 * A human readable string representing the name of the `WorkflowObjectTypeTrait` for display purposes. This is not guaranteed
 * to be unique. The maximum size allowed is 100 characters and is safe to log.
 */
type WorkflowObjectTypeTraitDisplayName = string;
/**
 * An human readable id uniquely identifying a `WorkflowObjectTypeTrait`. This is guaranteed to be unique and the maximum size
 * allowed is 100 characters. This is a human readable field and is safe to log.
 */
type WorkflowObjectTypeTraitId = string;
/**
 * A mapping between the `WorkflowObjectTypeTraitPropertyId` of the `WorkflowObjectTypeTrait` to the `PropertyRid` of the `ObjectType` it is to be associated with.
 */
interface WorkflowObjectTypeTraitImpl {
    mapping: Record<WorkflowObjectTypeTraitPropertyId, PropertyTypeRid>;
    reference: WorkflowObjectTypeTraitReference;
}
/**
 * Represents a property of a `WorkflowObjectTypeTrait`. For example, an Alert WorkflowObjectTypeTrait may have a required 'Assignee' WorkflowObjectTypeTraitProperty. All ObjectType(s) derived from the Alert WorkflowObjectTypeTrait must provide provide a property that conforms to the corresponding ObjectTypeTraitPropertySpecification
 */
interface WorkflowObjectTypeTraitProperty {
    description: WorkflowObjectTypeTraitPropertyDescription;
    displayName: WorkflowObjectTypeTraitPropertyDisplayName;
    id: WorkflowObjectTypeTraitPropertyId;
    specification: ObjectTypeTraitPropertySpecification;
}
/**
 * A description of the `WorkflowObjectTypeTraitProperty`. The maximum size allowed is 200 characters.
 */
type WorkflowObjectTypeTraitPropertyDescription = string;
/**
 * A string representing the name of the `WorkflowObjectTypeTraitProperty` for display purposes. This is guaranteed to be unique within
 * a single `WorkflowObjectTypeTrait`, but not across multiple `WorkflowObjectTypeTrait`(s). The maximum size allowed is 100 characters
 * and is safe to log.
 */
type WorkflowObjectTypeTraitPropertyDisplayName = string;
/**
 * An id uniquely identifying a `WorkflowObjectTypeTraitProperty`. This is a human readable field with a maximum allowed
 * size of 100 characters. This is safe to log.
 */
type WorkflowObjectTypeTraitPropertyId = string;
/**
 * A type to uniquely identify a specific version of a `WorkflowObjectTypeTrait` in an `ObjectTypeArchetype` definition.
 */
interface WorkflowObjectTypeTraitReference {
    traitId: WorkflowObjectTypeTraitId;
    version: WorkflowObjectTypeTraitVersion;
}
/**
 * This represents the version of the `WorkflowObjectTypeTrait`. This is a human readable field and is safe to log.
 */
type WorkflowObjectTypeTraitVersion = string;
/**
 * There was an attempt to create Workflows that already exist.
 */
interface WorkflowsAlreadyExistError {
    workflowRids: Array<WorkflowRid>;
}
/**
 * The Workflows were not found.
 */
interface WorkflowsNotFoundError {
    workflowRids: Array<WorkflowRid>;
}
/**
 * The rid for a Workshop.
 */
type WorkshopModuleRid = string;
/**
 * While Workshops are versioned resources, embedding a Workshop
 * today does not allow users to specify a version.
 */
interface WorkshopReference {
    workshopRid: WorkshopModuleRid;
}

/**
 * Endpoint to load Ontology entities in bulk. The returned OntologyBulkLoadEntitiesResponse will only
 * contain entities that actually exist and are visible to the user. If the user has requested entities at
 * invalid versions or entities that do not exist in the specified versions, those will not be present
 * in the response.
 *
 * There are limits on the number of entities that can be loaded in one request. Please refer to
 * documentation of OntologyBulkLoadEntitiesRequest for the values of these limits.
 */
declare function bulkLoadOntologyEntities(ctx: ConjureContext, onBehalfOf: string | null | undefined, request: OntologyBulkLoadEntitiesRequest): Promise<OntologyBulkLoadEntitiesResponse>;

/**
 * Endpoint to batch load links associated to given ObjectTypeRid(s). The GetLinkTypesForObjectTypesResponse
 * will only contain links that are visible to the user. If the user has requested to get link types at
 * invalid ontology versions or for ObjectTypeRid(s) that do not exist in the specified versions, those entries
 * will include an empty set of link types.
 *
 * The includeObjectTypesWithoutSearchableDatasources flag is respected if present in the request,
 * else we set it to a default (false) unless the user-agent is blocklisted.
 * The flag is set to true for blocklisted user agents. Currently the blocklist
 * includes functions-typescript-gradle-plugin only.
 */
declare function getLinkTypesForObjectTypes(ctx: ConjureContext, request: GetLinkTypesForObjectTypesRequest): Promise<GetLinkTypesForObjectTypesResponse>;

/**
 * Endpoint to load metadata about the Ontologies a user has access to. The response will contain
 * only Ontologies on which the user has `ontology:view-ontology`. Note that the returned
 * LoadAllOntologiesResponse may be empty if there is no Ontology yet.
 */
declare function loadAllOntologies(ctx: ConjureContext, request: LoadAllOntologiesRequest): Promise<LoadAllOntologiesResponse>;

interface ArrayType {
    elementType: BaseType;
}

interface BinaryType {
}

interface BooleanType {
}

interface ByteType {
}

interface DateType {
}

interface DecimalType {
    precision: number;
    scale: number;
}

interface DoubleType {
}

interface FloatType {
}

interface IntegerType {
}

interface LongType {
}

interface MapType {
    keyType: BaseType;
    valueType: BaseType;
}

interface OptionalType {
    wrappedType: BaseType;
}

/**
 * The rid for a Value Type, autogenerated by the service.
 */
type ValueTypeRid = string;

/**
 * The version id of a Value Type, autogenerated by the service.
 */
type ValueTypeVersionId = string;

interface VersionedReferencedType {
    rid: ValueTypeRid;
    version: ValueTypeVersionId;
}

interface ReferencedType_versionedReferencedType {
    type: "versionedReferencedType";
    versionedReferencedType: VersionedReferencedType;
}
type ReferencedType = ReferencedType_versionedReferencedType;

interface ShortType {
}

interface StringType {
}

type StructElementName = string;

interface StructElement {
    name: StructElementName;
    type: BaseType;
}

interface StructType {
    fields: Array<StructElement>;
}

/**
 * A string identifier used to map struct property fields to their respective base types and constraints.
 * This identifier is intentionally generically typed. Constraints used on ontology types should interpret the
 * identifier as a struct field API name and pipeline builder should interpret the identifier as a dataset
 * struct column field name.
 */
type StructFieldIdentifier = string;

interface StructElementV2 {
    identifier: StructFieldIdentifier;
    baseType: BaseType;
}

interface StructTypeV2 {
    fields: Array<StructElementV2>;
}

interface TimestampType {
}

/**
 * It is not possible to define constraints on a union type. Instead define each member as its own value
 * type with constraints, and reference those value types in the union.
 */
interface UnionType {
    memberTypes: Array<BaseType>;
}

interface BaseType_array {
    type: "array";
    array: ArrayType;
}
interface BaseType_boolean {
    type: "boolean";
    boolean: BooleanType;
}
interface BaseType_binary {
    type: "binary";
    binary: BinaryType;
}
interface BaseType_byte {
    type: "byte";
    byte: ByteType;
}
interface BaseType_date {
    type: "date";
    date: DateType;
}
interface BaseType_decimal {
    type: "decimal";
    decimal: DecimalType;
}
interface BaseType_double {
    type: "double";
    double: DoubleType;
}
interface BaseType_float {
    type: "float";
    float: FloatType;
}
interface BaseType_integer {
    type: "integer";
    integer: IntegerType;
}
interface BaseType_long {
    type: "long";
    long: LongType;
}
interface BaseType_map {
    type: "map";
    map: MapType;
}
interface BaseType_optional {
    type: "optional";
    optional: OptionalType;
}
interface BaseType_referenced {
    type: "referenced";
    referenced: ReferencedType;
}
interface BaseType_short {
    type: "short";
    short: ShortType;
}
interface BaseType_string {
    type: "string";
    string: StringType;
}
interface BaseType_struct {
    type: "struct";
    struct: StructType;
}
interface BaseType_structV2 {
    type: "structV2";
    structV2: StructTypeV2;
}
interface BaseType_timestamp {
    type: "timestamp";
    timestamp: TimestampType;
}
interface BaseType_union {
    type: "union";
    union: UnionType;
}
/**
 * Base physical (data) type, representing the lowest layer in the type system.
 */
type BaseType = BaseType_array | BaseType_boolean | BaseType_binary | BaseType_byte | BaseType_date | BaseType_decimal | BaseType_double | BaseType_float | BaseType_integer | BaseType_long | BaseType_map | BaseType_optional | BaseType_referenced | BaseType_short | BaseType_string | BaseType_struct | BaseType_structV2 | BaseType_timestamp | BaseType_union;

type ArrayTypeElementsUniqueConstraint = boolean;

interface RangeSizeConstraint {
    minSize: number | undefined;
    maxSize: number | undefined;
}

type ArrayTypeSizeConstraint = RangeSizeConstraint;

interface ArrayTypeDataConstraints {
    size: ArrayTypeSizeConstraint | undefined;
    elementsConstraint: DataConstraint | undefined;
    elementsUnique: ArrayTypeElementsUniqueConstraint | undefined;
}

type BinaryTypeSizeConstraint = RangeSizeConstraint;

interface BinaryTypeDataConstraints {
    size: BinaryTypeSizeConstraint;
}

type BooleanTypeDataConstraintValue = "TRUE_VALUE" | "FALSE_VALUE" | "NULL_VALUE";

interface BooleanTypeDataConstraints {
    allowedValues: Array<BooleanTypeDataConstraintValue>;
}

/**
 * ISO 8601 date.
 */
type DateTypeDataValue = string;

interface DateTypeRangeConstraint {
    min: DateTypeDataValue | undefined;
    max: DateTypeDataValue | undefined;
}

interface DateTypeDataConstraints {
    range: DateTypeRangeConstraint;
}

type DecimalTypeDataValue = string;

interface DecimalTypeRangeConstraint {
    min: DecimalTypeDataValue | undefined;
    max: DecimalTypeDataValue | undefined;
}

interface OneOfDecimalTypeConstraint {
    values: Array<DecimalTypeDataValue>;
}

interface DecimalTypeDataConstraints_range {
    type: "range";
    range: DecimalTypeRangeConstraint;
}
interface DecimalTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfDecimalTypeConstraint;
}
type DecimalTypeDataConstraints = DecimalTypeDataConstraints_range | DecimalTypeDataConstraints_oneOf;

type DoubleTypeDataValue = number;

interface DoubleTypeRangeConstraint {
    min: DoubleTypeDataValue | undefined;
    max: DoubleTypeDataValue | undefined;
}

interface OneOfDoubleTypeConstraint {
    values: Array<DoubleTypeDataValue>;
}

interface DoubleTypeDataConstraints_range {
    type: "range";
    range: DoubleTypeRangeConstraint;
}
interface DoubleTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfDoubleTypeConstraint;
}
type DoubleTypeDataConstraints = DoubleTypeDataConstraints_range | DoubleTypeDataConstraints_oneOf;

type FloatTypeDataValue = number;

interface FloatTypeRangeConstraint {
    min: FloatTypeDataValue | undefined;
    max: FloatTypeDataValue | undefined;
}

interface OneOfFloatTypeConstraint {
    values: Array<FloatTypeDataValue>;
}

interface FloatTypeDataConstraints_range {
    type: "range";
    range: FloatTypeRangeConstraint;
}
interface FloatTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfFloatTypeConstraint;
}
type FloatTypeDataConstraints = FloatTypeDataConstraints_range | FloatTypeDataConstraints_oneOf;

type IntegerTypeDataValue = number;

interface IntegerTypeRangeConstraint {
    min: IntegerTypeDataValue | undefined;
    max: IntegerTypeDataValue | undefined;
}

interface OneOfIntegerTypeConstraint {
    values: Array<IntegerTypeDataValue>;
}

interface IntegerTypeDataConstraints_range {
    type: "range";
    range: IntegerTypeRangeConstraint;
}
interface IntegerTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfIntegerTypeConstraint;
}
type IntegerTypeDataConstraints = IntegerTypeDataConstraints_range | IntegerTypeDataConstraints_oneOf;

type LongTypeDataValue = number;

interface LongTypeRangeConstraint {
    min: LongTypeDataValue | undefined;
    max: LongTypeDataValue | undefined;
}

interface OneOfLongTypeConstraint {
    values: Array<LongTypeDataValue>;
}

interface LongTypeDataConstraints_range {
    type: "range";
    range: LongTypeRangeConstraint;
}
interface LongTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfLongTypeConstraint;
}
type LongTypeDataConstraints = LongTypeDataConstraints_range | LongTypeDataConstraints_oneOf;

interface MapUniqueValuesConstraint {
    value: boolean;
}

interface MapTypeDataConstraints {
    keyTypeDataConstraints: Array<DataConstraint>;
    valueTypeDataConstraints: Array<DataConstraint>;
    uniqueValues: MapUniqueValuesConstraint | undefined;
}

type NullableOption = "NULLABLE" | "NOT_NULLABLE";

interface NullableDataConstraint {
    option: NullableOption;
}

type ShortTypeDataValue = number;

interface OneOfShortTypeConstraint {
    values: Array<ShortTypeDataValue>;
}

interface ShortTypeRangeConstraint {
    min: ShortTypeDataValue | undefined;
    max: ShortTypeDataValue | undefined;
}

interface ShortTypeDataConstraints_range {
    type: "range";
    range: ShortTypeRangeConstraint;
}
interface ShortTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfShortTypeConstraint;
}
type ShortTypeDataConstraints = ShortTypeDataConstraints_range | ShortTypeDataConstraints_oneOf;

type StringTypeDataValue = string;

interface OneOfStringTypeConstraint {
    values: Array<StringTypeDataValue>;
    useIgnoreCase: boolean | undefined;
}

interface RegexConstraint {
    regexPattern: string;
    usePartialMatch: boolean | undefined;
}

interface StringTypeIsRidConstraint {
}

interface StringTypeIsUuidConstraint {
}

type StringTypeLengthConstraint = RangeSizeConstraint;

interface StringTypeDataConstraints_regex {
    type: "regex";
    regex: RegexConstraint;
}
interface StringTypeDataConstraints_oneOf {
    type: "oneOf";
    oneOf: OneOfStringTypeConstraint;
}
interface StringTypeDataConstraints_length {
    type: "length";
    length: StringTypeLengthConstraint;
}
interface StringTypeDataConstraints_isUuid {
    type: "isUuid";
    isUuid: StringTypeIsUuidConstraint;
}
interface StringTypeDataConstraints_isRid {
    type: "isRid";
    isRid: StringTypeIsRidConstraint;
}
type StringTypeDataConstraints = StringTypeDataConstraints_regex | StringTypeDataConstraints_oneOf | StringTypeDataConstraints_length | StringTypeDataConstraints_isUuid | StringTypeDataConstraints_isRid;

/**
 * Map of constraints declared on struct elements keyed by the struct field (element) name.
 */
type StructTypeElementsConstraint = Record<StructElementName, DataConstraint>;

interface StructTypeDataConstraints {
    elementConstraints: StructTypeElementsConstraint;
}

/**
 * Reference representing a specific version of a Value Type. When versionId is omitted, we assume it is referencing the latest version available at the time.
 */
interface ValueTypeReference {
    rid: ValueTypeRid;
    versionId: ValueTypeVersionId | undefined;
}

/**
 * Map of value types declared on struct elements keyed by the struct field identifier.
 */
type StructTypeV2ElementsConstraint = Record<StructFieldIdentifier, ValueTypeReference>;

interface StructTypeV2DataConstraints {
    elementConstraints: StructTypeV2ElementsConstraint;
}

type TimestampTypeDataValue = string;

interface TimestampTypeRangeConstraint {
    min: TimestampTypeDataValue | undefined;
    max: TimestampTypeDataValue | undefined;
}

interface TimestampTypeDataConstraints {
    range: TimestampTypeRangeConstraint;
}

interface DataConstraint_array {
    type: "array";
    array: ArrayTypeDataConstraints;
}
interface DataConstraint_boolean {
    type: "boolean";
    boolean: BooleanTypeDataConstraints;
}
interface DataConstraint_binary {
    type: "binary";
    binary: BinaryTypeDataConstraints;
}
interface DataConstraint_date {
    type: "date";
    date: DateTypeDataConstraints;
}
interface DataConstraint_decimal {
    type: "decimal";
    decimal: DecimalTypeDataConstraints;
}
interface DataConstraint_double {
    type: "double";
    double: DoubleTypeDataConstraints;
}
interface DataConstraint_float {
    type: "float";
    float: FloatTypeDataConstraints;
}
interface DataConstraint_integer {
    type: "integer";
    integer: IntegerTypeDataConstraints;
}
interface DataConstraint_long {
    type: "long";
    long: LongTypeDataConstraints;
}
interface DataConstraint_map {
    type: "map";
    map: MapTypeDataConstraints;
}
interface DataConstraint_nullable {
    type: "nullable";
    nullable: NullableDataConstraint;
}
interface DataConstraint_short {
    type: "short";
    short: ShortTypeDataConstraints;
}
interface DataConstraint_string {
    type: "string";
    string: StringTypeDataConstraints;
}
interface DataConstraint_struct {
    type: "struct";
    struct: StructTypeDataConstraints;
}
interface DataConstraint_structV2 {
    type: "structV2";
    structV2: StructTypeV2DataConstraints;
}
interface DataConstraint_timestamp {
    type: "timestamp";
    timestamp: TimestampTypeDataConstraints;
}
type DataConstraint = DataConstraint_array | DataConstraint_boolean | DataConstraint_binary | DataConstraint_date | DataConstraint_decimal | DataConstraint_double | DataConstraint_float | DataConstraint_integer | DataConstraint_long | DataConstraint_map | DataConstraint_nullable | DataConstraint_short | DataConstraint_string | DataConstraint_struct | DataConstraint_structV2 | DataConstraint_timestamp;

interface FailureMessage {
    message: string;
}

interface DataConstraintWrapper {
    failureMessage: FailureMessage | undefined;
    constraint: DataConstraint;
}

type ArrayTypeDataValue = Array<BaseTypeDataValue>;

type BinaryTypeDataValue = Blob;

type BooleanTypeDataValue = boolean;

type ByteTypeDataValue = number;

interface MapTypeDataValue_byte {
    type: "byte";
    byte: Record<ByteTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_date {
    type: "date";
    date: Record<DateTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_double {
    type: "double";
    double: Record<DoubleTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_decimal {
    type: "decimal";
    decimal: Record<DecimalTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_float {
    type: "float";
    float: Record<FloatTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_integer {
    type: "integer";
    integer: Record<IntegerTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_short {
    type: "short";
    short: Record<ShortTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_string {
    type: "string";
    string: Record<StringTypeDataValue, BaseTypeDataValue>;
}
interface MapTypeDataValue_timestamp {
    type: "timestamp";
    timestamp: Record<TimestampTypeDataValue, BaseTypeDataValue>;
}
type MapTypeDataValue = MapTypeDataValue_byte | MapTypeDataValue_date | MapTypeDataValue_double | MapTypeDataValue_decimal | MapTypeDataValue_float | MapTypeDataValue_integer | MapTypeDataValue_short | MapTypeDataValue_string | MapTypeDataValue_timestamp;

type OptionalTypeDataValue = BaseTypeDataValue | undefined;

interface StructElementTypeDataValue {
    name: string;
    value: BaseTypeDataValue;
}

interface StructTypeDataValue {
    fields: Array<StructElementTypeDataValue>;
}

interface BaseTypeDataValue_array {
    type: "array";
    array: ArrayTypeDataValue;
}
interface BaseTypeDataValue_boolean {
    type: "boolean";
    boolean: BooleanTypeDataValue;
}
interface BaseTypeDataValue_binary {
    type: "binary";
    binary: BinaryTypeDataValue;
}
interface BaseTypeDataValue_byte {
    type: "byte";
    byte: ByteTypeDataValue;
}
interface BaseTypeDataValue_date {
    type: "date";
    date: DateTypeDataValue;
}
interface BaseTypeDataValue_decimal {
    type: "decimal";
    decimal: DecimalTypeDataValue;
}
interface BaseTypeDataValue_double {
    type: "double";
    double: DoubleTypeDataValue;
}
interface BaseTypeDataValue_float {
    type: "float";
    float: FloatTypeDataValue;
}
interface BaseTypeDataValue_integer {
    type: "integer";
    integer: IntegerTypeDataValue;
}
interface BaseTypeDataValue_long {
    type: "long";
    long: LongTypeDataValue;
}
interface BaseTypeDataValue_map {
    type: "map";
    map: MapTypeDataValue;
}
interface BaseTypeDataValue_optional {
    type: "optional";
    optional: OptionalTypeDataValue;
}
interface BaseTypeDataValue_short {
    type: "short";
    short: ShortTypeDataValue;
}
interface BaseTypeDataValue_string {
    type: "string";
    string: StringTypeDataValue;
}
interface BaseTypeDataValue_struct {
    type: "struct";
    struct: StructTypeDataValue;
}
interface BaseTypeDataValue_timestamp {
    type: "timestamp";
    timestamp: TimestampTypeDataValue;
}
/**
 * Data values representation of the base types. Used for defining the actual data constraints and to represent
 * actual data values.
 */
type BaseTypeDataValue = BaseTypeDataValue_array | BaseTypeDataValue_boolean | BaseTypeDataValue_binary | BaseTypeDataValue_byte | BaseTypeDataValue_date | BaseTypeDataValue_decimal | BaseTypeDataValue_double | BaseTypeDataValue_float | BaseTypeDataValue_integer | BaseTypeDataValue_long | BaseTypeDataValue_map | BaseTypeDataValue_optional | BaseTypeDataValue_short | BaseTypeDataValue_string | BaseTypeDataValue_struct | BaseTypeDataValue_timestamp;

/**
 * Example values for a value type. Used for documentation purposes.
 */
interface ExampleValue {
    value: BaseTypeDataValue;
}

type ValueTypeApiName = string;

interface ValueTypeDataConstraint {
    constraint: DataConstraintWrapper;
}

type Description = string;

type DisplayName = string;

interface ValueTypeDisplayMetadata {
    displayName: DisplayName;
    description: Description | undefined;
}

/**
 * This status indicates that the ValueType will not change on short notice and should thus be safe to use in user facing workflows. They will not be removed without first being deprecated.
 */
interface ActiveValueTypeStatus {
}

/**
 * This status indicates that the ValueType is reaching the end of its life and will be removed as per the deadline specified.
 */
interface DeprecatedValueTypeStatus {
    message: string;
    deadline: string;
    replacedBy: ValueTypeRid | undefined;
}

interface ValueTypeStatus_active {
    type: "active";
    active: ActiveValueTypeStatus;
}
interface ValueTypeStatus_deprecated {
    type: "deprecated";
    deprecated: DeprecatedValueTypeStatus;
}
/**
 * The status to indicate whether the Value Type is either Experimental, Active or Deprecated.
 */
type ValueTypeStatus = ValueTypeStatus_active | ValueTypeStatus_deprecated;

type ValueTypeVersion = string;

interface OntologyIr {
    blockData: OntologyIrOntologyBlockDataV2;
    importedTypes: OntologyIrImportedTypes;
}
type ApiNameValueTypeReference = {
    apiName: ValueTypeApiName;
    version: ValueTypeVersion;
};
type OntologyIrPackagedValueType = {
    version: ValueTypeVersion;
    baseType: BaseType;
    constraints: ValueTypeDataConstraint[];
    exampleValues: ExampleValue[];
};
type OntologyIrPackagedValueTypeMetadata = {
    apiName: ValueTypeApiName;
    displayMetadata: ValueTypeDisplayMetadata;
    status: ValueTypeStatus;
};
type OntologyIrValueTypeBlockDataEntry = {
    metadata: OntologyIrPackagedValueTypeMetadata;
    versions: OntologyIrPackagedValueType[];
};
type OntologyIrValueTypeBlockData = {
    valueTypes: OntologyIrValueTypeBlockDataEntry[];
};

export { type AccessRequestRid, type AccessRequestVersion, type AccessSubRequestRid, type AccessSubRequestVersion, type ActionApplierRevertConfig, type ActionApplyClientPreferences, type ActionApplyClientPreferences_disallowedClients, type ActionApplyDisallowedClients, type ActionLogConfiguration, type ActionLogMessage, type ActionLogMetadata, type ActionLogParameterReference, type ActionLogRule, type ActionLogRuleModification, type ActionLogSummaryPart, type ActionLogSummaryPart_message, type ActionLogSummaryPart_parameter, type ActionLogValue, type ActionLogValueModification, type ActionLogValueModification_actionRid, type ActionLogValueModification_actionTimestamp, type ActionLogValueModification_actionTypeRid, type ActionLogValueModification_actionTypeVersion, type ActionLogValueModification_actionUser, type ActionLogValueModification_allEditedObjects, type ActionLogValueModification_asynchronousWebhookInstanceIds, type ActionLogValueModification_editedObjects, type ActionLogValueModification_interfaceParameterPropertyValue, type ActionLogValueModification_isReverted, type ActionLogValueModification_notificationIds, type ActionLogValueModification_notifiedUsers, type ActionLogValueModification_objectParameterPropertyValue, type ActionLogValueModification_parameterValue, type ActionLogValueModification_revertTimestamp, type ActionLogValueModification_revertUser, type ActionLogValueModification_scenarioRid, type ActionLogValueModification_summary, type ActionLogValueModification_synchronousWebhookInstanceId, type ActionLogValue_actionRid, type ActionLogValue_actionTimestamp, type ActionLogValue_actionTypeRid, type ActionLogValue_actionTypeVersion, type ActionLogValue_actionUser, type ActionLogValue_allEditedObjects, type ActionLogValue_asynchronousWebhookInstanceIds, type ActionLogValue_editedObjects, type ActionLogValue_interfaceParameterPropertyValue, type ActionLogValue_isReverted, type ActionLogValue_notificationIds, type ActionLogValue_notifiedUsers, type ActionLogValue_objectParameterPropertyValue, type ActionLogValue_parameterValue, type ActionLogValue_revertTimestamp, type ActionLogValue_revertUser, type ActionLogValue_scenarioRid, type ActionLogValue_summary, type ActionLogValue_synchronousWebhookInstanceId, type ActionLogic, type ActionLogicModification, type ActionNotification, type ActionNotificationBody, type ActionNotificationBodyFunctionExecution, type ActionNotificationBodyFunctionExecutionModification, type ActionNotificationBodyModification, type ActionNotificationBodyModification_functionGenerated, type ActionNotificationBodyModification_templateNotification, type ActionNotificationBody_functionGenerated, type ActionNotificationBody_templateNotification, type ActionNotificationModification, type ActionNotificationRecipients, type ActionNotificationRecipientsModification, type ActionNotificationRecipientsModification_functionGenerated, type ActionNotificationRecipientsModification_parameter, type ActionNotificationRecipients_functionGenerated, type ActionNotificationRecipients_parameter, type ActionNotificationSettings, type ActionParameterShapeId, type ActionRevert, type ActionRevertEnabledFor, type ActionRevertEnabledFor_actionApplier, type ActionSubmissionConfiguration, type ActionTableSubmissionMode, type ActionTableSubmissionModeConfiguration, type ActionTableSubmissionMode_submitAllValidOrNothingThrowing, type ActionTableSubmissionMode_submitValidEntriesInOrderUntilFirstFailure, type ActionType, type ActionTypeApiName, type ActionTypeBlockDataV2, type ActionTypeCreate, type ActionTypeCreatedEvent, type ActionTypeDeletedEvent, type ActionTypeDisplayMetadata, type ActionTypeDisplayMetadataConfiguration, type ActionTypeDisplayMetadataModification, type ActionTypeDoesNotHaveActionTypeLevelValidationError, type ActionTypeEditingNonEditablePropertyTypeError, type ActionTypeEntities, type ActionTypeError, type ActionTypeError_actionTypeDoesNotHaveActionTypeLevelValidation, type ActionTypeError_actionTypeEditingNonEditablePropertyType, type ActionTypeError_actionTypesAlreadyExist, type ActionTypeError_actionTypesNotFound, type ActionTypeError_deletingAndEditingTheSameActionType, type ActionTypeError_inlineActionTypeCannotBeReferencedByMultipleObjectTypes, type ActionTypeError_nonExistentParametersUsedInParameterPrefill, type ActionTypeError_parameterValidationNotFound, type ActionTypeError_parameterValidationReferencesLaterParameters, type ActionTypeError_parametersDoNotMatchParameterOrdering, type ActionTypeError_versionedActionTypesNotFound, type ActionTypeFrontendConsumer, type ActionTypeFrontendConsumer_objectMonitoring, type ActionTypeGetOrganizationsRequest, type ActionTypeGetOrganizationsResponse, type ActionTypeIdInRequest, type ActionTypeIdentifier, type ActionTypeIdentifier_actionTypeIdInRequest, type ActionTypeIdentifier_rid, type ActionTypeInputManagerRid, type ActionTypeLevelValidation, type ActionTypeLoadAllRequest, type ActionTypeLoadRequest, type ActionTypeLoadRequestV2, type ActionTypeLoadResponse, type ActionTypeLoadResponseV2, type ActionTypeLoadVersionedRequest, type ActionTypeLoadVersionedResponse, type ActionTypeLogic, type ActionTypeMetadata, type ActionTypeMetadataModification, type ActionTypeModificationRequest, type ActionTypeModifyRequest, type ActionTypeModifyResponse, type ActionTypeParameterIdentifier, type ActionTypeParameterIdentifier_id, type ActionTypeParameterIdentifier_rid, type ActionTypePermissionInformation, type ActionTypeProvenanceModification, type ActionTypeProvenanceSourceModification, type ActionTypeProvenanceSourceModification_marketplace, type ActionTypeProvenanceSourceModification_none, type ActionTypeRestrictionStatus, type ActionTypeRichTextComponent, type ActionTypeRichTextComponent_message, type ActionTypeRichTextComponent_parameter, type ActionTypeRichTextComponent_parameterProperty, type ActionTypeRichTextMessage, type ActionTypeRichTextParameterPropertyReference, type ActionTypeRichTextParameterReference, type ActionTypeRid, type ActionTypeSetOrganizationsRequest, type ActionTypeStatus, type ActionTypeStatus_active, type ActionTypeStatus_deprecated, type ActionTypeStatus_example, type ActionTypeStatus_experimental, type ActionTypeUpdate, type ActionTypeUpdatedEvent, type ActionTypeVersion, type ActionTypesAlreadyExistError, type ActionTypesNotFoundError, type ActionTypesSummary, type ActionValidation, type ActionWebhooks, type ActionWebhooksModification, type ActionsObjectSet, type ActionsObjectSetModification, type ActionsVersion, type ActiveActionTypeStatus, type ActiveInterfaceTypeStatus, type ActiveLinkTypeStatus, type ActiveObjectTypeStatus, type ActivePropertyTypeStatus, type AddInterfaceLinkRule, type AddInterfaceLinkRuleModification, type AddInterfaceRule, type AddInterfaceRuleModification, type AddLinkRule, type AddObjectRule, type AddObjectRuleModification, type AddOrModifyObjectRule, type AddOrModifyObjectRuleModification, type AddOrModifyObjectRuleModificationV2, type AddOrModifyObjectRuleV2, type AliasEntityIdentifier, type AliasEntityIdentifier_objectTypeRid, type AliasEntityIdentifier_sharedPropertyTypeRid, type AllEditedObjectsFieldMapping, type AllFoundryRids, type AllNotificationRenderingMustSucceed, type AllowedParameterValues, type AllowedParameterValuesModification, type AllowedParameterValuesModification_attachment, type AllowedParameterValuesModification_boolean, type AllowedParameterValuesModification_cbacMarking, type AllowedParameterValuesModification_datetime, type AllowedParameterValuesModification_geohash, type AllowedParameterValuesModification_geoshape, type AllowedParameterValuesModification_geotimeSeriesReference, type AllowedParameterValuesModification_interfaceObjectQuery, type AllowedParameterValuesModification_interfacePropertyValue, type AllowedParameterValuesModification_mandatoryMarking, type AllowedParameterValuesModification_mediaReference, type AllowedParameterValuesModification_multipassGroup, type AllowedParameterValuesModification_objectList, type AllowedParameterValuesModification_objectPropertyValue, type AllowedParameterValuesModification_objectQuery, type AllowedParameterValuesModification_objectSetRid, type AllowedParameterValuesModification_objectTypeReference, type AllowedParameterValuesModification_oneOf, type AllowedParameterValuesModification_range, type AllowedParameterValuesModification_redacted, type AllowedParameterValuesModification_struct, type AllowedParameterValuesModification_text, type AllowedParameterValuesModification_timeSeriesReference, type AllowedParameterValuesModification_user, type AllowedParameterValuesModification_valueType, type AllowedParameterValues_attachment, type AllowedParameterValues_boolean, type AllowedParameterValues_cbacMarking, type AllowedParameterValues_datetime, type AllowedParameterValues_geohash, type AllowedParameterValues_geoshape, type AllowedParameterValues_geotimeSeriesReference, type AllowedParameterValues_interfaceObjectQuery, type AllowedParameterValues_interfacePropertyValue, type AllowedParameterValues_mandatoryMarking, type AllowedParameterValues_mediaReference, type AllowedParameterValues_multipassGroup, type AllowedParameterValues_objectList, type AllowedParameterValues_objectPropertyValue, type AllowedParameterValues_objectQuery, type AllowedParameterValues_objectSetRid, type AllowedParameterValues_objectTypeReference, type AllowedParameterValues_oneOf, type AllowedParameterValues_range, type AllowedParameterValues_redacted, type AllowedParameterValues_struct, type AllowedParameterValues_text, type AllowedParameterValues_timeSeriesReference, type AllowedParameterValues_user, type AllowedParameterValues_valueType, type AllowedStructFieldValues, type AllowedStructFieldValuesModification, type AllowedStructFieldValuesModification_boolean, type AllowedStructFieldValuesModification_datetime, type AllowedStructFieldValuesModification_geohash, type AllowedStructFieldValuesModification_oneOf, type AllowedStructFieldValuesModification_range, type AllowedStructFieldValuesModification_text, type AllowedStructFieldValuesOverride, type AllowedStructFieldValuesOverrideModification, type AllowedStructFieldValues_boolean, type AllowedStructFieldValues_datetime, type AllowedStructFieldValues_geohash, type AllowedStructFieldValues_oneOf, type AllowedStructFieldValues_range, type AllowedStructFieldValues_text, type AllowedValuesOverride, type AllowedValuesOverrideModification, type Analyzer, type Analyzer_languageAnalyzer, type Analyzer_notAnalyzed, type Analyzer_simpleAnalyzer, type Analyzer_standardAnalyzer, type Analyzer_whitespaceAnalyzer, type AndCondition, type AndConditionModification, type AnyNotificationRenderingCanFail, type ApiNameValueTypeReference, type ArrayPropertyType, type ArrayTypeDataConstraints$1 as ArrayTypeDataConstraints, type ArrayTypeDataValue$1 as ArrayTypeDataValue, type ArrayTypeElementsUniqueConstraint$1 as ArrayTypeElementsUniqueConstraint, type ArrayTypeSizeConstraint$1 as ArrayTypeSizeConstraint, type ArtifactGidFormatter, type AsynchronousPostWritebackWebhook, type AsynchronousPostWritebackWebhookModification, type AsynchronousPostWritebackWebhookModification_staticDirectInput, type AsynchronousPostWritebackWebhookModification_staticFunctionInput, type AsynchronousPostWritebackWebhook_staticDirectInput, type AsynchronousPostWritebackWebhook_staticFunctionInput, type AttachmentPropertyType, type Attribution, type BaseFormatter, type BaseFormatter_boolean, type BaseFormatter_date, type BaseFormatter_knownFormatter, type BaseFormatter_number, type BaseFormatter_string, type BaseFormatter_timeDependent, type BaseFormatter_timestamp, type BaseParameterSubtype, type BaseParameterSubtype_marking, type BasePropertyType, type BaseType, type BasicEmailBody, type BasicEmailBodyModification, type BatchedFunctionRule, type BatchedFunctionRuleModification, type BidirectionalRelation, type BidirectionalRelationCreateRequest, type BidirectionalRelationDeleteRequest, type BidirectionalRelationModifyRequest, type BidirectionalRelationModifyRequest_create, type BidirectionalRelationModifyRequest_delete, type BidirectionalRelationModifyRequest_update, type BidirectionalRelationUpdateRequest, type BidirectionalRelationWithoutRid, type BlockInternalId, type BlockPermissionInformation, type BlockShapeId, type BlueprintIcon, type BooleanFormatter, type BooleanPropertyType, type BooleanTypeDataConstraintValue$1 as BooleanTypeDataConstraintValue, type BooleanTypeDataConstraints$1 as BooleanTypeDataConstraints, type BooleanTypeDataValue$1 as BooleanTypeDataValue, type BranchClosedEvent, type BranchDeletedEvent, type BranchId, type BranchMergedEvent, type BuilderPipelineRid, type BulkExecutionModeConfig, type ButtonDisplayMetadata, type BytePropertyType, type ByteTypeDataValue$1 as ByteTypeDataValue, type CarbonWorkspaceComponentUrlTarget, type CarbonWorkspaceComponentUrlTargetModification, type CarbonWorkspaceComponentUrlTargetModification_rid, type CarbonWorkspaceComponentUrlTarget_rid, type CarbonWorkspaceUrlTarget, type CarbonWorkspaceUrlTargetModification, type CategoryId, type CipherTextPropertyType, type ClassificationConstraint, type ColumnLocator, type ColumnName, type ColumnNameType, type ComparisonCondition, type ComparisonConditionModification, type ComparisonOperator, type CompassProjectRid, type Condition, type ConditionDisplayMetadata, type ConditionIndex, type ConditionModification, type ConditionModification_and, type ConditionModification_comparison, type ConditionModification_markings, type ConditionModification_not, type ConditionModification_or, type ConditionModification_redacted, type ConditionModification_regex, type ConditionModification_true, type ConditionValue, type ConditionValueModification, type ConditionValueModification_interfaceParameterPropertyValue, type ConditionValueModification_objectParameterPropertyValue, type ConditionValueModification_parameterId, type ConditionValueModification_parameterLength, type ConditionValueModification_staticValue, type ConditionValueModification_userProperty, type ConditionValue_interfaceParameterPropertyValue, type ConditionValue_objectParameterPropertyValue, type ConditionValue_parameterId, type ConditionValue_parameterLength, type ConditionValue_staticValue, type ConditionValue_userProperty, type Condition_and, type Condition_comparison, type Condition_markings, type Condition_not, type Condition_or, type Condition_redacted, type Condition_regex, type Condition_true, type ConditionalOverride, type ConditionalOverrideModification, type ConditionalValidationBlock, type ConditionalValidationBlockModification, type CurrentTime, type CurrentUser, type DataConstraint, type DataConstraintWrapper, type DataConstraints, type DataFilter, type DataNullability, type DataNullabilityV2, type DataSecurity, type DataSetName, type DataType, type DataType_baseType, type DatasetRid, type DatasetRidAndBranchId, type DatasetTransactionRid, type DatasourceBackingRid, type DatasourceBackingRid_datasetRid, type DatasourceBackingRid_derivedPropertiesSourceRid, type DatasourceBackingRid_directSourceRid, type DatasourceBackingRid_editsOnlyRid, type DatasourceBackingRid_geotimeSeriesIntegrationRid, type DatasourceBackingRid_mediaSetRid, type DatasourceBackingRid_mediaSetViewRid, type DatasourceBackingRid_restrictedStreamRid, type DatasourceBackingRid_restrictedViewRid, type DatasourceBackingRid_streamLocatorRid, type DatasourceBackingRid_tableRid, type DatasourceBackingRid_timeSeriesSyncRid, type DatasourceIdentifier, type DatasourceIdentifier_datasetRidAndBranchId, type DatasourceIdentifier_derivedPropertiesSourceRid, type DatasourceIdentifier_directSourceRid, type DatasourceIdentifier_editsOnly, type DatasourceIdentifier_geotimeSeriesIntegrationRid, type DatasourceIdentifier_mediaSetView, type DatasourceIdentifier_mediaSourceRids, type DatasourceIdentifier_restrictedStream, type DatasourceIdentifier_restrictedViewRid, type DatasourceIdentifier_streamLocator, type DatasourceIdentifier_table, type DatasourceIdentifier_timeSeriesSyncRid, type DatasourcePredicate, type DatasourcePredicate_hasRid, type DatasourcePredicate_isOnlyDatasource, type DatasourcePredicate_or, type DatasourceRid, type DatasourceType, type DateFormatter, type DatePropertyType, type DateRangeValue, type DateRangeValueModification, type DateRangeValueModification_fixed, type DateRangeValueModification_now, type DateRangeValueModification_relative, type DateRangeValue_fixed, type DateRangeValue_now, type DateRangeValue_relative, type DateTypeDataConstraints$1 as DateTypeDataConstraints, type DateTypeDataValue$1 as DateTypeDataValue, type DateTypeRangeConstraint$1 as DateTypeRangeConstraint, type DatetimeFormat, type DatetimeFormat_localizedFormat, type DatetimeFormat_stringFormat, type DatetimeLocalizedFormat, type DatetimeStringFormat, type DatetimeTimezone, type DatetimeTimezoneDefinition, type DatetimeTimezoneDefinition_zoneId, type DatetimeTimezone_static, type DatetimeTimezone_user, type DecimalPropertyType, type DecimalTypeDataConstraints$1 as DecimalTypeDataConstraints, type DecimalTypeDataConstraints_oneOf$1 as DecimalTypeDataConstraints_oneOf, type DecimalTypeDataConstraints_range$1 as DecimalTypeDataConstraints_range, type DecimalTypeDataValue$1 as DecimalTypeDataValue, type DecimalTypeRangeConstraint$1 as DecimalTypeRangeConstraint, type DelegateToAllowedStructFieldValues, type DeleteInterfaceLinkRule, type DeleteInterfaceLinkRuleModification, type DeleteLinkRule, type DeleteObjectRule, type DeletedLinkTypesStillInUseError, type DeletedLinkTypesStillInUseInWorkflowError, type DeletedObjectTypesStillInUseError, type DeletedObjectTypesStillInUseInWorkflowError, type DeletingAndEditingTheSameActionTypeError, type DeletionMetadata, type DeprecatedActionTypeGetOrganizationsResponse, type DeprecatedActionTypeSetOrganizationsRequest, type DeprecatedActionTypeStatus, type DeprecatedInterfaceTypeStatus, type DeprecatedLinkTypeStatus, type DeprecatedObjectTypeStatus, type DeprecatedPropertyTypeStatus, type DerivedPropertiesSourceRid, type DirectSourceRid, type DirectedLinkTypeRid, type DisplayMetadataConfigurationDefaultLayout, type DisplayMetadataConfigurationDisplayAndFormat, type DoublePropertyType, type DoubleTypeDataConstraints$1 as DoubleTypeDataConstraints, type DoubleTypeDataConstraints_oneOf$1 as DoubleTypeDataConstraints_oneOf, type DoubleTypeDataConstraints_range$1 as DoubleTypeDataConstraints_range, type DoubleTypeDataValue$1 as DoubleTypeDataValue, type DoubleTypeRangeConstraint$1 as DoubleTypeRangeConstraint, type Duration, type DurationBaseValue, type DurationFormatStyle, type DurationFormatStyle_humanReadable, type DurationFormatStyle_timecode, type DurationPrecision, type DynamicObjectSet, type DynamicObjectSetInput, type DynamicObjectSetInputBase, type DynamicObjectSetInputParameter, type DynamicObjectSetInputUnioned, type DynamicObjectSetInput_base, type DynamicObjectSetInput_parameter, type DynamicObjectSetInput_unioned, type EditActionTypeRequest, type EditOnlyPropertyType, type EditParameterRequest, type EditParameterRequestModification, type EditSectionRequest, type EditSectionRequestModification, type EditValidationRuleRequest, type EditsConfiguration, type EditsHistoryObjectTypeRid, type EditsOnlyRid, type EmailBody, type EmailBodyModification, type EmailBodyModification_basic, type EmailBody_basic, type EmbeddingModel, type EmbeddingModel_text, type Empty, type EndorsedObjectTypeStatus, type EnrollmentRid, type EntityLoadByDatasourceResponse, type EntityLoadByDatasourceResponse_linkType, type EntityLoadByDatasourceResponse_objectType, type EntityMetadataLoadRequest, type EntityStatus, type EventMetadata, type EventsTopicRid, type EveryoneTrustedRedactionOverride, type ExampleActionTypeStatus, type ExampleInterfaceTypeStatus, type ExampleLinkTypeStatus, type ExampleObjectTypeStatus, type ExamplePropertyTypeStatus, type ExampleValue, type ExperimentalActionTypeStatus, type ExperimentalDeclarativeEditInformation, type ExperimentalInterfaceTypeStatus, type ExperimentalLinkTypeStatus, type ExperimentalObjectTypeStatus, type ExperimentalPropertyTypeStatus, type ExperimentalTimeDependentPropertyTypeV1, type FailureMessage, type FieldDisplayMetadata, type FieldMetadata, type FloatPropertyType, type FloatTypeDataConstraints$1 as FloatTypeDataConstraints, type FloatTypeDataConstraints_oneOf$1 as FloatTypeDataConstraints_oneOf, type FloatTypeDataConstraints_range$1 as FloatTypeDataConstraints_range, type FloatTypeDataValue$1 as FloatTypeDataValue, type FloatTypeRangeConstraint$1 as FloatTypeRangeConstraint, type FormContent, type FormContent_parameterId, type FormContent_sectionId, type FormatterUserId, type FoundryFieldType, type FoundryLiveDeployment, type FoundryObjectReference, type FunctionApiName, type FunctionAtVersion, type FunctionExecutionWithRecipientInput, type FunctionExecutionWithRecipientInputModification, type FunctionExecutionWithRecipientInputModification_logicRuleValue, type FunctionExecutionWithRecipientInputModification_recipient, type FunctionExecutionWithRecipientInput_logicRuleValue, type FunctionExecutionWithRecipientInput_recipient, type FunctionGeneratedActionNotificationRecipients, type FunctionGeneratedActionNotificationRecipientsModification, type FunctionGeneratedNotificationBody, type FunctionGeneratedNotificationBodyModification, type FunctionInputName, type FunctionReference, type FunctionRid, type FunctionRule, type FunctionRuleCustomExecutionMode, type FunctionRuleCustomExecutionMode_bulkExecutionModeConfig, type FunctionRuleModification, type FunctionVersion, type GenericOntologyMetadataError, type GeohashPropertyType, type GeoshapePropertyType, type GeotimeSeriesIntegrationName, type GeotimeSeriesIntegrationRid, type GeotimeSeriesReferencePropertyType, type GetActionTypesForInterfaceTypePageToken, type GetActionTypesForInterfaceTypeRequest, type GetActionTypesForInterfaceTypeResponse, type GetActionTypesForObjectTypePageToken, type GetActionTypesForObjectTypeRequest, type GetActionTypesForObjectTypeResponse, type GetBulkLinksPageRequest, type GetFeatureConfigurationsResponse, type GetLinkMetadataForObjectTypesRequest, type GetLinkMetadataForObjectTypesResponse, type GetLinkTypesForObjectTypesRequest, type GetLinkTypesForObjectTypesResponse, type GetObjectTypesForInterfaceTypesRequest, type GetObjectTypesForInterfaceTypesResponse, type GetObjectTypesForSharedPropertyTypesRequest, type GetObjectTypesForSharedPropertyTypesResponse, type GetObjectTypesForTypeGroupsRequest, type GetObjectTypesForTypeGroupsResponse, type GetOntologyEntitiesForTypeGroupsRequest, type GetOntologyEntitiesForTypeGroupsResponse, type GetOntologySummaryRequest, type GetOntologySummaryResponse, type GetRelationsForObjectTypesRequest, type GetRelationsForObjectTypesResponse, type GlobalBranchRid, type GroupId, type HandlebarsInputName, type HumanReadableFormat, type Icon, type IconReference, type Icon_blueprint, type ImportedActionType, type ImportedInterfaceLinkType, type ImportedInterfaceType, type ImportedLinkDefinition, type ImportedLinkDefinition_manyToMany, type ImportedLinkDefinition_oneToMany, type ImportedLinkType, type ImportedManyToManyLinkDefinition, type ImportedObjectType, type ImportedOneToManyLinkDefinition, type ImportedOntologyEntitiesForProjectSpanOntologies, type ImportedParameter, type ImportedPropertyType, type ImportedSharedPropertyType, type ImportedTypes, type InlineActionDisplayOptions, type InlineActionType, type InlineActionTypeCannotBeReferencedByMultipleObjectTypesError, type InstallLocationBlockShapeId, type IntegerPropertyType, type IntegerTypeDataConstraints$1 as IntegerTypeDataConstraints, type IntegerTypeDataConstraints_oneOf$1 as IntegerTypeDataConstraints_oneOf, type IntegerTypeDataConstraints_range$1 as IntegerTypeDataConstraints_range, type IntegerTypeDataValue$1 as IntegerTypeDataValue, type IntegerTypeRangeConstraint$1 as IntegerTypeRangeConstraint, type InterfaceLinkType, type InterfaceLinkTypeApiName, type InterfaceLinkTypeCardinality, type InterfaceLinkTypeIdInRequest, type InterfaceLinkTypeMetadata, type InterfaceLinkTypeRid, type InterfaceLinkTypeRidOrIdInRequest, type InterfaceLinkTypeRidOrIdInRequest_idInRequest, type InterfaceLinkTypeRidOrIdInRequest_rid, type InterfaceParameterPropertyValue, type InterfaceParameterPropertyValueModification, type InterfacePropertyImplementation, type InterfacePropertyTypeIdInRequest, type InterfacePropertyTypeRid, type InterfacePropertyTypeRidOrIdInRequest, type InterfacePropertyTypeRidOrIdInRequest_idInRequest, type InterfacePropertyTypeRidOrIdInRequest_rid, type InterfaceSharedPropertyType, type InterfaceType, type InterfaceTypeApiName, type InterfaceTypeBlockDataV2, type InterfaceTypeCreatedEvent, type InterfaceTypeDeletedEvent, type InterfaceTypeDisplayMetadata, type InterfaceTypeError, type InterfaceTypeError_interfaceTypesAlreadyExist, type InterfaceTypeError_interfaceTypesNotFound, type InterfaceTypeIdInRequest, type InterfaceTypeLoadRequest, type InterfaceTypeLoadResponse, type InterfaceTypeRid, type InterfaceTypeRidOrIdInRequest, type InterfaceTypeRidOrIdInRequest_idInRequest, type InterfaceTypeRidOrIdInRequest_rid, type InterfaceTypeStatus, type InterfaceTypeStatus_active, type InterfaceTypeStatus_deprecated, type InterfaceTypeStatus_example, type InterfaceTypeStatus_experimental, type InterfaceTypeUpdatedEvent, type InterfaceTypesAlreadyExistError, type InterfaceTypesNotFoundError, type InterfacesSummary, type IntermediaryLinkDefinition, type IsOnlyDatasource, type JoinDefinition, type JoinDefinition_joinTable, type JoinDefinition_singleKey, type KnownFormatter, type KnownFormatter_artifactGidFormatter, type KnownFormatter_ridFormatter, type KnownFormatter_userId, type KnownMarketplaceIdentifiers, type LabelledValue, type LanguageAnalyzer, type LimeIndexRid, type LinkDefinition, type LinkDefinition_intermediary, type LinkDefinition_manyToMany, type LinkDefinition_oneToMany, type LinkMetadata, type LinkMetadata_linkType, type LinkMetadata_softLink, type LinkType, type LinkTypeBlockDataV2, type LinkTypeCreatedEvent, type LinkTypeDeletedEvent, type LinkTypeDisplayMetadata, type LinkTypeError, type LinkTypeError_deletedLinkTypesStillInUse, type LinkTypeError_deletedObjectsStillInUse, type LinkTypeError_linkTypeRidsNotFound, type LinkTypeError_linkTypesAlreadyExist, type LinkTypeError_linkTypesNotFound, type LinkTypeError_referencedLinkTypesNotFound, type LinkTypeError_referencedObjectTypesNotFound, type LinkTypeId, type LinkTypeIdentifier, type LinkTypeIdentifier_linkTypeId, type LinkTypeIdentifier_linkTypeRid, type LinkTypeInputManagerRid, type LinkTypeInputSpec, type LinkTypeLoadRequest, type LinkTypeLoadResponse, type LinkTypeMetadata, type LinkTypeMetadataInputManagerRid, type LinkTypePeeringMetadata, type LinkTypePeeringMetadataV1, type LinkTypePeeringMetadata_v1, type LinkTypePeeringRid, type LinkTypePermissionInformation, type LinkTypeRestrictionStatus, type LinkTypeRid, type LinkTypeRidsNotFoundError, type LinkTypeStatus, type LinkTypeStatus_active, type LinkTypeStatus_deprecated, type LinkTypeStatus_example, type LinkTypeStatus_experimental, type LinkTypeUpdatedEvent, type LinkTypesAlreadyExistError, type LinkTypesNotFoundError, type LinkTypesSummary, type LinkedEntityTypeId, type LinkedEntityTypeId_interfaceType, type LinkedEntityTypeId_objectType, type LinkedEntityTypeRidOrIdInRequest, type LinkedEntityTypeRidOrIdInRequest_interfaceType, type LinkedEntityTypeRidOrIdInRequest_objectType, type LiveDeploymentRid, type LmsEmbeddingModel, type LoadActionTypesFromOntologyRequest, type LoadActionTypesFromOntologyResponse, type LoadAllActionTypesFromOntologyRequest, type LoadAllActionTypesPageItem, type LoadAllActionTypesPageRequest, type LoadAllActionTypesPageResponse, type LoadAllActionTypesPageToken, type LoadAllInterfaceTypesPageItem, type LoadAllInterfaceTypesPageRequest, type LoadAllInterfaceTypesPageResponse, type LoadAllInterfaceTypesPageToken, type LoadAllObjectTypesFromOntologyPageRequest, type LoadAllObjectTypesFromOntologyPageResponse, type LoadAllObjectTypesPageItem, type LoadAllObjectTypesPageRequest, type LoadAllObjectTypesPageResponse, type LoadAllObjectTypesPageToken, type LoadAllOntologiesRequest, type LoadAllOntologiesResponse, type LoadAllSharedPropertyTypesPageItem, type LoadAllSharedPropertyTypesPageRequest, type LoadAllSharedPropertyTypesPageResponse, type LoadAllSharedPropertyTypesPageToken, type LoadAllTypeGroupsPageItem, type LoadAllTypeGroupsPageRequest, type LoadAllTypeGroupsPageResponse, type LoadAllTypeGroupsPageToken, type LogicRule, type LogicRuleModification, type LogicRuleModification_addInterfaceLinkRule, type LogicRuleModification_addInterfaceRule, type LogicRuleModification_addLinkRule, type LogicRuleModification_addObjectRule, type LogicRuleModification_addOrModifyObjectRule, type LogicRuleModification_addOrModifyObjectRuleV2, type LogicRuleModification_batchedFunctionRule, type LogicRuleModification_deleteInterfaceLinkRule, type LogicRuleModification_deleteLinkRule, type LogicRuleModification_deleteObjectRule, type LogicRuleModification_functionRule, type LogicRuleModification_modifyInterfaceRule, type LogicRuleModification_modifyObjectRule, type LogicRuleValue, type LogicRuleValueModification, type LogicRuleValueModification_currentTime, type LogicRuleValueModification_currentUser, type LogicRuleValueModification_interfaceParameterPropertyValue, type LogicRuleValueModification_objectParameterPropertyValue, type LogicRuleValueModification_parameterId, type LogicRuleValueModification_staticValue, type LogicRuleValueModification_synchronousWebhookOutput, type LogicRuleValueModification_uniqueIdentifier, type LogicRuleValue_currentTime, type LogicRuleValue_currentUser, type LogicRuleValue_interfaceParameterPropertyValue, type LogicRuleValue_objectParameterPropertyValue, type LogicRuleValue_parameterId, type LogicRuleValue_staticValue, type LogicRuleValue_synchronousWebhookOutput, type LogicRuleValue_uniqueIdentifier, type LogicRule_addInterfaceLinkRule, type LogicRule_addInterfaceRule, type LogicRule_addLinkRule, type LogicRule_addObjectRule, type LogicRule_addOrModifyObjectRule, type LogicRule_addOrModifyObjectRuleV2, type LogicRule_batchedFunctionRule, type LogicRule_deleteInterfaceLinkRule, type LogicRule_deleteLinkRule, type LogicRule_deleteObjectRule, type LogicRule_functionRule, type LogicRule_modifyInterfaceRule, type LogicRule_modifyObjectRule, type LongPropertyType, type LongTypeDataConstraints$1 as LongTypeDataConstraints, type LongTypeDataConstraints_oneOf$1 as LongTypeDataConstraints_oneOf, type LongTypeDataConstraints_range$1 as LongTypeDataConstraints_range, type LongTypeDataValue$1 as LongTypeDataValue, type LongTypeRangeConstraint$1 as LongTypeRangeConstraint, type MandatoryMarkingConstraint, type ManyToManyJoinDefinition, type ManyToManyLinkDefinition, type ManyToManyLinkTypeDatasetDatasource, type ManyToManyLinkTypeDatasource, type ManyToManyLinkTypeDatasourceDefinition, type ManyToManyLinkTypeDatasourceDefinition_dataset, type ManyToManyLinkTypeDatasourceDefinition_stream, type ManyToManyLinkTypeStreamDatasource, type MarketplaceObjectTypeEntityMetadata, type MarkingFilter, type MarkingFilter_markingTypes, type MarkingId, type MarkingPropertyType, type MarkingSubtype, type MarkingType, type MarkingTypesFilter, type MarkingsCondition, type MarkingsConditionModification, type MediaItemRid, type MediaReferencePropertyType, type MediaSetBranchRid, type MediaSetRid, type MediaSetViewLocator, type MediaSetViewName, type MediaSetViewRid, type MediaSourceRid, type MediaSourceRid_datasetRid, type MediaSourceRid_mediaSetRid, type MissingAffectedObjectTypesForFunctionRule, type ModifyInterfaceRule, type ModifyInterfaceRuleModification, type ModifyObjectRule, type ModifyObjectRuleModification, type ModuleRid, type MultipassUserFilter, type MultipassUserFilterModification, type MultipassUserFilterModification_groupFilter, type MultipassUserFilter_groupFilter, type MultipassUserInGroupFilter, type MultipassUserInGroupFilterModification, type MustBeEmpty, type NestedStructFieldApiNameMapping, type NewObjectUrlTarget, type NewObjectUrlTargetModification, type NoRetentionPolicy, type NonExistentParametersUsedInParameterPrefillError, type NonNumericInternalInterpolation, type NonNumericSeriesValueMetadata, type NonNumericSeriesValueUnit, type NoneEntityProvenance, type NotAnalyzedAnalyzer, type NotCondition, type NotConditionModification, type NotepadReference, type NotepadRid, type NotificationRecipient, type NotificationResultTypeLink, type NotificationResultTypeLinkModification, type NotificationTemplateInputValue, type NotificationTemplateInputValueModification, type NotificationTemplateInputValueModification_actionTriggererValue, type NotificationTemplateInputValueModification_logicRuleValue, type NotificationTemplateInputValueModification_recipientValue, type NotificationTemplateInputValue_actionTriggererValue, type NotificationTemplateInputValue_logicRuleValue, type NotificationTemplateInputValue_recipientValue, type NumberFormatBase, type NumberFormatBasisPoint, type NumberFormatBillions, type NumberFormatCurrency, type NumberFormatCurrencyStyle, type NumberFormatCustomUnit, type NumberFormatDuration, type NumberFormatMillions, type NumberFormatNotation, type NumberFormatOrdinal, type NumberFormatPerMille, type NumberFormatPercentage, type NumberFormatPrePostFix, type NumberFormatThousands, type NumberFormatUnit, type NumberFormatter, type NumberFormatter_base, type NumberFormatter_basisPoint, type NumberFormatter_billions, type NumberFormatter_currency, type NumberFormatter_customUnit, type NumberFormatter_duration, type NumberFormatter_millions, type NumberFormatter_ordinal, type NumberFormatter_perMille, type NumberFormatter_percentage, type NumberFormatter_prePost, type NumberFormatter_thousands, type NumberFormatter_unit, type NumberRoundingMode, type NumericInternalInterpolation, type NumericOrNonNumericSeriesValueMetadata, type NumericOrNonNumericSeriesValueMetadataV2, type NumericSeriesValueMetadata, type NumericSeriesValueUnit, type NumericSeriesValueUnit_customUnit, type NumericSeriesValueUnit_standardUnit, type ObjectDbRid, type ObjectDbSyncRid, type ObjectDisplayMetadata, type ObjectIdentifier, type ObjectMonitoringFrontendConsumer, type ObjectParameterPropertyValue, type ObjectParameterStructFieldValue, type ObjectParameterStructFieldValueModification, type ObjectParameterStructListFieldValue, type ObjectParameterStructListFieldValueModification, type ObjectQueryPrefill, type ObjectQueryPrefillModification, type ObjectQueryPropertyValue, type ObjectQueryPropertyValueModification, type ObjectRid, type ObjectSet, type ObjectSetFilter$1 as ObjectSetFilter, type ObjectSetRidPrefill, type ObjectSetRidPrefillModification, type ObjectSetSearchAround, type ObjectSetTransform, type ObjectSetTransform_propertyFilter, type ObjectSetTransform_searchAround, type ObjectType, type ObjectTypeApiName, type ObjectTypeBlockDataV2, type ObjectTypeCreatedEvent, type ObjectTypeDatasetDatasource, type ObjectTypeDatasetDatasourceV2, type ObjectTypeDatasetDatasourceV3, type ObjectTypeDatasource, type ObjectTypeDatasourceDefinition, type ObjectTypeDatasourceDefinition_dataset, type ObjectTypeDatasourceDefinition_datasetV2, type ObjectTypeDatasourceDefinition_datasetV3, type ObjectTypeDatasourceDefinition_derived, type ObjectTypeDatasourceDefinition_direct, type ObjectTypeDatasourceDefinition_editsOnly, type ObjectTypeDatasourceDefinition_geotimeSeries, type ObjectTypeDatasourceDefinition_media, type ObjectTypeDatasourceDefinition_mediaSetView, type ObjectTypeDatasourceDefinition_restrictedStream, type ObjectTypeDatasourceDefinition_restrictedView, type ObjectTypeDatasourceDefinition_restrictedViewV2, type ObjectTypeDatasourceDefinition_stream, type ObjectTypeDatasourceDefinition_streamV2, type ObjectTypeDatasourceDefinition_streamV3, type ObjectTypeDatasourceDefinition_table, type ObjectTypeDatasourceDefinition_timeSeries, type ObjectTypeDeletedEvent, type ObjectTypeDerivedPropertiesDatasource, type ObjectTypeDirectDatasource, type ObjectTypeDisplayMetadata, type ObjectTypeEditsOnlyDatasource, type ObjectTypeEmbeddingInput, type ObjectTypeError, type ObjectTypeError_objectTypeRidsNotFound, type ObjectTypeError_objectTypesAlreadyExist, type ObjectTypeError_objectTypesNotFound, type ObjectTypeError_patchBackupInitializationConfigurationSourceDoesNotExist, type ObjectTypeFieldApiName, type ObjectTypeGeotimeSeriesDatasource, type ObjectTypeId, type ObjectTypeIdentifier, type ObjectTypeIdentifier_objectTypeId, type ObjectTypeIdentifier_objectTypeRid, type ObjectTypeIdsAndInterfaceTypeRids, type ObjectTypeInputManagerProperties, type ObjectTypeInputManagerRid, type ObjectTypeInputSpec, type ObjectTypeInterfaceImplementation, type ObjectTypeLoadRequest, type ObjectTypeLoadResponse, type ObjectTypeMediaDatasource, type ObjectTypeMediaSetViewDatasource, type ObjectTypeMetadataInputManagerRid, type ObjectTypePeeringMetadata, type ObjectTypePeeringMetadataV1, type ObjectTypePeeringMetadata_v1, type ObjectTypePeeringRid, type ObjectTypePermissionInformation, type ObjectTypeRestrictedStreamDatasource, type ObjectTypeRestrictedViewDatasource, type ObjectTypeRestrictedViewDatasourceV2, type ObjectTypeRestrictionStatus, type ObjectTypeRid, type ObjectTypeRidsAndInterfaceTypeRids, type ObjectTypeRidsNotFoundError, type ObjectTypeStatus, type ObjectTypeStatus_active, type ObjectTypeStatus_deprecated, type ObjectTypeStatus_endorsed, type ObjectTypeStatus_example, type ObjectTypeStatus_experimental, type ObjectTypeStreamDatasource, type ObjectTypeStreamDatasourceV2, type ObjectTypeStreamDatasourceV3, type ObjectTypeTableDatasource, type ObjectTypeTimeSeriesDatasource, type ObjectTypeTraitPropertySpecification, type ObjectTypeTraits, type ObjectTypeUpdatedEvent, type ObjectTypeWithRestrictedViewWithGpsPolicyColumnsNotMappedAsPropertyTypes, type ObjectTypesAlreadyExistError, type ObjectTypesNotFoundError, type ObjectTypesSummary, type ObjectsPlatformRids, type ObjectsWritebackDataset, type OneOfDecimalTypeConstraint$1 as OneOfDecimalTypeConstraint, type OneOfDoubleTypeConstraint$1 as OneOfDoubleTypeConstraint, type OneOfFloatTypeConstraint$1 as OneOfFloatTypeConstraint, type OneOfIntegerTypeConstraint$1 as OneOfIntegerTypeConstraint, type OneOfLongTypeConstraint$1 as OneOfLongTypeConstraint, type OneOfShortTypeConstraint$1 as OneOfShortTypeConstraint, type OneOfStringTypeConstraint$1 as OneOfStringTypeConstraint, type OneToManyLinkCardinalityHint, type OneToManyLinkDefinition, type OntologyActionTypeLoadRequest, type OntologyApiName, type OntologyBlockDataV2, type OntologyBranch, type OntologyBranchRid, type OntologyBulkLoadEntitiesByDatasourcesRequest, type OntologyBulkLoadEntitiesByDatasourcesResponse, type OntologyBulkLoadEntitiesRequest, type OntologyBulkLoadEntitiesResponse, type OntologyDatasetType, type OntologyEntitiesUsedInTypeGroup, type OntologyInformation, type OntologyIr, type OntologyIrActionLogMetadata, type OntologyIrActionLogRule, type OntologyIrActionLogValue, type OntologyIrActionLogValue_actionRid, type OntologyIrActionLogValue_actionTimestamp, type OntologyIrActionLogValue_actionTypeRid, type OntologyIrActionLogValue_actionTypeVersion, type OntologyIrActionLogValue_actionUser, type OntologyIrActionLogValue_allEditedObjects, type OntologyIrActionLogValue_asynchronousWebhookInstanceIds, type OntologyIrActionLogValue_editedObjects, type OntologyIrActionLogValue_interfaceParameterPropertyValue, type OntologyIrActionLogValue_isReverted, type OntologyIrActionLogValue_notificationIds, type OntologyIrActionLogValue_notifiedUsers, type OntologyIrActionLogValue_objectParameterPropertyValue, type OntologyIrActionLogValue_parameterValue, type OntologyIrActionLogValue_revertTimestamp, type OntologyIrActionLogValue_revertUser, type OntologyIrActionLogValue_scenarioRid, type OntologyIrActionLogValue_summary, type OntologyIrActionLogValue_synchronousWebhookInstanceId, type OntologyIrActionLogic, type OntologyIrActionNotification, type OntologyIrActionNotificationBody, type OntologyIrActionNotificationBodyFunctionExecution, type OntologyIrActionNotificationBody_functionGenerated, type OntologyIrActionNotificationBody_templateNotification, type OntologyIrActionNotificationRecipients, type OntologyIrActionNotificationRecipients_functionGenerated, type OntologyIrActionNotificationRecipients_parameter, type OntologyIrActionType, type OntologyIrActionTypeBlockDataV2, type OntologyIrActionTypeDisplayMetadata, type OntologyIrActionTypeEntities, type OntologyIrActionTypeLevelValidation, type OntologyIrActionTypeLogic, type OntologyIrActionTypeMetadata, type OntologyIrActionTypeRichTextComponent, type OntologyIrActionTypeRichTextComponent_message, type OntologyIrActionTypeRichTextComponent_parameter, type OntologyIrActionTypeRichTextComponent_parameterProperty, type OntologyIrActionTypeRichTextParameterPropertyReference, type OntologyIrActionTypeStatus, type OntologyIrActionTypeStatus_active, type OntologyIrActionTypeStatus_deprecated, type OntologyIrActionTypeStatus_example, type OntologyIrActionTypeStatus_experimental, type OntologyIrActionValidation, type OntologyIrActionWebhooks, type OntologyIrActionsObjectSet, type OntologyIrAddInterfaceLinkRule, type OntologyIrAddInterfaceRule, type OntologyIrAddObjectRule, type OntologyIrAddOrModifyObjectRule, type OntologyIrAddOrModifyObjectRuleV2, type OntologyIrAllEditedObjectsFieldMapping, type OntologyIrAllowedParameterValues, type OntologyIrAllowedParameterValues_attachment, type OntologyIrAllowedParameterValues_boolean, type OntologyIrAllowedParameterValues_cbacMarking, type OntologyIrAllowedParameterValues_datetime, type OntologyIrAllowedParameterValues_geohash, type OntologyIrAllowedParameterValues_geoshape, type OntologyIrAllowedParameterValues_geotimeSeriesReference, type OntologyIrAllowedParameterValues_interfaceObjectQuery, type OntologyIrAllowedParameterValues_interfacePropertyValue, type OntologyIrAllowedParameterValues_mandatoryMarking, type OntologyIrAllowedParameterValues_mediaReference, type OntologyIrAllowedParameterValues_multipassGroup, type OntologyIrAllowedParameterValues_objectList, type OntologyIrAllowedParameterValues_objectPropertyValue, type OntologyIrAllowedParameterValues_objectQuery, type OntologyIrAllowedParameterValues_objectSetRid, type OntologyIrAllowedParameterValues_objectTypeReference, type OntologyIrAllowedParameterValues_oneOf, type OntologyIrAllowedParameterValues_range, type OntologyIrAllowedParameterValues_redacted, type OntologyIrAllowedParameterValues_text, type OntologyIrAllowedParameterValues_timeSeriesReference, type OntologyIrAllowedParameterValues_user, type OntologyIrAllowedParameterValues_valueType, type OntologyIrAllowedStructFieldValues, type OntologyIrAllowedStructFieldValuesOverride, type OntologyIrAllowedStructFieldValues_boolean, type OntologyIrAllowedStructFieldValues_datetime, type OntologyIrAllowedStructFieldValues_geohash, type OntologyIrAllowedStructFieldValues_oneOf, type OntologyIrAllowedStructFieldValues_range, type OntologyIrAllowedStructFieldValues_text, type OntologyIrAllowedValuesOverride, type OntologyIrAndCondition, type OntologyIrArrayPropertyType, type OntologyIrAsynchronousPostWritebackWebhook, type OntologyIrAsynchronousPostWritebackWebhook_staticDirectInput, type OntologyIrAsynchronousPostWritebackWebhook_staticFunctionInput, type OntologyIrBaseFormatter, type OntologyIrBaseFormatter_boolean, type OntologyIrBaseFormatter_date, type OntologyIrBaseFormatter_knownFormatter, type OntologyIrBaseFormatter_number, type OntologyIrBaseFormatter_string, type OntologyIrBaseFormatter_timeDependent, type OntologyIrBaseFormatter_timestamp, type OntologyIrBaseParameterType, type OntologyIrBaseParameterType_decimal, type OntologyIrBaseParameterType_decimalList, type OntologyIrBaseParameterType_interfaceReference, type OntologyIrBaseParameterType_interfaceReferenceList, type OntologyIrBaseParameterType_objectReference, type OntologyIrBaseParameterType_objectReferenceList, type OntologyIrBaseParameterType_objectSetRid, type OntologyIrBaseParameterType_objectTypeReference, type OntologyIrBaseParameterType_struct, type OntologyIrBaseParameterType_structList, type OntologyIrBaseParameterType_timestamp, type OntologyIrBaseParameterType_timestampList, type OntologyIrBasicEmailBody, type OntologyIrBatchedFunctionRule, type OntologyIrBlockPermissionInformation, type OntologyIrCarbonWorkspaceComponentUrlTarget, type OntologyIrCarbonWorkspaceComponentUrlTarget_rid, type OntologyIrCarbonWorkspaceUrlTarget, type OntologyIrCipherTextPropertyType, type OntologyIrComparisonCondition, type OntologyIrCondition, type OntologyIrConditionValue, type OntologyIrConditionValue_interfaceParameterPropertyValue, type OntologyIrConditionValue_objectParameterPropertyValue, type OntologyIrConditionValue_parameterId, type OntologyIrConditionValue_parameterLength, type OntologyIrConditionValue_staticValue, type OntologyIrConditionValue_userProperty, type OntologyIrCondition_and, type OntologyIrCondition_comparison, type OntologyIrCondition_markings, type OntologyIrCondition_not, type OntologyIrCondition_or, type OntologyIrCondition_redacted, type OntologyIrCondition_regex, type OntologyIrCondition_true, type OntologyIrConditionalOverride, type OntologyIrConditionalValidationBlock, type OntologyIrDateRangeValue, type OntologyIrDateRangeValue_fixed, type OntologyIrDateRangeValue_now, type OntologyIrDateRangeValue_relative, type OntologyIrDatetimeTimezone, type OntologyIrDatetimeTimezoneDefinition, type OntologyIrDatetimeTimezoneDefinition_zoneId, type OntologyIrDatetimeTimezone_static, type OntologyIrDatetimeTimezone_user, type OntologyIrDeleteInterfaceLinkRule, type OntologyIrDeprecatedActionTypeStatus, type OntologyIrDeprecatedInterfaceTypeStatus, type OntologyIrDeprecatedLinkTypeStatus, type OntologyIrDeprecatedObjectTypeStatus, type OntologyIrDeprecatedPropertyTypeStatus, type OntologyIrDynamicObjectSet, type OntologyIrDynamicObjectSetInput, type OntologyIrDynamicObjectSetInputBase, type OntologyIrDynamicObjectSetInputUnioned, type OntologyIrDynamicObjectSetInput_base, type OntologyIrDynamicObjectSetInput_parameter, type OntologyIrDynamicObjectSetInput_unioned, type OntologyIrEmailBody, type OntologyIrEmailBody_basic, type OntologyIrEventMetadata, type OntologyIrExperimentalTimeDependentPropertyTypeV1, type OntologyIrFormContent, type OntologyIrFormContent_parameterId, type OntologyIrFormContent_sectionId, type OntologyIrFunctionExecutionWithRecipientInput, type OntologyIrFunctionExecutionWithRecipientInput_logicRuleValue, type OntologyIrFunctionExecutionWithRecipientInput_recipient, type OntologyIrFunctionGeneratedActionNotificationRecipients, type OntologyIrFunctionGeneratedNotificationBody, type OntologyIrFunctionRule, type OntologyIrImportedActionType, type OntologyIrImportedInterfaceType, type OntologyIrImportedObjectType, type OntologyIrImportedParameter, type OntologyIrImportedPropertyType, type OntologyIrImportedSharedPropertyType, type OntologyIrImportedTypes, type OntologyIrInlineActionType, type OntologyIrInterfaceLinkType, type OntologyIrInterfaceParameterPropertyValue, type OntologyIrInterfacePropertyImplementation, type OntologyIrInterfaceSharedPropertyType, type OntologyIrInterfaceType, type OntologyIrInterfaceTypeBlockDataV2, type OntologyIrInterfaceTypeStatus, type OntologyIrInterfaceTypeStatus_active, type OntologyIrInterfaceTypeStatus_deprecated, type OntologyIrInterfaceTypeStatus_example, type OntologyIrInterfaceTypeStatus_experimental, type OntologyIrIntermediaryLinkDefinition, type OntologyIrKnownMarketplaceIdentifiers, type OntologyIrLabelledValue, type OntologyIrLinkDefinition, type OntologyIrLinkDefinition_manyToMany, type OntologyIrLinkDefinition_oneToMany, type OntologyIrLinkType, type OntologyIrLinkTypeBlockDataV2, type OntologyIrLinkTypeStatus, type OntologyIrLinkTypeStatus_active, type OntologyIrLinkTypeStatus_deprecated, type OntologyIrLinkTypeStatus_example, type OntologyIrLinkTypeStatus_experimental, type OntologyIrLinkedEntityTypeId, type OntologyIrLinkedEntityTypeId_interfaceType, type OntologyIrLinkedEntityTypeId_objectType, type OntologyIrLogicRule, type OntologyIrLogicRuleValue, type OntologyIrLogicRuleValue_currentTime, type OntologyIrLogicRuleValue_currentUser, type OntologyIrLogicRuleValue_interfaceParameterPropertyValue, type OntologyIrLogicRuleValue_objectParameterPropertyValue, type OntologyIrLogicRuleValue_parameterId, type OntologyIrLogicRuleValue_staticValue, type OntologyIrLogicRuleValue_synchronousWebhookOutput, type OntologyIrLogicRuleValue_uniqueIdentifier, type OntologyIrLogicRule_addInterfaceRule, type OntologyIrLogicRule_addLinkRule, type OntologyIrLogicRule_addObjectRule, type OntologyIrLogicRule_addOrModifyObjectRuleV2, type OntologyIrLogicRule_deleteLinkRule, type OntologyIrLogicRule_deleteObjectRule, type OntologyIrLogicRule_modifyInterfaceRule, type OntologyIrLogicRule_modifyObjectRule, type OntologyIrManyToManyLinkDefinition, type OntologyIrManyToManyLinkTypeDatasetDatasource, type OntologyIrManyToManyLinkTypeDatasource, type OntologyIrManyToManyLinkTypeDatasourceDefinition, type OntologyIrManyToManyLinkTypeDatasourceDefinition_dataset, type OntologyIrManyToManyLinkTypeStreamDatasource, type OntologyIrMarketplaceObjectTypeEntityMetadata, type OntologyIrMarkingsCondition, type OntologyIrMediaSourceRid, type OntologyIrMediaSourceRid_datasetRid, type OntologyIrMediaSourceRid_mediaSetRid, type OntologyIrModifyInterfaceRule, type OntologyIrModifyObjectRule, type OntologyIrMultipassUserFilter, type OntologyIrMultipassUserFilter_groupFilter, type OntologyIrMultipassUserInGroupFilter, type OntologyIrNewObjectUrlTarget, type OntologyIrNonNumericSeriesValueMetadata, type OntologyIrNonNumericSeriesValueUnit, type OntologyIrNotCondition, type OntologyIrNotificationResultTypeLink, type OntologyIrNotificationTemplateInputValue, type OntologyIrNotificationTemplateInputValue_actionTriggererValue, type OntologyIrNotificationTemplateInputValue_logicRuleValue, type OntologyIrNotificationTemplateInputValue_recipientValue, type OntologyIrNumberFormatCurrency, type OntologyIrNumberFormatCustomUnit, type OntologyIrNumberFormatPrePostFix, type OntologyIrNumberFormatUnit, type OntologyIrNumberFormatter, type OntologyIrNumberFormatter_base, type OntologyIrNumberFormatter_basisPoint, type OntologyIrNumberFormatter_billions, type OntologyIrNumberFormatter_currency, type OntologyIrNumberFormatter_customUnit, type OntologyIrNumberFormatter_duration, type OntologyIrNumberFormatter_millions, type OntologyIrNumberFormatter_ordinal, type OntologyIrNumberFormatter_perMille, type OntologyIrNumberFormatter_percentage, type OntologyIrNumberFormatter_prePost, type OntologyIrNumberFormatter_thousands, type OntologyIrNumberFormatter_unit, type OntologyIrNumericOrNonNumericSeriesValueMetadataV2, type OntologyIrNumericSeriesValueMetadata, type OntologyIrNumericSeriesValueUnit, type OntologyIrNumericSeriesValueUnit_customUnit, type OntologyIrNumericSeriesValueUnit_standardUnit, type OntologyIrObjectParameterPropertyValue, type OntologyIrObjectParameterStructFieldValue, type OntologyIrObjectParameterStructListFieldValue, type OntologyIrObjectPropertyReference, type OntologyIrObjectQueryPrefill, type OntologyIrObjectQueryPropertyValue, type OntologyIrObjectSetRidPrefill, type OntologyIrObjectSetSearchAround, type OntologyIrObjectSetTransform, type OntologyIrObjectSetTransform_propertyFilter, type OntologyIrObjectSetTransform_searchAround, type OntologyIrObjectType, type OntologyIrObjectTypeBlockDataV2, type OntologyIrObjectTypeDatasetDatasource, type OntologyIrObjectTypeDatasetDatasourceV2, type OntologyIrObjectTypeDatasetDatasourceV3, type OntologyIrObjectTypeDatasource, type OntologyIrObjectTypeDatasourceDefinition, type OntologyIrObjectTypeDatasourceDefinition_datasetV2, type OntologyIrObjectTypeDatasourceDefinition_datasetV3, type OntologyIrObjectTypeDatasourceDefinition_derived, type OntologyIrObjectTypeDatasourceDefinition_direct, type OntologyIrObjectTypeDatasourceDefinition_editsOnly, type OntologyIrObjectTypeDatasourceDefinition_geotimeSeries, type OntologyIrObjectTypeDatasourceDefinition_mediaSetView, type OntologyIrObjectTypeDatasourceDefinition_restrictedStream, type OntologyIrObjectTypeDatasourceDefinition_restrictedViewV2, type OntologyIrObjectTypeDatasourceDefinition_streamV2, type OntologyIrObjectTypeDatasourceDefinition_streamV3, type OntologyIrObjectTypeDatasourceDefinition_table, type OntologyIrObjectTypeDatasourceDefinition_timeSeries, type OntologyIrObjectTypeDerivedPropertiesDatasource, type OntologyIrObjectTypeDirectDatasource, type OntologyIrObjectTypeEditsOnlyDatasource, type OntologyIrObjectTypeGeotimeSeriesDatasource, type OntologyIrObjectTypeInterfaceImplementation, type OntologyIrObjectTypeMediaDatasource, type OntologyIrObjectTypeMediaSetViewDatasource, type OntologyIrObjectTypeRestrictedStreamDatasource, type OntologyIrObjectTypeRestrictedViewDatasource, type OntologyIrObjectTypeRestrictedViewDatasourceV2, type OntologyIrObjectTypeStatus, type OntologyIrObjectTypeStatus_active, type OntologyIrObjectTypeStatus_deprecated, type OntologyIrObjectTypeStatus_endorsed, type OntologyIrObjectTypeStatus_example, type OntologyIrObjectTypeStatus_experimental, type OntologyIrObjectTypeStreamDatasource, type OntologyIrObjectTypeStreamDatasourceV2, type OntologyIrObjectTypeStreamDatasourceV3, type OntologyIrObjectTypeTableDatasource, type OntologyIrObjectTypeTimeSeriesDatasource, type OntologyIrObjectTypeTraits, type OntologyIrObjectsWritebackDataset, type OntologyIrOneToManyLinkDefinition, type OntologyIrOntologyBlockDataV2, type OntologyIrOrCondition, type OntologyIrParameter, type OntologyIrParameterActionNotificationRecipients, type OntologyIrParameterCbacConstraint, type OntologyIrParameterCbacMarking, type OntologyIrParameterCbacMarkingOrEmpty, type OntologyIrParameterCbacMarkingOrEmpty_cbacMarking, type OntologyIrParameterCbacMarkingOrEmpty_empty, type OntologyIrParameterDateRangeValue, type OntologyIrParameterDateTimeRange, type OntologyIrParameterDateTimeRangeOrEmpty, type OntologyIrParameterDateTimeRangeOrEmpty_datetime, type OntologyIrParameterDateTimeRangeOrEmpty_empty, type OntologyIrParameterDisplayMetadata, type OntologyIrParameterMultipassUser, type OntologyIrParameterMultipassUserOrEmpty, type OntologyIrParameterMultipassUserOrEmpty_empty, type OntologyIrParameterMultipassUserOrEmpty_user, type OntologyIrParameterObjectPropertyValue, type OntologyIrParameterObjectPropertyValueOrEmpty, type OntologyIrParameterObjectPropertyValueOrEmpty_empty, type OntologyIrParameterObjectPropertyValueOrEmpty_objectPropertyValue, type OntologyIrParameterObjectQuery, type OntologyIrParameterObjectQueryOrEmpty, type OntologyIrParameterObjectQueryOrEmpty_empty, type OntologyIrParameterObjectQueryOrEmpty_objectQuery, type OntologyIrParameterObjectTypeReference, type OntologyIrParameterObjectTypeReferenceOrEmpty, type OntologyIrParameterObjectTypeReferenceOrEmpty_empty, type OntologyIrParameterObjectTypeReferenceOrEmpty_objectTypeReference, type OntologyIrParameterPrefill, type OntologyIrParameterPrefillOverride, type OntologyIrParameterPrefill_interfaceParameterPropertyValue, type OntologyIrParameterPrefill_objectParameterPropertyValue, type OntologyIrParameterPrefill_objectQueryPrefill, type OntologyIrParameterPrefill_objectQueryPropertyValue, type OntologyIrParameterPrefill_objectSetRidPrefill, type OntologyIrParameterPrefill_redacted, type OntologyIrParameterPrefill_staticObject, type OntologyIrParameterPrefill_staticValue, type OntologyIrParameterRange, type OntologyIrParameterRangeOrEmpty, type OntologyIrParameterRangeOrEmpty_empty, type OntologyIrParameterRangeOrEmpty_range, type OntologyIrParameterRangeValue, type OntologyIrParameterValidation, type OntologyIrParameterValidationBlock, type OntologyIrParameterValidationBlockOverride, type OntologyIrParameterValidationBlockOverride_allowedValues, type OntologyIrParameterValidationBlockOverride_parameterRequired, type OntologyIrParameterValidationBlockOverride_prefill, type OntologyIrParameterValidationBlockOverride_visibility, type OntologyIrParameterValidationDisplayMetadata, type OntologyIrParameterValueOneOf, type OntologyIrParameterValueOneOfOrEmpty, type OntologyIrParameterValueOneOfOrEmpty_empty, type OntologyIrParameterValueOneOfOrEmpty_oneOf, type OntologyIrPrePostFix, type OntologyIrPropertySecurityGroup, type OntologyIrPropertySecurityGroups, type OntologyIrPropertyToColumnMapping, type OntologyIrPropertyToPropertyMapping, type OntologyIrPropertyType, type OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation, type OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation, type OntologyIrPropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType, type OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation, type OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation, type OntologyIrPropertyTypeReferenceOrNumericInternalInterpolation_propertyType, type OntologyIrPropertyTypeReferenceOrStringConstant, type OntologyIrPropertyTypeReferenceOrStringConstant_constant, type OntologyIrPropertyTypeReferenceOrStringConstant_propertyType, type OntologyIrPropertyTypeStatus, type OntologyIrPropertyTypeStatus_active, type OntologyIrPropertyTypeStatus_deprecated, type OntologyIrPropertyTypeStatus_example, type OntologyIrPropertyTypeStatus_experimental, type OntologyIrQualifiedSeriesIdPropertyValue, type OntologyIrRegexCondition, type OntologyIrRidUrlTarget, type OntologyIrRuleSetBinding, type OntologyIrSchemaMigrationBlockData, type OntologyIrSchemaTransitionsWithSchemaVersion, type OntologyIrSection, type OntologyIrSectionConditionalOverride, type OntologyIrSectionDisplayBlock, type OntologyIrSecurityGroupAndCondition, type OntologyIrSecurityGroupComparisonCondition, type OntologyIrSecurityGroupComparisonValue, type OntologyIrSecurityGroupComparisonValue_constant, type OntologyIrSecurityGroupComparisonValue_property, type OntologyIrSecurityGroupComparisonValue_userProperty, type OntologyIrSecurityGroupGranularCondition, type OntologyIrSecurityGroupGranularCondition_and, type OntologyIrSecurityGroupGranularCondition_comparison, type OntologyIrSecurityGroupGranularCondition_markings, type OntologyIrSecurityGroupGranularCondition_not, type OntologyIrSecurityGroupGranularCondition_or, type OntologyIrSecurityGroupGranularCondition_true, type OntologyIrSecurityGroupGranularPolicy, type OntologyIrSecurityGroupGranularSecurityDefinition, type OntologyIrSecurityGroupMarkingsCondition, type OntologyIrSecurityGroupNotCondition, type OntologyIrSecurityGroupOrCondition, type OntologyIrSecurityGroupSecurityDefinition, type OntologyIrSecurityGroupSecurityDefinition_granular, type OntologyIrSecurityGroupSecurityDefinition_mandatoryOnly, type OntologyIrSensorTrait, type OntologyIrSeriesValueMetadata, type OntologyIrSeriesValueMetadata_enum, type OntologyIrSeriesValueMetadata_numeric, type OntologyIrSeriesValueMetadata_numericOrNonNumeric, type OntologyIrSeriesValueMetadata_numericOrNonNumericV2, type OntologyIrSharedPropertyType, type OntologyIrSharedPropertyTypeBlockDataV2, type OntologyIrShortBody, type OntologyIrShortBody_basic, type OntologyIrStaticValue, type OntologyIrStaticWebhookWithDirectInput, type OntologyIrStaticWebhookWithFunctionResultInput, type OntologyIrStructFieldConditionalOverride, type OntologyIrStructFieldConditionalValidationBlock, type OntologyIrStructFieldPrefill, type OntologyIrStructFieldPrefillOverride, type OntologyIrStructFieldPrefill_objectParameterStructFieldValue, type OntologyIrStructFieldPrefill_objectParameterStructListFieldValue, type OntologyIrStructFieldType, type OntologyIrStructFieldValidation, type OntologyIrStructFieldValidationBlock, type OntologyIrStructFieldValidationBlockOverride, type OntologyIrStructFieldValidationBlockOverride_allowedValues, type OntologyIrStructFieldValidationBlockOverride_parameterRequired, type OntologyIrStructFieldValidationBlockOverride_prefill, type OntologyIrStructFieldValidationBlockOverride_visibility, type OntologyIrStructFieldValidationDisplayMetadata, type OntologyIrStructPropertyType, type OntologyIrStructuredShortBody, type OntologyIrSynchronousPreWritebackWebhook, type OntologyIrSynchronousPreWritebackWebhook_staticDirectInput, type OntologyIrSynchronousPreWritebackWebhook_staticFunctionInput, type OntologyIrTemplateNotificationBody, type OntologyIrTimeDependentFormatter, type OntologyIrTimeDependentNonNumericSeriesFormat, type OntologyIrTimeDependentNumericOrNonNumericSeriesFormat, type OntologyIrTimeDependentNumericOrNonNumericSeriesFormatV2, type OntologyIrTimeDependentNumericSeriesFormat, type OntologyIrTimeDependentSeriesFormat, type OntologyIrTimeDependentSeriesFormat_nonNumeric, type OntologyIrTimeDependentSeriesFormat_numeric, type OntologyIrTimeDependentSeriesFormat_numericOrNonNumeric, type OntologyIrTimeDependentSeriesFormat_numericOrNonNumericV2, type OntologyIrTimeSeriesMetadata, type OntologyIrTimestampFormatter, type OntologyIrType, type OntologyIrType_array, type OntologyIrType_attachment, type OntologyIrType_boolean, type OntologyIrType_byte, type OntologyIrType_cipherText, type OntologyIrType_date, type OntologyIrType_decimal, type OntologyIrType_double, type OntologyIrType_experimentalTimeDependentV1, type OntologyIrType_float, type OntologyIrType_geohash, type OntologyIrType_geoshape, type OntologyIrType_geotimeSeriesReference, type OntologyIrType_integer, type OntologyIrType_long, type OntologyIrType_marking, type OntologyIrType_mediaReference, type OntologyIrType_short, type OntologyIrType_string, type OntologyIrType_struct, type OntologyIrType_timestamp, type OntologyIrType_vector, type OntologyIrUrlTarget, type OntologyIrUrlTarget_carbonWorkspace, type OntologyIrUrlTarget_logicRuleValue, type OntologyIrUrlTarget_newObject, type OntologyIrUrlTarget_relativeUrlString, type OntologyIrUrlTarget_rid, type OntologyIrValidationRule, type OntologyIrValueReferenceSource, type OntologyIrValueReferenceSource_propertyTypeRid, type OntologyIrValueTypeBlockData, type OntologyIrValueTypeBlockDataEntry, type OntologyIrWorkflowObjectTypeTraitImpl, type OntologyLoadAllEntitiesRequest, type OntologyLoadAllRequest, type OntologyLoadDatasourcesRequest, type OntologyLoadDatasourcesResponse, type OntologyLoadEntitiesRequest, type OntologyLoadEntitiesResponse, type OntologyLoadRequest, type OntologyLoadResponse, type OntologyMetadataValidationError, type OntologyMetadataValidationError_actionType, type OntologyMetadataValidationError_interfaceType, type OntologyMetadataValidationError_linkType, type OntologyMetadataValidationError_objectType, type OntologyMetadataValidationError_ruleSet, type OntologyMetadataValidationError_sharedPropertyType, type OntologyMetadataValidationError_typeGroup, type OntologyMetadataValidationError_workflow, type OntologyModificationEvent, type OntologyModificationEvent_actionTypeCreated, type OntologyModificationEvent_actionTypeDeleted, type OntologyModificationEvent_actionTypeUpdated, type OntologyModificationEvent_branchClosed, type OntologyModificationEvent_branchDeleted, type OntologyModificationEvent_branchMerged, type OntologyModificationEvent_interfaceTypeCreated, type OntologyModificationEvent_interfaceTypeDeleted, type OntologyModificationEvent_interfaceTypeUpdated, type OntologyModificationEvent_linkTypeCreated, type OntologyModificationEvent_linkTypeDeleted, type OntologyModificationEvent_linkTypeUpdated, type OntologyModificationEvent_objectTypeCreated, type OntologyModificationEvent_objectTypeDeleted, type OntologyModificationEvent_objectTypeUpdated, type OntologyModificationEvent_sharedPropertyTypeCreated, type OntologyModificationEvent_sharedPropertyTypeDeleted, type OntologyModificationEvent_sharedPropertyTypeUpdated, type OntologyModifyRequest, type OntologyModifyResponse, type OntologyPackageRid, type OntologyProposalIdentifier, type OntologyProposalIdentifier_ontologyVersion, type OntologyProposalRid, type OntologyRid, type OntologyRidAndBranch, type OntologyRidsForEntitiesRequest, type OntologyRidsForEntitiesResponse, type OntologySparkInputManagerRid, type OntologySparkInputProperties, type OntologyVersion, type OrCondition, type OrConditionModification, type OrganizationMarkingId, type OrganizationRid, type OrganizationRidsAndEntityResourceIdentifiers, type OrganizationRidsForOntologyResponse, type OtherValueAllowed, type OutputMode, type PackagedEntityRid, type PackagedEntityRid_actionTypeRid, type PackagedEntityRid_interfaceTypeRid, type PackagedEntityRid_linkTypeRid, type PackagedEntityRid_objectTypeRid, type PackagedEntityRid_sharedPropertyTypeRid, type Parameter, type ParameterActionNotificationRecipients, type ParameterActionNotificationRecipientsModification, type ParameterAttachment, type ParameterAttachmentOrEmpty, type ParameterAttachmentOrEmpty_attachment, type ParameterAttachmentOrEmpty_empty, type ParameterBoolean, type ParameterBooleanOrEmpty, type ParameterBooleanOrEmpty_boolean, type ParameterBooleanOrEmpty_empty, type ParameterCbacConstraint, type ParameterCbacConstraintModification, type ParameterCbacMarking, type ParameterCbacMarkingModification, type ParameterCbacMarkingOrEmpty, type ParameterCbacMarkingOrEmptyModification, type ParameterCbacMarkingOrEmptyModification_cbacMarking, type ParameterCbacMarkingOrEmptyModification_empty, type ParameterCbacMarkingOrEmpty_cbacMarking, type ParameterCbacMarkingOrEmpty_empty, type ParameterDateRangeValue, type ParameterDateRangeValueModification, type ParameterDateTimeRange, type ParameterDateTimeRangeModification, type ParameterDateTimeRangeOrEmpty, type ParameterDateTimeRangeOrEmptyModification, type ParameterDateTimeRangeOrEmptyModification_datetime, type ParameterDateTimeRangeOrEmptyModification_empty, type ParameterDateTimeRangeOrEmpty_datetime, type ParameterDateTimeRangeOrEmpty_empty, type ParameterDisplayMetadata, type ParameterFreeText, type ParameterFreeTextOrEmpty, type ParameterFreeTextOrEmpty_empty, type ParameterFreeTextOrEmpty_text, type ParameterGeohash, type ParameterGeohashOrEmpty, type ParameterGeohashOrEmpty_empty, type ParameterGeohashOrEmpty_geohash, type ParameterGeoshape, type ParameterGeoshapeOrEmpty, type ParameterGeoshapeOrEmpty_empty, type ParameterGeoshapeOrEmpty_geoshape, type ParameterGeotimeSeriesReference, type ParameterGeotimeSeriesReferenceOrEmpty, type ParameterGeotimeSeriesReferenceOrEmpty_empty, type ParameterGeotimeSeriesReferenceOrEmpty_geotimeSeries, type ParameterId, type ParameterInterfaceObjectQuery, type ParameterInterfaceObjectQueryModification, type ParameterInterfaceObjectQueryOrEmpty, type ParameterInterfaceObjectQueryOrEmptyModification, type ParameterInterfaceObjectQueryOrEmptyModification_empty, type ParameterInterfaceObjectQueryOrEmptyModification_interfaceObjectQuery, type ParameterInterfaceObjectQueryOrEmpty_empty, type ParameterInterfaceObjectQueryOrEmpty_interfaceObjectQuery, type ParameterInterfacePropertyValueOrEmpty, type ParameterInterfacePropertyValueOrEmptyModification, type ParameterInterfacePropertyValueOrEmptyModification_empty, type ParameterInterfacePropertyValueOrEmptyModification_unrestricted, type ParameterInterfacePropertyValueOrEmpty_empty, type ParameterInterfacePropertyValueOrEmpty_unrestricted, type ParameterLength, type ParameterLength_parameterId, type ParameterMandatoryMarking, type ParameterMandatoryMarkingOrEmpty, type ParameterMandatoryMarkingOrEmpty_empty, type ParameterMandatoryMarkingOrEmpty_mandatoryMarking, type ParameterMediaReference, type ParameterMediaReferenceOrEmpty, type ParameterMediaReferenceOrEmpty_empty, type ParameterMediaReferenceOrEmpty_mediaReference, type ParameterMultipassGroup, type ParameterMultipassGroupOrEmpty, type ParameterMultipassGroupOrEmpty_empty, type ParameterMultipassGroupOrEmpty_group, type ParameterMultipassUser, type ParameterMultipassUserModification, type ParameterMultipassUserOrEmpty, type ParameterMultipassUserOrEmptyModification, type ParameterMultipassUserOrEmptyModification_empty, type ParameterMultipassUserOrEmptyModification_user, type ParameterMultipassUserOrEmpty_empty, type ParameterMultipassUserOrEmpty_user, type ParameterObjectList, type ParameterObjectListOrEmpty, type ParameterObjectListOrEmpty_empty, type ParameterObjectListOrEmpty_objectList, type ParameterObjectPropertyValue, type ParameterObjectPropertyValueModification, type ParameterObjectPropertyValueOrEmpty, type ParameterObjectPropertyValueOrEmptyModification, type ParameterObjectPropertyValueOrEmptyModification_empty, type ParameterObjectPropertyValueOrEmptyModification_objectPropertyValue, type ParameterObjectPropertyValueOrEmpty_empty, type ParameterObjectPropertyValueOrEmpty_objectPropertyValue, type ParameterObjectQuery, type ParameterObjectQueryModification, type ParameterObjectQueryOrEmpty, type ParameterObjectQueryOrEmptyModification, type ParameterObjectQueryOrEmptyModification_empty, type ParameterObjectQueryOrEmptyModification_objectQuery, type ParameterObjectQueryOrEmpty_empty, type ParameterObjectQueryOrEmpty_objectQuery, type ParameterObjectSetRid, type ParameterObjectSetRidOrEmpty, type ParameterObjectSetRidOrEmpty_empty, type ParameterObjectSetRidOrEmpty_objectSetRid, type ParameterObjectTypeReference, type ParameterObjectTypeReferenceModification, type ParameterObjectTypeReferenceOrEmpty, type ParameterObjectTypeReferenceOrEmptyModification, type ParameterObjectTypeReferenceOrEmptyModification_empty, type ParameterObjectTypeReferenceOrEmptyModification_objectTypeReference, type ParameterObjectTypeReferenceOrEmpty_empty, type ParameterObjectTypeReferenceOrEmpty_objectTypeReference, type ParameterPrefill, type ParameterPrefillModification, type ParameterPrefillModification_interfaceParameterPropertyValue, type ParameterPrefillModification_objectParameterPropertyValue, type ParameterPrefillModification_objectQueryPrefill, type ParameterPrefillModification_objectQueryPropertyValue, type ParameterPrefillModification_objectSetRidPrefill, type ParameterPrefillModification_redacted, type ParameterPrefillModification_staticObject, type ParameterPrefillModification_staticValue, type ParameterPrefillOverride, type ParameterPrefillOverrideModification, type ParameterPrefill_interfaceParameterPropertyValue, type ParameterPrefill_objectParameterPropertyValue, type ParameterPrefill_objectQueryPrefill, type ParameterPrefill_objectQueryPropertyValue, type ParameterPrefill_objectSetRidPrefill, type ParameterPrefill_redacted, type ParameterPrefill_staticObject, type ParameterPrefill_staticValue, type ParameterRange, type ParameterRangeModification, type ParameterRangeOrEmpty, type ParameterRangeOrEmptyModification, type ParameterRangeOrEmptyModification_empty, type ParameterRangeOrEmptyModification_range, type ParameterRangeOrEmpty_empty, type ParameterRangeOrEmpty_range, type ParameterRangeValue, type ParameterRangeValueModification, type ParameterRenderHint, type ParameterRequiredConfiguration, type ParameterRequiredOverride, type ParameterRid, type ParameterStructOrEmpty, type ParameterStructOrEmpty_delegateToAllowedStructFieldValues, type ParameterStructOrEmpty_empty, type ParameterTextRegex, type ParameterTimeSeriesReference, type ParameterTimeSeriesReferenceOrEmpty, type ParameterTimeSeriesReferenceOrEmpty_empty, type ParameterTimeSeriesReferenceOrEmpty_timeSeriesReference, type ParameterValidation, type ParameterValidationBlock, type ParameterValidationBlockModification, type ParameterValidationBlockOverride, type ParameterValidationBlockOverrideModification, type ParameterValidationBlockOverrideModification_allowedValues, type ParameterValidationBlockOverrideModification_parameterRequired, type ParameterValidationBlockOverrideModification_prefill, type ParameterValidationBlockOverrideModification_visibility, type ParameterValidationBlockOverride_allowedValues, type ParameterValidationBlockOverride_parameterRequired, type ParameterValidationBlockOverride_prefill, type ParameterValidationBlockOverride_visibility, type ParameterValidationDisplayMetadata, type ParameterValidationDisplayMetadataModification, type ParameterValidationModification, type ParameterValidationNotFoundError, type ParameterValidationReferencesLaterParametersError, type ParameterValueOneOf, type ParameterValueOneOfOrEmpty, type ParameterValueOneOfOrEmpty_empty, type ParameterValueOneOfOrEmpty_oneOf, type ParameterValueType, type ParameterValueTypeOrEmpty, type ParameterValueTypeOrEmpty_valueType, type ParametersDoNotMatchParameterOrderingError, type PartialObjectType, type PartialObjectTypeCreateRequest, type PartialObjectTypeDeleteRequest, type PartialObjectTypeModifyRequest, type PartialObjectTypeModifyRequest_create, type PartialObjectTypeModifyRequest_delete, type PartialObjectTypeModifyRequest_update, type PartialObjectTypeUpdateRequest, type PartialObjectTypeWithoutRids, type PatchBackupInitializationConfigurationSourceDoesNotExistError, type PatchesConfiguration, type PolicyVersion, type PrePostFix, type PrimaryKeyPropertySecurityGroupType, type PrincipalId, type ProjectEntityRid, type ProjectEntityRid_actionTypeRid, type ProjectEntityRid_interfaceTypeRid, type ProjectEntityRid_linkTypeRid, type ProjectEntityRid_objectTypeRid, type ProjectEntityRid_sharedPropertyTypeRid, type ProjectEntityRid_typeGroupRid, type PropertiesReferenceDuplicateColumnNameWrapper, type Property, type PropertyId, type PropertyPredicate, type PropertyPredicate_and, type PropertyPredicate_hasId, type PropertyPredicate_hasRid, type PropertyPredicate_not, type PropertyPredicate_or, type PropertyPropertySecurityGroupType, type PropertyRenderHint, type PropertyRid, type PropertySecurityGroup, type PropertySecurityGroupModification, type PropertySecurityGroupName, type PropertySecurityGroupRid, type PropertySecurityGroupType, type PropertySecurityGroupType_primaryKey, type PropertySecurityGroupType_property, type PropertySecurityGroups, type PropertySecurityGroupsModification, type PropertyType, type PropertyTypeDataConstraints, type PropertyTypeDataConstraintsWrapper, type PropertyTypeDataConstraints_array, type PropertyTypeDataConstraints_boolean, type PropertyTypeDataConstraints_date, type PropertyTypeDataConstraints_decimal, type PropertyTypeDataConstraints_double, type PropertyTypeDataConstraints_float, type PropertyTypeDataConstraints_integer, type PropertyTypeDataConstraints_long, type PropertyTypeDataConstraints_short, type PropertyTypeDataConstraints_string, type PropertyTypeDataConstraints_struct, type PropertyTypeDataConstraints_timestamp, type PropertyTypeDataValue, type PropertyTypeDataValue_array, type PropertyTypeDataValue_boolean, type PropertyTypeDataValue_byte, type PropertyTypeDataValue_date, type PropertyTypeDataValue_decimal, type PropertyTypeDataValue_double, type PropertyTypeDataValue_float, type PropertyTypeDataValue_integer, type PropertyTypeDataValue_long, type PropertyTypeDataValue_short, type PropertyTypeDataValue_string, type PropertyTypeDataValue_timestamp, type PropertyTypeDisplayMetadata, type PropertyTypeId, type PropertyTypeIdentifier, type PropertyTypeIdentifier_id, type PropertyTypeIdentifier_rid, type PropertyTypeLocator, type PropertyTypeMappingInfo, type PropertyTypeMappingInfo_column, type PropertyTypeMappingInfo_editOnly, type PropertyTypeMappingInfo_struct, type PropertyTypeReference, type PropertyTypeReferenceOrNonNumericInternalInterpolation, type PropertyTypeReferenceOrNonNumericInternalInterpolation_internalInterpolation, type PropertyTypeReferenceOrNonNumericInternalInterpolation_propertyType, type PropertyTypeReferenceOrNumericInternalInterpolation, type PropertyTypeReferenceOrNumericInternalInterpolation_internalInterpolation, type PropertyTypeReferenceOrNumericInternalInterpolation_propertyType, type PropertyTypeReferenceOrStringConstant, type PropertyTypeReferenceOrStringConstant_constant, type PropertyTypeReferenceOrStringConstant_propertyType, type PropertyTypeReference_baseType, type PropertyTypeRid, type PropertyTypeStatus, type PropertyTypeStatus_active, type PropertyTypeStatus_deprecated, type PropertyTypeStatus_example, type PropertyTypeStatus_experimental, type PropertyWithoutRid, type PutActionTypeRequest, type PutParameterRequest, type PutParameterRequestModification, type PutSectionRequest, type PutSectionRequestModification, type QualifiedSeriesIdPropertyValue, type QuiverDashboardReference, type QuiverDashboardRid, type QuiverDashboardVersion, type RangeSizeConstraint$1 as RangeSizeConstraint, type Redacted, type RedactionOverrideOptions, type RedactionOverrideOptions_everyoneTrusted, type ReferencedLinkTypesInWorkflowNotFoundError, type ReferencedLinkTypesNotFoundError, type ReferencedObjectTypesChange, type ReferencedObjectTypesInWorkflowNotFoundError, type ReferencedObjectTypesNotFoundError, type RegexCondition, type RegexConditionModification, type RegexConstraint$1 as RegexConstraint, type RelationCardinality, type RelationDisplayMetadata, type RelationId, type RelationRid, type RelativeDateRangeTense, type RelativeDateRangeValue, type RenderingSettings, type RenderingSettings_allNotificationRenderingMustSucceed, type RenderingSettings_anyNotificationRenderingCanFail, type RestrictedViewName, type RestrictedViewRid, type RestrictedViewTransactionRid, type RetentionPolicy, type RetentionPolicy_none, type RetentionPolicy_time, type RidFormatter, type RidFormatter_allFoundryRids, type RidFormatter_objectsPlatformRids, type RidUrlTarget, type RidUrlTargetModification, type RoleId, type RoleSetId, type RuleSetBinding, type RuleSetError, type RuleSetError_ruleSetsAlreadyExist, type RuleSetError_ruleSetsNotFound, type RuleSetRid, type RuleSetsAlreadyExistError, type RuleSetsNotFoundError, type SafeArg, type SafeDatasourceIdentifier, type SafeDatasourceIdentifier_datasetRid, type SafeDatasourceIdentifier_derivedPropertiesSourceRid, type SafeDatasourceIdentifier_directSourceRid, type SafeDatasourceIdentifier_editsOnly, type SafeDatasourceIdentifier_geotimeSeriesIntegrationRid, type SafeDatasourceIdentifier_mediaSetView, type SafeDatasourceIdentifier_mediaSourceRids, type SafeDatasourceIdentifier_restrictedStream, type SafeDatasourceIdentifier_restrictedViewRid, type SafeDatasourceIdentifier_streamLocatorRid, type SafeDatasourceIdentifier_tableRid, type SafeDatasourceIdentifier_timeSeriesSyncRid, type SchemaConfiguration, type SchemaMigrationBlockData, type SchemaMigrationRid, type SchemaTransitionsWithSchemaVersion, type SchemaVersion, type Section, type SectionConditionalOverride, type SectionConditionalOverrideModification, type SectionContent, type SectionContent_parameterId, type SectionDisplayBlock, type SectionDisplayBlockModification, type SectionDisplayBlockOverride, type SectionDisplayBlockOverride_visibility, type SectionDisplayMetadata, type SectionId, type SectionRid, type SectionStyle, type SectionStyle_box, type SectionStyle_minimal, type SectionValidationDisplayMetadata, type SectionVisibilityOverride, type SecurityGroupAndCondition, type SecurityGroupAndConditionModification, type SecurityGroupComparisonCondition, type SecurityGroupComparisonConditionModification, type SecurityGroupComparisonConstant, type SecurityGroupComparisonConstant_boolean, type SecurityGroupComparisonConstant_string, type SecurityGroupComparisonConstant_strings, type SecurityGroupComparisonOperator, type SecurityGroupComparisonUserProperty, type SecurityGroupComparisonUserProperty_groupIds, type SecurityGroupComparisonUserProperty_groupNames, type SecurityGroupComparisonUserProperty_userAttributes, type SecurityGroupComparisonUserProperty_userId, type SecurityGroupComparisonUserProperty_username, type SecurityGroupComparisonValue, type SecurityGroupComparisonValueModification, type SecurityGroupComparisonValueModification_constant, type SecurityGroupComparisonValueModification_property, type SecurityGroupComparisonValueModification_userProperty, type SecurityGroupComparisonValue_constant, type SecurityGroupComparisonValue_property, type SecurityGroupComparisonValue_userProperty, type SecurityGroupGranularCondition, type SecurityGroupGranularConditionModification, type SecurityGroupGranularConditionModification_and, type SecurityGroupGranularConditionModification_comparison, type SecurityGroupGranularConditionModification_markings, type SecurityGroupGranularConditionModification_not, type SecurityGroupGranularConditionModification_or, type SecurityGroupGranularConditionModification_true, type SecurityGroupGranularCondition_and, type SecurityGroupGranularCondition_comparison, type SecurityGroupGranularCondition_markings, type SecurityGroupGranularCondition_not, type SecurityGroupGranularCondition_or, type SecurityGroupGranularCondition_true, type SecurityGroupGranularPolicy, type SecurityGroupGranularPolicyModification, type SecurityGroupGranularSecurityDefinition, type SecurityGroupGranularSecurityDefinitionModification, type SecurityGroupGroupIdsUserProperty, type SecurityGroupGroupNamesUserProperty, type SecurityGroupMandatoryOnlySecurityDefinition, type SecurityGroupMandatoryOnlySecurityDefinitionModification, type SecurityGroupMandatoryPolicy, type SecurityGroupMarkingsCondition, type SecurityGroupMarkingsConditionModification, type SecurityGroupNotCondition, type SecurityGroupNotConditionModification, type SecurityGroupOrCondition, type SecurityGroupOrConditionModification, type SecurityGroupSecurityDefinition, type SecurityGroupSecurityDefinitionModification, type SecurityGroupSecurityDefinitionModification_granular, type SecurityGroupSecurityDefinitionModification_mandatoryOnly, type SecurityGroupSecurityDefinition_granular, type SecurityGroupSecurityDefinition_mandatoryOnly, type SecurityGroupTrueCondition, type SecurityGroupTrueConditionModification, type SecurityGroupUserAttributesUserProperty, type SecurityGroupUserIdUserProperty, type SecurityGroupUsernameUserProperty, type SemanticFunctionVersion, type SensorTrait, type SeriesIdPropertyValue, type SeriesValueMetadata, type SeriesValueMetadata_enum, type SeriesValueMetadata_numeric, type SeriesValueMetadata_numericOrNonNumeric, type SeriesValueMetadata_numericOrNonNumericV2, type SharedPropertiesSummary, type SharedPropertyType, type SharedPropertyTypeBlockDataV2, type SharedPropertyTypeCreatedEvent, type SharedPropertyTypeDeletedEvent, type SharedPropertyTypeDisplayMetadata, type SharedPropertyTypeError, type SharedPropertyTypeError_sharedPropertyTypesAlreadyExist, type SharedPropertyTypeError_sharedPropertyTypesNotFound, type SharedPropertyTypeGothamMapping, type SharedPropertyTypeIdInRequest, type SharedPropertyTypeLoadRequest, type SharedPropertyTypeLoadResponse, type SharedPropertyTypeLogicRuleValueModification, type SharedPropertyTypeRid, type SharedPropertyTypeRidOrIdInRequest, type SharedPropertyTypeRidOrIdInRequest_idInRequest, type SharedPropertyTypeRidOrIdInRequest_rid, type SharedPropertyTypeSoftLinkType, type SharedPropertyTypeStructFieldLogicRuleValueModification, type SharedPropertyTypeUpdatedEvent, type SharedPropertyTypesAlreadyExistError, type SharedPropertyTypesNotFoundError, type ShortBody, type ShortBodyModification, type ShortBodyModification_basic, type ShortBody_basic, type ShortPropertyType, type ShortTypeDataConstraints$1 as ShortTypeDataConstraints, type ShortTypeDataConstraints_oneOf$1 as ShortTypeDataConstraints_oneOf, type ShortTypeDataConstraints_range$1 as ShortTypeDataConstraints_range, type ShortTypeDataValue$1 as ShortTypeDataValue, type ShortTypeRangeConstraint$1 as ShortTypeRangeConstraint, type SimpleAnalyzer, type SingleKeyJoinDefinition, type SoftLink, type SoftLinkType, type SoftLinkType_sharedPropertyType, type StandardAnalyzer, type StaticObjectPrefill, type StaticValue, type StaticWebhookWithDirectInput, type StaticWebhookWithDirectInputModification, type StaticWebhookWithFunctionResultInput, type StaticWebhookWithFunctionResultInputModification, type StreamLocator, type StreamLocatorRid, type StreamName, type StreamViewRid, type StringFormatter, type StringPropertyType, type StringTypeDataConstraints$1 as StringTypeDataConstraints, type StringTypeDataConstraints_isRid$1 as StringTypeDataConstraints_isRid, type StringTypeDataConstraints_isUuid$1 as StringTypeDataConstraints_isUuid, type StringTypeDataConstraints_length$1 as StringTypeDataConstraints_length, type StringTypeDataConstraints_oneOf$1 as StringTypeDataConstraints_oneOf, type StringTypeDataConstraints_regex$1 as StringTypeDataConstraints_regex, type StringTypeDataValue$1 as StringTypeDataValue, type StringTypeIsRidConstraint$1 as StringTypeIsRidConstraint, type StringTypeIsUuidConstraint$1 as StringTypeIsUuidConstraint, type StringTypeLengthConstraint$1 as StringTypeLengthConstraint, type StructFieldAlias, type StructFieldApiNameMapping, type StructFieldApiNameOrRid, type StructFieldApiNameOrRid_apiName, type StructFieldApiNameOrRid_rid, type StructFieldConditionalOverride, type StructFieldConditionalOverrideModification, type StructFieldConditionalValidationBlock, type StructFieldConditionalValidationBlockModification, type StructFieldDisplayMetadata, type StructFieldLogicRuleValue, type StructFieldLogicRuleValueMappingModification, type StructFieldLogicRuleValueModification, type StructFieldLogicRuleValueModification_structListParameterFieldValue, type StructFieldLogicRuleValueModification_structParameterFieldValue, type StructFieldLogicRuleValue_structListParameterFieldValue, type StructFieldLogicRuleValue_structParameterFieldValue, type StructFieldName, type StructFieldPrefill, type StructFieldPrefillModification, type StructFieldPrefillModification_objectParameterStructFieldValue, type StructFieldPrefillModification_objectParameterStructListFieldValue, type StructFieldPrefillOverride, type StructFieldPrefillOverrideModification, type StructFieldPrefill_objectParameterStructFieldValue, type StructFieldPrefill_objectParameterStructListFieldValue, type StructFieldRid, type StructFieldType, type StructFieldValidation, type StructFieldValidationBlock, type StructFieldValidationBlockModification, type StructFieldValidationBlockOverride, type StructFieldValidationBlockOverrideModification, type StructFieldValidationBlockOverrideModification_allowedValues, type StructFieldValidationBlockOverrideModification_parameterRequired, type StructFieldValidationBlockOverrideModification_prefill, type StructFieldValidationBlockOverrideModification_visibility, type StructFieldValidationBlockOverride_allowedValues, type StructFieldValidationBlockOverride_parameterRequired, type StructFieldValidationBlockOverride_prefill, type StructFieldValidationBlockOverride_visibility, type StructFieldValidationDisplayMetadata, type StructFieldValidationDisplayMetadataModification, type StructFieldValidationModification, type StructListParameterFieldValue, type StructParameterFieldDisplayMetadata, type StructParameterFieldDisplayMetadataV2, type StructParameterFieldValue, type StructPropertyFieldType, type StructPropertyFieldType_boolean, type StructPropertyFieldType_date, type StructPropertyFieldType_double, type StructPropertyFieldType_geohash, type StructPropertyFieldType_integer, type StructPropertyFieldType_long, type StructPropertyFieldType_string, type StructPropertyFieldType_timestamp, type StructPropertyType, type StructTypeDataConstraints$1 as StructTypeDataConstraints, type StructTypeElementsConstraint$1 as StructTypeElementsConstraint, type StructuredShortBody, type StructuredShortBodyModification, type SubmitAllValidOrNothingThrowingMode, type SubmitValidEntriesInOrderUntilFirstFailureMode, type SynchronousPreWritebackWebhook, type SynchronousPreWritebackWebhookModification, type SynchronousPreWritebackWebhookModification_staticDirectInput, type SynchronousPreWritebackWebhookModification_staticFunctionInput, type SynchronousPreWritebackWebhook_staticDirectInput, type SynchronousPreWritebackWebhook_staticFunctionInput, type TableDisplayAndFormat, type TableLocator, type TableRid, type TemplateNotificationBody, type TemplateNotificationBodyModification, type TemplateRidPropertyValue, type TextEmbeddingModel, type TextEmbeddingModel_foundryLiveDeployment, type TextEmbeddingModel_lms, type TimeBasedRetentionPolicy, type TimeCodeFormat, type TimeDependentFormatter, type TimeDependentNonNumericSeriesFormat, type TimeDependentNumericOrNonNumericSeriesFormat, type TimeDependentNumericOrNonNumericSeriesFormatV2, type TimeDependentNumericSeriesFormat, type TimeDependentSeriesFormat, type TimeDependentSeriesFormat_nonNumeric, type TimeDependentSeriesFormat_numeric, type TimeDependentSeriesFormat_numericOrNonNumeric, type TimeDependentSeriesFormat_numericOrNonNumericV2, type TimeSeriesMetadata, type TimeSeriesSyncName, type TimeSeriesSyncRid, type TimeSeriesSyncViewRid, type TimestampFormatter, type TimestampPropertyType, type TimestampTypeDataConstraints$1 as TimestampTypeDataConstraints, type TimestampTypeDataValue$1 as TimestampTypeDataValue, type TimestampTypeRangeConstraint$1 as TimestampTypeRangeConstraint, type TrueCondition, type Type, type TypeClass, type TypeClassEntityIdentifier, type TypeClassEntityIdentifier_actionTypeRid, type TypeClassEntityIdentifier_linkTypeRid, type TypeClassEntityIdentifier_objectTypeRid, type TypeClassEntityIdentifier_sharedPropertyTypeRid, type TypeGroup, type TypeGroupDisplayMetadata, type TypeGroupError, type TypeGroupError_typeGroupsAlreadyExist, type TypeGroupError_typeGroupsNotFound, type TypeGroupGetOrganizationsRequest, type TypeGroupGetOrganizationsResponse, type TypeGroupIconColors, type TypeGroupIdInRequest, type TypeGroupLoadRequest, type TypeGroupLoadResponse, type TypeGroupRid, type TypeGroupRidOrIdInRequest, type TypeGroupRidOrIdInRequest_idInRequest, type TypeGroupRidOrIdInRequest_rid, type TypeGroupSetOrganizationsRequest, type TypeGroupsAlreadyExistError, type TypeGroupsNotFoundError, type TypeGroupsSummary, type Type_array, type Type_attachment, type Type_boolean, type Type_byte, type Type_cipherText, type Type_date, type Type_decimal, type Type_double, type Type_experimentalTimeDependentV1, type Type_float, type Type_geohash, type Type_geoshape, type Type_geotimeSeriesReference, type Type_integer, type Type_long, type Type_marking, type Type_mediaReference, type Type_short, type Type_string, type Type_struct, type Type_timestamp, type Type_vector, type UniqueIdentifier, type UnresolvedOntologySparkInputProperties, type UnrestrictedParameterInterfacePropertyValue, type UnsafeArg, type UrlTarget, type UrlTargetModification, type UrlTargetModification_carbonWorkspace, type UrlTargetModification_logicRuleValue, type UrlTargetModification_newObject, type UrlTargetModification_relativeUrlString, type UrlTargetModification_rid, type UrlTarget_carbonWorkspace, type UrlTarget_logicRuleValue, type UrlTarget_newObject, type UrlTarget_relativeUrlString, type UrlTarget_rid, type UseCaseRid, type UserAttributes, type UserId, type UserOrGroupId, type UserOrGroupId_groupId, type UserOrGroupId_userId, type UserProperty, type UserPropertyId, type UserPropertyId_currentUser, type UserPropertyValue, type UserPropertyValue_groupIds, type UserPropertyValue_groupNames, type UserPropertyValue_organizationMarkingIds, type UserPropertyValue_userAttributes, type UserPropertyValue_userId, type UserPropertyValue_userName, type UserTimezone, type UserValue, type ValidationRule, type ValidationRuleDisplayMetadata, type ValidationRuleIdInRequest, type ValidationRuleIdentifier, type ValidationRuleIdentifier_rid, type ValidationRuleIdentifier_validationRuleIdInRequest, type ValidationRuleIndex, type ValidationRuleModification, type ValidationRuleRid, type ValueReferenceId, type ValueReferenceSource, type ValueReferenceSource_propertyTypeRid, type ValueType, type ValueTypeApiName, type ValueTypeApiNameReference, type ValueTypeDataConstraint, type ValueTypeDisplayMetadata, type ValueTypeIdInRequest, type ValueTypeInputManagerRid, type ValueTypeLabel, type ValueTypeReference$1 as ValueTypeReference, type ValueTypeRid$1 as ValueTypeRid, type ValueTypeStatus, type ValueTypeVersion, type ValueTypeVersionId$1 as ValueTypeVersionId, type VectorPropertyType, type VectorSimilarityFunction, type VersionReference, type VersionReference_ontologyBranch, type VersionReference_ontologyVersion, type VersionedActionTypeRid, type VersionedActionTypesNotFoundError, type VersionedLinkTypeRid, type VersionedObjectTypeRid, type Visibility, type VisibilityOverride, type WebhookInputParamName, type WebhookOutputParamName, type WebhookRid, type WebhookVersion, type WhitespaceAnalyzer, type WorkflowError, type WorkflowError_deletedLinkTypesStillInUseInWorkflow, type WorkflowError_deletedObjectTypesStillInUseInWorkflow, type WorkflowError_referencedLinkTypesInWorkflowNotFound, type WorkflowError_referencedObjectTypesInWorkflowNotFound, type WorkflowError_workflowsAlreadyExist, type WorkflowError_workflowsNotFound, type WorkflowObjectTypeTrait, type WorkflowObjectTypeTraitDescription, type WorkflowObjectTypeTraitDisplayName, type WorkflowObjectTypeTraitId, type WorkflowObjectTypeTraitImpl, type WorkflowObjectTypeTraitProperty, type WorkflowObjectTypeTraitPropertyDescription, type WorkflowObjectTypeTraitPropertyDisplayName, type WorkflowObjectTypeTraitPropertyId, type WorkflowObjectTypeTraitReference, type WorkflowObjectTypeTraitVersion, type WorkflowsAlreadyExistError, type WorkflowsNotFoundError, type WorkshopModuleRid, type WorkshopReference, type WritebackDatasetRid, type WritebackDatasetSpec, bulkLoadOntologyEntities, createTemporaryObjectSet, getBulkLinksPage, getLinkTypesForObjectTypes, loadAllOntologies };
