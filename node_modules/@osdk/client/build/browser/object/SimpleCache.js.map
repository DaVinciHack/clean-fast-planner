{"version":3,"file":"SimpleCache.js","names":["createSimpleCache","map","Map","fn","set","key","value","get","r","undefined","remove","delete","createSimpleAsyncCache","type","createCacheLocal","cache","WeakMap","inProgress","ret","getOrUndefined","k","v","e"],"sources":["SimpleCache.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A simple cache that can be used to store values for a given client.\n */\n\nexport interface SimpleCache<K, V> {\n  get: (key: K) => V;\n  set: <X extends V>(key: K, value: X) => X;\n  remove: (key: K) => boolean;\n}\n/**\n * Create a new cache with a factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n */\n\nexport function createSimpleCache<K, V>(\n  map: Map<K, V> | (K extends object ? WeakMap<K, V> : never),\n  fn: (k: K) => V,\n): SimpleCache<K, V>;\n/**\n * Create a new cache without a factory function.\n */\nexport function createSimpleCache<K, V>(\n  map?: Map<K, V> | (K extends object ? WeakMap<K, V> : never),\n): SimpleCache<\n  K,\n  V | undefined\n>;\nexport function createSimpleCache<K, V>(\n  map: Map<K, V> | (K extends object ? WeakMap<K, V> : never) =\n    new Map() as any,\n  fn?: undefined | ((k: K) => V),\n): typeof fn extends undefined ? SimpleCache<K, V | undefined>\n  : SimpleCache<K, V>\n{\n  function get(key: K) {\n    let r = (map as Map<K, V>).get(key as any);\n    if (r === undefined && fn !== undefined) {\n      return set(key, fn(key));\n    } else {\n      return r;\n    }\n  }\n\n  function set(key: K, value: V) {\n    map.set(key as any, value);\n    return value;\n  }\n\n  function remove(key: K) {\n    return map.delete(key as any);\n  }\n\n  return { get, set, remove } as SimpleCache<K, V>;\n}\n/**\n * A simple async cache that can be used to store values for a given client.\n */\n\nexport interface WeakAsyncCache<K, V> {\n  getOrUndefined: (key: K) => V | undefined;\n\n  get: (key: K) => Promise<V>;\n\n  /**\n   * @param client the client to key from\n   * @param key the sub-key to use\n   * @param value the value or a promise to the value\n   * @returns a new promise to the resolved value\n   */\n  set: (\n    key: K,\n    value: V | Promise<V>,\n  ) => Promise<V>;\n}\n/**\n * Create a new cache with an async factory function.\n * @param fn A factory function that will be used to create the value if it does not exist in the cache.\n * @returns\n */\n\nexport function createSimpleAsyncCache<K, V>(\n  type: \"weak\" | \"strong\",\n  fn: (key: K) => Promise<V>,\n  createCacheLocal: typeof createSimpleCache = createSimpleCache,\n): WeakAsyncCache<K, V> {\n  const cache = createCacheLocal<K, V>(\n    (type === \"weak\" ? new WeakMap() : new Map()) as Map<K, V>,\n  );\n  const inProgress = createCacheLocal<K, Promise<V> | V>(\n    (type === \"weak\" ? new WeakMap() : new Map()) as Map<K, V>,\n  );\n\n  const ret = {\n    getOrUndefined: function getOrUndefined(key: K) {\n      return cache.get(key);\n    },\n\n    get: async function get(key: K) {\n      return cache.get(key) ?? inProgress.get(key)\n        ?? ret.set(key, fn(key));\n    },\n\n    set: async function set(k: K, v: V | Promise<V>) {\n      // the `.set` happens first to prevent races.\n      try {\n        const r = await inProgress.set(k, v); // returns v\n\n        cache.set(k, r);\n        inProgress.remove(k);\n        return r;\n      } catch (e) {\n        // we don't want to cache failures\n        inProgress.remove(k);\n        throw e;\n      }\n    },\n  };\n\n  return ret;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAOA;AACA;AACA;AACA;;AAMA;AACA;AACA;;AAOA,OAAO,SAASA,iBAAiBA,CAC/BC,GAA2D,GACzD,IAAIC,GAAG,CAAC,CAAQ,EAClBC,EAA8B,EAGhC;EAUE,SAASC,GAAGA,CAACC,GAAM,EAAEC,KAAQ,EAAE;IAC7BL,GAAG,CAACG,GAAG,CAACC,GAAG,EAASC,KAAK,CAAC;IAC1B,OAAOA,KAAK;EACd;EAMA,OAAO;IAAEC,GAAG,EAlBZ,SAAAA,CAAaF,GAAM,EAAE;MACnB,IAAIG,CAAC,GAAIP,GAAG,CAAeM,GAAG,CAACF,GAAU,CAAC;MAC1C,IAAIG,CAAC,KAAKC,SAAS,IAAIN,EAAE,KAAKM,SAAS,EAAE;QACvC,OAAOL,GAAG,CAACC,GAAG,EAAEF,EAAE,CAACE,GAAG,CAAC,CAAC;MAC1B,CAAC,MAAM;QACL,OAAOG,CAAC;MACV;IACF,CAWY;IAAEJ,GAAG;IAAEM,MAAM,EAJzB,SAAAA,CAAgBL,GAAM,EAAE;MACtB,OAAOJ,GAAG,CAACU,MAAM,CAACN,GAAU,CAAC;IAC/B;EAE0B,CAAC;AAC7B;AACA;AACA;AACA;;AAkBA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASO,sBAAsBA,CACpCC,IAAuB,EACvBV,EAA0B,EAC1BW,gBAA0C,GAAGd,iBAAiB,EACxC;EACtB,MAAMe,KAAK,GAAGD,gBAAgB,CAC3BD,IAAI,KAAK,MAAM,GAAG,IAAIG,OAAO,CAAC,CAAC,GAAG,IAAId,GAAG,CAAC,CAC7C,CAAC;EACD,MAAMe,UAAU,GAAGH,gBAAgB,CAChCD,IAAI,KAAK,MAAM,GAAG,IAAIG,OAAO,CAAC,CAAC,GAAG,IAAId,GAAG,CAAC,CAC7C,CAAC;EAED,MAAMgB,GAAG,GAAG;IACVC,cAAc,EAAE,SAAAA,CAAwBd,GAAM,EAAE;MAC9C,OAAOU,KAAK,CAACR,GAAG,CAACF,GAAG,CAAC;IACvB,CAAC;IAEDE,GAAG,EAAE,eAAAA,CAAmBF,GAAM,EAAE;MAC9B,OAAOU,KAAK,CAACR,GAAG,CAACF,GAAG,CAAC,IAAIY,UAAU,CAACV,GAAG,CAACF,GAAG,CAAC,IACvCa,GAAG,CAACd,GAAG,CAACC,GAAG,EAAEF,EAAE,CAACE,GAAG,CAAC,CAAC;IAC5B,CAAC;IAEDD,GAAG,EAAE,eAAAA,CAAmBgB,CAAI,EAAEC,CAAiB,EAAE;MAC/C;MACA,IAAI;QACF,MAAMb,CAAC,GAAG,MAAMS,UAAU,CAACb,GAAG,CAACgB,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC;;QAEtCN,KAAK,CAACX,GAAG,CAACgB,CAAC,EAAEZ,CAAC,CAAC;QACfS,UAAU,CAACP,MAAM,CAACU,CAAC,CAAC;QACpB,OAAOZ,CAAC;MACV,CAAC,CAAC,OAAOc,CAAC,EAAE;QACV;QACAL,UAAU,CAACP,MAAM,CAACU,CAAC,CAAC;QACpB,MAAME,CAAC;MACT;IACF;EACF,CAAC;EAED,OAAOJ,GAAG;AACZ","ignoreList":[]}