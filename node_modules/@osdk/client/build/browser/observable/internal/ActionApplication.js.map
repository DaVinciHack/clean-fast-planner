{"version":3,"file":"ActionApplication.js","names":["delay","runOptimisticJob","ACTION_DELAY","process","env","NODE_ENV","ActionApplication","constructor","store","applyAction","action","args","optimisticUpdate","logger","child","methodName","removeOptimisticResult","Array","isArray","debug","results","client","batchApplyAction","$returnEdits","invalidateActionEditResponse","actionResults","#invalidateActionEditResponse","deletedObjects","modifiedObjects","addedObjects","editedObjectTypes","type","changes","promisesToWait","list","obj","push","invalidateObject","objectType","primaryKey","batch","cacheKey","getCacheKey","peekQuery","deleteFromStore","Promise","all","apiName","invalidateObjectType"],"sources":["ActionApplication.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  ActionEditResponse,\n  ActionReturnTypeForOptions,\n} from \"@osdk/api\";\nimport delay from \"delay\";\nimport type { ActionSignatureFromDef } from \"../../actions/applyAction.js\";\nimport { type Changes } from \"./Changes.js\";\nimport type { ObjectCacheKey } from \"./ObjectQuery.js\";\nimport { runOptimisticJob } from \"./OptimisticJob.js\";\nimport type { Store } from \"./Store.js\";\n\nconst ACTION_DELAY = process.env.NODE_ENV === \"production\" ? 0 : 1000;\n\nexport class ActionApplication {\n  constructor(private store: Store) {}\n\n  applyAction: <Q extends ActionDefinition<any>>(\n    action: Q,\n    args:\n      | Parameters<ActionSignatureFromDef<Q>[\"applyAction\"]>[0]\n      | Array<Parameters<ActionSignatureFromDef<Q>[\"applyAction\"]>[0]>,\n    opts?: Store.ApplyActionOptions,\n  ) => Promise<ActionEditResponse> = async (\n    action,\n    args,\n    { optimisticUpdate } = {},\n  ) => {\n    const logger = process.env.NODE_ENV !== \"production\"\n      ? this.store.logger?.child({ methodName: \"applyAction\" })\n      : this.store.logger;\n    const removeOptimisticResult = runOptimisticJob(\n      this.store,\n      optimisticUpdate,\n    );\n\n    return await (async () => {\n      try {\n        if (Array.isArray(args)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            logger?.debug(\"applying action to multiple args\", args);\n          }\n\n          const results: ActionReturnTypeForOptions<{ $returnEdits: true }> =\n            await this.store\n              .client(action).batchApplyAction(\n                args,\n                { $returnEdits: true },\n              );\n\n          await this.#invalidateActionEditResponse(results);\n\n          return results;\n        }\n\n        // The types for client get confused when we dynamically applyAction so we\n        // have to deal with the `any` here and force cast it to what it should be.\n        // TODO: Update the types so this doesn't happen!\n\n        const actionResults: ActionEditResponse = await this.store.client(\n          action,\n        ).applyAction(args as any, { $returnEdits: true });\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (ACTION_DELAY > 0) {\n            logger?.debug(\"action done, pausing\", actionResults);\n            await delay(ACTION_DELAY);\n            logger?.debug(\"action done, pausing done\");\n          }\n        }\n        await this.#invalidateActionEditResponse(actionResults);\n        return actionResults;\n      } finally {\n        if (process.env.NODE_ENV !== \"production\") {\n          logger?.debug(\n            \"optimistic action complete; remove the results\",\n          );\n        }\n        // make sure this happens even if the action fails\n        await removeOptimisticResult();\n      }\n    })();\n  };\n\n  #invalidateActionEditResponse = async (\n    { deletedObjects, modifiedObjects, addedObjects, editedObjectTypes, type }:\n      ActionEditResponse,\n  ): Promise<void> => {\n    let changes: Changes | undefined;\n    if (type === \"edits\") {\n      const promisesToWait: Promise<any>[] = [];\n\n      for (const list of [deletedObjects, modifiedObjects, addedObjects]) {\n        for (const obj of list ?? []) {\n          promisesToWait.push(\n            this.store.invalidateObject(obj.objectType, obj.primaryKey),\n          );\n        }\n      }\n\n      this.store.batch({}, (batch) => {\n        for (const { objectType, primaryKey } of deletedObjects ?? []) {\n          const cacheKey = this.store.getCacheKey<ObjectCacheKey>(\n            \"object\",\n            objectType,\n            primaryKey,\n          );\n          this.store.peekQuery(cacheKey)?.deleteFromStore(\n            \"loaded\", // this is probably not the best value to use\n            batch,\n          );\n        }\n      });\n      await Promise.all(promisesToWait);\n    } else {\n      for (const apiName of editedObjectTypes) {\n        await this.store.invalidateObjectType(apiName as string, changes);\n      }\n    }\n  };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA,OAAOA,KAAK,MAAM,OAAO;AAIzB,SAASC,gBAAgB,QAAQ,oBAAoB;AAGrD,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG,CAAC,GAAG,IAAI;AAErE,OAAO,MAAMC,iBAAiB,CAAC;EAC7BC,WAAWA,CAASC,KAAY,EAAE;IAAA,KAAdA,KAAY,GAAZA,KAAY;EAAG;EAEnCC,WAAW,GAMwB,MAAAA,CACjCC,MAAM,EACNC,IAAI,EACJ;IAAEC;EAAiB,CAAC,GAAG,CAAC,CAAC,KACtB;IACH,MAAMC,MAAM,GAAGV,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAChD,IAAI,CAACG,KAAK,CAACK,MAAM,EAAEC,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAc,CAAC,CAAC,GACvD,IAAI,CAACP,KAAK,CAACK,MAAM;IACrB,MAAMG,sBAAsB,GAAGf,gBAAgB,CAC7C,IAAI,CAACO,KAAK,EACVI,gBACF,CAAC;IAED,OAAO,MAAM,CAAC,YAAY;MACxB,IAAI;QACF,IAAIK,KAAK,CAACC,OAAO,CAACP,IAAI,CAAC,EAAE;UACvB,IAAIR,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;YACzCQ,MAAM,EAAEM,KAAK,CAAC,kCAAkC,EAAER,IAAI,CAAC;UACzD;UAEA,MAAMS,OAA2D,GAC/D,MAAM,IAAI,CAACZ,KAAK,CACba,MAAM,CAACX,MAAM,CAAC,CAACY,gBAAgB,CAC9BX,IAAI,EACJ;YAAEY,YAAY,EAAE;UAAK,CACvB,CAAC;UAEL,MAAM,IAAI,CAAC,CAACC,4BAA4B,CAACJ,OAAO,CAAC;UAEjD,OAAOA,OAAO;QAChB;;QAEA;QACA;QACA;;QAEA,MAAMK,aAAiC,GAAG,MAAM,IAAI,CAACjB,KAAK,CAACa,MAAM,CAC/DX,MACF,CAAC,CAACD,WAAW,CAACE,IAAI,EAAS;UAAEY,YAAY,EAAE;QAAK,CAAC,CAAC;QAElD,IAAIpB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzC,IAAIH,YAAY,GAAG,CAAC,EAAE;YACpBW,MAAM,EAAEM,KAAK,CAAC,sBAAsB,EAAEM,aAAa,CAAC;YACpD,MAAMzB,KAAK,CAACE,YAAY,CAAC;YACzBW,MAAM,EAAEM,KAAK,CAAC,2BAA2B,CAAC;UAC5C;QACF;QACA,MAAM,IAAI,CAAC,CAACK,4BAA4B,CAACC,aAAa,CAAC;QACvD,OAAOA,aAAa;MACtB,CAAC,SAAS;QACR,IAAItB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzCQ,MAAM,EAAEM,KAAK,CACX,gDACF,CAAC;QACH;QACA;QACA,MAAMH,sBAAsB,CAAC,CAAC;MAChC;IACF,CAAC,EAAE,CAAC;EACN,CAAC;EAED,CAACQ,4BAA4B,GAAG,MAAAE,CAC9B;IAAEC,cAAc;IAAEC,eAAe;IAAEC,YAAY;IAAEC,iBAAiB;IAAEC;EACjD,CAAC,KACF;IAClB,IAAIC,OAA4B;IAChC,IAAID,IAAI,KAAK,OAAO,EAAE;MACpB,MAAME,cAA8B,GAAG,EAAE;MAEzC,KAAK,MAAMC,IAAI,IAAI,CAACP,cAAc,EAAEC,eAAe,EAAEC,YAAY,CAAC,EAAE;QAClE,KAAK,MAAMM,GAAG,IAAID,IAAI,IAAI,EAAE,EAAE;UAC5BD,cAAc,CAACG,IAAI,CACjB,IAAI,CAAC5B,KAAK,CAAC6B,gBAAgB,CAACF,GAAG,CAACG,UAAU,EAAEH,GAAG,CAACI,UAAU,CAC5D,CAAC;QACH;MACF;MAEA,IAAI,CAAC/B,KAAK,CAACgC,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;QAC9B,KAAK,MAAM;UAAEF,UAAU;UAAEC;QAAW,CAAC,IAAIZ,cAAc,IAAI,EAAE,EAAE;UAC7D,MAAMc,QAAQ,GAAG,IAAI,CAACjC,KAAK,CAACkC,WAAW,CACrC,QAAQ,EACRJ,UAAU,EACVC,UACF,CAAC;UACD,IAAI,CAAC/B,KAAK,CAACmC,SAAS,CAACF,QAAQ,CAAC,EAAEG,eAAe,CAC7C,QAAQ;UAAE;UACVJ,KACF,CAAC;QACH;MACF,CAAC,CAAC;MACF,MAAMK,OAAO,CAACC,GAAG,CAACb,cAAc,CAAC;IACnC,CAAC,MAAM;MACL,KAAK,MAAMc,OAAO,IAAIjB,iBAAiB,EAAE;QACvC,MAAM,IAAI,CAACtB,KAAK,CAACwC,oBAAoB,CAACD,OAAO,EAAYf,OAAO,CAAC;MACnE;IACF;EACF,CAAC;AACH","ignoreList":[]}