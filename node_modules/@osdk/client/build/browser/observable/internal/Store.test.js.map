{"version":3,"file":"Store.test.js","names":["editTodo","Employee","FooInterface","Todo","FauxFoundry","ontologies","startNodeApiServer","stubData","TypeHelpers","chalk","invariant","afterAll","afterEach","beforeAll","beforeEach","describe","expect","it","vi","vitest","ActionValidationError","createClient","TestLogger","createOptimisticId","runOptimisticJob","invalidateList","Store","applyCustomMatchers","createClientMockHelper","createDefer","expectNoMoreCalls","expectSingleListCallAndClear","expectSingleObjectCallAndClear","getObject","mockListSubCallback","mockSingleSubCallback","objectPayloadContaining","updateList","updateObject","waitForCall","JOHN_DOE_ID","defer","logger","setConfig","fakeTimers","toFake","resetConfig","ANY_INIT_ENTRY","object","undefined","lastUpdated","status","fullTaskName","task","suite","name","x","console","log","bgRed","white","testStage","s","bgYellow","setupOntology","fauxFoundry","fauxOntology","getDefaultOntology","addEmployeeOntology","registerObjectType","todoWithLinkTypes","registerActionType","actionTypeV2","b","payload","id","other","parameters","modifyObject","apiName","setupSomeEmployees","dataStore","getDefaultDataStore","registerObject","employeeId","$apiName","fullName","client","cache","employeesAsServerReturns","mutatedEmployees","testSetup","fetchPage","data","$clone","slice","apiServer","close","emp","cacheKey","getCacheKey","$primaryKey","getValue","value","toBeUndefined","result","toBe","toEqual","updatedEmpFromCache","not","subFn","observeObject","mode","optimisticId","removeLayer","type","where","orderBy","empSubFn","listSubFn","observeList","optimisticEmployee","next","toHaveBeenCalled","isOptimistic","truthUpdatedEmployee","subListFn","batch","changes","deleteObject","delete","staleEmp","invalidateObject","useFakeTimers","useRealTimers","invalidateListPromise","pInvalidateComplete","invalidateObjectType","subFn1","subFn2","complete","mockClear","error","likeEmployee50030","objectContaining","toHaveBeenCalledExactlyOnceWith","firstLoad","mock","lastCall","toBeGreaterThan","sub","find","unsubscribe","toHaveBeenCalledTimes","calls","listSub1","ifaceSub","mocked","mockReset","runOnlyPendingTimers","$gt","listSub","pageSize","fetchMore","store","resetHandlers","a","expectLoadingAndLoaded","loading","loaded","clear","text","todoSubFn","applyAction","fauxObject","process","env","NODE_ENV","optimisticUpdate","ctx","rejects","toThrow","nextPk","fauxObjectA","fauxObjectB","fauxObjectC","Promise","all","map","fetchOne","noWhereNoOrderBy","noWhereOrderByText","subListUnordered","subListOrdered","optimisticallyMutatedA","pkForOptimistic","optimisticallyCreatedObjectD","removeOptimisticResult","createObject","actionDefinition","crazyAction","crazyActionTypeV2","actionTypeBuilder","addParameter","build","idForD","addObject","$title","pActionResult","modifiedObjectA","pkForD","addedObjects","primaryKey","createdObjectD","clientHelper","baseObjects","i","$objectType","cacheKeys","obj","layerIds","write"],"sources":["Store.test.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Osdk } from \"@osdk/api\";\nimport {\n  editTodo,\n  Employee,\n  FooInterface,\n  Todo,\n} from \"@osdk/client.test.ontology\";\nimport type { SetupServer } from \"@osdk/shared.test\";\nimport {\n  FauxFoundry,\n  ontologies,\n  startNodeApiServer,\n  stubData,\n  TypeHelpers,\n} from \"@osdk/shared.test\";\nimport chalk from \"chalk\";\nimport invariant from \"tiny-invariant\";\nimport type { Task } from \"vitest\";\nimport {\n  afterAll,\n  afterEach,\n  beforeAll,\n  beforeEach,\n  describe,\n  expect,\n  it,\n  vi,\n  vitest,\n} from \"vitest\";\nimport { ActionValidationError } from \"../../actions/ActionValidationError.js\";\nimport { type Client } from \"../../Client.js\";\nimport { createClient } from \"../../createClient.js\";\nimport { TestLogger } from \"../../logger/TestLogger.js\";\nimport type { ObjectHolder } from \"../../object/convertWireToOsdkObjects/ObjectHolder.js\";\nimport type {\n  ObserveListOptions,\n  Unsubscribable,\n} from \"../ObservableClient.js\";\nimport type { ObjectCacheKey } from \"./ObjectQuery.js\";\nimport { createOptimisticId } from \"./OptimisticId.js\";\nimport { runOptimisticJob } from \"./OptimisticJob.js\";\nimport { invalidateList, Store } from \"./Store.js\";\nimport {\n  applyCustomMatchers,\n  createClientMockHelper,\n  createDefer,\n  expectNoMoreCalls,\n  expectSingleListCallAndClear,\n  expectSingleObjectCallAndClear,\n  getObject,\n  mockListSubCallback,\n  mockSingleSubCallback,\n  objectPayloadContaining,\n  updateList,\n  updateObject,\n  waitForCall,\n} from \"./testUtils.js\";\n\nconst JOHN_DOE_ID = 50030;\n\nconst defer = createDefer();\n\nconst logger = new TestLogger();\n\nbeforeAll(() => {\n  vi.setConfig({\n    fakeTimers: {\n      toFake: [\n        \"setTimeout\",\n        \"clearTimeout\",\n        \"Date\",\n        \"setInterval\",\n        \"clearInterval\",\n      ],\n    },\n  });\n});\nafterAll(() => {\n  vi.resetConfig();\n});\n\nconst ANY_INIT_ENTRY = {\n  // cacheKey: expect.any(Object),\n  object: undefined,\n  lastUpdated: 0,\n  status: \"init\",\n};\n\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nfunction fullTaskName(task?: Task): string {\n  return task ? `${fullTaskName(task.suite)} > ${task.name}` : \"\";\n}\n\nbeforeEach((x) => {\n  console.log(\n    chalk.bgRed(chalk.white(fullTaskName(x.task))),\n  );\n});\n\n// helper method to make debugging tests easier\nfunction testStage(s: string) {\n  console.log(chalk.bgYellow(`Test Stage: ${s}`));\n}\n\napplyCustomMatchers();\n\nfunction setupOntology(fauxFoundry: FauxFoundry) {\n  const fauxOntology = fauxFoundry.getDefaultOntology();\n  ontologies.addEmployeeOntology(fauxOntology);\n\n  fauxFoundry.getDefaultOntology().registerObjectType(\n    stubData.todoWithLinkTypes,\n  );\n\n  fauxFoundry.getDefaultOntology().registerActionType(\n    stubData.editTodo.actionTypeV2,\n    (b, payload) => {\n      const { id, ...other } = payload.parameters;\n\n      b.modifyObject<Todo>(Todo.apiName, id, { ...other });\n    },\n  );\n}\n\nfunction setupSomeEmployees(fauxFoundry: FauxFoundry) {\n  const dataStore = fauxFoundry.getDefaultDataStore();\n\n  dataStore.registerObject(Employee, {\n    employeeId: 1,\n  });\n\n  dataStore.registerObject(Employee, {\n    employeeId: 2,\n  });\n\n  dataStore.registerObject(Employee, {\n    $apiName: \"Employee\",\n    employeeId: 3,\n  });\n\n  dataStore.registerObject(Employee, {\n    $apiName: \"Employee\",\n    employeeId: 4,\n  });\n\n  dataStore.registerObject(Employee, {\n    $apiName: \"Employee\",\n    employeeId: JOHN_DOE_ID,\n    fullName: \"John Doe\",\n  });\n}\n\ndescribe(Store, () => {\n  describe(\"with mock server\", () => {\n    let client: Client;\n    let cache: Store;\n\n    let employeesAsServerReturns: Osdk.Instance<Employee>[];\n    let mutatedEmployees: Osdk.Instance<Employee>[];\n\n    beforeAll(async () => {\n      const testSetup = startNodeApiServer(\n        new FauxFoundry(\"https://stack.palantir.com/\"),\n        createClient,\n        { logger },\n      );\n      ({ client } = testSetup);\n\n      setupOntology(testSetup.fauxFoundry);\n      setupSomeEmployees(testSetup.fauxFoundry);\n\n      employeesAsServerReturns = (await client(Employee).fetchPage()).data;\n      mutatedEmployees = [\n        employeesAsServerReturns[0],\n        employeesAsServerReturns[1].$clone({\n          fullName: \"foo\",\n        }),\n        ...employeesAsServerReturns.slice(2),\n      ];\n\n      return () => {\n        testSetup.apiServer.close();\n      };\n    });\n\n    beforeEach(() => {\n      cache = new Store(client);\n\n      return () => {\n        cache = undefined!;\n      };\n    });\n\n    it(\"basic single object works\", async () => {\n      const emp = employeesAsServerReturns[0];\n\n      const cacheKey = cache.getCacheKey<ObjectCacheKey>(\n        \"object\",\n        \"Employee\",\n        emp.$primaryKey,\n      );\n\n      // starts empty\n      expect(\n        cache.getValue(cacheKey)?.value,\n      ).toBeUndefined();\n\n      const result = updateObject(cache, emp);\n      expect(emp).toBe(result);\n\n      // getting the object now matches the result\n      expect(cache.getValue(cacheKey)?.value).toEqual(\n        result,\n      );\n\n      const updatedEmpFromCache = updateObject(\n        cache,\n        emp.$clone({ fullName: \"new name\" }),\n      );\n      expect(updatedEmpFromCache).not.toBe(emp);\n\n      // getting it again is the updated object\n      expect(cache.getValue(cacheKey)?.value).toEqual(\n        updatedEmpFromCache,\n      );\n    });\n\n    describe(\"optimistic updates\", () => {\n      it(\"rolls back objects\", async () => {\n        const emp = employeesAsServerReturns[0];\n        updateObject(cache, emp); // pre-seed the cache with the \"real\" value\n\n        const subFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n\n        const optimisticId = createOptimisticId();\n        // update with an optimistic write\n        updateObject(cache, emp.$clone({ fullName: \"new name\" }), {\n          optimisticId,\n        });\n        expectSingleObjectCallAndClear(\n          subFn,\n          emp.$clone({ fullName: \"new name\" }),\n          \"loaded\",\n        );\n\n        // remove the optimistic write\n        cache.removeLayer(optimisticId);\n\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n      });\n\n      it(\"rolls back to an updated real value\", async () => {\n        // pre-seed the cache with the \"real\" value\n        updateList(cache, {\n          type: Employee,\n          where: {},\n          orderBy: {},\n        }, employeesAsServerReturns);\n\n        const emp = employeesAsServerReturns[0];\n\n        const empSubFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            empSubFn,\n          ),\n        );\n\n        expectSingleObjectCallAndClear(empSubFn, emp, \"loaded\");\n\n        const listSubFn = mockListSubCallback();\n        defer(\n          cache.observeList({\n            type: Employee,\n            mode: \"offline\",\n          }, listSubFn),\n        );\n\n        await waitForCall(listSubFn, 1);\n        expectSingleListCallAndClear(listSubFn, employeesAsServerReturns);\n\n        const optimisticEmployee = emp.$clone({ fullName: \"new name\" });\n\n        const optimisticId = createOptimisticId();\n\n        testStage(\"optimistic update\");\n        expect(listSubFn.next).not.toHaveBeenCalled();\n\n        // update with an optimistic write\n        updateObject(cache, optimisticEmployee, {\n          optimisticId,\n        });\n\n        testStage(\"after optimistic update\");\n\n        // expect optimistic write\n        expectSingleObjectCallAndClear(empSubFn, optimisticEmployee);\n\n        // expect optimistic write to the list\n        await waitForCall(listSubFn, 1);\n        expectSingleListCallAndClear(\n          listSubFn,\n          [\n            optimisticEmployee,\n            ...employeesAsServerReturns.slice(1),\n          ],\n          {\n            isOptimistic: true,\n            status: \"loading\",\n          },\n        );\n\n        // write the real update, via the earlier list definition\n        const truthUpdatedEmployee = emp.$clone({\n          fullName: \"real update\",\n        });\n\n        testStage(\"write real update\");\n\n        updateList(cache, { type: Employee, where: {}, orderBy: {} }, [\n          truthUpdatedEmployee,\n        ]);\n\n        // remove the optimistic write\n        cache.removeLayer(optimisticId);\n\n        // see the object observation get updated\n        expectSingleObjectCallAndClear(\n          empSubFn,\n          truthUpdatedEmployee,\n          \"loaded\",\n        );\n\n        // see the list get updated\n        await waitForCall(listSubFn, 1);\n        expectSingleListCallAndClear(listSubFn, [truthUpdatedEmployee], {\n          status: \"loaded\",\n          isOptimistic: false,\n        });\n      });\n\n      it(\"rolls back to an updated real value via list\", async () => {\n        const emp = employeesAsServerReturns[0];\n        updateObject(cache, emp); // pre-seed the cache with the \"real\" value\n\n        const subFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n\n        const optimisticEmployee = emp.$clone({ fullName: \"new name\" });\n\n        // update with an optimistic write\n        const optimisticId = createOptimisticId();\n        updateObject(cache, optimisticEmployee, {\n          optimisticId,\n        });\n        expectSingleObjectCallAndClear(subFn, optimisticEmployee);\n\n        const truthUpdatedEmployee = emp.$clone({\n          fullName: \"real update\",\n        });\n        updateObject(cache, truthUpdatedEmployee);\n\n        // we shouldn't expect an update because the top layer has a value\n        expect(subFn.next).not.toHaveBeenCalled();\n\n        // remove the optimistic write\n        cache.removeLayer(optimisticId);\n\n        expectSingleObjectCallAndClear(subFn, truthUpdatedEmployee);\n        expectNoMoreCalls(subFn);\n      });\n\n      describe(\"object deletes\", () => {\n        it(\"it properly updates the list\", async () => {\n          const emp = employeesAsServerReturns[0];\n          updateList(cache, { type: Employee, where: {}, orderBy: {} }, [\n            emp,\n          ]);\n\n          const subFn = mockSingleSubCallback();\n          defer(\n            cache.observeObject(\n              Employee,\n              emp.$primaryKey,\n              { mode: \"offline\" },\n              subFn,\n            ),\n          );\n          expectSingleObjectCallAndClear(subFn, emp);\n\n          const subListFn = mockListSubCallback();\n          defer(\n            cache.observeList({\n              type: Employee,\n              mode: \"offline\",\n            }, subListFn),\n          );\n\n          await waitForCall(subListFn, 1);\n          expectSingleListCallAndClear(\n            subListFn,\n            [emp],\n            { status: \"loaded\" },\n          );\n\n          const cacheKey = cache.getCacheKey<ObjectCacheKey>(\n            \"object\",\n            emp.$apiName,\n            emp.$primaryKey,\n          );\n\n          // Actual test is here, prior to this is setup\n          testStage(\"delete the object\");\n\n          cache.batch({\n            optimisticId: createOptimisticId(),\n          }, (batch) => {\n            batch.changes.deleteObject(cacheKey);\n            batch.delete(cacheKey, \"loading\");\n          });\n\n          expectSingleObjectCallAndClear(subFn, undefined);\n\n          await waitForCall(subListFn, 1);\n          expectSingleListCallAndClear(\n            subListFn,\n            [],\n            { isOptimistic: true, status: \"loading\" },\n          );\n        });\n      });\n    });\n\n    describe(\".invalidateObject\", () => {\n      it(\"triggers an update\", async () => {\n        const emp = employeesAsServerReturns[0];\n        const staleEmp = emp.$clone({ fullName: \"stale\" });\n        updateObject(cache, staleEmp);\n\n        const subFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n\n        expectSingleObjectCallAndClear(subFn, staleEmp, \"loaded\");\n\n        // invalidate\n        void cache.invalidateObject(Employee, staleEmp.$primaryKey);\n\n        await waitForCall(subFn);\n        expectSingleObjectCallAndClear(subFn, staleEmp, \"loading\");\n\n        await waitForCall(subFn);\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n\n        expectNoMoreCalls(subFn);\n      });\n    });\n\n    describe(\".invalidateList\", () => {\n      beforeEach(() => {\n        vi.useFakeTimers({});\n      });\n      afterEach(() => {\n        vi.useRealTimers();\n      });\n\n      it(\"triggers an update\", async () => {\n        const emp = employeesAsServerReturns[0];\n        const staleEmp = emp.$clone({ fullName: \"stale\" });\n        updateList(cache, { type: Employee, where: {}, orderBy: {} }, [\n          staleEmp,\n        ]);\n\n        const subFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n        expectSingleObjectCallAndClear(subFn, staleEmp);\n\n        const subListFn = mockListSubCallback();\n        defer(\n          cache.observeList({\n            type: Employee,\n            mode: \"offline\",\n          }, subListFn),\n        );\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(\n          subListFn,\n          [staleEmp],\n          { status: \"loaded\" },\n        );\n\n        testStage(\"invalidate\");\n\n        const invalidateListPromise = invalidateList(cache, { type: Employee });\n        testStage(\"check invalidate\");\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(\n          subListFn,\n          [staleEmp],\n          { status: \"loading\" },\n        );\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(\n          subListFn,\n          employeesAsServerReturns,\n          { status: \"loaded\" },\n        );\n\n        await waitForCall(subFn, 1);\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n\n        // don't leave promises dangling\n        await invalidateListPromise;\n      });\n    });\n\n    describe(\".invalidateObjectType\", () => {\n      beforeEach(() => {\n        vi.useFakeTimers({});\n      });\n      afterEach(() => {\n        vi.useRealTimers();\n      });\n\n      it(\"triggers an update\", async () => {\n        const emp = employeesAsServerReturns[0];\n        const staleEmp = emp.$clone({ fullName: \"stale\" });\n        updateList(cache, { type: Employee, where: {}, orderBy: {} }, [\n          staleEmp,\n        ]);\n\n        const subFn = mockSingleSubCallback();\n        defer(\n          cache.observeObject(\n            Employee,\n            emp.$primaryKey,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n        expectSingleObjectCallAndClear(subFn, staleEmp);\n\n        const subListFn = mockListSubCallback();\n        defer(\n          cache.observeList({\n            type: Employee,\n            where: {},\n            orderBy: {},\n            mode: \"offline\",\n          }, subListFn),\n        );\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(\n          subListFn,\n          [staleEmp],\n          { status: \"loaded\" },\n        );\n\n        testStage(\"invalidate\");\n\n        const pInvalidateComplete = cache.invalidateObjectType(\n          Employee,\n          undefined,\n        );\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(subListFn, [staleEmp], {\n          status: \"loading\",\n        });\n\n        await waitForCall(subListFn, 1);\n        expectSingleListCallAndClear(subListFn, employeesAsServerReturns);\n\n        await waitForCall(subFn, 1);\n        expectSingleObjectCallAndClear(subFn, emp, \"loaded\");\n\n        // we don't need this value to control the test but we want to make sure we don't have\n        // any unhandled exceptions upon test completion\n        await pInvalidateComplete;\n      });\n    });\n\n    describe(\".observeObject (force)\", () => {\n      const subFn1 = mockSingleSubCallback();\n      const subFn2 = mockSingleSubCallback();\n\n      beforeEach(async () => {\n        subFn1.complete.mockClear();\n        subFn1.next.mockClear();\n        subFn1.error.mockClear();\n\n        subFn2.complete.mockClear();\n        subFn2.next.mockClear();\n        subFn2.error.mockClear();\n      });\n\n      const likeEmployee50030 = expect.objectContaining({\n        $primaryKey: JOHN_DOE_ID,\n        fullName: \"John Doe\",\n      });\n\n      it(\"fetches and updates twice\", async () => {\n        defer(\n          cache.observeObject(Employee, JOHN_DOE_ID, { mode: \"force\" }, subFn1),\n        );\n\n        expect(subFn1.next).toHaveBeenCalledExactlyOnceWith(\n          objectPayloadContaining({\n            status: \"loading\",\n            object: undefined,\n            isOptimistic: false,\n          }),\n        );\n\n        subFn1.next.mockClear();\n\n        await waitForCall(subFn1);\n        expect(subFn1.next).toHaveBeenCalledExactlyOnceWith(\n          objectPayloadContaining({\n            object: likeEmployee50030,\n            isOptimistic: false,\n          }),\n        );\n\n        const firstLoad = subFn1.next.mock.lastCall?.[0]!;\n\n        subFn1.next.mockClear();\n\n        defer(\n          cache.observeObject(Employee, JOHN_DOE_ID, { mode: \"force\" }, subFn2),\n        );\n        expectSingleObjectCallAndClear(subFn1, likeEmployee50030, \"loading\");\n\n        // should be the earlier results\n        expectSingleObjectCallAndClear(subFn2, likeEmployee50030, \"loading\");\n\n        // both will be updated\n        for (const s of [subFn1, subFn2]) {\n          // wait for the result to come in\n          await waitForCall(s, 1);\n          expect(s.next).toHaveBeenCalledExactlyOnceWith(\n            objectPayloadContaining({\n              ...firstLoad,\n              lastUpdated: expect.toBeGreaterThan(firstLoad.lastUpdated),\n            }),\n          );\n\n          s.next.mockClear();\n        }\n      });\n    });\n\n    describe(\".observeObject (offline)\", () => {\n      const subFn = mockSingleSubCallback();\n      let sub: Unsubscribable;\n\n      beforeEach(() => {\n        subFn.complete.mockClear();\n        subFn.next.mockClear();\n        subFn.error.mockClear();\n\n        sub = defer(\n          cache.observeObject(\n            Employee,\n            JOHN_DOE_ID,\n            { mode: \"offline\" },\n            subFn,\n          ),\n        );\n\n        expectSingleObjectCallAndClear(subFn, undefined!, \"init\");\n      });\n\n      it(\"does basic observation and unsubscribe\", async () => {\n        const emp = employeesAsServerReturns.find(x =>\n          x.$primaryKey === JOHN_DOE_ID\n        )!;\n\n        // force an update\n        updateObject(cache, emp);\n        expectSingleObjectCallAndClear(subFn, emp);\n\n        // force again\n        updateObject(cache, emp.$clone({ fullName: \"new name\" }));\n        expectSingleObjectCallAndClear(\n          subFn,\n          emp.$clone({ fullName: \"new name\" }),\n        );\n\n        sub.unsubscribe();\n\n        // force again but no subscription update\n        updateObject(cache, emp.$clone({ fullName: \"new name 2\" }));\n        expect(subFn.next).not.toHaveBeenCalled();\n      });\n\n      it(\"observes with list update\", async () => {\n        const emp = employeesAsServerReturns.find(x =>\n          x.$primaryKey === JOHN_DOE_ID\n        )!;\n\n        // force an update\n        updateObject(cache, emp.$clone({ fullName: \"not the name\" }));\n        expect(subFn.next).toHaveBeenCalledTimes(1);\n\n        updateList(\n          cache,\n          { type: Employee, where: {}, orderBy: {} },\n          employeesAsServerReturns,\n        );\n        expect(subFn.next).toHaveBeenCalledTimes(2);\n\n        expect(subFn.next.mock.calls[1][0]).toEqual(\n          objectPayloadContaining({\n            object: emp as unknown as ObjectHolder<typeof emp>,\n          }),\n        );\n      });\n    });\n\n    describe(\".observeList\", () => {\n      const listSub1 = mockListSubCallback();\n      const ifaceSub = mockListSubCallback();\n\n      beforeEach(() => {\n        vi.useFakeTimers({});\n        vi.mocked(listSub1.next).mockReset();\n        vi.mocked(listSub1.error).mockReset();\n        vi.mocked(listSub1.complete).mockReset();\n\n        vi.mocked(ifaceSub.next).mockReset();\n        vi.mocked(ifaceSub.error).mockReset();\n        vi.mocked(ifaceSub.complete).mockReset();\n      });\n      afterEach(() => {\n        vi.useRealTimers();\n      });\n\n      describe(\"mode=force\", () => {\n        it(\"initial load\", async () => {\n          defer(\n            cache.observeList({\n              type: Employee,\n\n              orderBy: {},\n              mode: \"force\",\n            }, listSub1),\n          );\n\n          defer(\n            cache.observeList({\n              type: FooInterface,\n\n              orderBy: {},\n              mode: \"force\",\n            }, ifaceSub),\n          );\n\n          vitest.runOnlyPendingTimers();\n          await waitForCall(listSub1);\n          await waitForCall(ifaceSub);\n\n          expectSingleListCallAndClear(\n            listSub1,\n            [],\n            { status: \"loading\" },\n          );\n\n          expectSingleListCallAndClear(\n            ifaceSub,\n            [],\n            { status: \"loading\" },\n          );\n\n          await waitForCall(listSub1);\n          expectSingleListCallAndClear(\n            listSub1,\n            employeesAsServerReturns,\n            {\n              status: \"loaded\",\n            },\n          );\n\n          await waitForCall(ifaceSub);\n          expectSingleListCallAndClear(\n            ifaceSub,\n            employeesAsServerReturns,\n            {\n              status: \"loaded\",\n            },\n          );\n\n          expectNoMoreCalls(listSub1);\n          expectNoMoreCalls(ifaceSub);\n\n          expect(listSub1.next).not.toHaveBeenCalled();\n          expect(listSub1.error).not.toHaveBeenCalled();\n          expect(ifaceSub.next).not.toHaveBeenCalled();\n          expect(ifaceSub.error).not.toHaveBeenCalled();\n        });\n\n        it(\"subsequent load\", async () => {\n          // Pre-seed with data the server doesn't return\n          updateList(\n            cache,\n            { type: Employee, where: {}, orderBy: {} },\n            mutatedEmployees,\n          );\n\n          defer(\n            cache.observeList({\n              type: Employee,\n              mode: \"force\",\n            }, listSub1),\n          );\n\n          await waitForCall(listSub1, 1);\n          const firstLoad = listSub1.next.mock.calls[0][0]!;\n          expectSingleListCallAndClear(listSub1, mutatedEmployees, {\n            status: \"loading\",\n          });\n\n          await waitForCall(listSub1, 1);\n          expectSingleListCallAndClear(listSub1, employeesAsServerReturns, {\n            status: \"loaded\",\n            lastUpdated: expect.toBeGreaterThan(\n              firstLoad.lastUpdated,\n            ),\n          });\n        });\n      });\n\n      describe(\"mode = offline\", () => {\n        it(\"updates with list updates\", async () => {\n          defer(\n            cache.observeList({\n              type: Employee,\n              where: {},\n              orderBy: {},\n              mode: \"offline\",\n            }, listSub1),\n          );\n          expect(listSub1.next).toHaveBeenCalledTimes(0);\n\n          updateList(\n            cache,\n            { type: Employee, where: {}, orderBy: {} },\n            employeesAsServerReturns,\n          );\n          vitest.runOnlyPendingTimers();\n\n          expectSingleListCallAndClear(listSub1, employeesAsServerReturns);\n\n          // list is just now one object\n          updateList(cache, { type: Employee, where: {}, orderBy: {} }, [\n            employeesAsServerReturns[0],\n          ]);\n          vitest.runOnlyPendingTimers();\n\n          expectSingleListCallAndClear(listSub1, [employeesAsServerReturns[0]]);\n        });\n\n        it(\"updates with different list updates\", async () => {\n          defer(\n            cache.observeList({\n              type: Employee,\n              where: {},\n              orderBy: {},\n              mode: \"offline\",\n            }, listSub1),\n          );\n\n          expect(listSub1.next).toHaveBeenCalledTimes(0);\n\n          updateList(\n            cache,\n            { type: Employee, where: {}, orderBy: {} },\n            employeesAsServerReturns,\n          );\n          vitest.runOnlyPendingTimers();\n\n          expectSingleListCallAndClear(listSub1, employeesAsServerReturns);\n\n          // new where === different list\n          updateList(cache, {\n            type: Employee,\n            where: { employeeId: { $gt: 0 } },\n            orderBy: {},\n          }, mutatedEmployees);\n          vitest.runOnlyPendingTimers();\n\n          // original list updates still\n          expectSingleListCallAndClear(listSub1, mutatedEmployees);\n        });\n      });\n    });\n\n    describe(\".fetchMore\", () => {\n      beforeEach(() => {\n        vi.useFakeTimers({});\n      });\n      afterEach(() => {\n        vi.useRealTimers();\n      });\n\n      it(\"works in the solo case\", async () => {\n        const listSub = mockListSubCallback();\n        defer(cache.observeList(\n          {\n            type: Employee,\n            where: {},\n            orderBy: {},\n            mode: \"force\",\n            pageSize: 1,\n          },\n          listSub,\n        ));\n\n        expect(listSub.next).not.toHaveBeenCalled();\n\n        await waitForCall(listSub, 1);\n        expectSingleListCallAndClear(listSub, [], { status: \"loading\" });\n\n        await waitForCall(listSub, 1);\n        const { fetchMore } = listSub.next.mock.calls[0][0]!;\n        expectSingleListCallAndClear(\n          listSub,\n          employeesAsServerReturns.slice(0, 1),\n          { status: \"loaded\" },\n        );\n\n        void fetchMore();\n\n        await waitForCall(listSub, 1);\n        expectSingleListCallAndClear(\n          listSub,\n          employeesAsServerReturns.slice(0, 1),\n          { status: \"loading\" },\n        );\n\n        await waitForCall(listSub, 1);\n        expectSingleListCallAndClear(\n          listSub,\n          employeesAsServerReturns.slice(0, 2),\n          { status: \"loaded\" },\n        );\n      });\n    });\n  });\n\n  describe(\"with mock client\", () => {\n    let client: Client;\n    let apiServer: SetupServer;\n    let fauxFoundry: FauxFoundry;\n    let store: Store;\n\n    beforeAll(async () => {\n      const testSetup = startNodeApiServer(\n        new FauxFoundry(\"https://stack.palantir.com/\", undefined, { logger }),\n        createClient,\n        { logger },\n      );\n      ({ client, apiServer, fauxFoundry } = testSetup);\n\n      setupOntology(testSetup.fauxFoundry);\n\n      return () => {\n        testSetup.apiServer.close();\n      };\n    });\n\n    beforeEach(() => {\n      apiServer.resetHandlers();\n    });\n\n    beforeEach(async () => {\n      store = new Store(client);\n    });\n\n    it(\"properly fires error handler for a list\", async () => {\n      const sub = mockListSubCallback();\n\n      store.observeList({\n        type: { apiName: \"notReal\", type: \"object\" },\n        orderBy: {},\n      }, sub);\n\n      await waitForCall(sub.error, 1);\n\n      expect(sub.error).toHaveBeenCalled();\n      expect(sub.next).not.toHaveBeenCalled();\n    });\n\n    describe(\"batching\", () => {\n      it(\"groups requests for single objects\", async () => {\n        fauxFoundry.getDefaultDataStore().registerObject(Employee, {\n          $apiName: \"Employee\",\n          employeeId: 0,\n        });\n        fauxFoundry.getDefaultDataStore().registerObject(Employee, {\n          $apiName: \"Employee\",\n          employeeId: 1,\n        });\n\n        const a = mockSingleSubCallback();\n        const b = mockSingleSubCallback();\n\n        defer(store.observeObject(Employee, 0, {}, a));\n        defer(store.observeObject(Employee, 1, {}, b));\n\n        await a.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n            object: undefined,\n          }),\n          loaded: objectPayloadContaining({\n            object: expect.objectContaining({\n              $primaryKey: 0,\n            }),\n          }),\n        });\n        await b.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n            object: undefined,\n          }),\n          loaded: objectPayloadContaining({\n            object: expect.objectContaining({\n              $primaryKey: 1,\n            }),\n          }),\n        });\n      });\n    });\n\n    describe(\"actions\", () => {\n      beforeEach(() => {\n        fauxFoundry.getDefaultDataStore().clear();\n      });\n\n      it(\"properly invalidates objects\", async () => {\n        fauxFoundry.getDefaultDataStore().registerObject(Todo, {\n          $apiName: \"Todo\",\n          id: 0,\n          text: \"og title\",\n        });\n\n        const todoSubFn = mockSingleSubCallback();\n\n        defer(store.observeObject(Todo, 0, {}, todoSubFn));\n\n        await todoSubFn.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n            object: undefined,\n          }),\n          loaded: objectPayloadContaining({\n            object: expect.objectContaining({\n              $primaryKey: 0,\n            }),\n          }),\n        });\n\n        // at this point we have an observation properly set up\n        await store.applyAction(editTodo, {\n          id: 0,\n          text: \"hello there kind sir\",\n        });\n\n        await todoSubFn.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n          }),\n          loaded: objectPayloadContaining({\n            object: expect.objectContaining({\n              text: \"hello there kind sir\",\n            }),\n          }),\n        });\n      });\n\n      it(\"rolls back optimistic updates on error\", async () => {\n        const fauxObject = expect.objectContaining({\n          id: 0,\n          text: \"does not matter\",\n        });\n\n        // set the object in the \"backend\"\n        fauxFoundry.getDefaultDataStore().registerObject(Todo, {\n          $apiName: \"Todo\",\n          id: 0,\n          text: \"does not matter\",\n        });\n\n        const todoSubFn = mockSingleSubCallback();\n        defer(\n          store.observeObject(Todo, 0, {}, todoSubFn),\n        );\n\n        await todoSubFn.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n            object: undefined,\n            isOptimistic: false,\n          }),\n          loaded: objectPayloadContaining({\n            object: fauxObject,\n            status: \"loaded\",\n            isOptimistic: false,\n          }),\n        });\n\n        const object: Osdk.Instance<Todo> | undefined = store.getValue(\n          store.getCacheKey<ObjectCacheKey>(\"object\", \"Todo\", 0),\n        )?.value as any;\n        invariant(object);\n\n        // at this point we have an observation properly set up\n        await expect(\n          store.applyAction(editTodo, {\n            id: \"not an id that exists\",\n          } as any, {\n            optimisticUpdate: (ctx) => {\n              ctx.updateObject(object.$clone({ text: \"optimistic\" }));\n            },\n          }),\n        ).rejects.toThrow(ActionValidationError);\n\n        await waitForCall(todoSubFn, 2);\n        await todoSubFn.expectLoadingAndLoaded({\n          loading: objectPayloadContaining({\n            status: \"loading\",\n            object: expect.objectContaining({\n              id: 0,\n              text: \"optimistic\",\n            }),\n            isOptimistic: true,\n          }),\n          loaded: objectPayloadContaining({\n            object: fauxObject,\n            status: \"loaded\",\n            isOptimistic: false,\n          }),\n        });\n      });\n    });\n\n    describe(\"orderBy\", async () => {\n      let nextPk = 0;\n\n      let fauxObjectA: Osdk.Instance<Todo>;\n      let fauxObjectB: Osdk.Instance<Todo>;\n      let fauxObjectC: Osdk.Instance<Todo>;\n\n      beforeAll(async () => {\n        fauxFoundry.getDefaultDataStore().clear();\n        [fauxObjectA, fauxObjectB, fauxObjectC] = await Promise.all(\n          ([\"a\", \"b\", \"c\"] as const).map(text => {\n            const id = nextPk++;\n\n            fauxFoundry.getDefaultDataStore().registerObject(Todo, {\n              $apiName: \"Todo\",\n              id,\n              text,\n            });\n\n            return client(Todo).fetchOne(id);\n          }),\n        );\n      });\n\n      const noWhereNoOrderBy = {\n        type: Todo,\n        where: {},\n        orderBy: {},\n      } satisfies ObserveListOptions<Todo>;\n\n      const noWhereOrderByText = {\n        type: Todo,\n        where: {},\n        orderBy: {\n          text: \"asc\",\n        },\n      } satisfies ObserveListOptions<Todo>;\n\n      const subListUnordered = mockListSubCallback();\n      const subListOrdered = mockListSubCallback();\n\n      beforeEach(() => {\n        defer(\n          store.observeList({\n            ...noWhereNoOrderBy,\n            mode: \"offline\",\n          }, subListUnordered),\n        );\n        expect(subListUnordered.next).toHaveBeenCalledTimes(0);\n\n        defer(\n          store.observeList({\n            ...noWhereOrderByText,\n            mode: \"offline\",\n          }, subListOrdered),\n        );\n        expect(subListOrdered.next).toHaveBeenCalledTimes(0);\n      });\n\n      it(\"invalidates the correct lists\", async () => {\n        // for whatever reason, the first list is loaded as [B, A]\n        updateList(store, noWhereNoOrderBy, [fauxObjectB, fauxObjectA]);\n\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(\n          subListUnordered,\n          [fauxObjectB, fauxObjectA],\n        );\n\n        // The other list definitely matches on the where clause and we can insert\n        // orderBy properly. So this is [A, B]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [fauxObjectA, fauxObjectB],\n        );\n\n        // For whatever reason, object B is no longer in the first set (use your imagination)\n        // but we have added a C before A. So the first list is [C, A]\n        updateList(store, { type: Todo, where: {}, orderBy: {} }, [\n          fauxObjectC,\n          fauxObjectA,\n        ]);\n\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(\n          subListUnordered,\n          [fauxObjectC, fauxObjectA],\n        );\n\n        // Nothing told the system that B was deleted so we can presume it still exists\n        // and therefore the second list is now [A, B, C]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [fauxObjectA, fauxObjectB, fauxObjectC],\n        );\n      });\n\n      it(\"produces proper results with optimistic updates and successful action\", async () => {\n        const optimisticallyMutatedA = fauxObjectA.$clone({\n          text: \"optimistic\",\n        });\n        const pkForOptimistic = nextPk++;\n        const optimisticallyCreatedObjectD = expect.objectContaining({\n          \"text\": \"d\",\n          id: pkForOptimistic,\n        });\n\n        // for whatever reason, the first list is loaded as [B, A]\n        updateList(store, noWhereNoOrderBy, [fauxObjectB, fauxObjectA]);\n\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(\n          subListUnordered,\n          [fauxObjectB, fauxObjectA],\n        );\n\n        // The other list definitely matches on the where clause and we can insert\n        // orderBy properly. So this is [A, B]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [fauxObjectA, fauxObjectB],\n        );\n\n        testStage(\"Start\");\n\n        // Perform something optimistic.\n        const removeOptimisticResult = runOptimisticJob(store, (b) => {\n          b.createObject(Todo, pkForOptimistic, {\n            id: pkForOptimistic,\n            text: \"d\",\n          });\n          b.updateObject(optimisticallyMutatedA as Osdk.Instance<any>);\n        });\n\n        // The first list is now [B, A, optimistic]\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(\n          subListUnordered,\n          [\n            fauxObjectB,\n            optimisticallyMutatedA, // same position, new values\n            optimisticallyCreatedObjectD,\n          ],\n          { isOptimistic: true },\n        );\n\n        // the second list is now [A, B, optimistic]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [\n            fauxObjectB,\n            optimisticallyCreatedObjectD,\n            optimisticallyMutatedA,\n          ],\n          { isOptimistic: true },\n        );\n\n        // Roll back the optimistic update\n        await removeOptimisticResult();\n\n        // The first list is now [B, A]\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(\n          subListUnordered,\n          [fauxObjectB, fauxObjectA],\n          { isOptimistic: false },\n        );\n\n        // the second list is now [A, B]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [fauxObjectA, fauxObjectB],\n          { isOptimistic: false },\n        );\n      });\n      // I think these are named backwards\n      it(\"produces proper results with optimistic updates and rollback\", async () => {\n        const pkForOptimistic = nextPk++;\n        const optimisticallyCreatedObjectD = expect.objectContaining({\n          \"$primaryKey\": pkForOptimistic,\n          \"$title\": undefined, // FIXME once this is calculated by optimistic then this needs to be the right value\n          \"text\": \"d optimistic\",\n          id: pkForOptimistic,\n        });\n        const optimisticallyMutatedA = fauxObjectA.$clone({\n          text: \"optimistic\",\n        });\n\n        testStage(\"Initial Setup\");\n\n        // for whatever reason, the first list is loaded as [B, A]\n        updateList(store, noWhereNoOrderBy, [fauxObjectB, fauxObjectA]);\n\n        await waitForCall(subListUnordered, 1);\n\n        expectSingleListCallAndClear(subListUnordered, [\n          fauxObjectB,\n          fauxObjectA,\n        ]);\n\n        // The other list definitely matches on the where clause and we can insert\n        // orderBy properly. So this is [A, B]\n        expectSingleListCallAndClear(subListOrdered, [\n          fauxObjectA,\n          fauxObjectB,\n        ]);\n\n        testStage(\"Optimistic Creation\");\n\n        // create the weirdest action ever. It always creates a Todo with\n        // a new primary key and the text \"d\" and updates A\n        const {\n          actionDefinition: crazyAction,\n          actionTypeV2: crazyActionTypeV2,\n        } = TypeHelpers.actionTypeBuilder(\"asdf\")\n          .addParameter(\"foo\", \"string\")\n          .build();\n\n        fauxFoundry.getDefaultOntology().registerActionType(\n          crazyActionTypeV2,\n          (batch, params) => {\n            const idForD = nextPk++;\n\n            batch.addObject(Todo.apiName, idForD, {\n              id: idForD,\n              text: \"d\",\n            });\n\n            batch.modifyObject(fauxObjectA.$apiName, fauxObjectA.$primaryKey, {\n              text: \"a prime\",\n              $title: \"a prime\", // FIXME we shouldn't have to set this, it can be calculated\n            });\n          },\n        );\n\n        // the optimistic job will call createObject which triggers the `objectFactory2` of the\n        // cache context.\n\n        // Perform something optimistic.\n        const pActionResult = store.applyAction<typeof crazyAction>(\n          crazyAction,\n          {},\n          {\n            optimisticUpdate: (b) => {\n              b.createObject(Todo, pkForOptimistic, {\n                id: pkForOptimistic,\n                text: \"d optimistic\",\n              });\n              b.updateObject(optimisticallyMutatedA);\n            },\n          },\n        );\n\n        testStage(\"Optimistic Updates\");\n\n        // The first list is now [B, A, optimistic]\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(subListUnordered, [\n          fauxObjectB,\n          optimisticallyMutatedA, // same position, new values\n          optimisticallyCreatedObjectD,\n        ], { isOptimistic: true });\n\n        // the second list is now [B, optimistic, optimistic a]\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(subListOrdered, [\n          fauxObjectB,\n          optimisticallyCreatedObjectD,\n          optimisticallyMutatedA,\n        ], { isOptimistic: true });\n\n        testStage(\"Resolve Action\");\n\n        const modifiedObjectA = fauxObjectA.$clone({\n          text: \"a prime\",\n        });\n\n        const pkForD = (await pActionResult).addedObjects?.[0].primaryKey;\n        invariant(typeof pkForD === \"number\");\n        // load this without the cache for comparisons\n        const createdObjectD = await client(Todo).fetchOne(pkForD);\n\n        await waitForCall(subListUnordered, 1);\n        expectSingleListCallAndClear(subListUnordered, [\n          fauxObjectB,\n          modifiedObjectA,\n          createdObjectD,\n        ], { isOptimistic: false });\n\n        await waitForCall(subListOrdered, 1);\n        expectSingleListCallAndClear(\n          subListOrdered,\n          [modifiedObjectA, fauxObjectB, createdObjectD],\n          { isOptimistic: false },\n        );\n      });\n    });\n  });\n\n  describe(\"layers\", () => {\n    it(\"properly remove\", () => {\n      const clientHelper = createClientMockHelper();\n      const store = new Store(clientHelper.client);\n\n      const baseObjects = [1, 2].map((i) => ({\n        $primaryKey: i,\n        $objectType: \"Employee\",\n        $apiName: \"Employee\",\n        $title: `truth ${i}`,\n      } as Osdk.Instance<Employee>));\n\n      const cacheKeys = baseObjects.map((obj) =>\n        store.getCacheKey(\"object\", \"Employee\", obj.$primaryKey)\n      );\n\n      // set the truth\n      for (const obj of baseObjects) {\n        updateObject(store, obj);\n      }\n\n      // expect the truth\n      for (const obj of baseObjects) {\n        expect(getObject(store, \"Employee\", obj.$primaryKey)).toEqual(\n          expect.objectContaining({ $title: `truth ${obj.$primaryKey}` }),\n        );\n      }\n\n      const layerIds = [1, 2].map(createOptimisticId);\n\n      // optimistically set the objects in their own layers\n      for (let i = 0; i < 2; i++) {\n        store.batch({ optimisticId: layerIds[i] }, (batch) => {\n          batch.write(\n            cacheKeys[i],\n            {\n              ...baseObjects[i],\n              $title: `optimistic ${baseObjects[i].$primaryKey}`,\n            },\n            \"loading\",\n          );\n        });\n      }\n\n      // expect the optimistic values\n      for (let i = 0; i < 2; i++) {\n        expect(getObject(store, \"Employee\", baseObjects[i].$primaryKey))\n          .toEqual(\n            expect.objectContaining({\n              $title: `optimistic ${baseObjects[i].$primaryKey}`,\n            }),\n          );\n      }\n\n      // remove the first layer\n      store.removeLayer(layerIds[0]);\n\n      // should have truth object 1 and optimistic object 2\n      expect(getObject(store, \"Employee\", 1)).toEqual(\n        expect.objectContaining({ $title: \"truth 1\" }),\n      );\n      expect(getObject(store, \"Employee\", 2)).toEqual(\n        expect.objectContaining({ $title: \"optimistic 2\" }),\n      );\n\n      // remove the second layer\n      store.removeLayer(layerIds[1]);\n\n      // should have truth objects\n      for (const obj of baseObjects) {\n        expect(getObject(store, \"Employee\", obj.$primaryKey)).toEqual(\n          expect.objectContaining({ $title: `truth ${obj.$primaryKey}` }),\n        );\n      }\n    });\n  });\n});\n"],"mappings":"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","ignoreList":[]}