{"version":3,"file":"applyQuery.js","names":["OntologiesV2","invariant","createObjectSet","hydrateAttachmentFromRidInternal","addUserAgentAndRequestContextHeaders","augmentRequestContext","createObjectSpecifierFromPrimaryKey","toDataValueQueries","applyQuery","client","query","params","qd","ontologyProvider","getQueryDefinition","apiName","response","Queries","execute","finalMethodCall","ontologyRid","parameters","remapQueryParams","objectOutputDefs","getRequiredDefinitions","output","remappedResponse","remapQueryResponse","value","paramTypes","parameterMap","key","Object","entries","responseDataType","responseValue","definitions","nullable","undefined","Error","multiplicity","withoutMultiplicity","i","length","type","set","def","get","object","createQueryObjectResponse","objectSet","objectSets","objectType","reference","subtype","struct","requiresConversion","map","Array","isArray","process","env","NODE_ENV","entry","keyType","getObjectSpecifier","valueType","result","groups","push","subResult","subKey","dataType","Map","objectDef","getObjectDefinition","values","some","primaryKey","objectTypeApiName","$apiName","$title","$objectType","$primaryKey","$objectSpecifier"],"sources":["applyQuery.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AllowedBucketKeyTypes,\n  AllowedBucketTypes,\n  CompileTimeMetadata,\n  ObjectOrInterfaceDefinition,\n  ObjectTypeDefinition,\n  OsdkBase,\n  PrimaryKeyType,\n  QueryDataTypeDefinition,\n  QueryDefinition,\n  QueryParameterDefinition,\n} from \"@osdk/api\";\nimport type { DataValue } from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { createObjectSet } from \"../objectSet/createObjectSet.js\";\nimport { hydrateAttachmentFromRidInternal } from \"../public-utils/hydrateAttachmentFromRid.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport { augmentRequestContext } from \"../util/augmentRequestContext.js\";\nimport { createObjectSpecifierFromPrimaryKey } from \"../util/objectSpecifierUtils.js\";\nimport { toDataValueQueries } from \"../util/toDataValueQueries.js\";\nimport type { QueryParameterType, QueryReturnType } from \"./types.js\";\n\nexport async function applyQuery<\n  QD extends QueryDefinition<any>,\n  P extends QueryParameterType<CompileTimeMetadata<QD>[\"parameters\"]>,\n>(\n  client: MinimalClient,\n  query: QD,\n  params?: P,\n): Promise<\n  QueryReturnType<CompileTimeMetadata<QD>[\"output\"]>\n> {\n  const qd = await client.ontologyProvider.getQueryDefinition(query.apiName);\n\n  const response = await OntologiesV2.Queries.execute(\n    addUserAgentAndRequestContextHeaders(\n      augmentRequestContext(client, _ => ({ finalMethodCall: \"applyQuery\" })),\n      query,\n    ),\n    await client.ontologyRid,\n    query.apiName,\n    {\n      parameters: params\n        ? await remapQueryParams(\n          params as { [parameterId: string]: any },\n          client,\n          qd.parameters,\n        )\n        : {},\n    },\n  );\n  const objectOutputDefs = await getRequiredDefinitions(qd.output, client);\n  const remappedResponse = await remapQueryResponse(\n    client,\n    qd.output,\n    response.value,\n    objectOutputDefs,\n  );\n  return remappedResponse as QueryReturnType<CompileTimeMetadata<QD>[\"output\"]>;\n}\n\nasync function remapQueryParams(\n  params: { [parameterId: string]: any },\n  client: MinimalClient,\n  paramTypes: Record<string, QueryParameterDefinition<any>>,\n): Promise<{ [parameterId: string]: any }> {\n  const parameterMap: { [parameterName: string]: unknown } = {};\n  for (const [key, value] of Object.entries(params)) {\n    parameterMap[key] = await toDataValueQueries(\n      value,\n      client,\n      paramTypes[key],\n    );\n  }\n  return parameterMap;\n}\n\nasync function remapQueryResponse<\n  Q extends ObjectTypeDefinition,\n  T extends QueryDataTypeDefinition<Q | never>,\n>(\n  client: MinimalClient,\n  responseDataType: T,\n  responseValue: DataValue,\n  definitions: Map<string, ObjectOrInterfaceDefinition>,\n): Promise<QueryReturnType<T>> {\n  // handle null responses\n  if (responseValue == null) {\n    if (responseDataType.nullable) {\n      return undefined as unknown as QueryReturnType<typeof responseDataType>;\n    } else {\n      throw new Error(\"Got null response when nullable was not allowed\");\n    }\n  }\n\n  if (\n    responseDataType.multiplicity != null\n    && responseDataType.multiplicity\n  ) {\n    const withoutMultiplicity = { ...responseDataType, multiplicity: false };\n    for (let i = 0; i < responseValue.length; i++) {\n      responseValue[i] = await remapQueryResponse(\n        client,\n        withoutMultiplicity,\n        responseValue[i],\n        definitions,\n      );\n    }\n    return responseValue as QueryReturnType<typeof responseDataType>;\n  }\n\n  switch (responseDataType.type) {\n    case \"union\": {\n      throw new Error(\"Union return types are not yet supported\");\n    }\n\n    case \"set\": {\n      for (let i = 0; i < responseValue.length; i++) {\n        responseValue[i] = await remapQueryResponse(\n          client,\n          responseDataType.set,\n          responseValue[i],\n          definitions,\n        );\n      }\n\n      return responseValue as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"attachment\": {\n      return hydrateAttachmentFromRidInternal(\n        client,\n        responseValue,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n    case \"object\": {\n      const def = definitions.get(responseDataType.object);\n      if (!def || def.type !== \"object\") {\n        throw new Error(\n          `Missing definition for ${responseDataType.object}`,\n        );\n      }\n      return createQueryObjectResponse(\n        responseValue,\n        def,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n\n    case \"objectSet\": {\n      const def = definitions.get(responseDataType.objectSet);\n      if (!def) {\n        throw new Error(\n          `Missing definition for ${responseDataType.objectSet}`,\n        );\n      }\n      if (typeof responseValue === \"string\") {\n        return createObjectSet(def, client, {\n          type: \"intersect\",\n          objectSets: [\n            { type: \"base\", objectType: responseDataType.objectSet },\n            { type: \"reference\", reference: responseValue },\n          ],\n        }) as QueryReturnType<typeof responseDataType>;\n      }\n\n      return createObjectSet(\n        def,\n        client,\n        responseValue,\n      ) as QueryReturnType<\n        typeof responseDataType\n      >;\n    }\n    case \"struct\": {\n      // figure out what keys need to be fixed up\n      for (const [key, subtype] of Object.entries(responseDataType.struct)) {\n        if (requiresConversion(subtype)) {\n          responseValue[key] = await remapQueryResponse(\n            client,\n            subtype,\n            responseValue[key],\n            definitions,\n          );\n        }\n      }\n\n      return responseValue as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"map\": {\n      const map = {} as any;\n\n      invariant(Array.isArray(responseValue), \"Expected array entry\");\n      for (const entry of responseValue) {\n        invariant(entry.key, \"Expected key\");\n        invariant(entry.value, \"Expected value\");\n        const key = responseDataType.keyType.type === \"object\"\n          ? getObjectSpecifier(\n            entry.key,\n            responseDataType.keyType.object,\n            definitions,\n          )\n          : entry.key;\n        const value = await remapQueryResponse(\n          client,\n          responseDataType.valueType,\n          entry.value,\n          definitions,\n        );\n        map[key] = value;\n      }\n      return map;\n    }\n\n    case \"twoDimensionalAggregation\": {\n      const result: {\n        key: AllowedBucketKeyTypes;\n        value: AllowedBucketTypes;\n      }[] = [];\n      for (const { key, value } of responseValue.groups) {\n        result.push({ key, value });\n      }\n      return result as QueryReturnType<typeof responseDataType>;\n    }\n\n    case \"threeDimensionalAggregation\": {\n      const result: {\n        key: AllowedBucketKeyTypes;\n        groups: { key: AllowedBucketKeyTypes; value: AllowedBucketTypes }[];\n      }[] = [];\n      for (const { key, groups } of responseValue.groups) {\n        const subResult: { key: any; value: any }[] = [];\n        for (const { key: subKey, value } of groups) {\n          subResult.push({ key: subKey, value });\n        }\n        result.push({ key, groups: subResult });\n      }\n      return result as QueryReturnType<typeof responseDataType>;\n    }\n  }\n\n  return responseValue as QueryReturnType<typeof responseDataType>;\n}\n\nasync function getRequiredDefinitions(\n  dataType: QueryDataTypeDefinition,\n  client: MinimalClient,\n): Promise<Map<string, ObjectOrInterfaceDefinition>> {\n  const result = new Map<string, ObjectOrInterfaceDefinition>();\n  switch (dataType.type) {\n    case \"objectSet\": {\n      const objectDef = await client.ontologyProvider.getObjectDefinition(\n        dataType.objectSet,\n      );\n      result.set(dataType.objectSet, objectDef);\n      break;\n    }\n    case \"object\": {\n      const objectDef = await client.ontologyProvider.getObjectDefinition(\n        dataType.object,\n      );\n      result.set(dataType.object, objectDef);\n      break;\n    }\n\n    case \"set\": {\n      return getRequiredDefinitions(dataType.set, client);\n    }\n\n    case \"map\": {\n      for (const value of [dataType.keyType, dataType.valueType]) {\n        for (\n          const [type, objectDef] of await getRequiredDefinitions(value, client)\n        ) {\n          result.set(type, objectDef);\n        }\n      }\n      break;\n    }\n\n    case \"struct\": {\n      for (const value of Object.values(dataType.struct)) {\n        for (\n          const [type, objectDef] of await getRequiredDefinitions(value, client)\n        ) {\n          result.set(type, objectDef);\n        }\n      }\n      break;\n    }\n    case \"attachment\":\n    case \"boolean\":\n    case \"date\":\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"string\":\n    case \"threeDimensionalAggregation\":\n    case \"timestamp\":\n    case \"twoDimensionalAggregation\":\n    case \"union\":\n      break;\n  }\n\n  return result;\n}\nfunction requiresConversion(dataType: QueryDataTypeDefinition) {\n  switch (dataType.type) {\n    case \"boolean\":\n    case \"date\":\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"string\":\n    case \"timestamp\":\n      return false;\n\n    case \"union\":\n      return true;\n\n    case \"struct\":\n      return Object.values(dataType.struct).some(requiresConversion);\n\n    case \"set\":\n      return requiresConversion(dataType.set);\n\n    case \"attachment\":\n    case \"objectSet\":\n    case \"twoDimensionalAggregation\":\n    case \"threeDimensionalAggregation\":\n    case \"object\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction getObjectSpecifier(\n  primaryKey: any,\n  objectTypeApiName: string,\n  definitions: Map<string, ObjectOrInterfaceDefinition>,\n): string {\n  const def = definitions.get(objectTypeApiName);\n  if (!def || def.type !== \"object\") {\n    throw new Error(\n      `Missing definition for ${objectTypeApiName}`,\n    );\n  }\n  return createObjectSpecifierFromPrimaryKey(\n    def,\n    primaryKey,\n  );\n}\n\nexport function createQueryObjectResponse<\n  Q extends ObjectTypeDefinition,\n>(\n  primaryKey: PrimaryKeyType<Q>,\n  objectDef: Q,\n): OsdkBase<Q> {\n  return {\n    $apiName: objectDef.apiName,\n    $title: undefined,\n    $objectType: objectDef.apiName,\n    $primaryKey: primaryKey,\n    $objectSpecifier: createObjectSpecifierFromPrimaryKey(\n      objectDef,\n      primaryKey,\n    ),\n  };\n}\n"],"mappings":"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","ignoreList":[]}