{"version":3,"file":"timeseriesUtils.js","names":["TimeseriesDurationMapping","iterateReadableStream","parseStreamedResponse","getTimeRange","body","type","startTime","$startTime","endTime","$endTime","$before","when","value","unit","$unit","$after","asyncIterPointsHelper","iterator","reader","getReader","point","time"],"sources":["timeseriesUtils.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { TimeSeriesQuery } from \"@osdk/api\";\nimport { TimeseriesDurationMapping } from \"@osdk/api\";\nimport type { TimeRange } from \"@osdk/foundry.ontologies\";\nimport { iterateReadableStream, parseStreamedResponse } from \"./streamutils.js\";\n\nexport function getTimeRange(body: TimeSeriesQuery): TimeRange {\n  if (\"$startTime\" in body || \"$endTime\" in body) {\n    return {\n      type: \"absolute\",\n      startTime: body.$startTime,\n      endTime: body.$endTime,\n    };\n  }\n  return body.$before\n    ? {\n      type: \"relative\",\n      startTime: {\n        when: \"BEFORE\",\n        value: body.$before,\n        unit: TimeseriesDurationMapping[body.$unit],\n      },\n    }\n    : {\n      type: \"relative\",\n      endTime: {\n        when: \"AFTER\",\n        value: body.$after!,\n        unit: TimeseriesDurationMapping[body.$unit],\n      },\n    };\n}\n\nexport async function* asyncIterPointsHelper<\n  T extends number | string | GeoJSON.Point,\n>(\n  iterator: Response,\n): AsyncGenerator<\n  {\n    time: any;\n    value: T;\n  },\n  void,\n  unknown\n> {\n  const reader = iterator.body?.getReader()!;\n  for await (\n    const point of parseStreamedResponse(iterateReadableStream(reader))\n  ) {\n    yield {\n      time: point.time,\n      value: point.value as T,\n    };\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASA,yBAAyB,QAAQ,WAAW;AAErD,SAASC,qBAAqB,EAAEC,qBAAqB,QAAQ,kBAAkB;AAE/E,OAAO,SAASC,YAAYA,CAACC,IAAqB,EAAa;EAC7D,IAAI,YAAY,IAAIA,IAAI,IAAI,UAAU,IAAIA,IAAI,EAAE;IAC9C,OAAO;MACLC,IAAI,EAAE,UAAU;MAChBC,SAAS,EAAEF,IAAI,CAACG,UAAU;MAC1BC,OAAO,EAAEJ,IAAI,CAACK;IAChB,CAAC;EACH;EACA,OAAOL,IAAI,CAACM,OAAO,GACf;IACAL,IAAI,EAAE,UAAU;IAChBC,SAAS,EAAE;MACTK,IAAI,EAAE,QAAQ;MACdC,KAAK,EAAER,IAAI,CAACM,OAAO;MACnBG,IAAI,EAAEb,yBAAyB,CAACI,IAAI,CAACU,KAAK;IAC5C;EACF,CAAC,GACC;IACAT,IAAI,EAAE,UAAU;IAChBG,OAAO,EAAE;MACPG,IAAI,EAAE,OAAO;MACbC,KAAK,EAAER,IAAI,CAACW,MAAO;MACnBF,IAAI,EAAEb,yBAAyB,CAACI,IAAI,CAACU,KAAK;IAC5C;EACF,CAAC;AACL;AAEA,OAAO,gBAAgBE,qBAAqBA,CAG1CC,QAAkB,EAQlB;EACA,MAAMC,MAAM,GAAGD,QAAQ,CAACb,IAAI,EAAEe,SAAS,CAAC,CAAE;EAC1C,WACE,MAAMC,KAAK,IAAIlB,qBAAqB,CAACD,qBAAqB,CAACiB,MAAM,CAAC,CAAC,EACnE;IACA,MAAM;MACJG,IAAI,EAAED,KAAK,CAACC,IAAI;MAChBT,KAAK,EAAEQ,KAAK,CAACR;IACf,CAAC;EACH;AACF","ignoreList":[]}