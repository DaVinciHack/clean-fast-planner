{"version":3,"file":"ConjureSupport.js","names":["bulkLoadOntologyEntities","getLinkTypesForObjectTypes","loadAllOntologies","invariant","createSimpleAsyncCache","createSimpleCache","makeConjureContext","cachedAllOntologies","getOntologyVersionForRid","ctx","ontologyRid","ontologies","process","env","NODE_ENV","currentOntologyVersion","strongMemoSync","fn","Map","get","weakMemoSync","WeakMap","strongMemoAsync","weakMemoAsync","MetadataClient","client","logger","constructor","ontologyProvider","getObjectDefinition","child","mcc","forObjectByRid","rid","Promise","resolve","getPropertyMapping","objectPropertyMapping","bind","getLinkMapping","objectLinkMapping","getRid","getApiName","getConjureObjectType","apiName","forObjectByApiName","objectApiName","objectDef","objectTypeRid","conjureObjectType","createObjectPropertyMapping","linkTypes","includeObjectTypesWithoutSearchableDatasources","loadRedacted","objectTypeBranches","objectTypeVersions","ontologyVersion","ret","l","helper","linkSide","otherObjectType","directedLinkTypeRid","linkTypeRid","definition","type","oneToMany","objectTypeRidManySide","manyToOneLinkMetadata","objectTypeRidOneSide","oneToManyLinkMetadata","manyToMany","objectTypeRidA","objectTypeAToBLinkMetadata","objectTypeRidB","objectTypeBToALinkMetadata","debug","body","datasourceTypes","objectTypes","identifier","versionReference","sharedPropertyTypes","interfaceTypes","typeGroups","includeObjectTypeCount","undefined","includeEntityMetadata","actionTypes","includeTypeGroupEntitiesCount","entityMetadata","entities","objectType","metadataCacheClient","conjureOT","primaryKeys","length","pkRid","pkProperty","Object","values","propertyTypes","find","a","Error","propertyIdToApiNameMapping","fromEntries","map","property","id","propertyApiNameToIdMapping","pk"],"sources":["ConjureSupport.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  DirectedLinkTypeRid,\n  LinkTypeMetadata,\n  LoadAllOntologiesResponse,\n  ObjectType,\n  Type,\n} from \"@osdk/client.unstable\";\nimport {\n  bulkLoadOntologyEntities,\n  getLinkTypesForObjectTypes,\n  loadAllOntologies,\n} from \"@osdk/client.unstable\";\nimport type { ConjureContext } from \"conjure-lite\";\nimport invariant from \"tiny-invariant\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport {\n  createSimpleAsyncCache,\n  createSimpleCache,\n} from \"../object/SimpleCache.js\";\nimport { makeConjureContext } from \"../ontology/makeConjureContext.js\";\n\nexport interface ObjectPropertyMapping {\n  apiName: string;\n  id: string;\n  propertyIdToApiNameMapping: Record<string, string>;\n  propertyApiNameToIdMapping: Record<string, string>;\n  pk: {\n    rid: string;\n    apiName: string;\n    type: Type;\n  };\n}\n\ntype ObjectLinkMapping = Record<string, {\n  apiName: string;\n  directedLinkTypeRid: DirectedLinkTypeRid;\n  otherObjectType: string; // rid\n}>;\n\nlet cachedAllOntologies: LoadAllOntologiesResponse | undefined;\nasync function getOntologyVersionForRid(\n  ctx: ConjureContext,\n  ontologyRid: string,\n) {\n  cachedAllOntologies ??= await loadAllOntologies(ctx, {});\n  invariant(\n    cachedAllOntologies.ontologies[ontologyRid],\n    \"ontology should be loaded\",\n  );\n\n  return cachedAllOntologies.ontologies[ontologyRid].currentOntologyVersion;\n}\n\nconst strongMemoSync = <K, V>(fn: (entry: K) => V) =>\n  createSimpleCache<K, V>(new Map(), fn).get;\n\nconst weakMemoSync = <K extends object, V>(fn: (entry: K) => V) =>\n  createSimpleCache<K, V>(new WeakMap() as any, fn).get; // FIXME\n\nconst strongMemoAsync = <K, V>(fn: (entry: K) => Promise<V>) =>\n  createSimpleAsyncCache<K, V>(\"strong\", fn).get;\n\nconst weakMemoAsync = <K, V>(fn: (entry: K) => Promise<V>) =>\n  createSimpleAsyncCache<K, V>(\"weak\", fn).get;\n\nexport class MetadataClient {\n  #client: MinimalClient;\n  #ctx: ConjureContext;\n  #logger: any;\n\n  constructor(client: MinimalClient) {\n    this.#client = client;\n    this.#ctx = makeConjureContext(client, \"ontology-metadata/api\");\n    this.#client.ontologyProvider.getObjectDefinition;\n\n    this.#logger = this.#client.logger?.child({\n      mcc: true,\n    });\n  }\n\n  forObjectByRid: (key: string) => Promise<{\n    getPropertyMapping: () => Promise<ObjectPropertyMapping>;\n    getLinkMapping: () => Promise<ObjectLinkMapping>;\n    getRid: () => string;\n    getApiName: () => Promise<string | null | undefined>;\n  }> = strongMemoAsync(async (rid: string) => {\n    return Promise.resolve({\n      getPropertyMapping: this.#objectPropertyMapping.bind(this, rid),\n      getLinkMapping: this.#objectLinkMapping.bind(this, rid),\n      getRid: () => rid,\n      getApiName: async () => (await this.#getConjureObjectType(rid)).apiName,\n    });\n  });\n\n  forObjectByApiName: (key: string) => Promise<{\n    getPropertyMapping: () => Promise<ObjectPropertyMapping>;\n    getLinkMapping: () => Promise<ObjectLinkMapping>;\n    getRid: () => string;\n    getApiName: () => Promise<string | null | undefined>;\n  }> = strongMemoAsync(\n    async (objectApiName: string) => {\n      const objectDef = await this.#client.ontologyProvider.getObjectDefinition(\n        objectApiName,\n      );\n      return this.forObjectByRid(objectDef.rid);\n    },\n  );\n\n  #objectPropertyMapping = strongMemoAsync(async (objectTypeRid: string) => {\n    const conjureObjectType = await this.#getConjureObjectType(objectTypeRid);\n    return createObjectPropertyMapping(conjureObjectType);\n  });\n\n  #objectLinkMapping = strongMemoAsync(async (objectTypeRid: string) => {\n    const linkTypes = await getLinkTypesForObjectTypes(this.#ctx, {\n      includeObjectTypesWithoutSearchableDatasources: true,\n      loadRedacted: false,\n      objectTypeBranches: {},\n      objectTypeVersions: {\n        [objectTypeRid]: await this.ontologyVersion(\"\"),\n      },\n    });\n    invariant(\n      linkTypes.linkTypes[objectTypeRid],\n      \"link type should be loaded\",\n    );\n\n    // apiName to content\n    const ret: ObjectLinkMapping = {};\n    for (const l of linkTypes.linkTypes[objectTypeRid]) {\n      const helper = (\n        { apiName }: LinkTypeMetadata,\n        linkSide: \"SOURCE\" | \"TARGET\",\n        otherObjectType: string,\n      ) => {\n        if (apiName) {\n          ret[apiName] = {\n            apiName,\n            directedLinkTypeRid: {\n              linkTypeRid: l.rid,\n              linkSide,\n            },\n            otherObjectType,\n          };\n        }\n      };\n      if (l.definition.type === \"oneToMany\") {\n        const {\n          oneToMany: {\n            objectTypeRidManySide,\n            manyToOneLinkMetadata,\n            objectTypeRidOneSide,\n            oneToManyLinkMetadata,\n          },\n        } = l.definition;\n        if (objectTypeRidManySide === objectTypeRid) {\n          helper(\n            manyToOneLinkMetadata,\n            \"TARGET\",\n            objectTypeRidOneSide,\n          );\n        }\n        if (objectTypeRidOneSide === objectTypeRid) {\n          helper(\n            oneToManyLinkMetadata,\n            \"SOURCE\",\n            objectTypeRidManySide,\n          );\n        }\n      } else if (l.definition.type === \"manyToMany\") {\n        const {\n          manyToMany: {\n            objectTypeRidA,\n            objectTypeAToBLinkMetadata,\n            objectTypeRidB,\n            objectTypeBToALinkMetadata,\n          },\n        } = l.definition;\n        if (objectTypeRidA === objectTypeRid) {\n          helper(\n            objectTypeAToBLinkMetadata,\n            \"SOURCE\",\n            objectTypeRidB,\n          );\n        }\n\n        if (objectTypeRidB === objectTypeRid) {\n          helper(\n            objectTypeBToALinkMetadata,\n            \"TARGET\",\n            objectTypeRidA,\n          );\n        }\n      }\n    }\n\n    return ret;\n  });\n\n  #getConjureObjectType = strongMemoAsync(async (objectTypeRid: string) => {\n    this.#logger?.debug(`getConjureObjectType(${objectTypeRid})`);\n    const body = {\n      datasourceTypes: [],\n      objectTypes: [{\n        identifier: {\n          type: \"objectTypeRid\" as const,\n          objectTypeRid: objectTypeRid,\n        },\n        versionReference: {\n          type: \"ontologyVersion\" as const,\n          ontologyVersion: await this.ontologyVersion(\"\"),\n        },\n      }],\n      linkTypes: [],\n      sharedPropertyTypes: [],\n      interfaceTypes: [],\n      typeGroups: [],\n      loadRedacted: false,\n      includeObjectTypeCount: undefined,\n      includeObjectTypesWithoutSearchableDatasources: true,\n      includeEntityMetadata: undefined,\n      actionTypes: [],\n      includeTypeGroupEntitiesCount: undefined,\n      entityMetadata: undefined,\n    };\n    const entities = await bulkLoadOntologyEntities(this.#ctx, undefined, body);\n    invariant(\n      entities.objectTypes[0]?.objectType,\n      \"object type should be loaded\",\n    );\n    return entities.objectTypes[0].objectType;\n  });\n\n  ontologyVersion: (key: string) => Promise<string> = strongMemoAsync(async (\n    _: string,\n  ) => getOntologyVersionForRid(this.#ctx, await this.#client.ontologyRid));\n}\n\nexport const metadataCacheClient: (\n  key: MinimalClient,\n) => Promise<MetadataClient> = weakMemoAsync(\n  (client: MinimalClient) => Promise.resolve(new MetadataClient(client)),\n);\n\nfunction createObjectPropertyMapping(\n  conjureOT: ObjectType,\n): ObjectPropertyMapping {\n  invariant(\n    conjureOT.primaryKeys.length === 1,\n    `only one primary key supported, got ${conjureOT.primaryKeys.length}`,\n  );\n  const pkRid = conjureOT.primaryKeys[0];\n\n  const pkProperty = Object.values(conjureOT.propertyTypes).find(a =>\n    a.rid === pkRid\n  );\n  if (!pkProperty) {\n    throw new Error(`Could not find PK property by rid: ${pkRid}`);\n  }\n\n  const propertyIdToApiNameMapping: Record<string, string> = Object\n    .fromEntries(\n      Object.values(conjureOT.propertyTypes).map(\n        property => {\n          return [property.id, property.apiName!];\n        },\n      ),\n    );\n\n  const propertyApiNameToIdMapping: Record<string, string> = Object\n    .fromEntries(\n      Object.values(conjureOT.propertyTypes).map(\n        property => {\n          return [property.apiName!, property.id];\n        },\n      ),\n    );\n\n  return {\n    apiName: conjureOT.apiName!,\n    id: conjureOT.id,\n    propertyIdToApiNameMapping,\n    propertyApiNameToIdMapping,\n    pk: {\n      rid: pkRid,\n      apiName: pkProperty.apiName!,\n      type: pkProperty.type,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]}