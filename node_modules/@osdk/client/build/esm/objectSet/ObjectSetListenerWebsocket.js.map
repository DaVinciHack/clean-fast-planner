{"version":3,"file":"ObjectSetListenerWebsocket.js","names":["WebSocket","invariant","MINIMUM_RECONNECT_DELAY_MS","doNothing","fillOutListener","onChange","onError","onOutOfDate","onSuccessfulSubscription","isReady","sub","subscriptionIsDone","status","ObjectSetListenerWebsocket","instances","WeakMap","getInstance","client","instance","get","clientCacheKey","set","ws","lastWsConnect","logger","pendingSubscriptions","Map","subscriptions","endedSubscriptions","Set","maybeDisconnectTimeout","constructor","minimumReconnectDelayMs","child","msgPrefix","baseUrl","startsWith","process","env","NODE_ENV","subscribe","objectType","objectSet","listener","properties","objOrInterfaceDef","type","ontologyProvider","getObjectDefinition","apiName","getInterfaceDefinition","objectProperties","referenceProperties","length","Object","keys","filter","p","primaryKeyPropertyName","undefined","primaryKeyApiName","requestedProperties","requestedReferenceProperties","subscriptionId","nextUuid","interfaceApiName","initiateSubscribe","unsubscribe","#initiateSubscribe","debug","ensureWebsocket","readyState","OPEN","sendSubscribeMessage","error","tryCatchOnError","#sendSubscribeMessage","readySubs","values","id","requests","map","propertySet","referenceSet","payload","send","JSON","stringify","#unsubscribe","newStatus","delete","add","clearTimeout","setTimeout","size","cycleWebsocket","#ensureWebsocket","tokenProvider","url","constructWebsocketUrl","ontologyRid","token","nextConnectTime","Date","now","Promise","resolve","addEventListener","onClose","onMessage","onOpen","CONNECTING","reject","cleanup","removeEventListener","open","evt","#onOpen","message","data","parse","toString","handleMessage_objectSetChanged","handleMessage_refreshObjectSet","handleMessage_subscribeResponses","handleMessage_subscriptionClosed","objectUpdates","updates","update","referenceUpdates","osdkObjectsWithReferenceUpdates","all","o","osdkObjectArray","objectFactory2","__apiName","__primaryKey","primaryKey","property","value","fetchInterfaceMapping","singleOsdkObject","object","state","osdkObjects","keysToDelete","key","includes","osdkObject","#fetchInterfaceMapping","objectTypeApiName","interfaceMap","responses","subs","i","response","errors","shouldFireOutOfDate","#handleMessage_subscriptionClosed","has","cause","event","#cycleWebsocket","CLOSING","CLOSED","close","s","#tryCatchOnError","subscriptionClosed","onErrorError","console","base","URL","protocol","replace","uuidCounter","padStart"],"sources":["ObjectSetListenerWebsocket.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  Logger,\n  ObjectOrInterfaceDefinition,\n  ObjectSetSubscription,\n  Osdk,\n  PropertyKeys,\n} from \"@osdk/api\";\nimport type {\n  ObjectSet,\n  ObjectSetStreamSubscribeRequest,\n  ObjectSetStreamSubscribeRequests,\n  ObjectSetSubscribeResponses,\n  ObjectSetUpdates,\n  ObjectState,\n  RefreshObjectSet,\n  StreamMessage,\n  SubscriptionClosed,\n} from \"@osdk/foundry.ontologies\";\nimport WebSocket from \"isomorphic-ws\";\nimport invariant from \"tiny-invariant\";\nimport type { ClientCacheKey, MinimalClient } from \"../MinimalClientContext.js\";\n\nconst MINIMUM_RECONNECT_DELAY_MS = 5 * 1000;\n\n/** Noop function to reduce conditional checks */\nfunction doNothing() {}\n\n/**\n * Converts an ObjectSetListener to one where all the functions are defined.\n */\nfunction fillOutListener<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n>(\n  {\n    onChange = doNothing,\n    onError = doNothing,\n    onOutOfDate = doNothing,\n    onSuccessfulSubscription = doNothing,\n  }: ObjectSetSubscription.Listener<Q, P>,\n): Required<ObjectSetSubscription.Listener<Q, P>> {\n  return { onChange, onError, onOutOfDate, onSuccessfulSubscription };\n}\n\ninterface Subscription<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n> {\n  listener: Required<ObjectSetSubscription.Listener<Q, P>>;\n  requestedProperties: Array<P>;\n  requestedReferenceProperties: Array<P>;\n  objectSet: ObjectSet;\n\n  subscriptionId: string;\n  isReady?: boolean;\n  status:\n    | \"preparing\"\n    | \"subscribed\"\n    | \"done\"\n    | \"expired\"\n    | \"error\"\n    | \"reconnecting\";\n\n  interfaceApiName?: string;\n  primaryKeyPropertyName?: string;\n}\n\nfunction isReady<\n  Q extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<Q>,\n>(\n  sub: Subscription<Q, P>,\n): sub is Subscription<Q, P> & { temporaryObjectSetId: string } {\n  return sub.isReady != null;\n}\n\nfunction subscriptionIsDone(sub: Subscription<any, any>) {\n  return sub.status === \"done\" || sub.status === \"error\";\n}\n\n/** @internal */\nexport class ObjectSetListenerWebsocket {\n  static #instances = new WeakMap<\n    ClientCacheKey,\n    ObjectSetListenerWebsocket\n  >();\n  readonly MINIMUM_RECONNECT_DELAY_MS: number;\n\n  // FIXME\n  static getInstance(client: MinimalClient): ObjectSetListenerWebsocket {\n    let instance = ObjectSetListenerWebsocket.#instances.get(\n      client.clientCacheKey,\n    );\n    if (instance == null) {\n      instance = new ObjectSetListenerWebsocket(client);\n      ObjectSetListenerWebsocket.#instances.set(\n        client.clientCacheKey,\n        instance,\n      );\n    }\n    return instance;\n  }\n\n  #ws: WebSocket | undefined;\n  #lastWsConnect = 0;\n  #client: MinimalClient;\n\n  #logger?: Logger;\n\n  /**\n   * map of requestId to all active subscriptions at the time of the request\n   */\n  #pendingSubscriptions = new Map<\n    string,\n    Subscription<any, any>[]\n  >();\n\n  /**\n   * Map of subscriptionId to Subscription. Note: the subscriptionId may be\n   * temporary and not the actual subscriptionId from the server.\n   */\n  #subscriptions = new Map<\n    string,\n    Subscription<any, any>\n  >();\n\n  #endedSubscriptions = new Set<\n    string\n  >();\n\n  #maybeDisconnectTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  // DO NOT CONSTRUCT DIRECTLY. ONLY EXPOSED AS A TESTING SEAM\n  constructor(\n    client: MinimalClient,\n    {\n      minimumReconnectDelayMs = MINIMUM_RECONNECT_DELAY_MS,\n    } = {},\n  ) {\n    this.MINIMUM_RECONNECT_DELAY_MS = minimumReconnectDelayMs;\n    this.#client = client;\n    this.#logger = client.logger?.child({}, {\n      msgPrefix: \"<OSW> \",\n    });\n    invariant(\n      client.baseUrl.startsWith(\"https://\")\n        || client.baseUrl.startsWith(\"http://\"),\n      \"Stack must be a URL\",\n    );\n  }\n\n  async subscribe<\n    Q extends ObjectOrInterfaceDefinition,\n    P extends PropertyKeys<Q>,\n  >(\n    objectType: ObjectOrInterfaceDefinition,\n    objectSet: ObjectSet,\n    listener: ObjectSetSubscription.Listener<Q, P>,\n    properties: Array<P> = [],\n  ): Promise<() => void> {\n    const objOrInterfaceDef = objectType.type === \"object\"\n      ? await this.#client.ontologyProvider.getObjectDefinition(\n        objectType.apiName,\n      )\n      : await this.#client.ontologyProvider.getInterfaceDefinition(\n        objectType.apiName,\n      );\n\n    let objectProperties: Array<P> = [];\n    let referenceProperties: Array<P> = [];\n\n    if (properties.length === 0) {\n      properties = Object.keys(objOrInterfaceDef.properties) as Array<P>;\n    }\n\n    objectProperties = properties.filter((p) =>\n      objOrInterfaceDef.properties[p].type !== \"geotimeSeriesReference\"\n    );\n\n    referenceProperties = properties.filter((p) =>\n      objOrInterfaceDef.properties[p].type === \"geotimeSeriesReference\"\n    );\n\n    const sub: Subscription<Q, P> = {\n      listener: fillOutListener<Q, P>(listener),\n      objectSet,\n      primaryKeyPropertyName: objOrInterfaceDef.type === \"interface\"\n        ? undefined\n        : objOrInterfaceDef.primaryKeyApiName,\n      requestedProperties: objectProperties,\n      requestedReferenceProperties: referenceProperties,\n      status: \"preparing\",\n      // Since we don't have a real subscription id yet but we need to keep\n      // track of this reference, we can just use a random uuid.\n      subscriptionId: `TMP-${nextUuid()}}`,\n      interfaceApiName: objOrInterfaceDef.type === \"object\"\n        ? undefined\n        : objOrInterfaceDef.apiName,\n    };\n\n    this.#subscriptions.set(sub.subscriptionId, sub);\n\n    // actually prepares the subscription, ensures the ws is ready, and sends\n    // a subscribe message. We don't want to block on this.\n    void this.#initiateSubscribe(sub);\n\n    return () => {\n      this.#unsubscribe(sub);\n    };\n  }\n\n  /**\n   * Called at least once for every subscription.\n   *\n   * - Resets pending expiry\n   * - Recreates temporary object set\n   * - Triggers a full subscribe message\n   *\n   * @returns\n   */\n  async #initiateSubscribe(sub: Subscription<any, any>) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\"#initiateSubscribe()\");\n    }\n\n    try {\n      await this.#ensureWebsocket();\n\n      // the consumer may have already unsubscribed before we are ready to request a subscription\n      // so we have to acquire the pendingSubscription after the await.\n      if (subscriptionIsDone(sub)) {\n        return;\n      }\n      sub.isReady = true;\n      // if we aren't open, then this happens after we #onConnect\n      if (this.#ws?.readyState === WebSocket.OPEN) {\n        this.#sendSubscribeMessage();\n      }\n    } catch (error) {\n      this.#logger?.error(error, \"Error in #initiateSubscribe\");\n      this.#tryCatchOnError(sub, true, error);\n    }\n  }\n\n  #sendSubscribeMessage() {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\"#sendSubscribeMessage()\");\n    }\n    // If two calls to `.subscribe()` happen at once (or if the connection is reset),\n    // we may have multiple subscriptions that don't have a subscriptionId yet,\n    // so we filter those out.\n    const readySubs = [...this.#subscriptions.values()].filter(isReady);\n\n    const id = nextUuid();\n    // responses come back as an array of subIds, so we need to know the sources\n    this.#pendingSubscriptions.set(id, readySubs);\n\n    // every subscribe message \"overwrites\" the previous ones that are not\n    // re-included, so we have to reconstitute the entire list of subscriptions\n    const subscribe: ObjectSetStreamSubscribeRequests = {\n      id,\n      requests: readySubs.map<ObjectSetStreamSubscribeRequest>((\n        {\n          objectSet,\n          requestedProperties,\n          requestedReferenceProperties,\n          interfaceApiName,\n        },\n      ) => {\n        return {\n          objectSet: objectSet,\n          propertySet: requestedProperties,\n          referenceSet: requestedReferenceProperties,\n        };\n      }),\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug(\n        { payload: subscribe },\n        \"sending subscribe message\",\n      );\n    }\n    this.#ws?.send(JSON.stringify(subscribe));\n  }\n\n  #unsubscribe<Q extends ObjectOrInterfaceDefinition>(\n    sub: Subscription<Q, any>,\n    newStatus: \"done\" | \"error\" = \"done\",\n  ) {\n    if (subscriptionIsDone(sub)) {\n      // if we are already done, we don't need to do anything\n      return;\n    }\n\n    sub.status = newStatus;\n\n    // make sure listeners do nothing now\n    sub.listener = fillOutListener<Q, any>({});\n\n    this.#subscriptions.delete(sub.subscriptionId);\n    this.#endedSubscriptions.add(sub.subscriptionId);\n    this.#sendSubscribeMessage();\n\n    // If we have no more subscriptions, we can disconnect the websocket\n    // however we should wait a bit to see if we get any more subscriptions.\n    // For example, when switching between react views, you may unsubscribe\n    // in the old view and subscribe in the new view. We don't need to re-establish\n    // the websocket connection in that case.\n    if (this.#maybeDisconnectTimeout) {\n      // We reset the timeout on every unsubscribe so its always at least 15s from\n      // the last time we are empty. E.g.:\n      //   - 0s: Subscribe(A)\n      //   - 10s: Unsubscribe(A)\n      //   - 11s: Subscribe(B)\n      //   - 20s: Unsubscribe(B)\n      // If we do not clear out the timeout we would disconnect at 25s but that would only be\n      // 5s after the last subscription was removed instead of at 35s for the desired 15s.\n      clearTimeout(this.#maybeDisconnectTimeout);\n    }\n    this.#maybeDisconnectTimeout = setTimeout(() => {\n      this.#maybeDisconnectTimeout = undefined;\n      if (this.#subscriptions.size === 0) {\n        this.#cycleWebsocket();\n      }\n    }, 15_000 /* ms */);\n  }\n\n  async #ensureWebsocket() {\n    if (this.#ws == null) {\n      const { baseUrl, tokenProvider } = this.#client;\n      const url = constructWebsocketUrl(\n        baseUrl,\n        await this.#client.ontologyRid,\n      );\n\n      const token = await tokenProvider();\n\n      // tokenProvider is async, there could potentially be a race to create the websocket.\n      // Only the first call to reach here will find a null this.#ws, the rest will bail out\n      if (this.#ws == null) {\n        // TODO this can probably be exponential backoff with jitter\n        // don't reconnect more quickly than MINIMUM_RECONNECT_DELAY\n        const nextConnectTime = (this.#lastWsConnect ?? 0)\n          + this.MINIMUM_RECONNECT_DELAY_MS;\n        if (nextConnectTime > Date.now()) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, nextConnectTime - Date.now());\n          });\n        }\n\n        this.#lastWsConnect = Date.now();\n\n        // we again may have lost the race after our minimum backoff time\n        if (this.#ws == null) {\n          if (process.env.NODE_ENV !== \"production\") {\n            this.#logger?.debug(\"Creating websocket\");\n          }\n          this.#ws = new WebSocket(url, [`Bearer-${token}`]);\n          this.#ws.addEventListener(\"close\", this.#onClose);\n          this.#ws.addEventListener(\"message\", this.#onMessage);\n          this.#ws.addEventListener(\"open\", this.#onOpen);\n        }\n      }\n      // Allow await-ing the websocket open event if it isn't open already.\n      // This needs to happen even for callers that didn't just create this.#ws\n      if (this.#ws.readyState === WebSocket.CONNECTING) {\n        const ws = this.#ws;\n        return new Promise<void>((resolve, reject) => {\n          function cleanup() {\n            ws.removeEventListener(\"open\", open);\n            ws.removeEventListener(\"error\", error);\n            ws.removeEventListener(\"close\", cleanup);\n          }\n          function open() {\n            cleanup();\n            resolve();\n          }\n          function error(evt: unknown) {\n            cleanup();\n            reject(evt);\n          }\n          ws.addEventListener(\"open\", open);\n          ws.addEventListener(\"error\", error);\n          ws.addEventListener(\"close\", cleanup);\n        });\n      }\n    }\n  }\n\n  #onOpen = () => {\n    // resubscribe all of the listeners\n    this.#sendSubscribeMessage();\n  };\n\n  #onMessage = async (message: WebSocket.MessageEvent): Promise<void> => {\n    const data = JSON.parse(message.data.toString()) as StreamMessage;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug({ payload: data }, \"received message from ws\");\n    }\n    switch (data.type) {\n      case \"objectSetChanged\":\n        await this.#handleMessage_objectSetChanged(data);\n        return;\n\n      case \"refreshObjectSet\":\n        this.#handleMessage_refreshObjectSet(data);\n        return;\n\n      case \"subscribeResponses\":\n        this.#handleMessage_subscribeResponses(data);\n        return;\n\n      case \"subscriptionClosed\": {\n        this.#handleMessage_subscriptionClosed(data);\n        return;\n      }\n\n      default:\n        const _: never = data;\n        invariant(false, \"Unexpected message type\");\n    }\n  };\n\n  #handleMessage_objectSetChanged = async (\n    payload: ObjectSetUpdates,\n  ) => {\n    const sub = this.#subscriptions.get(payload.id);\n    if (sub == null) return;\n\n    const objectUpdates = payload.updates.filter((update) =>\n      update.type === \"object\"\n    );\n    const referenceUpdates = payload.updates.filter((update) =>\n      update.type === \"reference\"\n    );\n    const osdkObjectsWithReferenceUpdates = await Promise.all(\n      referenceUpdates.map(async (o) => {\n        const osdkObjectArray = await this.#client.objectFactory2(\n          this.#client,\n          [{\n            __apiName: o.objectType,\n            __primaryKey: sub.primaryKeyPropertyName != null\n              ? o.primaryKey[sub.primaryKeyPropertyName]\n              : undefined,\n            ...o.primaryKey,\n            [o.property]: o.value,\n          }],\n          sub.interfaceApiName,\n          {},\n          false,\n          undefined,\n          false,\n          await this.#fetchInterfaceMapping(\n            o.objectType,\n            sub.interfaceApiName,\n          ),\n        );\n        const singleOsdkObject = osdkObjectArray[0] ?? undefined;\n        return singleOsdkObject != null\n          ? {\n            object: singleOsdkObject as Osdk.Instance<any, never, any>,\n            state: \"ADDED_OR_UPDATED\" as ObjectState,\n          }\n          : undefined;\n      }),\n    );\n\n    for (const update of osdkObjectsWithReferenceUpdates) {\n      if (update != null) {\n        try {\n          sub.listener.onChange?.(update);\n        } catch (error) {\n          this.#logger?.error(error, \"Error in onChange callback\");\n          this.#tryCatchOnError(sub, false, error);\n        }\n      }\n    }\n\n    const osdkObjects = await Promise.all(objectUpdates.map(async (o) => {\n      const keysToDelete = Object.keys(o.object).filter((key) =>\n        sub.requestedReferenceProperties.includes(key)\n      );\n      for (const key of keysToDelete) {\n        delete o.object[key];\n      }\n\n      const osdkObjectArray = await this.#client.objectFactory2(\n        this.#client,\n        [o.object],\n        sub.interfaceApiName,\n        {},\n        false,\n        undefined,\n        false,\n        await this.#fetchInterfaceMapping(\n          o.object.__apiName,\n          sub.interfaceApiName,\n        ),\n      ) as Array<Osdk.Instance<any, never, any>>;\n      const singleOsdkObject = osdkObjectArray[0] ?? undefined;\n      return singleOsdkObject != null\n        ? {\n          object: singleOsdkObject,\n          state: o.state,\n        }\n        : undefined;\n    }));\n\n    for (const osdkObject of osdkObjects) {\n      if (osdkObject != null) {\n        try {\n          sub.listener.onChange?.(osdkObject);\n        } catch (error) {\n          this.#logger?.error(error, \"Error in onChange callback\");\n          this.#tryCatchOnError(sub, false, error);\n        }\n      }\n    }\n  };\n\n  async #fetchInterfaceMapping(\n    objectTypeApiName: string,\n    interfaceApiName: string | undefined,\n  ): Promise<Record<string, Record<string, Record<string, string>>>> {\n    if (interfaceApiName == null) return {};\n    const interfaceMap = (await this.#client.ontologyProvider\n      .getObjectDefinition(objectTypeApiName)).interfaceMap;\n    return {\n      [interfaceApiName]: {\n        [objectTypeApiName]: interfaceMap[interfaceApiName],\n      },\n    };\n  }\n\n  #handleMessage_refreshObjectSet = (payload: RefreshObjectSet) => {\n    const sub = this.#subscriptions.get(payload.id);\n    invariant(sub, `Expected subscription id ${payload.id}`);\n    try {\n      sub.listener.onOutOfDate();\n    } catch (error) {\n      this.#logger?.error(error, \"Error in onOutOfDate callback\");\n      this.#tryCatchOnError(sub, false, error);\n    }\n  };\n\n  #handleMessage_subscribeResponses = (\n    payload: ObjectSetSubscribeResponses,\n  ) => {\n    const { id, responses } = payload;\n\n    const subs = this.#pendingSubscriptions.get(id);\n    invariant(subs, `should have a pending subscription for ${id}`);\n    this.#pendingSubscriptions.delete(id);\n\n    for (let i = 0; i < responses.length; i++) {\n      const sub = subs[i];\n      const response = responses[i];\n\n      switch (response.type) {\n        case \"error\":\n          this.#tryCatchOnError(sub, true, response.errors);\n          this.#unsubscribe(sub, \"error\");\n          break;\n\n        case \"qos\":\n          // the server has requested that we tear down our websocket and reconnect to help load balance\n          this.#cycleWebsocket();\n          break;\n\n        case \"success\":\n          // `\"preparing\"` should only be the status on an initial subscribe.\n          const shouldFireOutOfDate = sub.status === \"expired\"\n            || sub.status === \"reconnecting\";\n\n          if (process.env.NODE_ENV !== \"production\") {\n            this.#logger?.debug({ shouldFireOutOfDate }, \"success\");\n          }\n          sub.status = \"subscribed\";\n          if (sub.subscriptionId !== response.id) {\n            // might be the temporary one\n            this.#subscriptions.delete(sub.subscriptionId);\n            sub.subscriptionId = response.id;\n            this.#subscriptions.set(sub.subscriptionId, sub); // future messages come by this subId\n          }\n          try {\n            if (shouldFireOutOfDate) sub.listener.onOutOfDate();\n            else sub.listener.onSuccessfulSubscription();\n          } catch (error) {\n            this.#logger?.error(\n              error,\n              \"Error in onOutOfDate or onSuccessfulSubscription callback\",\n            );\n            this.#tryCatchOnError(sub, false, error);\n          }\n          break;\n        default:\n          this.#tryCatchOnError(sub, true, response);\n      }\n    }\n  };\n\n  #handleMessage_subscriptionClosed(payload: SubscriptionClosed) {\n    const sub = this.#subscriptions.get(payload.id);\n    if (sub == null && this.#endedSubscriptions.has(payload.id)) return;\n    invariant(sub, `Expected subscription id ${payload.id}`);\n    this.#tryCatchOnError(sub, true, payload.cause);\n    this.#unsubscribe(sub, \"error\");\n  }\n\n  #onClose = (event: WebSocket.CloseEvent) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#logger?.debug({ event }, \"Received close event from ws\", event);\n    }\n    // TODO we should probably throttle this so we don't abuse the backend\n    this.#cycleWebsocket();\n  };\n\n  #cycleWebsocket = () => {\n    if (this.#ws) {\n      this.#ws.removeEventListener(\"open\", this.#onOpen);\n      this.#ws.removeEventListener(\"message\", this.#onMessage);\n      this.#ws.removeEventListener(\"close\", this.#onClose);\n\n      if (\n        this.#ws.readyState !== WebSocket.CLOSING\n        && this.#ws.readyState !== WebSocket.CLOSED\n      ) {\n        this.#ws.close();\n      }\n      this.#ws = undefined;\n    }\n\n    // if we have any listeners that are still depending on us, go ahead and reopen the websocket\n    if (this.#subscriptions.size > 0) {\n      if (process.env.NODE_ENV !== \"production\") {\n        for (const s of this.#subscriptions.values()) {\n          invariant(\n            s.status !== \"done\" && s.status !== \"error\",\n            \"should not have done/error subscriptions still\",\n          );\n        }\n      }\n\n      for (const s of this.#subscriptions.values()) {\n        if (s.status === \"subscribed\") s.status = \"reconnecting\";\n      }\n\n      // we don't care about the result of this (we want cycleWebsocket to be fire and forget)\n      // just that it happens\n      void this.#ensureWebsocket();\n    }\n  };\n\n  #tryCatchOnError = (\n    sub: Subscription<any, any>,\n    subscriptionClosed: boolean,\n    error: any,\n  ) => {\n    try {\n      sub.listener.onError({ subscriptionClosed: subscriptionClosed, error });\n    } catch (onErrorError) {\n      // eslint-disable-next-line no-console\n      console.error(\n        `Error encountered in an onError callback for an OSDK subscription`,\n        onErrorError,\n      );\n      // eslint-disable-next-line no-console\n      console.error(\n        `This onError call was triggered by an error in another callback`,\n        error,\n      );\n      // eslint-disable-next-line no-console\n      console.error(\n        `The subscription has been closed.`,\n        error,\n      );\n\n      if (!subscriptionClosed) {\n        this.#logger?.error(error, \"Error in onError callback\");\n        this.#unsubscribe(sub, \"error\");\n        this.#tryCatchOnError(sub, true, onErrorError);\n      }\n    }\n  };\n}\n\n/** @internal */\nexport function constructWebsocketUrl(\n  baseUrl: string,\n  ontologyRid: string,\n) {\n  const base = new URL(baseUrl);\n  const url = new URL(\n    `api/v2/ontologySubscriptions/ontologies/${ontologyRid}/streamSubscriptions`,\n    base,\n  );\n  url.protocol = url.protocol.replace(\"https\", \"wss\");\n  return url;\n}\n\nlet uuidCounter = 0;\n\nfunction nextUuid() {\n  return `00000000-0000-0000-0000-${\n    (uuidCounter++).toString().padStart(12, \"0\")\n  }`;\n}\n"],"mappings":"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","ignoreList":[]}