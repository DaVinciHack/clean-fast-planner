{"version":3,"file":"modernToLegacyWhereClause.js","names":["DistanceUnitMapping","invariant","extractNamespace","fqApiName","last","lastIndexOf","undefined","slice","modernToLegacyWhereClause","whereClause","objectOrInterface","type","value","$and","map","clause","$or","$not","parts","Object","entries","length","handleWherePair","v","makeGeoFilterBbox","bbox","filterType","propertyIdentifier","field","topLeft","coordinates","bottomRight","makeGeoFilterPolygon","fieldName","filter","structFieldSelector","process","env","NODE_ENV","propertyApiName","fullyQualifyPropName","keysOfFilter","keys","hasDollarSign","some","key","startsWith","structFilter","structFieldApiName","firstKey","withinBody","Array","isArray","$bbox","$distance","$of","center","distance","unit","$polygon","intersectsBody","substring","fuzzy","objApiNamespace","apiName","fieldApiNamespace","fieldShortName"],"sources":["modernToLegacyWhereClause.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  GeoFilterOptions,\n  ObjectOrInterfaceDefinition,\n  PossibleWhereClauseFilters,\n  WhereClause,\n} from \"@osdk/api\";\nimport { DistanceUnitMapping } from \"@osdk/api\";\n\nimport type {\n  PropertyIdentifier,\n  SearchJsonQueryV2,\n} from \"@osdk/foundry.ontologies\";\nimport type { BBox, Position } from \"geojson\";\nimport invariant from \"tiny-invariant\";\n\nexport function extractNamespace(\n  fqApiName: string,\n): [string | undefined, string] {\n  const last = fqApiName.lastIndexOf(\".\");\n  if (last === -1) return [undefined, fqApiName];\n  return [fqApiName.slice(0, last), fqApiName.slice(last + 1)];\n}\n\n/** @internal */\nexport function modernToLegacyWhereClause<\n  T extends ObjectOrInterfaceDefinition,\n>(\n  whereClause: WhereClause<T>,\n  objectOrInterface: T,\n): SearchJsonQueryV2 {\n  if (\"$and\" in whereClause) {\n    return {\n      type: \"and\",\n      value: (whereClause.$and as WhereClause<T>[]).map(\n        (clause) => modernToLegacyWhereClause(clause, objectOrInterface),\n      ),\n    };\n  } else if (\"$or\" in whereClause) {\n    return {\n      type: \"or\",\n      value: (whereClause.$or as WhereClause<T>[]).map(\n        (clause) => modernToLegacyWhereClause(clause, objectOrInterface),\n      ),\n    };\n  } else if (\"$not\" in whereClause) {\n    return {\n      type: \"not\",\n      value: modernToLegacyWhereClause(\n        whereClause.$not as WhereClause<T>,\n        objectOrInterface,\n      ),\n    };\n  }\n\n  const parts = Object.entries(whereClause);\n\n  if (parts.length === 1) {\n    return handleWherePair(parts[0], objectOrInterface);\n  }\n\n  return {\n    type: \"and\",\n    value: parts.map<SearchJsonQueryV2>(\n      v => handleWherePair(v, objectOrInterface),\n    ),\n  };\n}\n\nfunction makeGeoFilterBbox(\n  bbox: BBox,\n  filterType: \"$within\" | \"$intersects\",\n  propertyIdentifier?: PropertyIdentifier,\n  field?: string,\n): SearchJsonQueryV2 {\n  return {\n    type: filterType === \"$within\"\n      ? \"withinBoundingBox\"\n      : \"intersectsBoundingBox\",\n    /**\n     * This is a bit ugly, but did this so that propertyIdentifier only shows up in the return object if its defined,\n     * this makes it so we don't need to go update our entire test bed either to include a field which may change in near future.\n     * Once we solidify that this is the way forward, I can remove field and clean this up\n     */\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: {\n      topLeft: {\n        type: \"Point\",\n        coordinates: [bbox[0], bbox[3]],\n      },\n      bottomRight: {\n        type: \"Point\",\n        coordinates: [bbox[2], bbox[1]],\n      },\n    },\n  };\n}\n\nfunction makeGeoFilterPolygon(\n  coordinates: Position[][],\n  filterType: \"intersectsPolygon\" | \"withinPolygon\",\n  propertyIdentifier?: PropertyIdentifier,\n  field?: string,\n): SearchJsonQueryV2 {\n  return {\n    type: filterType,\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: {\n      type: \"Polygon\",\n      coordinates,\n    },\n  };\n}\n\nfunction handleWherePair(\n  [fieldName, filter]: [string, any],\n  objectOrInterface: ObjectOrInterfaceDefinition,\n  structFieldSelector?: { propertyApiName: string; structFieldApiName: string },\n): SearchJsonQueryV2 {\n  invariant(\n    filter != null,\n    \"Defined key values are only allowed when they are not undefined.\",\n  );\n\n  const propertyIdentifier: PropertyIdentifier | undefined =\n    structFieldSelector != null\n      ? {\n        type: \"structField\",\n        ...structFieldSelector,\n        propertyApiName: fullyQualifyPropName(\n          structFieldSelector.propertyApiName,\n          objectOrInterface,\n        ),\n      }\n      : undefined;\n  const field = structFieldSelector == null\n    ? fullyQualifyPropName(fieldName, objectOrInterface)\n    : undefined;\n\n  if (\n    typeof filter === \"string\" || typeof filter === \"number\"\n    || typeof filter === \"boolean\"\n  ) {\n    propertyIdentifier;\n    return {\n      type: \"eq\",\n      ...(propertyIdentifier != null\n        && { propertyIdentifier }),\n      field,\n      value: filter,\n    };\n  }\n\n  const keysOfFilter = Object.keys(filter);\n\n  // If any of the keys start with `$` then they must be the only one.\n  // e.g. `where({ name: { $eq: \"foo\", $ne: \"bar\" } })` is invalid currently\n  const hasDollarSign = keysOfFilter.some((key) => key.startsWith(\"$\"));\n  invariant(\n    !hasDollarSign\n      || keysOfFilter.length === 1,\n    \"A WhereClause Filter with multiple clauses/fields is not allowed. Instead, use an 'or'/'and' clause to combine multiple filters.\",\n  );\n\n  if (!hasDollarSign) {\n    const structFilter = Object.entries(filter);\n    invariant(\n      structFilter.length === 1,\n      \"Cannot filter on more than one struct field in the same clause, need to use an and clause\",\n    );\n    const structFieldApiName = keysOfFilter[0];\n    return handleWherePair(Object.entries(filter)[0], objectOrInterface, {\n      propertyApiName: fieldName,\n      structFieldApiName,\n    });\n  }\n\n  const firstKey = keysOfFilter[0] as PossibleWhereClauseFilters;\n  invariant(filter[firstKey] != null);\n\n  if (firstKey === \"$ne\") {\n    return {\n      type: \"not\",\n      value: {\n        type: \"eq\",\n        ...(propertyIdentifier != null && { propertyIdentifier }),\n        field,\n        value: filter[firstKey],\n      },\n    };\n  }\n\n  if (firstKey === \"$within\") {\n    const withinBody = filter[firstKey] as GeoFilterOptions[\"$within\"];\n\n    if (Array.isArray(withinBody)) {\n      return makeGeoFilterBbox(withinBody, firstKey, propertyIdentifier, field);\n    } else if (\"$bbox\" in withinBody && withinBody.$bbox != null) {\n      return makeGeoFilterBbox(\n        withinBody.$bbox,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else if (\n      (\"$distance\" in withinBody && \"$of\" in withinBody)\n      && withinBody.$distance != null\n      && withinBody.$of != null\n    ) {\n      return {\n        type: \"withinDistanceOf\",\n        ...(propertyIdentifier != null && { propertyIdentifier }),\n        field,\n        value: {\n          center: Array.isArray(withinBody.$of)\n            ? {\n              type: \"Point\",\n              coordinates: withinBody.$of,\n            }\n            : withinBody.$of,\n          distance: {\n            value: withinBody.$distance[0],\n            unit: DistanceUnitMapping[withinBody.$distance[1]],\n          },\n        },\n      };\n    } else {\n      const coordinates = (\"$polygon\" in withinBody)\n        ? withinBody.$polygon\n        : withinBody.coordinates;\n      return makeGeoFilterPolygon(\n        coordinates,\n        \"withinPolygon\",\n        propertyIdentifier,\n        fieldName,\n      );\n    }\n  }\n  if (firstKey === \"$intersects\") {\n    const intersectsBody = filter[firstKey] as GeoFilterOptions[\"$intersects\"];\n    if (Array.isArray(intersectsBody)) {\n      return makeGeoFilterBbox(\n        intersectsBody,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else if (\"$bbox\" in intersectsBody && intersectsBody.$bbox != null) {\n      return makeGeoFilterBbox(\n        intersectsBody.$bbox,\n        firstKey,\n        propertyIdentifier,\n        field,\n      );\n    } else {\n      const coordinates = (\"$polygon\" in intersectsBody)\n        ? intersectsBody.$polygon\n        : intersectsBody.coordinates;\n      return makeGeoFilterPolygon(\n        coordinates,\n        \"intersectsPolygon\",\n        propertyIdentifier,\n        field,\n      );\n    }\n  }\n\n  if (firstKey === \"$containsAllTerms\" || firstKey === \"$containsAnyTerm\") {\n    return {\n      type: firstKey.substring(1) as DropDollarSign<typeof firstKey>,\n      ...(propertyIdentifier != null && { propertyIdentifier }),\n      field,\n      value: typeof filter[firstKey] === \"string\"\n        ? filter[firstKey]\n        : filter[firstKey][\"term\"],\n      fuzzy: typeof filter[firstKey] === \"string\"\n        ? false\n        : filter[firstKey][\"fuzzySearch\"] ?? false,\n    };\n  }\n\n  return {\n    type: firstKey.substring(1) as DropDollarSign<typeof firstKey>,\n    ...(propertyIdentifier != null && { propertyIdentifier }),\n    field,\n    value: filter[firstKey] as any,\n  };\n}\n\ntype DropDollarSign<T extends `$${string}`> = T extends `$${infer U}` ? U\n  : never;\n\nfunction fullyQualifyPropName(\n  fieldName: string,\n  objectOrInterface: ObjectOrInterfaceDefinition,\n) {\n  if (objectOrInterface.type === \"interface\") {\n    const [objApiNamespace] = extractNamespace(objectOrInterface.apiName);\n    const [fieldApiNamespace, fieldShortName] = extractNamespace(fieldName);\n    return (fieldApiNamespace == null && objApiNamespace != null)\n      ? `${objApiNamespace}.${fieldShortName}`\n      : fieldName;\n  }\n  return fieldName;\n}\n"],"mappings":"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","ignoreList":[]}