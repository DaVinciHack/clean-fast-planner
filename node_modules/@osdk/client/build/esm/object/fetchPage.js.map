{"version":3,"file":"fetchPage.js","names":["OntologiesV2","addUserAgentAndRequestContextHeaders","extractRdpDefinition","resolveBaseObjectSetType","augment","type","properties","apiName","objectSetToSearchJsonV2","objectSet","expectedApiName","existingWhere","undefined","objectType","Error","interfaceType","where","value","resolveInterfaceObjectSet","interfaceTypeApiName","args","$includeAllBaseObjectProperties","objectSets","includeAllBaseObjectProperties","fetchInterfacePage","client","$__UNSTABLE_useOldInterfaceApis","result","OntologyInterfaces","search","ontologyRid","applyFetchArgs","augmentedProperties","augmentedSharedPropertyTypes","otherInterfaceTypes","selectedObjectTypes","selectedSharedPropertyTypes","$select","preview","data","objectFactory","$includeRid","OntologyObjectSets","loadMultipleObjectTypes","select","excludeRid","Promise","resolve","objectFactory2","interfaceToObjectTypeMappings","nextPageToken","totalCount","fetchPageInternal","fetchObjectPage","fetchPageWithErrorsInternal","e","error","fetchPage","fetchPageWithErrors","body","$nextPageToken","pageToken","$pageSize","pageSize","$orderBy","orderBy","fields","Object","entries","map","field","direction","r","load"],"sources":["fetchPage.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  Augment,\n  Augments,\n  FetchPageArgs,\n  FetchPageResult,\n  InterfaceDefinition,\n  NullabilityAdherence,\n  ObjectOrInterfaceDefinition,\n  ObjectTypeDefinition,\n  PropertyKeys,\n  Result,\n} from \"@osdk/api\";\nimport type { PageSize, PageToken } from \"@osdk/foundry.core\";\nimport type {\n  LoadObjectSetRequestV2,\n  LoadObjectSetV2MultipleObjectTypesRequest,\n  ObjectSet,\n  OntologyObjectV2,\n  SearchJsonQueryV2,\n  SearchObjectsForInterfaceRequest,\n  SearchOrderByV2,\n} from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport { extractRdpDefinition } from \"../util/extractRdpDefinition.js\";\nimport { resolveBaseObjectSetType } from \"../util/objectSetUtils.js\";\n\nexport function augment<\n  Q extends ObjectOrInterfaceDefinition,\n  T extends PropertyKeys<Q>,\n>(\n  type: Q,\n  ...properties: T[]\n): Augment<Q, T> {\n  return { [type.apiName]: properties } as any;\n}\n\n/** @internal */\nexport function objectSetToSearchJsonV2(\n  objectSet: ObjectSet,\n  expectedApiName: string,\n  existingWhere: SearchJsonQueryV2 | undefined = undefined,\n): SearchJsonQueryV2 | undefined {\n  if (objectSet.type === \"base\" || objectSet.type === \"interfaceBase\") {\n    if (objectSet.type === \"base\" && objectSet.objectType !== expectedApiName) {\n      throw new Error(\n        `Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.objectType}`,\n      );\n    }\n    if (\n      objectSet.type === \"interfaceBase\"\n      && objectSet.interfaceType !== expectedApiName\n    ) {\n      throw new Error(\n        `Expected objectSet.objectType to be ${expectedApiName}, but got ${objectSet.interfaceType}`,\n      );\n    }\n\n    return existingWhere;\n  }\n\n  if (objectSet.type === \"filter\") {\n    return objectSetToSearchJsonV2(\n      objectSet.objectSet,\n      expectedApiName,\n      existingWhere == null ? objectSet.where : {\n        type: \"and\",\n        value: [existingWhere, objectSet.where],\n      },\n    );\n  }\n\n  throw new Error(`Unsupported objectSet type: ${objectSet.type}`);\n}\n\n/** @internal */\nexport function resolveInterfaceObjectSet(\n  objectSet: ObjectSet,\n  interfaceTypeApiName: string,\n  args: FetchPageArgs<any, any, any, any, any, any>,\n): ObjectSet {\n  return args?.$includeAllBaseObjectProperties\n    ? {\n      type: \"intersect\",\n      objectSets: [objectSet, {\n        type: \"interfaceBase\",\n        interfaceType: interfaceTypeApiName,\n        includeAllBaseObjectProperties: true,\n      }],\n    }\n    : objectSet;\n}\n\nasync function fetchInterfacePage<\n  Q extends InterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  interfaceType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet,\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  if (args.$__UNSTABLE_useOldInterfaceApis) {\n    const result = await OntologiesV2.OntologyInterfaces\n      .search(\n        addUserAgentAndRequestContextHeaders(client, interfaceType),\n        await client.ontologyRid,\n        interfaceType.apiName,\n        applyFetchArgs<SearchObjectsForInterfaceRequest>(args, {\n          augmentedProperties: {},\n          augmentedSharedPropertyTypes: {},\n          otherInterfaceTypes: [],\n          selectedObjectTypes: [],\n          selectedSharedPropertyTypes: args.$select as undefined | string[]\n            ?? [],\n          where: objectSetToSearchJsonV2(objectSet, interfaceType.apiName),\n        }),\n        { preview: true },\n      );\n\n    result.data = await client.objectFactory(\n      client,\n      result.data as OntologyObjectV2[], // drop readonly\n      interfaceType.apiName,\n      !args.$includeRid,\n      await extractRdpDefinition(client, objectSet),\n    );\n    return result as any;\n  }\n  const result = await OntologiesV2.OntologyObjectSets.loadMultipleObjectTypes(\n    addUserAgentAndRequestContextHeaders(client, interfaceType),\n    await client.ontologyRid,\n    applyFetchArgs<LoadObjectSetV2MultipleObjectTypesRequest>(args, {\n      objectSet: resolveInterfaceObjectSet(\n        objectSet,\n        interfaceType.apiName,\n        args,\n      ),\n      select: ((args?.$select as string[] | undefined) ?? []),\n      excludeRid: !args?.$includeRid,\n    }),\n    { preview: true },\n  );\n  return Promise.resolve({\n    data: await client.objectFactory2(\n      client,\n      result.data,\n      interfaceType.apiName,\n      {},\n      !args.$includeRid,\n      args.$select,\n      false,\n      result.interfaceToObjectTypeMappings,\n    ),\n    nextPageToken: result.nextPageToken,\n    totalCount: result.totalCount,\n  }) as unknown as Promise<FetchPageResult<Q, L, R, S, T>>;\n}\n\n/** @internal */\nexport async function fetchPageInternal<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  A extends Augments,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet,\n  args: FetchPageArgs<Q, L, R, A, S, T> = {},\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  if (objectType.type === \"interface\") {\n    return await fetchInterfacePage(\n      client,\n      objectType,\n      args,\n      objectSet,\n    ) as any; // fixme\n  } else {\n    return await fetchObjectPage(\n      client,\n      objectType,\n      args,\n      objectSet,\n    ) as any; // fixme\n  }\n}\n\n/** @internal */\nexport async function fetchPageWithErrorsInternal<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  A extends Augments,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet,\n  args: FetchPageArgs<Q, L, R, A, S, T> = {},\n): Promise<Result<FetchPageResult<Q, L, R, S, T>>> {\n  try {\n    const result = await fetchPageInternal(client, objectType, objectSet, args);\n    return { value: result };\n  } catch (e) {\n    if (e instanceof Error) {\n      return { error: e };\n    }\n    return { error: e as Error };\n  }\n}\n\n/**\n * @param client\n * @param objectType\n * @param args\n * @param objectSet\n * @returns\n * @internal\n */\nexport async function fetchPage<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  return fetchPageInternal(client, objectType, objectSet, args);\n}\n\n/** @internal */\nexport async function fetchPageWithErrors<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, any, S, T>,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n): Promise<Result<FetchPageResult<Q, L, R, S, T>>> {\n  return fetchPageWithErrorsInternal(client, objectType, objectSet, args);\n}\n\nfunction applyFetchArgs<\n  X extends {\n    orderBy?: SearchOrderByV2;\n    pageToken?: PageToken;\n    pageSize?: PageSize;\n  },\n>(\n  args: FetchPageArgs<any, any, any, any, any, any>,\n  body: X,\n): X {\n  if (args?.$nextPageToken) {\n    body.pageToken = args.$nextPageToken;\n  }\n\n  if (args?.$pageSize != null) {\n    body.pageSize = args.$pageSize;\n  }\n\n  if (args?.$orderBy != null) {\n    body.orderBy = {\n      fields: Object.entries(args.$orderBy).map(([field, direction]) => ({\n        field,\n        direction,\n      })),\n    };\n  }\n\n  return body;\n}\n\n/** @internal */\nexport async function fetchObjectPage<\n  Q extends ObjectTypeDefinition,\n  L extends PropertyKeys<Q>,\n  R extends boolean,\n  S extends NullabilityAdherence,\n  T extends boolean,\n>(\n  client: MinimalClient,\n  objectType: Q,\n  args: FetchPageArgs<Q, L, R, Augments, S, T>,\n  objectSet: ObjectSet,\n): Promise<FetchPageResult<Q, L, R, S, T>> {\n  const r = await OntologiesV2.OntologyObjectSets.load(\n    addUserAgentAndRequestContextHeaders(client, objectType),\n    await client.ontologyRid,\n    applyFetchArgs<LoadObjectSetRequestV2>(args, {\n      objectSet,\n      // We have to do the following case because LoadObjectSetRequestV2 isn't readonly\n      select: ((args?.$select as string[] | undefined) ?? []), // FIXME?\n      excludeRid: !args?.$includeRid,\n    }),\n  );\n\n  return Promise.resolve({\n    data: await client.objectFactory(\n      client,\n      r.data as OntologyObjectV2[],\n      undefined,\n      undefined,\n      await extractRdpDefinition(client, objectSet),\n      args.$select,\n    ),\n    nextPageToken: r.nextPageToken,\n    totalCount: r.totalCount,\n  }) as unknown as Promise<FetchPageResult<Q, L, R, S, T>>;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAwBA,OAAO,KAAKA,YAAY,MAAM,0BAA0B;AAExD,SAASC,oCAAoC,QAAQ,iDAAiD;AACtG,SAASC,oBAAoB,QAAQ,iCAAiC;AACtE,SAASC,wBAAwB,QAAQ,2BAA2B;AAEpE,OAAO,SAASC,OAAOA,CAIrBC,IAAO,EACP,GAAGC,UAAe,EACH;EACf,OAAO;IAAE,CAACD,IAAI,CAACE,OAAO,GAAGD;EAAW,CAAC;AACvC;;AAEA;AACA,OAAO,SAASE,uBAAuBA,CACrCC,SAAoB,EACpBC,eAAuB,EACvBC,aAA4C,GAAGC,SAAS,EACzB;EAC/B,IAAIH,SAAS,CAACJ,IAAI,KAAK,MAAM,IAAII,SAAS,CAACJ,IAAI,KAAK,eAAe,EAAE;IACnE,IAAII,SAAS,CAACJ,IAAI,KAAK,MAAM,IAAII,SAAS,CAACI,UAAU,KAAKH,eAAe,EAAE;MACzE,MAAM,IAAII,KAAK,CACb,uCAAuCJ,eAAe,aAAaD,SAAS,CAACI,UAAU,EACzF,CAAC;IACH;IACA,IACEJ,SAAS,CAACJ,IAAI,KAAK,eAAe,IAC/BI,SAAS,CAACM,aAAa,KAAKL,eAAe,EAC9C;MACA,MAAM,IAAII,KAAK,CACb,uCAAuCJ,eAAe,aAAaD,SAAS,CAACM,aAAa,EAC5F,CAAC;IACH;IAEA,OAAOJ,aAAa;EACtB;EAEA,IAAIF,SAAS,CAACJ,IAAI,KAAK,QAAQ,EAAE;IAC/B,OAAOG,uBAAuB,CAC5BC,SAAS,CAACA,SAAS,EACnBC,eAAe,EACfC,aAAa,IAAI,IAAI,GAAGF,SAAS,CAACO,KAAK,GAAG;MACxCX,IAAI,EAAE,KAAK;MACXY,KAAK,EAAE,CAACN,aAAa,EAAEF,SAAS,CAACO,KAAK;IACxC,CACF,CAAC;EACH;EAEA,MAAM,IAAIF,KAAK,CAAC,+BAA+BL,SAAS,CAACJ,IAAI,EAAE,CAAC;AAClE;;AAEA;AACA,OAAO,SAASa,yBAAyBA,CACvCT,SAAoB,EACpBU,oBAA4B,EAC5BC,IAAiD,EACtC;EACX,OAAOA,IAAI,EAAEC,+BAA+B,GACxC;IACAhB,IAAI,EAAE,WAAW;IACjBiB,UAAU,EAAE,CAACb,SAAS,EAAE;MACtBJ,IAAI,EAAE,eAAe;MACrBU,aAAa,EAAEI,oBAAoB;MACnCI,8BAA8B,EAAE;IAClC,CAAC;EACH,CAAC,GACCd,SAAS;AACf;AAEA,eAAee,kBAAkBA,CAO/BC,MAAqB,EACrBV,aAAgB,EAChBK,IAAuC,EACvCX,SAAoB,EACqB;EACzC,IAAIW,IAAI,CAACM,+BAA+B,EAAE;IACxC,MAAMC,MAAM,GAAG,MAAM3B,YAAY,CAAC4B,kBAAkB,CACjDC,MAAM,CACL5B,oCAAoC,CAACwB,MAAM,EAAEV,aAAa,CAAC,EAC3D,MAAMU,MAAM,CAACK,WAAW,EACxBf,aAAa,CAACR,OAAO,EACrBwB,cAAc,CAAmCX,IAAI,EAAE;MACrDY,mBAAmB,EAAE,CAAC,CAAC;MACvBC,4BAA4B,EAAE,CAAC,CAAC;MAChCC,mBAAmB,EAAE,EAAE;MACvBC,mBAAmB,EAAE,EAAE;MACvBC,2BAA2B,EAAEhB,IAAI,CAACiB,OAAO,IACpC,EAAE;MACPrB,KAAK,EAAER,uBAAuB,CAACC,SAAS,EAAEM,aAAa,CAACR,OAAO;IACjE,CAAC,CAAC,EACF;MAAE+B,OAAO,EAAE;IAAK,CAClB,CAAC;IAEHX,MAAM,CAACY,IAAI,GAAG,MAAMd,MAAM,CAACe,aAAa,CACtCf,MAAM,EACNE,MAAM,CAACY,IAAI;IAAwB;IACnCxB,aAAa,CAACR,OAAO,EACrB,CAACa,IAAI,CAACqB,WAAW,EACjB,MAAMvC,oBAAoB,CAACuB,MAAM,EAAEhB,SAAS,CAC9C,CAAC;IACD,OAAOkB,MAAM;EACf;EACA,MAAMA,MAAM,GAAG,MAAM3B,YAAY,CAAC0C,kBAAkB,CAACC,uBAAuB,CAC1E1C,oCAAoC,CAACwB,MAAM,EAAEV,aAAa,CAAC,EAC3D,MAAMU,MAAM,CAACK,WAAW,EACxBC,cAAc,CAA4CX,IAAI,EAAE;IAC9DX,SAAS,EAAES,yBAAyB,CAClCT,SAAS,EACTM,aAAa,CAACR,OAAO,EACrBa,IACF,CAAC;IACDwB,MAAM,EAAIxB,IAAI,EAAEiB,OAAO,IAA6B,EAAG;IACvDQ,UAAU,EAAE,CAACzB,IAAI,EAAEqB;EACrB,CAAC,CAAC,EACF;IAAEH,OAAO,EAAE;EAAK,CAClB,CAAC;EACD,OAAOQ,OAAO,CAACC,OAAO,CAAC;IACrBR,IAAI,EAAE,MAAMd,MAAM,CAACuB,cAAc,CAC/BvB,MAAM,EACNE,MAAM,CAACY,IAAI,EACXxB,aAAa,CAACR,OAAO,EACrB,CAAC,CAAC,EACF,CAACa,IAAI,CAACqB,WAAW,EACjBrB,IAAI,CAACiB,OAAO,EACZ,KAAK,EACLV,MAAM,CAACsB,6BACT,CAAC;IACDC,aAAa,EAAEvB,MAAM,CAACuB,aAAa;IACnCC,UAAU,EAAExB,MAAM,CAACwB;EACrB,CAAC,CAAC;AACJ;;AAEA;AACA,OAAO,eAAeC,iBAAiBA,CAQrC3B,MAAqB,EACrBZ,UAAa,EACbJ,SAAoB,EACpBW,IAAqC,GAAG,CAAC,CAAC,EACD;EACzC,IAAIP,UAAU,CAACR,IAAI,KAAK,WAAW,EAAE;IACnC,OAAO,MAAMmB,kBAAkB,CAC7BC,MAAM,EACNZ,UAAU,EACVO,IAAI,EACJX,SACF,CAAC,CAAQ,CAAC;EACZ,CAAC,MAAM;IACL,OAAO,MAAM4C,eAAe,CAC1B5B,MAAM,EACNZ,UAAU,EACVO,IAAI,EACJX,SACF,CAAC,CAAQ,CAAC;EACZ;AACF;;AAEA;AACA,OAAO,eAAe6C,2BAA2BA,CAQ/C7B,MAAqB,EACrBZ,UAAa,EACbJ,SAAoB,EACpBW,IAAqC,GAAG,CAAC,CAAC,EACO;EACjD,IAAI;IACF,MAAMO,MAAM,GAAG,MAAMyB,iBAAiB,CAAC3B,MAAM,EAAEZ,UAAU,EAAEJ,SAAS,EAAEW,IAAI,CAAC;IAC3E,OAAO;MAAEH,KAAK,EAAEU;IAAO,CAAC;EAC1B,CAAC,CAAC,OAAO4B,CAAC,EAAE;IACV,IAAIA,CAAC,YAAYzC,KAAK,EAAE;MACtB,OAAO;QAAE0C,KAAK,EAAED;MAAE,CAAC;IACrB;IACA,OAAO;MAAEC,KAAK,EAAED;IAAW,CAAC;EAC9B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeE,SAASA,CAO7BhC,MAAqB,EACrBZ,UAAa,EACbO,IAAuC,EACvCX,SAAoB,GAAGN,wBAAwB,CAACU,UAAU,CAAC,EAClB;EACzC,OAAOuC,iBAAiB,CAAC3B,MAAM,EAAEZ,UAAU,EAAEJ,SAAS,EAAEW,IAAI,CAAC;AAC/D;;AAEA;AACA,OAAO,eAAesC,mBAAmBA,CAOvCjC,MAAqB,EACrBZ,UAAa,EACbO,IAAuC,EACvCX,SAAoB,GAAGN,wBAAwB,CAACU,UAAU,CAAC,EACV;EACjD,OAAOyC,2BAA2B,CAAC7B,MAAM,EAAEZ,UAAU,EAAEJ,SAAS,EAAEW,IAAI,CAAC;AACzE;AAEA,SAASW,cAAcA,CAOrBX,IAAiD,EACjDuC,IAAO,EACJ;EACH,IAAIvC,IAAI,EAAEwC,cAAc,EAAE;IACxBD,IAAI,CAACE,SAAS,GAAGzC,IAAI,CAACwC,cAAc;EACtC;EAEA,IAAIxC,IAAI,EAAE0C,SAAS,IAAI,IAAI,EAAE;IAC3BH,IAAI,CAACI,QAAQ,GAAG3C,IAAI,CAAC0C,SAAS;EAChC;EAEA,IAAI1C,IAAI,EAAE4C,QAAQ,IAAI,IAAI,EAAE;IAC1BL,IAAI,CAACM,OAAO,GAAG;MACbC,MAAM,EAAEC,MAAM,CAACC,OAAO,CAAChD,IAAI,CAAC4C,QAAQ,CAAC,CAACK,GAAG,CAAC,CAAC,CAACC,KAAK,EAAEC,SAAS,CAAC,MAAM;QACjED,KAAK;QACLC;MACF,CAAC,CAAC;IACJ,CAAC;EACH;EAEA,OAAOZ,IAAI;AACb;;AAEA;AACA,OAAO,eAAeN,eAAeA,CAOnC5B,MAAqB,EACrBZ,UAAa,EACbO,IAA4C,EAC5CX,SAAoB,EACqB;EACzC,MAAM+D,CAAC,GAAG,MAAMxE,YAAY,CAAC0C,kBAAkB,CAAC+B,IAAI,CAClDxE,oCAAoC,CAACwB,MAAM,EAAEZ,UAAU,CAAC,EACxD,MAAMY,MAAM,CAACK,WAAW,EACxBC,cAAc,CAAyBX,IAAI,EAAE;IAC3CX,SAAS;IACT;IACAmC,MAAM,EAAIxB,IAAI,EAAEiB,OAAO,IAA6B,EAAG;IAAE;IACzDQ,UAAU,EAAE,CAACzB,IAAI,EAAEqB;EACrB,CAAC,CACH,CAAC;EAED,OAAOK,OAAO,CAACC,OAAO,CAAC;IACrBR,IAAI,EAAE,MAAMd,MAAM,CAACe,aAAa,CAC9Bf,MAAM,EACN+C,CAAC,CAACjC,IAAI,EACN3B,SAAS,EACTA,SAAS,EACT,MAAMV,oBAAoB,CAACuB,MAAM,EAAEhB,SAAS,CAAC,EAC7CW,IAAI,CAACiB,OACP,CAAC;IACDa,aAAa,EAAEsB,CAAC,CAACtB,aAAa;IAC9BC,UAAU,EAAEqB,CAAC,CAACrB;EAChB,CAAC,CAAC;AACJ","ignoreList":[]}