{"version":3,"file":"fetchPage.test.js","names":["Employee","FooInterface","Todo","describe","expect","expectTypeOf","it","createMinimalClient","fetchPage","objectSetToSearchJsonV2","resolveInterfaceObjectSet","createObjectSet","getWireObjectSet","metadata","ontologyRid","branded","toEqualTypeOf","type","objectSet","objectType","where","field","value","undefined","toEqual","client","text","id","$gt","wireObjectSet","fooSpt","$includeAllBaseObjectProperties","objectSets","interfaceType","includeAllBaseObjectProperties","objectSetWithSpecialPropertyTypes","toBeCallableWith","$and","$lte","employeeLocation","$eq","$ne","$isNull","employeeStatus"],"sources":["fetchPage.test.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  FetchPageArgs,\n  FetchPageResult,\n  ObjectTypeDefinition,\n  Osdk,\n  PageResult,\n  PropertyKeys,\n  SelectArgToKeys,\n} from \"@osdk/api\";\nimport { Employee, FooInterface, Todo } from \"@osdk/client.test.ontology\";\nimport type { SearchJsonQueryV2 } from \"@osdk/foundry.ontologies\";\nimport { describe, expect, expectTypeOf, it } from \"vitest\";\nimport { createMinimalClient } from \"../createMinimalClient.js\";\nimport {\n  fetchPage,\n  objectSetToSearchJsonV2,\n  resolveInterfaceObjectSet,\n} from \"../object/fetchPage.js\";\nimport {\n  createObjectSet,\n  getWireObjectSet,\n} from \"../objectSet/createObjectSet.js\";\n\nconst metadata = {\n  ontologyRid: \"asdf\",\n};\ntype TodoDef = Todo;\n\ndescribe(fetchPage, () => {\n  it(\"infers select properly\", () => {\n    // this helper lets us get return types of functions that are generic\n    class Helper<\n      T extends ObjectTypeDefinition,\n      const A extends FetchPageArgs<T>,\n    > {\n      public fetchPage<\n        L extends SelectArgToKeys<T, A>,\n        R extends A[\"$includeRid\"] extends true ? true : false,\n      >() {\n        return fetchPage<\n          T,\n          L & PropertyKeys<T>,\n          R,\n          \"drop\",\n          false\n        >({} as any, {} as any, {} as any);\n      }\n    }\n\n    expectTypeOf<Awaited<ReturnType<Helper<TodoDef, {}>[\"fetchPage\"]>>>()\n      .branded\n      .toEqualTypeOf<PageResult<Osdk<TodoDef, \"$all\">>>();\n\n    // e.g. fetchPage({ select: [] });\n    expectTypeOf<\n      Awaited<ReturnType<Helper<TodoDef, { $select: [] }>[\"fetchPage\"]>>\n    >()\n      .branded\n      .toEqualTypeOf<PageResult<Osdk<TodoDef, \"$all\">>>();\n\n    // e.g. fetchPage()\n    expectTypeOf<\n      Awaited<\n        ReturnType<\n          Helper<TodoDef, FetchPageArgs<TodoDef>>[\"fetchPage\"]\n        >\n      >\n    >()\n      .branded\n      .toEqualTypeOf<PageResult<Osdk<TodoDef, \"$all\">>>();\n\n    // e.g. fetchPage({ $select: [\"text\"]}\n    expectTypeOf<\n      Awaited<\n        ReturnType<Helper<TodoDef, { $select: [\"text\"] }>[\"fetchPage\"]>\n      >\n    >()\n      .branded\n      .toEqualTypeOf<PageResult<Osdk<TodoDef, \"text\">>>();\n  });\n\n  it(\"converts interface objectsets to search properly\", () => {\n    expect(objectSetToSearchJsonV2(\n      {\n        type: \"filter\",\n        objectSet: {\n          type: \"filter\",\n          objectSet: {\n            type: \"base\",\n            objectType: \"Todo\",\n          },\n          where: {\n            type: \"eq\",\n            field: \"text\",\n            value: \"hello\",\n          },\n        },\n\n        where: {\n          type: \"gt\",\n          field: \"id\",\n          value: 2,\n        },\n      },\n      \"Todo\",\n      undefined,\n    )).toEqual(\n      {\n        type: \"and\",\n        value: [\n          {\n            type: \"gt\",\n            field: \"id\",\n            value: 2,\n          },\n          {\n            type: \"eq\",\n            field: \"text\",\n            value: \"hello\",\n          },\n        ],\n      } satisfies SearchJsonQueryV2,\n    );\n  });\n\n  it(\"converts interface objectsets to search properly part 2\", () => {\n    const client = createMinimalClient(\n      metadata,\n      \"https://foo\",\n      async () => \"\",\n    );\n    const objectSet = createObjectSet(Todo, client).where({\n      text: \"hello\",\n    }).where({\n      id: { $gt: 2 },\n    });\n\n    const wireObjectSet = getWireObjectSet(objectSet);\n\n    expect(objectSetToSearchJsonV2(wireObjectSet, \"Todo\", undefined)).toEqual(\n      {\n        type: \"and\",\n        value: [\n          {\n            type: \"gt\",\n            field: \"id\",\n            value: 2,\n          },\n          {\n            type: \"eq\",\n            field: \"text\",\n            value: \"hello\",\n          },\n        ],\n      } satisfies SearchJsonQueryV2,\n    );\n  });\n\n  it(\"converts interface object set for new API correctly\", () => {\n    const client = createMinimalClient(\n      metadata,\n      \"https://foo\",\n      async () => \"\",\n    );\n    const objectSet = createObjectSet(FooInterface, client).where({\n      fooSpt: \"hello\",\n    });\n\n    const wireObjectSet = getWireObjectSet(objectSet);\n\n    expect(\n      resolveInterfaceObjectSet(wireObjectSet, \"FooInterface\", {\n        $includeAllBaseObjectProperties: true,\n      }),\n    ).toEqual(\n      {\n        type: \"intersect\",\n        objectSets: [\n          {\n            type: \"filter\",\n            where: {\n              type: \"eq\",\n              field: \"fooSpt\",\n              value: \"hello\",\n            },\n            objectSet: { interfaceType: \"FooInterface\", type: \"interfaceBase\" },\n          },\n          {\n            type: \"interfaceBase\",\n            interfaceType: \"FooInterface\",\n            includeAllBaseObjectProperties: true,\n          },\n        ],\n      },\n    );\n\n    expect(\n      resolveInterfaceObjectSet(wireObjectSet, \"FooInterface\", {}),\n    ).toEqual(\n      {\n        type: \"filter\",\n        where: {\n          type: \"eq\",\n          field: \"fooSpt\",\n          value: \"hello\",\n        },\n        objectSet: { interfaceType: \"FooInterface\", type: \"interfaceBase\" },\n      },\n    );\n    expect(\n      resolveInterfaceObjectSet(wireObjectSet, \"FooInterface\", {\n        $includeAllBaseObjectProperties: false,\n      }),\n    ).toEqual(\n      {\n        type: \"filter\",\n        where: {\n          type: \"eq\",\n          field: \"fooSpt\",\n          value: \"hello\",\n        },\n        objectSet: { interfaceType: \"FooInterface\", type: \"interfaceBase\" },\n      },\n    );\n  });\n\n  it(\"where clause keys correctly typed\", () => {\n    const client = createMinimalClient(\n      metadata,\n      \"https://foo\",\n      async () => \"\",\n    );\n    const objectSet = createObjectSet(Todo, client);\n    const objectSetWithSpecialPropertyTypes = createObjectSet(Employee, client);\n\n    expectTypeOf(objectSet.where).toBeCallableWith({\n      $and: [{ id: { $gt: 2 } }, { id: { $lte: 2 } }],\n    });\n    expectTypeOf(objectSet.where).toBeCallableWith({\n      // @ts-expect-error\n      id: { $gt: 2, $lte: 2 },\n    });\n\n    // We used to default to number filters for other types, like geotimeseries reference and timeseries. These tests will make sure\n    // we don't do that anymore\n    expectTypeOf(objectSetWithSpecialPropertyTypes.where).toBeCallableWith({\n      $and: [\n        { employeeLocation: { $eq: \"myLocation\" } },\n        {\n          employeeLocation: { $ne: \"notMyLocation\" },\n        },\n        { employeeLocation: { $isNull: false } },\n        // @ts-expect-error\n        { employeeLocation: { $isNull: false, $eq: \"myLocation\" } },\n        // @ts-expect-error\n        { employeeLocation: { $gt: 5 } },\n      ],\n    });\n\n    expectTypeOf(objectSetWithSpecialPropertyTypes.where).toBeCallableWith({\n      $and: [\n        { employeeStatus: { $eq: \"myStatus\" } },\n        {\n          employeeLocation: { $ne: \"notMyStatus\" },\n        },\n        { employeeLocation: { $isNull: false } },\n        // @ts-expect-error\n        { employeeLocation: { $lte: 5 } },\n      ],\n    });\n  });\n\n  describe(\"includeRid\", () => {\n    it(\"properly returns the correct string for includeRid\", () => {\n      expectTypeOf<\n        Awaited<FetchPageResult<TodoDef, \"text\", false, \"throw\", false>>\n      >()\n        .toEqualTypeOf<{\n          data: Osdk<TodoDef, \"text\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n\n      expectTypeOf<\n        Awaited<FetchPageResult<TodoDef, \"text\", true, false, false>>\n      >()\n        .branded\n        .toEqualTypeOf<{\n          data: Osdk<TodoDef, \"text\" | \"$rid\" | \"$notStrict\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n    });\n\n    it(\"works with $all\", () => {\n      expectTypeOf<\n        Awaited<FetchPageResult<TodoDef, \"text\" | \"id\", false, \"drop\", false>>\n      >().branded\n        .toEqualTypeOf<{\n          data: Osdk<TodoDef>[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n\n      expectTypeOf<\n        Awaited<FetchPageResult<TodoDef, \"text\" | \"id\", true, \"drop\", false>>\n      >()\n        .branded\n        .toEqualTypeOf<{\n          data: Osdk<TodoDef, \"$all\" | \"$rid\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n\n      expectTypeOf<\n        Awaited<FetchPageResult<TodoDef, \"text\" | \"id\", true, \"drop\", false>>\n      >()\n        .branded\n        .toEqualTypeOf<{\n          data: Osdk<TodoDef, \"$all\" | \"$rid\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n\n      expectTypeOf<\n        Awaited<FetchPageResult<FooInterface, \"fooSpt\", true, \"drop\", false>>\n      >()\n        .branded\n        .toEqualTypeOf<{\n          data: Osdk<FooInterface, \"$all\" | \"$rid\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n\n      expectTypeOf<\n        Awaited<FetchPageResult<FooInterface, \"fooSpt\", true, \"drop\", false>>\n      >()\n        .branded\n        .toEqualTypeOf<{\n          data: Osdk<FooInterface, \"$all\" | \"$rid\">[];\n          nextPageToken: string | undefined;\n          totalCount: string;\n        }>();\n    });\n  });\n});\n"],"mappings":"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","ignoreList":[]}