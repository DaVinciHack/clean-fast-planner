{"version":3,"file":"createOsdkInterface.js","names":["extractNamespace","InterfaceDefRef","ObjectDefRef","UnderlyingOsdkObject","createOsdkInterface","underlying","interfaceDef","objApiNamespace","apiName","Object","freeze","defineProperties","value","enumerable","$as","$objectType","$primaryKey","$objectSpecifier","$title","$rid","clone","fromEntries","keys","properties","map","p","objDef","apiNamespace","targetPropName","interfaceMap","update","$clone","key","Error","remappedProps","mapProperty","filter","x","propertyName"],"sources":["createOsdkInterface.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { InterfaceMetadata } from \"@osdk/api\";\nimport { extractNamespace } from \"../../internal/conversions/modernToLegacyWhereClause.js\";\nimport type { FetchedObjectTypeDefinition } from \"../../ontology/OntologyProvider.js\";\nimport type { InterfaceHolder } from \"./InterfaceHolder.js\";\nimport {\n  InterfaceDefRef,\n  ObjectDefRef,\n  UnderlyingOsdkObject,\n} from \"./InternalSymbols.js\";\nimport type { ObjectHolder } from \"./ObjectHolder.js\";\n\n/** @internal */\nexport function createOsdkInterface<\n  Q extends FetchedObjectTypeDefinition,\n>(\n  underlying: ObjectHolder,\n  interfaceDef: InterfaceMetadata,\n): InterfaceHolder {\n  const [objApiNamespace] = extractNamespace(interfaceDef.apiName);\n\n  return Object.freeze(\n    Object.defineProperties({}, {\n      // first to minimize hidden classes\n      [UnderlyingOsdkObject]: { value: underlying },\n\n      \"$apiName\": { value: interfaceDef.apiName, enumerable: true },\n      \"$as\": {\n        value: underlying.$as,\n        enumerable: false,\n      },\n      \"$objectType\": {\n        value: underlying.$objectType,\n        enumerable: \"$objectType\" in underlying,\n      },\n      \"$primaryKey\": {\n        value: underlying.$primaryKey,\n        enumerable: \"$primaryKey\" in underlying,\n      },\n      \"$objectSpecifier\": {\n        value: underlying.$objectSpecifier,\n        enumerable: \"$objectSpecifier\" in underlying,\n      },\n      \"$title\": {\n        value: underlying.$title,\n        enumerable: \"$title\" in underlying,\n      },\n      \"$rid\": {\n        value: (underlying as any).$rid,\n        enumerable: \"$rid\" in underlying,\n      },\n      \"$clone\": {\n        value: clone,\n        enumerable: false,\n      },\n\n      [InterfaceDefRef]: { value: interfaceDef },\n\n      ...Object.fromEntries(\n        Object.keys(interfaceDef.properties).map(p => {\n          const objDef = underlying[ObjectDefRef];\n\n          const [apiNamespace, apiName] = extractNamespace(p);\n\n          const targetPropName = objDef\n            .interfaceMap![interfaceDef.apiName][p];\n\n          return [apiNamespace === objApiNamespace ? apiName : p, {\n            enumerable: targetPropName in underlying,\n            value: underlying[targetPropName as keyof typeof underlying],\n          }];\n        }),\n      ),\n    }) as InterfaceHolder,\n  );\n  function clone(update: Record<string, any> | undefined) {\n    if (update == null) {\n      return underlying.$clone().$as(interfaceDef);\n    }\n\n    for (const key of Object.keys(update)) {\n      if (!(key in interfaceDef.properties)) {\n        throw new Error(\n          `Invalid property ${key} for interface ${interfaceDef.apiName}`,\n        );\n      }\n    }\n\n    const remappedProps = Object.fromEntries(\n      Object.keys(update).map(p => mapProperty(p, update[p])).filter(x =>\n        x != null\n      ),\n    );\n\n    return underlying.$clone(remappedProps).$as(interfaceDef);\n  }\n  function mapProperty(propertyName: string, value: any) {\n    const objDef = underlying[ObjectDefRef];\n    const targetPropName =\n      objDef.interfaceMap![interfaceDef.apiName][propertyName];\n    // If the underlying object does not implement the SPT, throw errors\n    if (targetPropName == null) {\n      throw new Error(\n        `Cannot clone interface with ${propertyName} as property is not implemented by the underlying object type ${objDef.apiName}`,\n      );\n    }\n    return [targetPropName, value];\n  }\n}\n"],"mappings":"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","ignoreList":[]}