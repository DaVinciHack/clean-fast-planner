{"version":3,"file":"aggregate.js","names":["OntologiesV2","invariant","legacyToModernSingleAggregationResult","modernToLegacyAggregationClause","modernToLegacyGroupByClause","addUserAgentAndRequestContextHeaders","resolveBaseObjectSetType","aggregate","clientCtx","objectType","objectSet","req","body","aggregation","$select","groupBy","where","undefined","$groupBy","result","OntologyObjectSets","ontologyRid","data","length","process","env","NODE_ENV","aggregationToCountResult","ret","map","entry","$group","group","aggregateResult","metrics","name","$count","value"],"sources":["aggregate.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  AggregateOpts,\n  AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy,\n  AggregationResultsWithGroups,\n  AggregationsResults,\n  ObjectOrInterfaceDefinition,\n} from \"@osdk/api\";\nimport type {\n  AggregateObjectsRequestV2,\n  AggregateObjectsResponseV2,\n  ObjectSet,\n} from \"@osdk/foundry.ontologies\";\nimport * as OntologiesV2 from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\nimport { legacyToModernSingleAggregationResult } from \"../internal/conversions/legacyToModernSingleAggregationResult.js\";\nimport { modernToLegacyAggregationClause } from \"../internal/conversions/modernToLegacyAggregationClause.js\";\nimport { modernToLegacyGroupByClause } from \"../internal/conversions/modernToLegacyGroupByClause.js\";\nimport type { MinimalClient } from \"../MinimalClientContext.js\";\nimport { addUserAgentAndRequestContextHeaders } from \"../util/addUserAgentAndRequestContextHeaders.js\";\nimport type { ArrayElement } from \"../util/ArrayElement.js\";\nimport { resolveBaseObjectSetType } from \"../util/objectSetUtils.js\";\n\n/** @internal */\nexport async function aggregate<\n  Q extends ObjectOrInterfaceDefinition,\n  AO extends AggregateOpts<Q>,\n>(\n  clientCtx: MinimalClient,\n  objectType: Q,\n  objectSet: ObjectSet = resolveBaseObjectSetType(objectType),\n  req: AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy<Q, AO>,\n): Promise<AggregationsResults<Q, AO>> {\n  const resolvedObjectSet = resolveBaseObjectSetType(objectType);\n  const body: AggregateObjectsRequestV2 = {\n    aggregation: modernToLegacyAggregationClause<AO[\"$select\"]>(\n      req.$select,\n    ),\n    groupBy: [],\n    where: undefined,\n  };\n\n  if (req.$groupBy) {\n    body.groupBy = modernToLegacyGroupByClause(req.$groupBy);\n  }\n\n  const result = await OntologiesV2.OntologyObjectSets.aggregate(\n    addUserAgentAndRequestContextHeaders(clientCtx, objectType),\n    await clientCtx.ontologyRid,\n    {\n      objectSet,\n      groupBy: body.groupBy,\n      aggregation: body.aggregation,\n    },\n  );\n\n  if (!req.$groupBy) {\n    invariant(\n      result.data.length === 1,\n      \"no group by clause should mean only one data result\",\n    );\n\n    return {\n      ...aggregationToCountResult(result.data[0]),\n      ...legacyToModernSingleAggregationResult(\n        result.data[0],\n      ),\n    } as any;\n  }\n\n  const ret: AggregationResultsWithGroups<Q, AO[\"$select\"], any> = result.data\n    .map((entry) => {\n      return {\n        $group: entry.group as any,\n        ...aggregationToCountResult(entry),\n        ...legacyToModernSingleAggregationResult(entry),\n      };\n    }) as any; // fixme\n\n  return ret as any; // FIXME\n}\n\nfunction aggregationToCountResult(\n  entry: ArrayElement<AggregateObjectsResponseV2[\"data\"]>,\n): { $count: number } | undefined {\n  for (const aggregateResult of entry.metrics) {\n    if (aggregateResult.name === \"count\") {\n      return { $count: aggregateResult.value };\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAcA,OAAO,KAAKA,YAAY,MAAM,0BAA0B;AACxD,OAAOC,SAAS,MAAM,gBAAgB;AACtC,SAASC,qCAAqC,QAAQ,kEAAkE;AACxH,SAASC,+BAA+B,QAAQ,4DAA4D;AAC5G,SAASC,2BAA2B,QAAQ,wDAAwD;AAEpG,SAASC,oCAAoC,QAAQ,iDAAiD;AAEtG,SAASC,wBAAwB,QAAQ,2BAA2B;;AAEpE;AACA,OAAO,eAAeC,SAASA,CAI7BC,SAAwB,EACxBC,UAAa,EACbC,SAAoB,GAAGJ,wBAAwB,CAACG,UAAU,CAAC,EAC3DE,GAA0E,EACrC;EACXL,wBAAwB,CAACG,UAAU,CAAC;EAC9D,MAAMG,IAA+B,GAAG;IACtCC,WAAW,EAAEV,+BAA+B,CAC1CQ,GAAG,CAACG,OACN,CAAC;IACDC,OAAO,EAAE,EAAE;IACXC,KAAK,EAAEC;EACT,CAAC;EAED,IAAIN,GAAG,CAACO,QAAQ,EAAE;IAChBN,IAAI,CAACG,OAAO,GAAGX,2BAA2B,CAACO,GAAG,CAACO,QAAQ,CAAC;EAC1D;EAEA,MAAMC,MAAM,GAAG,MAAMnB,YAAY,CAACoB,kBAAkB,CAACb,SAAS,CAC5DF,oCAAoC,CAACG,SAAS,EAAEC,UAAU,CAAC,EAC3D,MAAMD,SAAS,CAACa,WAAW,EAC3B;IACEX,SAAS;IACTK,OAAO,EAAEH,IAAI,CAACG,OAAO;IACrBF,WAAW,EAAED,IAAI,CAACC;EACpB,CACF,CAAC;EAED,IAAI,CAACF,GAAG,CAACO,QAAQ,EAAE;IACjB,EACEC,MAAM,CAACG,IAAI,CAACC,MAAM,KAAK,CAAC,IAAAC,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAD1BzB,SAAS,QAEP,qDAAqD,IAFvDA,SAAS;IAKT,OAAO;MACL,GAAG0B,wBAAwB,CAACR,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;MAC3C,GAAGpB,qCAAqC,CACtCiB,MAAM,CAACG,IAAI,CAAC,CAAC,CACf;IACF,CAAC;EACH;EAEA,MAAMM,GAAwD,GAAGT,MAAM,CAACG,IAAI,CACzEO,GAAG,CAAEC,KAAK,IAAK;IACd,OAAO;MACLC,MAAM,EAAED,KAAK,CAACE,KAAY;MAC1B,GAAGL,wBAAwB,CAACG,KAAK,CAAC;MAClC,GAAG5B,qCAAqC,CAAC4B,KAAK;IAChD,CAAC;EACH,CAAC,CAAQ,CAAC,CAAC;;EAEb,OAAOF,GAAG,CAAQ,CAAC;AACrB;AAEA,SAASD,wBAAwBA,CAC/BG,KAAuD,EACvB;EAChC,KAAK,MAAMG,eAAe,IAAIH,KAAK,CAACI,OAAO,EAAE;IAC3C,IAAID,eAAe,CAACE,IAAI,KAAK,OAAO,EAAE;MACpC,OAAO;QAAEC,MAAM,EAAEH,eAAe,CAACI;MAAM,CAAC;IAC1C;EACF;AACF","ignoreList":[]}