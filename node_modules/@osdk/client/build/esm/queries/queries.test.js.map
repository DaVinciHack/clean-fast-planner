{"version":3,"file":"queries.test.js","names":["$Queries","acceptsThreeDimensionalAggregationFunction","acceptsTwoDimensionalAggregationFunction","addOne","Employee","incrementPersonAge","incrementPersonAgeComplex","queryAcceptsObject","queryAcceptsObjectSets","queryTypeReturnsMap","returnsDate","returnsTimestamp","threeDimensionalAggregationFunction","twoDimensionalAggregationFunction","LegacyFauxFoundry","startNodeApiServer","beforeAll","describe","expect","expectTypeOf","it","createClient","client","testSetup","apiServer","close","result","executeFunction","n","toBe","toMatchTypeOf","object","$apiName","$primaryKey","toEqual","$objectType","$objectSpecifier","employee","fetchOne","$title","employeeObjectSet","objectSet","resultWithTimestamp","resultWithDate","person","firstName","lastName","age","toEqualTypeOf","key","value","aggFunction","groups","startValue","endValue","fail","e","message","toMatch","peopleMap","toMatchInlineSnapshot","queries","Object","keys","toStrictEqual","queryTypeReturnsArray","people","result2","version","isFixedVersion"],"sources":["queries.test.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectSet, ObjectSpecifier, OsdkBase } from \"@osdk/api\";\nimport {\n  $Queries,\n  acceptsThreeDimensionalAggregationFunction,\n  acceptsTwoDimensionalAggregationFunction,\n  addOne,\n  Employee,\n  incrementPersonAge,\n  incrementPersonAgeComplex,\n  queryAcceptsObject,\n  queryAcceptsObjectSets,\n  queryTypeReturnsMap,\n  returnsDate,\n  returnsTimestamp,\n  threeDimensionalAggregationFunction,\n  twoDimensionalAggregationFunction,\n} from \"@osdk/client.test.ontology\";\nimport { LegacyFauxFoundry, startNodeApiServer } from \"@osdk/shared.test\";\nimport { beforeAll, describe, expect, expectTypeOf, it } from \"vitest\";\nimport type { Client } from \"../Client.js\";\nimport { createClient } from \"../createClient.js\";\n\ndescribe(\"queries\", () => {\n  let client: Client;\n\n  beforeAll(() => {\n    const testSetup = startNodeApiServer(new LegacyFauxFoundry(), createClient);\n    ({ client } = testSetup);\n    return () => {\n      testSetup.apiServer.close();\n    };\n  });\n\n  it(\"simple query works\", async () => {\n    const result = await client(addOne).executeFunction({ n: 2 });\n    expect(result).toBe(3);\n  });\n\n  describe(\"Queries that accept objects work do not break\", () => {\n    it(\"Works when using $apiName, $primaryKey\", async () => {\n      const fn = client(queryAcceptsObject).executeFunction;\n      type InferredParamType = Parameters<typeof fn>[0];\n      expectTypeOf<{\n        object: {\n          $apiName: \"Employee\";\n          $primaryKey: number;\n        };\n      }>().toMatchTypeOf<InferredParamType>();\n\n      const result = await client(queryAcceptsObject).executeFunction({\n        object: {\n          $apiName: \"Employee\",\n          $primaryKey: 50030,\n        },\n      });\n      expect(result).toEqual({\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      });\n    });\n\n    it(\"Works when using an existing object\", async () => {\n      const employee = await client(Employee).fetchOne(\n        50030,\n      );\n      const result = await client(queryAcceptsObject).executeFunction({\n        object: employee,\n      });\n      expect(result).toEqual({\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      });\n    });\n\n    it(\"Works when using a primary key\", async () => {\n      const result = await client(queryAcceptsObject).executeFunction({\n        object: 50030,\n      });\n      expect(result).toEqual({\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      });\n    });\n\n    it(\"Works when explicitly typing object with OsdkBase\", async () => {\n      /**\n       * We do this test because we used to type object parameters with OsdkBase\n       */\n      const objectQueryParameter = {\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50030,\n        $title: \"Test\",\n        $objectSpecifier: \"Employee:50031\" as ObjectSpecifier<Employee>,\n      } satisfies OsdkBase<Employee>;\n      const result = await client(queryAcceptsObject).executeFunction({\n        object: objectQueryParameter,\n      });\n      expect(result).toEqual({\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      });\n    });\n  });\n\n  it(\"accepts objectSets\", async () => {\n    const employeeObjectSet = client(Employee);\n    const result = await client(queryAcceptsObjectSets).executeFunction({\n      objectSet: employeeObjectSet,\n    });\n\n    expectTypeOf<ObjectSet<Employee>>().toMatchTypeOf<typeof result>();\n  });\n\n  it(\"no params work\", async () => {\n    const resultWithTimestamp = await client(returnsTimestamp)\n      .executeFunction();\n    expect(resultWithTimestamp).toBe(\"2019-01-01T00:00:00.000Z\");\n\n    const resultWithDate = await client(returnsDate).executeFunction();\n    expect(resultWithDate).toBe(\"2019-01-01\");\n  });\n\n  it(\"returns and accepts structs property\", async () => {\n    const result = await client(incrementPersonAge).executeFunction({\n      person: { firstName: \"John\", lastName: \"Doe\", age: 42 },\n    });\n    expect(result).toEqual({\n      firstName: \"John\",\n      lastName: \"Doe\",\n      age: 43,\n    });\n  });\n\n  it(\"returns and accepts complex structs property\", async () => {\n    const employee = await client(Employee).fetchOne(\n      50030,\n    );\n    const result = await client(incrementPersonAgeComplex).executeFunction({\n      person: { firstName: \"John\", lastName: \"Doe\", age: 42, object: employee },\n    });\n    expect(result).toEqual({\n      firstName: \"John\",\n      lastName: \"Doe\",\n      age: 43,\n      object: {\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      },\n    });\n  });\n\n  it(\"two dimensional aggregation response works\", async () => {\n    const result = await client(twoDimensionalAggregationFunction)\n      .executeFunction();\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      { key: string; value: number }[]\n    >;\n    expect(result).toEqual([{ key: \"Q-AFN\", value: 1 }, {\n      key: \"Q-AFO\",\n      value: 2,\n    }]);\n  });\n\n  it(\"two dimensional aggregation request/response works\", async () => {\n    const clientBoundQueryFunction =\n      client(acceptsTwoDimensionalAggregationFunction).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<{ aggFunction: { key: string; value: number }[] }>()\n      .toMatchTypeOf<InferredParamType>();\n\n    const result = await client(acceptsTwoDimensionalAggregationFunction)\n      .executeFunction({\n        aggFunction: [\n          {\n            key: \"testKey1\",\n            value: 1,\n          },\n          {\n            key: \"testKey2\",\n            value: 2,\n          },\n        ],\n      });\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      { key: string; value: number }[]\n    >;\n\n    expect(result).toEqual([{ key: \"responseKey1\", value: 3 }, {\n      key: \"responseKey2\",\n      value: 4,\n    }]);\n  });\n\n  it(\"three dimensional aggregation response works\", async () => {\n    const result = await client(threeDimensionalAggregationFunction)\n      .executeFunction();\n\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      {\n        key: string;\n        groups: {\n          key: { startValue: string | undefined; endValue: string | undefined };\n          value: number;\n        }[];\n      }[]\n    >;\n    expect(result).toEqual([{\n      key: \"Q-AFN\",\n      groups: [{\n        key: {\n          startValue: \"2010-10-01T00:00:00Z\",\n          endValue: \"2010-10-02T00:00:00Z\",\n        },\n        value: 65.0,\n      }],\n    }, { key: \"Q-AFO\", groups: [] }]);\n  });\n\n  it(\"throws when response is null and response is non-nullable\", async () => {\n    try {\n      const result = await client(addOne).executeFunction({ n: 3 });\n      expect.fail(\"Should not reach here\");\n    } catch (e) {\n      expect((e as Error).message).toMatch(\n        `Got null response when nullable was not allowed`,\n      );\n    }\n  });\n\n  it(\"three dimensional aggregation request/response works\", async () => {\n    const clientBoundQueryFunction =\n      client(acceptsThreeDimensionalAggregationFunction).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<{\n      aggFunction: {\n        key: string;\n        groups: {\n          key: { startValue: string | undefined; endValue: string };\n          value: number;\n        }[];\n      }[];\n    }>()\n      .toMatchTypeOf<InferredParamType>();\n\n    const result = await client(acceptsThreeDimensionalAggregationFunction)\n      .executeFunction({\n        aggFunction: [\n          {\n            key: \"testKey1\",\n            groups: [\n              {\n                key: {\n                  startValue: \"2010-10-01T00:00:00Z\",\n                  endValue: \"2010-10-02T00:00:00Z\",\n                },\n                value: 65.0,\n              },\n            ],\n          },\n          {\n            key: \"testKey2\",\n            groups: [],\n          },\n        ],\n      });\n\n    expect(result).toEqual([\n      {\n        key: \"Q-AFN\",\n        groups: [\n          {\n            key: {\n              startValue: \"2010-10-01T00:00:00Z\",\n              endValue: \"2010-10-02T00:00:00Z\",\n            },\n            value: 65.0,\n          },\n        ],\n      },\n      {\n        key: \"Q-AFO\",\n        groups: [],\n      },\n    ]);\n  });\n\n  it(\"map type request and response works\", async () => {\n    const clientBoundQueryFunction =\n      client(queryTypeReturnsMap).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<InferredParamType>()\n      .toMatchTypeOf<\n        { peopleMap: Partial<Record<ObjectSpecifier<Employee>, string>> }\n      >();\n\n    const myMap: Record<ObjectSpecifier<Employee>, string> = {\n      [\"Employee:person1\" as any]: \"hi\",\n    };\n    const result = await client(queryTypeReturnsMap).executeFunction({\n      peopleMap: myMap,\n    });\n\n    expect(result).toMatchInlineSnapshot(`\n      {\n        \"Employee:50030\": \"bye\",\n      }\n    `);\n\n    expectTypeOf<typeof result>().toMatchTypeOf<\n      Partial<Record<ObjectSpecifier<Employee>, number>>\n    >();\n\n    const object = await client(Employee).fetchOne(50030);\n\n    const value = result[object.$objectSpecifier];\n\n    expect(value).toBe(\"bye\");\n  });\n\n  it(\"accepts and returns objects\", async () => {\n    const employeeObjectSet = client(Employee);\n    const result = await client(queryAcceptsObjectSets).executeFunction({\n      objectSet: employeeObjectSet,\n    });\n\n    expectTypeOf<ObjectSet<Employee>>().toMatchTypeOf<typeof result>();\n  });\n  it(\"queries are enumerable\", async () => {\n    const queries = Object.keys($Queries);\n    expect(queries).toStrictEqual([\n      \"acceptsThreeDimensionalAggregationFunction\",\n      \"acceptsTwoDimensionalAggregationFunction\",\n      \"addOne\",\n      \"incrementPersonAge\",\n      \"incrementPersonAgeComplex\",\n      \"queryAcceptsObject\",\n      \"queryAcceptsObjectSets\",\n      \"queryTypeReturnsArray\",\n      \"queryTypeReturnsMap\",\n      \"returnsDate\",\n      \"returnsObject\",\n      \"returnsTimestamp\",\n      \"threeDimensionalAggregationFunction\",\n      \"twoDimensionalAggregationFunction\",\n    ]);\n  });\n\n  it(\"queries work with arrays\", async () => {\n    const result = await client($Queries.queryTypeReturnsArray).executeFunction(\n      { people: [\"Brad\", \"George\", \"Ryan\"] },\n    );\n    expect(result).toEqual([\"Pitt\", \"Clooney\", \"Reynolds\"]);\n  });\n\n  it(\"pinned queries call execute with the right version\", async () => {\n    const result = await client($Queries.addOne).executeFunction({\n      n: 2,\n    });\n    expect(result).toEqual(3);\n\n    const result2 = await client({ ...$Queries.addOne, version: \"0.0.1\" })\n      .executeFunction({\n        n: 6,\n      });\n    expect(result2).toEqual(7);\n  });\n\n  it(\"non-pinned queries call execute with the right version\", async () => {\n    // The stubbed data for version 0.0.5 does not exist. This test passes\n    // because executeQuery is called without a version and our stubs resolve to latest.\n    const result2 = await client({\n      ...$Queries.addOne,\n      version: \"0.0.5\",\n      isFixedVersion: false,\n    })\n      .executeFunction({\n        n: 2,\n      });\n    expect(result2).toEqual(3);\n  });\n});\n"],"mappings":"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","ignoreList":[]}