{"version":3,"file":"queries.test.js","names":["$Queries","acceptsThreeDimensionalAggregationFunction","acceptsTwoDimensionalAggregationFunction","addOne","Employee","incrementPersonAge","incrementPersonAgeComplex","queryAcceptsObject","queryAcceptsObjectSets","queryTypeReturnsMap","returnsDate","returnsTimestamp","threeDimensionalAggregationFunction","twoDimensionalAggregationFunction","LegacyFauxFoundry","startNodeApiServer","beforeAll","describe","expect","expectTypeOf","it","createClient","client","testSetup","apiServer","close","result","executeFunction","n","toBe","employee","fetchOne","object","toEqual","$apiName","$objectType","$primaryKey","$objectSpecifier","result2","employeeObjectSet","objectSet","toMatchTypeOf","resultWithTimestamp","resultWithDate","person","firstName","lastName","age","toEqualTypeOf","key","value","aggFunction","groups","startValue","endValue","fail","e","message","toMatch","peopleMap","toMatchInlineSnapshot","queries","Object","keys","toStrictEqual","queryTypeReturnsArray","people"],"sources":["queries.test.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectSet, ObjectSpecifier } from \"@osdk/api\";\nimport {\n  $Queries,\n  acceptsThreeDimensionalAggregationFunction,\n  acceptsTwoDimensionalAggregationFunction,\n  addOne,\n  Employee,\n  incrementPersonAge,\n  incrementPersonAgeComplex,\n  queryAcceptsObject,\n  queryAcceptsObjectSets,\n  queryTypeReturnsMap,\n  returnsDate,\n  returnsTimestamp,\n  threeDimensionalAggregationFunction,\n  twoDimensionalAggregationFunction,\n} from \"@osdk/client.test.ontology\";\nimport { LegacyFauxFoundry, startNodeApiServer } from \"@osdk/shared.test\";\nimport { beforeAll, describe, expect, expectTypeOf, it } from \"vitest\";\nimport type { Client } from \"../Client.js\";\nimport { createClient } from \"../createClient.js\";\n\ndescribe(\"queries\", () => {\n  let client: Client;\n\n  beforeAll(() => {\n    const testSetup = startNodeApiServer(new LegacyFauxFoundry(), createClient);\n    ({ client } = testSetup);\n    return () => {\n      testSetup.apiServer.close();\n    };\n  });\n\n  it(\"simple query works\", async () => {\n    const result = await client(addOne).executeFunction({ n: 2 });\n    expect(result).toBe(3);\n  });\n\n  it(\"accepts objects\", async () => {\n    const employee = await client(Employee).fetchOne(\n      50030,\n    );\n    const result = await client(queryAcceptsObject).executeFunction({\n      object: employee,\n    });\n    expect(result).toEqual({\n      $apiName: \"Employee\",\n      $objectType: \"Employee\",\n      $primaryKey: 50031,\n      $objectSpecifier: \"Employee:50031\",\n    });\n\n    // Should also accept primary keys\n    const result2 = await client(queryAcceptsObject).executeFunction({\n      object: 50030,\n    });\n    expect(result2).toEqual({\n      $apiName: \"Employee\",\n      $objectType: \"Employee\",\n      $primaryKey: 50031,\n      $objectSpecifier: \"Employee:50031\",\n    });\n  });\n\n  it(\"accepts objectSets\", async () => {\n    const employeeObjectSet = client(Employee);\n    const result = await client(queryAcceptsObjectSets).executeFunction({\n      objectSet: employeeObjectSet,\n    });\n\n    expectTypeOf<ObjectSet<Employee>>().toMatchTypeOf<typeof result>();\n  });\n\n  it(\"no params work\", async () => {\n    const resultWithTimestamp = await client(returnsTimestamp)\n      .executeFunction();\n    expect(resultWithTimestamp).toBe(\"2019-01-01T00:00:00.000Z\");\n\n    const resultWithDate = await client(returnsDate).executeFunction();\n    expect(resultWithDate).toBe(\"2019-01-01\");\n  });\n\n  it(\"returns and accepts structs property\", async () => {\n    const result = await client(incrementPersonAge).executeFunction({\n      person: { firstName: \"John\", lastName: \"Doe\", age: 42 },\n    });\n    expect(result).toEqual({\n      firstName: \"John\",\n      lastName: \"Doe\",\n      age: 43,\n    });\n  });\n\n  it(\"returns and accepts complex structs property\", async () => {\n    const employee = await client(Employee).fetchOne(\n      50030,\n    );\n    const result = await client(incrementPersonAgeComplex).executeFunction({\n      person: { firstName: \"John\", lastName: \"Doe\", age: 42, object: employee },\n    });\n    expect(result).toEqual({\n      firstName: \"John\",\n      lastName: \"Doe\",\n      age: 43,\n      object: {\n        $apiName: \"Employee\",\n        $objectType: \"Employee\",\n        $primaryKey: 50031,\n        $objectSpecifier: \"Employee:50031\",\n      },\n    });\n  });\n\n  it(\"two dimensional aggregation response works\", async () => {\n    const result = await client(twoDimensionalAggregationFunction)\n      .executeFunction();\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      { key: string; value: number }[]\n    >;\n    expect(result).toEqual([{ key: \"Q-AFN\", value: 1 }, {\n      key: \"Q-AFO\",\n      value: 2,\n    }]);\n  });\n\n  it(\"two dimensional aggregation request/response works\", async () => {\n    const clientBoundQueryFunction =\n      client(acceptsTwoDimensionalAggregationFunction).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<{ aggFunction: { key: string; value: number }[] }>()\n      .toMatchTypeOf<InferredParamType>();\n\n    const result = await client(acceptsTwoDimensionalAggregationFunction)\n      .executeFunction({\n        aggFunction: [\n          {\n            key: \"testKey1\",\n            value: 1,\n          },\n          {\n            key: \"testKey2\",\n            value: 2,\n          },\n        ],\n      });\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      { key: string; value: number }[]\n    >;\n\n    expect(result).toEqual([{ key: \"responseKey1\", value: 3 }, {\n      key: \"responseKey2\",\n      value: 4,\n    }]);\n  });\n\n  it(\"three dimensional aggregation response works\", async () => {\n    const result = await client(threeDimensionalAggregationFunction)\n      .executeFunction();\n\n    expectTypeOf<typeof result>().toEqualTypeOf<\n      {\n        key: string;\n        groups: {\n          key: { startValue: string | undefined; endValue: string | undefined };\n          value: number;\n        }[];\n      }[]\n    >;\n    expect(result).toEqual([{\n      key: \"Q-AFN\",\n      groups: [{\n        key: {\n          startValue: \"2010-10-01T00:00:00Z\",\n          endValue: \"2010-10-02T00:00:00Z\",\n        },\n        value: 65.0,\n      }],\n    }, { key: \"Q-AFO\", groups: [] }]);\n  });\n\n  it(\"throws when response is null and response is non-nullable\", async () => {\n    try {\n      const result = await client(addOne).executeFunction({ n: 3 });\n      expect.fail(\"Should not reach here\");\n    } catch (e) {\n      expect((e as Error).message).toMatch(\n        `Got null response when nullable was not allowed`,\n      );\n    }\n  });\n\n  it(\"three dimensional aggregation request/response works\", async () => {\n    const clientBoundQueryFunction =\n      client(acceptsThreeDimensionalAggregationFunction).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<{\n      aggFunction: {\n        key: string;\n        groups: {\n          key: { startValue: string | undefined; endValue: string };\n          value: number;\n        }[];\n      }[];\n    }>()\n      .toMatchTypeOf<InferredParamType>();\n\n    const result = await client(acceptsThreeDimensionalAggregationFunction)\n      .executeFunction({\n        aggFunction: [\n          {\n            key: \"testKey1\",\n            groups: [\n              {\n                key: {\n                  startValue: \"2010-10-01T00:00:00Z\",\n                  endValue: \"2010-10-02T00:00:00Z\",\n                },\n                value: 65.0,\n              },\n            ],\n          },\n          {\n            key: \"testKey2\",\n            groups: [],\n          },\n        ],\n      });\n\n    expect(result).toEqual([\n      {\n        key: \"Q-AFN\",\n        groups: [\n          {\n            key: {\n              startValue: \"2010-10-01T00:00:00Z\",\n              endValue: \"2010-10-02T00:00:00Z\",\n            },\n            value: 65.0,\n          },\n        ],\n      },\n      {\n        key: \"Q-AFO\",\n        groups: [],\n      },\n    ]);\n  });\n\n  it(\"map type request and response works\", async () => {\n    const clientBoundQueryFunction =\n      client(queryTypeReturnsMap).executeFunction;\n    type InferredParamType = Parameters<\n      typeof clientBoundQueryFunction\n    >[0];\n\n    expectTypeOf<InferredParamType>()\n      .toMatchTypeOf<\n        { peopleMap: Record<ObjectSpecifier<Employee>, string> }\n      >();\n\n    const myMap: Record<ObjectSpecifier<Employee>, string> = {\n      [\"Employee:person1\" as any]: \"hi\",\n    };\n    const result = await client(queryTypeReturnsMap).executeFunction({\n      peopleMap: myMap,\n    });\n\n    expect(result).toMatchInlineSnapshot(`\n      {\n        \"Employee:50030\": \"bye\",\n      }\n    `);\n\n    expectTypeOf<typeof result>().toMatchTypeOf<\n      Record<ObjectSpecifier<Employee>, number>\n    >();\n\n    const object = await client(Employee).fetchOne(50030);\n\n    const value = result[object.$objectSpecifier];\n\n    expect(value).toBe(\"bye\");\n  });\n\n  it(\"accepts and returns objects\", async () => {\n    const employeeObjectSet = client(Employee);\n    const result = await client(queryAcceptsObjectSets).executeFunction({\n      objectSet: employeeObjectSet,\n    });\n\n    expectTypeOf<ObjectSet<Employee>>().toMatchTypeOf<typeof result>();\n  });\n  it(\"queries are enumerable\", async () => {\n    const queries = Object.keys($Queries);\n    expect(queries).toStrictEqual([\n      \"acceptsThreeDimensionalAggregationFunction\",\n      \"acceptsTwoDimensionalAggregationFunction\",\n      \"addOne\",\n      \"incrementPersonAge\",\n      \"incrementPersonAgeComplex\",\n      \"queryAcceptsObject\",\n      \"queryAcceptsObjectSets\",\n      \"queryTypeReturnsArray\",\n      \"queryTypeReturnsMap\",\n      \"returnsDate\",\n      \"returnsObject\",\n      \"returnsTimestamp\",\n      \"threeDimensionalAggregationFunction\",\n      \"twoDimensionalAggregationFunction\",\n    ]);\n  });\n\n  it(\"queries work with arrays\", async () => {\n    const result = await client($Queries.queryTypeReturnsArray).executeFunction(\n      { people: [\"Brad\", \"George\", \"Ryan\"] },\n    );\n    expect(result).toEqual([\"Pitt\", \"Clooney\", \"Reynolds\"]);\n  });\n});\n"],"mappings":"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","ignoreList":[]}