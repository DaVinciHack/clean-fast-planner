{"version":3,"file":"createWithPropertiesObjectSet.test.js","names":["Employee","describe","expect","it","createWithPropertiesObjectSet","map","Map","deriveObjectSet","type","result","base","pivotTo","selectProperty","definition","get","toMatchInlineSnapshot","clause","aggregate","percentile","limit","secondResult","secondDefinition","add","extractPart","min"],"sources":["createWithPropertiesObjectSet.test.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { DerivedProperty } from \"@osdk/api\";\nimport { Employee } from \"@osdk/client.test.ontology\";\nimport type { DerivedPropertyDefinition } from \"@osdk/foundry.ontologies\";\nimport { describe, expect, it } from \"vitest\";\nimport { createWithPropertiesObjectSet } from \"./createWithPropertiesObjectSet.js\";\n\ndescribe(createWithPropertiesObjectSet, () => {\n  it(\"correctly creates basic object set with derived properties\", () => {\n    const map = new Map<any, DerivedPropertyDefinition>();\n    const deriveObjectSet = createWithPropertiesObjectSet(Employee, {\n      type: \"methodInput\",\n    }, map);\n\n    const clause = {\n      \"derivedPropertyName\": (base) =>\n        base.pivotTo(\"lead\").selectProperty(\"employeeId\"),\n    } satisfies DerivedProperty.Clause<Employee>;\n\n    const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n    const definition = map.get(result);\n    expect(definition).toMatchInlineSnapshot(`\n        {\n          \"objectSet\": {\n            \"link\": \"lead\",\n            \"objectSet\": {\n              \"type\": \"methodInput\",\n            },\n            \"type\": \"searchAround\",\n          },\n          \"operation\": {\n            \"selectedPropertyApiName\": \"employeeId\",\n            \"type\": \"get\",\n          },\n          \"type\": \"selection\",\n        }\n      `);\n  });\n\n  it(\"correctly allows select property off the base object set\", () => {\n    const map = new Map<any, DerivedPropertyDefinition>();\n    const deriveObjectSet = createWithPropertiesObjectSet(\n      Employee,\n      {\n        type: \"methodInput\",\n      },\n      map,\n      true,\n    );\n\n    const clause = {\n      \"derivedPropertyName\": (base) => base.selectProperty(\"employeeId\"),\n    } satisfies DerivedProperty.Clause<Employee>;\n\n    const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n    const definition = map.get(result);\n    expect(definition).toMatchInlineSnapshot(`\n      {\n        \"apiName\": \"employeeId\",\n        \"type\": \"property\",\n      }\n    `);\n  });\n\n  it(\"correctly handles multiple definitions in one clause\", () => {\n    const map = new Map<any, DerivedPropertyDefinition>();\n    const deriveObjectSet = createWithPropertiesObjectSet(Employee, {\n      type: \"methodInput\",\n    }, map);\n\n    const clause: DerivedProperty.Clause<Employee> = {\n      \"derivedPropertyName\": (base) =>\n        base.pivotTo(\"lead\").aggregate(\"employeeId:approximatePercentile\", {\n          percentile: 0.5,\n        }),\n\n      \"secondaryDerivedPropertyName\": (base) =>\n        base.pivotTo(\"lead\").aggregate(\"fullName:collectSet\", {\n          limit: 10,\n        }),\n    };\n\n    const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n    const definition = map.get(result);\n\n    const secondResult = clause[\"secondaryDerivedPropertyName\"](\n      deriveObjectSet,\n    );\n    const secondDefinition = map.get(secondResult);\n\n    expect(definition).toMatchInlineSnapshot(`\n        {\n          \"objectSet\": {\n            \"link\": \"lead\",\n            \"objectSet\": {\n              \"type\": \"methodInput\",\n            },\n            \"type\": \"searchAround\",\n          },\n          \"operation\": {\n            \"approximatePercentile\": 0.5,\n            \"selectedPropertyApiName\": \"employeeId\",\n            \"type\": \"approximatePercentile\",\n          },\n          \"type\": \"selection\",\n        }\n      `);\n\n    expect(secondDefinition).toMatchInlineSnapshot(`\n        {\n          \"objectSet\": {\n            \"link\": \"lead\",\n            \"objectSet\": {\n              \"type\": \"methodInput\",\n            },\n            \"type\": \"searchAround\",\n          },\n          \"operation\": {\n            \"limit\": 10,\n            \"selectedPropertyApiName\": \"fullName\",\n            \"type\": \"collectSet\",\n          },\n          \"type\": \"selection\",\n        }\n      `);\n  });\n\n  describe(\"expressions\", () => {\n    it(\"can handle expressions referencing other property keys\", () => {\n      const map = new Map<any, DerivedPropertyDefinition>();\n      const deriveObjectSet = createWithPropertiesObjectSet(\n        Employee,\n        {\n          type: \"methodInput\",\n        },\n        map,\n        true,\n      );\n\n      const clause: DerivedProperty.Clause<Employee> = {\n        \"derivedPropertyName\": (base) =>\n          base.pivotTo(\"lead\").selectProperty(\"employeeId\").add(\n            base.selectProperty(\"employeeId\"),\n          ),\n        // \"secondaryDerivedPropertyName\": (base) =>\n        //   base.pivotTo(\"lead\").aggregate(\"employeeId:avg\").divide(\"employeeId\", 2),\n      };\n\n      const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n      const definition = map.get(result);\n\n      expect(definition).toMatchInlineSnapshot(`\n        {\n          \"properties\": [\n            {\n              \"objectSet\": {\n                \"link\": \"lead\",\n                \"objectSet\": {\n                  \"type\": \"methodInput\",\n                },\n                \"type\": \"searchAround\",\n              },\n              \"operation\": {\n                \"selectedPropertyApiName\": \"employeeId\",\n                \"type\": \"get\",\n              },\n              \"type\": \"selection\",\n            },\n            {\n              \"apiName\": \"employeeId\",\n              \"type\": \"property\",\n            },\n          ],\n          \"type\": \"add\",\n        }\n      `);\n    });\n\n    // TODO: Add test for literal\n    it(\"can handle nested definitions in an expression\", () => {\n      const map = new Map<any, DerivedPropertyDefinition>();\n      const deriveObjectSet = createWithPropertiesObjectSet(Employee, {\n        type: \"methodInput\",\n      }, map);\n\n      const clause: DerivedProperty.Clause<Employee> = {\n        \"derivedPropertyName\": (base) =>\n          base.pivotTo(\"lead\").selectProperty(\"employeeId\").add(\n            base.pivotTo(\"lead\").selectProperty(\"employeeId\"),\n          ),\n      };\n\n      const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n      const definition = map.get(result);\n\n      expect(definition).toMatchInlineSnapshot(`\n        {\n          \"properties\": [\n            {\n              \"objectSet\": {\n                \"link\": \"lead\",\n                \"objectSet\": {\n                  \"type\": \"methodInput\",\n                },\n                \"type\": \"searchAround\",\n              },\n              \"operation\": {\n                \"selectedPropertyApiName\": \"employeeId\",\n                \"type\": \"get\",\n              },\n              \"type\": \"selection\",\n            },\n            {\n              \"objectSet\": {\n                \"link\": \"lead\",\n                \"objectSet\": {\n                  \"type\": \"methodInput\",\n                },\n                \"type\": \"searchAround\",\n              },\n              \"operation\": {\n                \"selectedPropertyApiName\": \"employeeId\",\n                \"type\": \"get\",\n              },\n              \"type\": \"selection\",\n            },\n          ],\n          \"type\": \"add\",\n        }\n      `);\n    });\n  });\n\n  it(\"handles datetime expressions\", () => {\n    const map = new Map<any, DerivedPropertyDefinition>();\n    const deriveObjectSet = createWithPropertiesObjectSet(Employee, {\n      type: \"methodInput\",\n    }, map);\n\n    const clause: DerivedProperty.Clause<Employee> = {\n      \"derivedPropertyName\": (base) =>\n        base.pivotTo(\"lead\").selectProperty(\"startDate\").extractPart(\"MONTHS\"),\n      \"secondaryDerivedPropertyName\": (base) =>\n        base.pivotTo(\"lead\").selectProperty(\"startDate\").min(\n          base.pivotTo(\"lead\").selectProperty(\"startDate\"),\n        ),\n    };\n\n    const result = clause[\"derivedPropertyName\"](deriveObjectSet);\n    const definition = map.get(result);\n\n    expect(definition).toMatchInlineSnapshot(`\n      {\n        \"part\": \"MONTHS\",\n        \"property\": {\n          \"objectSet\": {\n            \"link\": \"lead\",\n            \"objectSet\": {\n              \"type\": \"methodInput\",\n            },\n            \"type\": \"searchAround\",\n          },\n          \"operation\": {\n            \"selectedPropertyApiName\": \"startDate\",\n            \"type\": \"get\",\n          },\n          \"type\": \"selection\",\n        },\n        \"type\": \"extract\",\n      }\n    `);\n  });\n});\n"],"mappings":"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","ignoreList":[]}