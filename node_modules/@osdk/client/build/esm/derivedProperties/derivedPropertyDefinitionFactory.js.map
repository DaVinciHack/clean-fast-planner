{"version":3,"file":"derivedPropertyDefinitionFactory.js","names":["invariant","derivedPropertyDefinitionFactory","wireDefinition","definitionMap","definition","abs","type","property","negate","max","value","properties","getDefinitionFromMap","min","add","subtract","multiply","divide","extractPart","part","set","arg","get","process","env","NODE_ENV"],"sources":["derivedPropertyDefinitionFactory.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { DerivedProperty } from \"@osdk/api\";\nimport type { DerivedPropertyDefinition } from \"@osdk/foundry.ontologies\";\nimport invariant from \"tiny-invariant\";\n\n/** @internal */\nexport function derivedPropertyDefinitionFactory(\n  wireDefinition: DerivedPropertyDefinition,\n  definitionMap: Map<any, DerivedPropertyDefinition>,\n): DerivedProperty.NumericPropertyDefinition<any, any> & {\n  extractPart: DerivedProperty.DatetimePropertyDefinition<\n    any,\n    any\n  >[\"extractPart\"];\n} {\n  type RemoveSymbolKeys<T> = {\n    [K in keyof T as K extends symbol ? never : K]: T[K];\n  };\n\n  const definition:\n    & RemoveSymbolKeys<DerivedProperty.NumericPropertyDefinition<any, any>>\n    & {\n      extractPart: DerivedProperty.DatetimePropertyDefinition<\n        any,\n        any\n      >[\"extractPart\"];\n    } = {\n      abs() {\n        return derivedPropertyDefinitionFactory({\n          type: \"absoluteValue\",\n          property: wireDefinition,\n        }, definitionMap);\n      },\n      negate() {\n        return derivedPropertyDefinitionFactory({\n          type: \"negate\",\n          property: wireDefinition,\n        }, definitionMap);\n      },\n      max(value) {\n        return derivedPropertyDefinitionFactory({\n          type: \"greatest\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      min(value) {\n        return derivedPropertyDefinitionFactory({\n          type: \"least\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      add(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          type: \"add\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      subtract(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          \"type\": \"subtract\",\n          \"left\": wireDefinition,\n          \"right\": getDefinitionFromMap(value, definitionMap),\n        }, definitionMap);\n      },\n      multiply(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          type: \"multiply\",\n          properties: [\n            wireDefinition,\n            getDefinitionFromMap(value, definitionMap),\n          ],\n        }, definitionMap);\n      },\n      divide(\n        value,\n      ) {\n        return derivedPropertyDefinitionFactory({\n          \"type\": \"subtract\",\n          \"left\": wireDefinition,\n          \"right\": getDefinitionFromMap(value, definitionMap),\n        }, definitionMap);\n      },\n      extractPart: (part) => {\n        return derivedPropertyDefinitionFactory({\n          type: \"extract\",\n          part,\n          property: wireDefinition,\n        }, definitionMap);\n      },\n    };\n\n  definitionMap.set(definition, wireDefinition);\n  return definition as any;\n}\n\nconst getDefinitionFromMap = (\n  arg: string | number | DerivedProperty.Definition<any, any>,\n  definitionMap: Map<any, DerivedPropertyDefinition>,\n): DerivedPropertyDefinition => {\n  if (typeof arg === \"object\") {\n    const definition = definitionMap.get(arg);\n    invariant(definition, \"Derived Property is not defined\");\n    return definition;\n  } else if (typeof arg === \"number\") {\n    invariant(false, \"Literals for derived properties are not yet supported\");\n  }\n  invariant(false, \"Invalid argument type for a derived property\");\n};\n"],"mappings":"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","ignoreList":[]}