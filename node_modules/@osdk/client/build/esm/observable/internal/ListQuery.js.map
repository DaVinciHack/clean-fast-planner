{"version":3,"file":"ListQuery.js","names":["deepEqual","groupBy","auditTime","combineLatest","connectable","map","of","ReplaySubject","switchMap","invariant","additionalContext","ObjectDefRef","UnderlyingOsdkObject","DEBUG_ONLY__cacheKeysToString","DEBUG_ONLY__changesToString","objectSortaMatchesWhereClause","objectMatchesWhereClause","storeOsdkInstances","Query","API_NAME_IDX","TYPE_IDX","WHERE_IDX","ORDER_BY_IDX","BaseListQuery","_updateList","objectCacheKeys","append","status","batch","process","env","NODE_ENV","logger","child","methodName","debug","JSON","stringify","retainReleaseAppend","_sortCacheKeys","removeDuplicates","writeToStore","data","entry","read","cacheKey","value","write","ret","changes","registerList","#retainReleaseAppend","existingList","optimisticWrite","objectCacheKey","store","release","retain","_dispose","console","log","ListQuery","type","apiName","whereClause","minNumResults","nextPageToken","pendingPageFetch","orderBy","objectSet","sortFns","constructor","subject","apiType","opts","client","msgPrefix","otherKeys","x","join","undefined","where","createOrderBySortFns","canonicalWhere","_createConnectable","pipe","listEntry","resolvedList","getSubject","objectEntry","isOptimistic","fetchMore","hasMore","lastUpdated","resetOnDisconnect","connector","_preFetch","_fetchAndStore","info","fetchPageAndUpdate","abortController","signal","count","length","setStatus","Promise","resolve","pendingFetch","res","finally","#fetchPageAndUpdate","fetchPage","$nextPageToken","$pageSize","options","pageSize","Object","keys","$orderBy","aborted","reloadDataAsFullObjects","retVal","e","error","revalidateObjectType","revalidate","objectMetadata","fetchMetadata","interfaceMap","maybeUpdateAndRevalidate","optimisticId","modified","has","add","relevantObjects","_extractRelevantObjects","added","all","sortaMatches","size","newList","needsRevalidation","Set","toAdd","strictMatches","toRemove","obj","getCacheKey","$objectType","$primaryKey","existingObjectCacheKey","key","push","extractRelevantObjectsForTypeObject","extractRelevantObjectsForTypeInterface","group","values","strictMatch","sortaMatch","#extractRelevantObjectsForTypeInterface","Array","from","addedObjects","filter","object","$as","modifiedObjects","#extractRelevantObjectsForTypeObject","get","sort","a","b","sortFn","registerStreamUpdates","sub","websocketSubscription","subscribe","onChange","onOswChange","bind","onError","onOswError","onOutOfDate","onOswOutOfDate","onSuccessfulSubscription","onOswSuccessfulSubscription","unsubscribe","#onOswSuccessfulSubscription","#onOswOutOfDate","#onOswError","errors","#onOswChange","objOrIface","state","$apiName","onOswRemoved","#onOswRemoved","existing","newObjects","o","catch","visited","entries","order","aValue","bValue","m","groups","objectTypeToPrimaryKeyToObject","fromEntries","objects","objectDef","primaryKeyApiName","$in","result","isListCacheKey"],"sources":["ListQuery.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  Logger,\n  ObjectOrInterfaceDefinition,\n  ObjectSet,\n  ObjectTypeDefinition,\n  Osdk,\n  PropertyKeys,\n} from \"@osdk/api\";\nimport deepEqual from \"fast-deep-equal\";\nimport groupBy from \"object.groupby\";\nimport type { Connectable, Observable, Subscription } from \"rxjs\";\nimport {\n  auditTime,\n  combineLatest,\n  connectable,\n  map,\n  of,\n  ReplaySubject,\n  switchMap,\n} from \"rxjs\";\nimport invariant from \"tiny-invariant\";\nimport { additionalContext, type Client } from \"../../Client.js\";\nimport type { InterfaceHolder } from \"../../object/convertWireToOsdkObjects/InterfaceHolder.js\";\nimport {\n  ObjectDefRef,\n  UnderlyingOsdkObject,\n} from \"../../object/convertWireToOsdkObjects/InternalSymbols.js\";\nimport type {\n  ObjectHolder,\n} from \"../../object/convertWireToOsdkObjects/ObjectHolder.js\";\nimport type { ListPayload } from \"../ListPayload.js\";\nimport type { CommonObserveOptions, Status } from \"../ObservableClient.js\";\nimport {\n  type CacheKey,\n  DEBUG_ONLY__cacheKeysToString as DEBUG_ONLY__cacheKeysToString,\n} from \"./CacheKey.js\";\nimport type { Canonical } from \"./Canonical.js\";\nimport { type Changes, DEBUG_ONLY__changesToString } from \"./Changes.js\";\nimport type { Entry } from \"./Layer.js\";\nimport { objectSortaMatchesWhereClause as objectMatchesWhereClause } from \"./objectMatchesWhereClause.js\";\nimport { type ObjectCacheKey, storeOsdkInstances } from \"./ObjectQuery.js\";\nimport type { OptimisticId } from \"./OptimisticId.js\";\nimport { Query } from \"./Query.js\";\nimport type { SimpleWhereClause } from \"./SimpleWhereClause.js\";\nimport type { BatchContext, Store, SubjectPayload } from \"./Store.js\";\n\ninterface ListStorageData {\n  data: ObjectCacheKey[];\n}\n\nexport interface ListCacheKey extends\n  CacheKey<\n    \"list\",\n    ListStorageData,\n    ListQuery,\n    [\n      type: \"object\" | \"interface\",\n      apiName: string,\n      whereClause: Canonical<SimpleWhereClause>,\n      orderByClause: Canonical<Record<string, \"asc\" | \"desc\" | undefined>>,\n    ]\n  > //\n{}\n\nexport interface BaseListCacheKey<\n  T_Type extends string,\n  T_Query extends Query<any, any, any>,\n  T_KeyFactoryArgs extends any[] = any[],\n> extends CacheKey<T_Type, ListStorageData, T_Query, T_KeyFactoryArgs> {\n}\n\nexport const API_NAME_IDX = 1;\nexport const TYPE_IDX = 0;\nexport const WHERE_IDX = 2;\nexport const ORDER_BY_IDX = 3;\n\nexport interface ListQueryOptions extends CommonObserveOptions {\n  pageSize?: number;\n}\n\ntype ExtractRelevantObjectsResult = Record<\"added\" | \"modified\", {\n  all: (ObjectHolder | InterfaceHolder)[];\n  strictMatches: Set<(ObjectHolder | InterfaceHolder)>;\n  sortaMatches: Set<(ObjectHolder | InterfaceHolder)>;\n}>;\n\nabstract class BaseListQuery<\n  // THIS IS THE WRONG EXTENDS\n  KEY extends ListCacheKey,\n  PAYLOAD,\n  O extends CommonObserveOptions,\n> extends Query<KEY, PAYLOAD, O> {\n  //\n  // Per list type implementations\n  //\n\n  protected abstract _sortCacheKeys(\n    objectCacheKeys: ObjectCacheKey[],\n    batch: BatchContext,\n  ): ObjectCacheKey[];\n\n  //\n  // Shared Implementations\n  //\n\n  /**\n   * Only intended to be \"protected\" and used by subclasses but exposed for\n   * testing.\n   *\n   * @param objectCacheKeys\n   * @param append\n   * @param status\n   * @param batch\n   * @returns\n   */\n  _updateList(\n    objectCacheKeys: Array<ObjectCacheKey>,\n    append: boolean,\n    status: Status,\n    batch: BatchContext,\n  ): Entry<ListCacheKey> {\n    if (process.env.NODE_ENV !== \"production\") {\n      const logger = process.env.NODE_ENV !== \"production\"\n        ? this.logger?.child({ methodName: \"updateList\" })\n        : this.logger;\n\n      logger?.debug(\n        `{status: ${status}}`,\n        JSON.stringify(objectCacheKeys, null, 2),\n      );\n    }\n\n    objectCacheKeys = this.#retainReleaseAppend(batch, append, objectCacheKeys);\n    objectCacheKeys = this._sortCacheKeys(objectCacheKeys, batch);\n    objectCacheKeys = removeDuplicates(objectCacheKeys, batch);\n\n    return this.writeToStore({ data: objectCacheKeys }, status, batch);\n  }\n\n  writeToStore(\n    data: ListStorageData,\n    status: Status,\n    batch: BatchContext,\n  ): Entry<KEY> {\n    const entry = batch.read(this.cacheKey);\n\n    if (entry && deepEqual(data, entry.value)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        this.logger?.child({ methodName: \"writeToStore\" }).debug(\n          `Object was deep equal, just setting status`,\n        );\n      }\n      return batch.write(this.cacheKey, entry.value, status);\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      this.logger?.child({ methodName: \"writeToStore\" }).debug(\n        `{status: ${status}},`,\n        DEBUG_ONLY__cacheKeysToString(data.data),\n      );\n    }\n\n    const ret = batch.write(this.cacheKey, data, status);\n    batch.changes.registerList(this.cacheKey);\n    return ret;\n  }\n\n  #retainReleaseAppend(\n    batch: BatchContext,\n    append: boolean,\n    objectCacheKeys: ObjectCacheKey[],\n  ): ObjectCacheKey[] {\n    const existingList = batch.read(this.cacheKey);\n\n    // whether its append or update we need to retain all the new objects\n    if (!batch.optimisticWrite) {\n      if (!append) {\n        // we need to release all the old objects\n        // N.B. the store keeps the cache keys around for a bit so we don't\n        // need to worry about them being GC'd before we re-retain them\n        for (const objectCacheKey of existingList?.value?.data ?? []) {\n          this.store.release(objectCacheKey);\n        }\n      }\n\n      for (const objectCacheKey of objectCacheKeys) {\n        this.store.retain(objectCacheKey);\n      }\n    }\n\n    if (append) {\n      objectCacheKeys = [\n        ...existingList?.value?.data ?? [],\n        ...objectCacheKeys,\n      ];\n    }\n    return objectCacheKeys;\n  }\n\n  _dispose(): void {\n    // eslint-disable-next-line no-console\n    console.log(\"DISPOSE LIST QUERY\");\n    this.store.batch({}, (batch) => {\n      const entry = batch.read(this.cacheKey);\n      if (entry) {\n        for (const objectCacheKey of entry.value?.data ?? []) {\n          this.store.release(objectCacheKey);\n        }\n      }\n    });\n  }\n}\n\nexport class ListQuery extends BaseListQuery<\n  ListCacheKey,\n  ListPayload,\n  ListQueryOptions\n> {\n  // pageSize?: number; // this is the internal page size. we need to track this properly\n\n  #type: \"object\" | \"interface\";\n  #apiName: string;\n  #whereClause: Canonical<SimpleWhereClause>;\n\n  // this represents the minimum number of results we need to load if we revalidate\n  #minNumResults = 0;\n\n  #nextPageToken?: string;\n  #pendingPageFetch?: Promise<unknown>;\n  #orderBy: Canonical<Record<string, \"asc\" | \"desc\" | undefined>>;\n  #objectSet: ObjectSet<ObjectTypeDefinition>;\n  #sortFns: Array<\n    (\n      a: ObjectHolder | InterfaceHolder | undefined,\n      b: ObjectHolder | InterfaceHolder | undefined,\n    ) => number\n  >;\n\n  constructor(\n    store: Store,\n    subject: Observable<SubjectPayload<ListCacheKey>>,\n    apiType: \"object\" | \"interface\",\n    apiName: string,\n    whereClause: Canonical<SimpleWhereClause>,\n    orderBy: Canonical<Record<string, \"asc\" | \"desc\" | undefined>>,\n    cacheKey: ListCacheKey,\n    opts: ListQueryOptions,\n  ) {\n    super(\n      store,\n      subject,\n      opts,\n      cacheKey,\n      process.env.NODE_ENV !== \"production\"\n        ? (\n          store.client[additionalContext].logger?.child({}, {\n            msgPrefix: `ListQuery<${\n              cacheKey.otherKeys.map(x => JSON.stringify(x)).join(\", \")\n            }>`,\n          })\n        )\n        : undefined,\n    );\n\n    this.#type = apiType;\n    this.#apiName = apiName;\n    this.#whereClause = whereClause;\n    this.#orderBy = orderBy;\n    this.#objectSet = store.client({\n      type: this.#type,\n      apiName: this.#apiName,\n    } as ObjectTypeDefinition)\n      .where(this.#whereClause);\n    this.#sortFns = createOrderBySortFns(this.#orderBy);\n  }\n\n  get canonicalWhere(): Canonical<SimpleWhereClause> {\n    return this.#whereClause;\n  }\n\n  protected _createConnectable(\n    subject: Observable<SubjectPayload<ListCacheKey>>,\n  ): Connectable<ListPayload> {\n    return connectable<ListPayload>(\n      subject.pipe(\n        switchMap(listEntry => {\n          return combineLatest({\n            resolvedList: listEntry?.value?.data == null\n              ? of([])\n              : combineLatest(\n                listEntry.value.data.map(cacheKey =>\n                  this.store.getSubject(cacheKey).pipe(\n                    map(objectEntry => objectEntry?.value!),\n                  )\n                ),\n              ),\n            isOptimistic: of(listEntry.isOptimistic),\n            fetchMore: of(this.fetchMore),\n            hasMore: of(this.#nextPageToken != null),\n            status: of(listEntry.status),\n            lastUpdated: of(listEntry.lastUpdated),\n          });\n        }),\n        // like throttle but returns the tail\n        auditTime(0),\n      ),\n      {\n        resetOnDisconnect: false,\n        connector: () => new ReplaySubject(1),\n      },\n    );\n  }\n\n  protected _preFetch(): void {\n    this.#nextPageToken = undefined;\n  }\n\n  protected async _fetchAndStore(): Promise<void> {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.logger?.child({ methodName: \"_fetchAndStore\" }).info(\n        \"fetching pages\",\n      );\n    }\n    while (true) {\n      const entry = await this.#fetchPageAndUpdate(\n        this.#objectSet,\n        \"loading\",\n        this.abortController?.signal,\n      );\n      if (!entry) {\n        // we were aborted\n        return;\n      }\n\n      invariant(entry.value?.data);\n      const count = entry.value.data.length;\n\n      if (count > this.#minNumResults || this.#nextPageToken == null) {\n        break;\n      }\n    }\n    this.store.batch({}, (batch) => {\n      this.setStatus(\"loaded\", batch);\n    });\n\n    return Promise.resolve();\n  }\n\n  fetchMore = (): Promise<unknown> => {\n    if (this.#pendingPageFetch) {\n      return this.#pendingPageFetch;\n    }\n\n    if (this.pendingFetch) {\n      this.#pendingPageFetch = new Promise(async (res) => {\n        await this.pendingFetch;\n        res(this.fetchMore());\n      });\n      return this.#pendingPageFetch;\n    }\n\n    if (this.#nextPageToken == null) {\n      return Promise.resolve();\n    }\n\n    this.store.batch({}, (batch) => {\n      this.setStatus(\"loading\", batch);\n    });\n\n    this.pendingFetch = this.#fetchPageAndUpdate(\n      this.#objectSet,\n      \"loaded\",\n      this.abortController?.signal,\n    ).finally(() => {\n      this.#pendingPageFetch = undefined;\n    });\n    return this.pendingFetch;\n  };\n\n  async #fetchPageAndUpdate(\n    objectSet: ObjectSet,\n    status: Status,\n    signal: AbortSignal | undefined,\n  ): Promise<Entry<ListCacheKey> | undefined> {\n    const append = this.#nextPageToken != null;\n\n    try {\n      let { data, nextPageToken } = await objectSet.fetchPage({\n        $nextPageToken: this.#nextPageToken,\n        $pageSize: this.options.pageSize,\n        // For now this keeps the shared test code from falling apart\n        // but shouldn't be needed ideally\n        ...(Object.keys(this.#orderBy).length > 0\n          ? { $orderBy: this.#orderBy }\n          : {}),\n      });\n\n      if (signal?.aborted) {\n        return;\n      }\n\n      this.#nextPageToken = nextPageToken;\n\n      // Our caching really expects to have the full objects in the list\n      // so we need to fetch them all here\n      if (this.#type === \"interface\") {\n        data = await reloadDataAsFullObjects(this.store.client, data);\n      }\n\n      const { retVal } = this.store.batch({}, (batch) => {\n        return this._updateList(\n          storeOsdkInstances(this.store, data, batch),\n          append,\n          nextPageToken ? status : \"loaded\",\n          batch,\n        );\n      });\n\n      return retVal;\n    } catch (e) {\n      this.logger?.error(\"error\", e);\n      this.store.getSubject(this.cacheKey).error(e);\n\n      // rethrowing would result in many unhandled promise rejections\n      // which i don't think we want\n      // throw e;\n    }\n  }\n\n  /**\n   * Will revalidate the list if its query is affected by invalidating the\n   * apiName of the object type passed in.\n   *\n   * @param apiName to invalidate\n   * @returns\n   */\n  revalidateObjectType = async (\n    apiName: string,\n  ): Promise<void> => {\n    if (this.#type === \"object\") {\n      if (this.#apiName === apiName) {\n        await this.revalidate(/* force */ true);\n        return;\n      } else {\n        return;\n      }\n    }\n    //\n    const objectMetadata = await this.store.client.fetchMetadata({\n      type: \"object\",\n      apiName,\n    });\n\n    if (this.#apiName in objectMetadata.interfaceMap) {\n      await this.revalidate(/* force */ true);\n      return;\n    }\n  };\n\n  /**\n   * Note: This method is not async because I want it to return right after it\n   *       finishes the synchronous updates. The promise that is returned\n   *       will resolve after the revalidation is complete.\n   * @param changes\n   * @param optimisticId\n   * @returns If revalidation is needed, a promise that resolves after the\n   *          revalidation is complete. Otherwise, undefined.\n   */\n\n  maybeUpdateAndRevalidate = (\n    changes: Changes,\n    optimisticId: OptimisticId | undefined,\n  ): Promise<void> | undefined => {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.logger?.child({ methodName: \"maybeUpdateAndRevalidate\" }).debug(\n        DEBUG_ONLY__changesToString(changes),\n      );\n    }\n\n    if (changes.modified.has(this.cacheKey)) return;\n    // mark ourselves as updated so we don't infinite recurse.\n    changes.modified.add(this.cacheKey);\n\n    try {\n      const relevantObjects = this._extractRelevantObjects(changes);\n\n      if (\n        relevantObjects.added.all.length === 0\n        && relevantObjects.modified.all.length === 0\n      ) {\n        return;\n      }\n\n      // If we got purely strict matches we can just update the list and move\n      // on with our lives. But if we got sorta matches, then we need to revalidate\n      // the list so we preemptively set it to loading to avoid thrashing the store.\n      const status = optimisticId\n          || relevantObjects.added.sortaMatches.size > 0\n          || relevantObjects.modified.sortaMatches.size > 0\n        ? \"loading\"\n        : \"loaded\";\n\n      // while we only push updates for the strict matches, we still need to\n      // trigger the list updating if some of our objects changed\n\n      const newList: Array<ObjectCacheKey> = [];\n\n      let needsRevalidation = false;\n      this.store.batch({ optimisticId, changes }, (batch) => {\n        const existingList = new Set(\n          batch.read(this.cacheKey)?.value?.data,\n        );\n\n        const toAdd = new Set<ObjectHolder | InterfaceHolder>(\n          // easy case. objects are new to the cache and they match this filter\n          relevantObjects.added.strictMatches,\n        );\n\n        const toRemove = new Set<ObjectCacheKey>();\n\n        // deal with the modified objects\n        for (const obj of relevantObjects.modified.all) {\n          if (relevantObjects.modified.strictMatches.has(obj)) {\n            const objectCacheKey = this.store.getCacheKey<ObjectCacheKey>(\n              \"object\",\n              obj.$objectType,\n              obj.$primaryKey,\n            );\n\n            if (!existingList.has(objectCacheKey)) {\n              // object is new to the list\n              toAdd.add(obj);\n            }\n            continue;\n          } else if (batch.optimisticWrite) {\n            // we aren't removing objects in optimistic mode\n            // we also don't want to trigger revalidation in optimistic mode\n            // as it should be triggered when the optimistic job is done\n            continue;\n          } else {\n            // object is no longer a strict match\n            const existingObjectCacheKey = this.store.getCacheKey<\n              ObjectCacheKey\n            >(\n              \"object\",\n              obj.$objectType,\n              obj.$primaryKey,\n            );\n\n            toRemove.add(existingObjectCacheKey);\n\n            if (relevantObjects.modified.sortaMatches.has(obj)) {\n              // since it might still be in the list we need to revalidate\n              needsRevalidation = true;\n            }\n          }\n        }\n\n        for (const key of existingList) {\n          if (toRemove.has(key)) continue;\n          newList.push(key);\n        }\n        for (const obj of toAdd) {\n          newList.push(\n            this.store.getCacheKey<ObjectCacheKey>(\n              \"object\",\n              obj.$objectType,\n              obj.$primaryKey,\n            ),\n          );\n        }\n\n        this._updateList(\n          newList,\n          /* append */ false,\n          status,\n          batch,\n        );\n      });\n\n      if (needsRevalidation) {\n        return this.revalidate(true);\n      }\n      return undefined;\n    } finally {\n      if (process.env.NODE_ENV !== \"production\") {\n        this.logger?.child({ methodName: \"maybeUpdateAndRevalidate\" })\n          .debug(\"in finally\");\n      }\n    }\n  };\n\n  protected _extractRelevantObjects(\n    changes: Changes,\n  ): ExtractRelevantObjectsResult {\n    // TODO refactor this ternary into subclasses\n    const relevantObjects = this.#type === \"object\"\n      ? this.#extractRelevantObjectsForTypeObject(changes)\n      : this.#extractRelevantObjectsForTypeInterface(changes);\n\n    // categorize\n    for (const group of Object.values(relevantObjects)) {\n      for (const obj of group.all ?? []) {\n        // if its a strict match we can just insert it into place\n        const strictMatch = objectMatchesWhereClause(\n          obj,\n          this.#whereClause,\n          true,\n        );\n\n        if (strictMatch) {\n          group.strictMatches.add(obj);\n        } else {\n          // sorta match means it used a filter we cannot use on the frontend\n          const sortaMatch = objectMatchesWhereClause(\n            obj,\n            this.#whereClause,\n            false,\n          );\n          if (sortaMatch) {\n            group.sortaMatches.add(obj);\n          }\n        }\n      }\n    }\n\n    return relevantObjects;\n  }\n\n  #extractRelevantObjectsForTypeInterface(\n    changes: Changes,\n  ): ExtractRelevantObjectsResult {\n    const added = Array.from(changes.addedObjects).filter(([, object]) => {\n      return this.#apiName in object[ObjectDefRef].interfaceMap;\n    }).map(([, object]) => object.$as(this.#apiName));\n\n    const modified = Array.from(changes.modifiedObjects).filter(\n      ([, object]) => {\n        return this.#apiName in object[ObjectDefRef].interfaceMap;\n      },\n    ).map(([, object]) => object.$as(this.#apiName));\n\n    return {\n      added: {\n        all: added,\n        strictMatches: new Set(),\n        sortaMatches: new Set(),\n      },\n      modified: {\n        all: modified,\n        strictMatches: new Set(),\n        sortaMatches: new Set(),\n      },\n    };\n  }\n\n  #extractRelevantObjectsForTypeObject(\n    changes: Changes,\n  ): ExtractRelevantObjectsResult {\n    return {\n      added: {\n        all: changes.addedObjects.get(this.cacheKey.otherKeys[API_NAME_IDX])\n          ?? [],\n        strictMatches: new Set(),\n        sortaMatches: new Set(),\n      },\n      modified: {\n        all: changes.modifiedObjects.get(this.cacheKey.otherKeys[API_NAME_IDX])\n          ?? [],\n        strictMatches: new Set(),\n        sortaMatches: new Set(),\n      },\n    };\n  }\n\n  _sortCacheKeys(\n    objectCacheKeys: ObjectCacheKey[],\n    batch: BatchContext,\n  ): ObjectCacheKey[] {\n    if (Object.keys(this.#orderBy).length > 0) {\n      objectCacheKeys = objectCacheKeys.sort((a, b) => {\n        for (const sortFn of this.#sortFns) {\n          const ret = sortFn(\n            batch.read(a)?.value?.$as(this.#apiName),\n            batch.read(b)?.value?.$as(this.#apiName),\n          );\n          if (ret !== 0) {\n            return ret;\n          }\n        }\n        return 0;\n      });\n    }\n    return objectCacheKeys;\n  }\n\n  registerStreamUpdates(sub: Subscription): void {\n    const logger = process.env.NODE_ENV !== \"production\"\n      ? this.logger?.child({ methodName: \"registerStreamUpdates\" })\n      : this.logger;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      logger?.child({ methodName: \"observeList\" }).info(\n        \"Subscribing from websocket\",\n      );\n    }\n\n    // FIXME: We should only do this once. If we already have one we should probably\n    // just reuse it.\n\n    const websocketSubscription = this.#objectSet.subscribe({\n      onChange: this.#onOswChange.bind(this),\n      onError: this.#onOswError.bind(this),\n      onOutOfDate: this.#onOswOutOfDate.bind(this),\n      onSuccessfulSubscription: this.#onOswSuccessfulSubscription.bind(this),\n    });\n\n    sub.add(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        logger?.child({ methodName: \"observeList\" }).info(\n          \"Unsubscribing from websocket\",\n        );\n      }\n\n      websocketSubscription.unsubscribe();\n    });\n  }\n\n  #onOswSuccessfulSubscription(): void {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.logger?.child(\n        { methodName: \"onSuccessfulSubscription\" },\n      ).debug(\"\");\n    }\n  }\n\n  #onOswOutOfDate(): void {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.logger?.child(\n        { methodName: \"onOutOfDate\" },\n      ).info(\"\");\n    }\n  }\n\n  #onOswError(errors: {\n    subscriptionClosed: boolean;\n    error: any;\n  }) {\n    if (this.logger) {\n      this.logger?.child({ methodName: \"onError\" }).error(\n        \"subscription errors\",\n        errors,\n      );\n    }\n  }\n\n  #onOswChange(\n    { object: objOrIface, state }: ObjectUpdate<ObjectTypeDefinition, string>,\n  ): void {\n    const logger = process.env.NODE_ENV !== \"production\"\n      ? this.logger?.child({ methodName: \"registerStreamUpdates\" })\n      : this.logger;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      logger?.child({ methodName: \"onChange\" }).debug(\n        `Got an update of type: ${state}`,\n        objOrIface,\n      );\n    }\n\n    if (state === \"ADDED_OR_UPDATED\") {\n      const object: ObjectHolder =\n        (objOrIface.$apiName !== objOrIface.$objectType\n          ? objOrIface.$as(objOrIface.$objectType)\n          : objOrIface) as unknown as ObjectHolder;\n\n      this.store.batch({}, (batch) => {\n        storeOsdkInstances(this.store, [object as Osdk.Instance<any>], batch);\n      });\n    } else if (state === \"REMOVED\") {\n      this.#onOswRemoved(objOrIface, logger);\n    }\n  }\n\n  #onOswRemoved(\n    objOrIface: Osdk.Instance<ObjectTypeDefinition, never, string, {}>,\n    logger: Logger | undefined,\n  ) {\n    this.store.batch({}, (batch) => {\n      // Read the truth layer (since not optimistic)\n      const existing = batch.read(this.cacheKey);\n      invariant(\n        existing,\n        \"the truth value for our list should exist as we already subscribed\",\n      );\n      if (existing.status === \"loaded\") {\n        const objectCacheKey = this.store.getCacheKey<ObjectCacheKey>(\n          \"object\",\n          objOrIface.$objectType,\n          objOrIface.$primaryKey,\n        );\n        // remove the object from the list\n        const newObjects = existing.value?.data.filter(\n          (o) => o !== objectCacheKey,\n        );\n\n        // If the filter didn't change anything, then the list was already\n        // updated (or didn't exist, which is nonsensical)\n        if (newObjects?.length !== existing.value?.data.length) {\n          batch.changes.registerList(this.cacheKey);\n          batch.write(\n            this.cacheKey,\n            { data: newObjects ?? [] },\n            \"loaded\",\n          );\n          // Should there be an else for this case? Do we need to invalidate\n          // the paging tokens we may have? FIXME\n        }\n\n        return;\n      }\n      // There may be a tiny race here where OSW tells us the object has\n      // been removed but an outstanding invalidation of this query is\n      // about to return. In this case, its possible that we remove this item\n      // from the list and then the returned list load re-adds it.\n      // To avoid this, we will just force reload the query to be sure\n      // we don't leave things in a bad state.\n      if (process.env.NODE_ENV !== \"production\") {\n        logger?.info(\n          \"Removing an object from an object list that is in the middle of being loaded.\",\n          existing,\n        );\n      }\n\n      this.revalidate(/* force */ true).catch((e: unknown) => {\n        if (logger) {\n          logger?.error(\"Uncaught error while revalidating list\", e);\n        } else {\n          // Make sure we write to the console if there is no logger!\n          // eslint-disable-next-line no-console\n          console.error(\"Uncaught error while revalidating list\", e);\n        }\n      });\n    });\n  }\n}\n\nfunction removeDuplicates(\n  objectCacheKeys: ObjectCacheKey[],\n  batch: BatchContext,\n) {\n  const visited = new Set<ObjectCacheKey>();\n  objectCacheKeys = objectCacheKeys.filter((key) => {\n    batch.read(key);\n    if (visited.has(key)) {\n      return false;\n    }\n    visited.add(key);\n    return true;\n  });\n  return objectCacheKeys;\n}\n\nfunction createOrderBySortFns(\n  orderBy: Canonical<Record<string, \"asc\" | \"desc\" | undefined>>,\n) {\n  return Object.entries(orderBy).map(([key, order]) => {\n    return (\n      a: ObjectHolder | InterfaceHolder | undefined,\n      b: ObjectHolder | InterfaceHolder | undefined,\n    ): number => {\n      const aValue = a?.[key];\n      const bValue = b?.[key];\n\n      if (aValue == null && bValue == null) {\n        return 0;\n      }\n      if (aValue == null) {\n        return 1;\n      }\n      if (bValue == null) {\n        return -1;\n      }\n      const m = order === \"asc\" ? -1 : 1;\n      return aValue < bValue ? m : aValue > bValue ? -m : 0;\n    };\n  });\n}\n\n// Hopefully this can go away when we can just request the full object properties on first load\nasync function reloadDataAsFullObjects(\n  client: Client,\n  data: Osdk.Instance<any>[],\n) {\n  const groups = groupBy(data, (x) => x.$objectType);\n  const objectTypeToPrimaryKeyToObject = Object.fromEntries(\n    await Promise.all(\n      Object.entries(groups).map<\n        Promise<\n          [\n            /** objectType **/ string,\n            Record<string | number, Osdk.Instance<ObjectTypeDefinition>>,\n          ]\n        >\n      >(async ([apiName, objects]) => {\n        // to keep InternalSimpleOsdkInstance simple, we make both the `ObjectDefRef` and\n        // the `InterfaceDefRef` optional but we know that the right one is on there\n        // thus we can `!`\n        const objectDef = (objects[0] as ObjectHolder)[UnderlyingOsdkObject][\n          ObjectDefRef\n        ]!;\n        const where: SimpleWhereClause = {\n          [objectDef.primaryKeyApiName]: {\n            $in: objects.map(x => x.$primaryKey),\n          },\n        };\n\n        const result = await client(\n          objectDef as ObjectTypeDefinition,\n        ).where(where).fetchPage();\n        return [\n          apiName,\n          Object.fromEntries(result.data.map(\n            x => [x.$primaryKey, x],\n          )),\n        ];\n      }),\n    ),\n  );\n\n  data = data.map((obj) => {\n    invariant(\n      objectTypeToPrimaryKeyToObject[obj.$objectType][obj.$primaryKey],\n      `Could not find object ${obj.$objectType} ${obj.$primaryKey}`,\n    );\n    return objectTypeToPrimaryKeyToObject[obj.$objectType][obj.$primaryKey];\n  });\n\n  return data;\n}\n\nexport function isListCacheKey(\n  cacheKey: CacheKey,\n): cacheKey is ListCacheKey {\n  return cacheKey.type === \"list\";\n}\n\n/**\n * Copied from @osdk/api\n */\ntype ObjectUpdate<\n  O extends ObjectOrInterfaceDefinition,\n  P extends PropertyKeys<O>,\n> = {\n  object: Osdk.Instance<O, never, P>;\n  state: \"ADDED_OR_UPDATED\" | \"REMOVED\";\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAUA,OAAOA,SAAS,MAAM,iBAAiB;AACvC,OAAOC,OAAO,MAAM,gBAAgB;AAEpC,SACEC,SAAS,EACTC,aAAa,EACbC,WAAW,EACXC,GAAG,EACHC,EAAE,EACFC,aAAa,EACbC,SAAS,QACJ,MAAM;AACb,OAAOC,SAAS,MAAM,gBAAgB;AACtC,SAASC,iBAAiB,QAAqB,iBAAiB;AAEhE,SACEC,YAAY,EACZC,oBAAoB,QACf,0DAA0D;AAMjE,SAEEC,6BAA8D,QACzD,eAAe;AAEtB,SAAuBC,2BAA2B,QAAQ,cAAc;AAExE,SAASC,6BAA6B,IAAIC,wBAAwB,QAAQ,+BAA+B;AACzG,SAA8BC,kBAAkB,QAAQ,kBAAkB;AAE1E,SAASC,KAAK,QAAQ,YAAY;AA6BlC,OAAO,MAAMC,YAAY,GAAG,CAAC;AAC7B,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,SAAS,GAAG,CAAC;AAC1B,OAAO,MAAMC,YAAY,GAAG,CAAC;AAY7B,MAAeC,aAAa,SAKlBL,KAAK,CAAkB;EAC/B;EACA;EACA;;EAOA;EACA;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEM,WAAWA,CACTC,eAAsC,EACtCC,MAAe,EACfC,MAAc,EACdC,KAAmB,EACE;IACrB,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,MAAMC,MAAM,GAAGH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAChD,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAa,CAAC,CAAC,GAChD,IAAI,CAACF,MAAM;MAEfA,MAAM,EAAEG,KAAK,CACX,YAAYR,MAAM,GAAG,EACrBS,IAAI,CAACC,SAAS,CAACZ,eAAe,EAAE,IAAI,EAAE,CAAC,CACzC,CAAC;IACH;IAEAA,eAAe,GAAG,IAAI,CAAC,CAACa,mBAAmB,CAACV,KAAK,EAAEF,MAAM,EAAED,eAAe,CAAC;IAC3EA,eAAe,GAAG,IAAI,CAACc,cAAc,CAACd,eAAe,EAAEG,KAAK,CAAC;IAC7DH,eAAe,GAAGe,gBAAgB,CAACf,eAAe,EAAEG,KAAK,CAAC;IAE1D,OAAO,IAAI,CAACa,YAAY,CAAC;MAAEC,IAAI,EAAEjB;IAAgB,CAAC,EAAEE,MAAM,EAAEC,KAAK,CAAC;EACpE;EAEAa,YAAYA,CACVC,IAAqB,EACrBf,MAAc,EACdC,KAAmB,EACP;IACZ,MAAMe,KAAK,GAAGf,KAAK,CAACgB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC;IAEvC,IAAIF,KAAK,IAAI3C,SAAS,CAAC0C,IAAI,EAAEC,KAAK,CAACG,KAAK,CAAC,EAAE;MACzC,IAAIjB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;UAAEC,UAAU,EAAE;QAAe,CAAC,CAAC,CAACC,KAAK,CACtD,4CACF,CAAC;MACH;MACA,OAAOP,KAAK,CAACmB,KAAK,CAAC,IAAI,CAACF,QAAQ,EAAEF,KAAK,CAACG,KAAK,EAAEnB,MAAM,CAAC;IACxD;IAEA,IAAIE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAe,CAAC,CAAC,CAACC,KAAK,CACtD,YAAYR,MAAM,IAAI,EACtBd,6BAA6B,CAAC6B,IAAI,CAACA,IAAI,CACzC,CAAC;IACH;IAEA,MAAMM,GAAG,GAAGpB,KAAK,CAACmB,KAAK,CAAC,IAAI,CAACF,QAAQ,EAAEH,IAAI,EAAEf,MAAM,CAAC;IACpDC,KAAK,CAACqB,OAAO,CAACC,YAAY,CAAC,IAAI,CAACL,QAAQ,CAAC;IACzC,OAAOG,GAAG;EACZ;EAEA,CAACV,mBAAmBa,CAClBvB,KAAmB,EACnBF,MAAe,EACfD,eAAiC,EACf;IAClB,MAAM2B,YAAY,GAAGxB,KAAK,CAACgB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC;;IAE9C;IACA,IAAI,CAACjB,KAAK,CAACyB,eAAe,EAAE;MAC1B,IAAI,CAAC3B,MAAM,EAAE;QACX;QACA;QACA;QACA,KAAK,MAAM4B,cAAc,IAAIF,YAAY,EAAEN,KAAK,EAAEJ,IAAI,IAAI,EAAE,EAAE;UAC5D,IAAI,CAACa,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC;QACpC;MACF;MAEA,KAAK,MAAMA,cAAc,IAAI7B,eAAe,EAAE;QAC5C,IAAI,CAAC8B,KAAK,CAACE,MAAM,CAACH,cAAc,CAAC;MACnC;IACF;IAEA,IAAI5B,MAAM,EAAE;MACVD,eAAe,GAAG,CAChB,IAAG2B,YAAY,EAAEN,KAAK,EAAEJ,IAAI,IAAI,EAAE,GAClC,GAAGjB,eAAe,CACnB;IACH;IACA,OAAOA,eAAe;EACxB;EAEAiC,QAAQA,CAAA,EAAS;IACf;IACAC,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;IACjC,IAAI,CAACL,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;MAC9B,MAAMe,KAAK,GAAGf,KAAK,CAACgB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC;MACvC,IAAIF,KAAK,EAAE;QACT,KAAK,MAAMW,cAAc,IAAIX,KAAK,CAACG,KAAK,EAAEJ,IAAI,IAAI,EAAE,EAAE;UACpD,IAAI,CAACa,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC;QACpC;MACF;IACF,CAAC,CAAC;EACJ;AACF;AAEA,OAAO,MAAMO,SAAS,SAAStC,aAAa,CAI1C;EACA;;EAEA,CAACuC,IAAI;EACL,CAACC,OAAO;EACR,CAACC,WAAW;;EAEZ;EACA,CAACC,aAAa,GAAG,CAAC;EAElB,CAACC,aAAa;EACd,CAACC,gBAAgB;EACjB,CAACC,OAAO;EACR,CAACC,SAAS;EACV,CAACC,OAAO;EAORC,WAAWA,CACThB,KAAY,EACZiB,OAAiD,EACjDC,OAA+B,EAC/BV,OAAe,EACfC,WAAyC,EACzCI,OAA8D,EAC9DvB,QAAsB,EACtB6B,IAAsB,EACtB;IACA,KAAK,CACHnB,KAAK,EACLiB,OAAO,EACPE,IAAI,EACJ7B,QAAQ,EACRhB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAEjCwB,KAAK,CAACoB,MAAM,CAACjE,iBAAiB,CAAC,CAACsB,MAAM,EAAEC,KAAK,CAAC,CAAC,CAAC,EAAE;MAChD2C,SAAS,EAAE,aACT/B,QAAQ,CAACgC,SAAS,CAACxE,GAAG,CAACyE,CAAC,IAAI1C,IAAI,CAACC,SAAS,CAACyC,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;IAE7D,CAAC,CAAC,GAEFC,SACN,CAAC;IAED,IAAI,CAAC,CAAClB,IAAI,GAAGW,OAAO;IACpB,IAAI,CAAC,CAACV,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACC,WAAW,GAAGA,WAAW;IAC/B,IAAI,CAAC,CAACI,OAAO,GAAGA,OAAO;IACvB,IAAI,CAAC,CAACC,SAAS,GAAGd,KAAK,CAACoB,MAAM,CAAC;MAC7Bb,IAAI,EAAE,IAAI,CAAC,CAACA,IAAI;MAChBC,OAAO,EAAE,IAAI,CAAC,CAACA;IACjB,CAAyB,CAAC,CACvBkB,KAAK,CAAC,IAAI,CAAC,CAACjB,WAAW,CAAC;IAC3B,IAAI,CAAC,CAACM,OAAO,GAAGY,oBAAoB,CAAC,IAAI,CAAC,CAACd,OAAO,CAAC;EACrD;EAEA,IAAIe,cAAcA,CAAA,EAAiC;IACjD,OAAO,IAAI,CAAC,CAACnB,WAAW;EAC1B;EAEUoB,kBAAkBA,CAC1BZ,OAAiD,EACvB;IAC1B,OAAOpE,WAAW,CAChBoE,OAAO,CAACa,IAAI,CACV7E,SAAS,CAAC8E,SAAS,IAAI;MACrB,OAAOnF,aAAa,CAAC;QACnBoF,YAAY,EAAED,SAAS,EAAExC,KAAK,EAAEJ,IAAI,IAAI,IAAI,GACxCpC,EAAE,CAAC,EAAE,CAAC,GACNH,aAAa,CACbmF,SAAS,CAACxC,KAAK,CAACJ,IAAI,CAACrC,GAAG,CAACwC,QAAQ,IAC/B,IAAI,CAACU,KAAK,CAACiC,UAAU,CAAC3C,QAAQ,CAAC,CAACwC,IAAI,CAClChF,GAAG,CAACoF,WAAW,IAAIA,WAAW,EAAE3C,KAAM,CACxC,CACF,CACF,CAAC;QACH4C,YAAY,EAAEpF,EAAE,CAACgF,SAAS,CAACI,YAAY,CAAC;QACxCC,SAAS,EAAErF,EAAE,CAAC,IAAI,CAACqF,SAAS,CAAC;QAC7BC,OAAO,EAAEtF,EAAE,CAAC,IAAI,CAAC,CAAC4D,aAAa,IAAI,IAAI,CAAC;QACxCvC,MAAM,EAAErB,EAAE,CAACgF,SAAS,CAAC3D,MAAM,CAAC;QAC5BkE,WAAW,EAAEvF,EAAE,CAACgF,SAAS,CAACO,WAAW;MACvC,CAAC,CAAC;IACJ,CAAC,CAAC;IACF;IACA3F,SAAS,CAAC,CAAC,CACb,CAAC,EACD;MACE4F,iBAAiB,EAAE,KAAK;MACxBC,SAAS,EAAEA,CAAA,KAAM,IAAIxF,aAAa,CAAC,CAAC;IACtC,CACF,CAAC;EACH;EAEUyF,SAASA,CAAA,EAAS;IAC1B,IAAI,CAAC,CAAC9B,aAAa,GAAGc,SAAS;EACjC;EAEA,MAAgBiB,cAAcA,CAAA,EAAkB;IAC9C,IAAIpE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAiB,CAAC,CAAC,CAACgE,IAAI,CACvD,gBACF,CAAC;IACH;IACA,OAAO,IAAI,EAAE;MACX,MAAMvD,KAAK,GAAG,MAAM,IAAI,CAAC,CAACwD,kBAAkB,CAC1C,IAAI,CAAC,CAAC9B,SAAS,EACf,SAAS,EACT,IAAI,CAAC+B,eAAe,EAAEC,MACxB,CAAC;MACD,IAAI,CAAC1D,KAAK,EAAE;QACV;QACA;MACF;MAEA,CAAUA,KAAK,CAACG,KAAK,EAAEJ,IAAI,GAAAb,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBAA3BtB,SAAS,UAATA,SAAS;MACT,MAAM6F,KAAK,GAAG3D,KAAK,CAACG,KAAK,CAACJ,IAAI,CAAC6D,MAAM;MAErC,IAAID,KAAK,GAAG,IAAI,CAAC,CAACrC,aAAa,IAAI,IAAI,CAAC,CAACC,aAAa,IAAI,IAAI,EAAE;QAC9D;MACF;IACF;IACA,IAAI,CAACX,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;MAC9B,IAAI,CAAC4E,SAAS,CAAC,QAAQ,EAAE5E,KAAK,CAAC;IACjC,CAAC,CAAC;IAEF,OAAO6E,OAAO,CAACC,OAAO,CAAC,CAAC;EAC1B;EAEAf,SAAS,GAAGA,CAAA,KAAwB;IAClC,IAAI,IAAI,CAAC,CAACxB,gBAAgB,EAAE;MAC1B,OAAO,IAAI,CAAC,CAACA,gBAAgB;IAC/B;IAEA,IAAI,IAAI,CAACwC,YAAY,EAAE;MACrB,IAAI,CAAC,CAACxC,gBAAgB,GAAG,IAAIsC,OAAO,CAAC,MAAOG,GAAG,IAAK;QAClD,MAAM,IAAI,CAACD,YAAY;QACvBC,GAAG,CAAC,IAAI,CAACjB,SAAS,CAAC,CAAC,CAAC;MACvB,CAAC,CAAC;MACF,OAAO,IAAI,CAAC,CAACxB,gBAAgB;IAC/B;IAEA,IAAI,IAAI,CAAC,CAACD,aAAa,IAAI,IAAI,EAAE;MAC/B,OAAOuC,OAAO,CAACC,OAAO,CAAC,CAAC;IAC1B;IAEA,IAAI,CAACnD,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;MAC9B,IAAI,CAAC4E,SAAS,CAAC,SAAS,EAAE5E,KAAK,CAAC;IAClC,CAAC,CAAC;IAEF,IAAI,CAAC+E,YAAY,GAAG,IAAI,CAAC,CAACR,kBAAkB,CAC1C,IAAI,CAAC,CAAC9B,SAAS,EACf,QAAQ,EACR,IAAI,CAAC+B,eAAe,EAAEC,MACxB,CAAC,CAACQ,OAAO,CAAC,MAAM;MACd,IAAI,CAAC,CAAC1C,gBAAgB,GAAGa,SAAS;IACpC,CAAC,CAAC;IACF,OAAO,IAAI,CAAC2B,YAAY;EAC1B,CAAC;EAED,MAAM,CAACR,kBAAkBW,CACvBzC,SAAoB,EACpB1C,MAAc,EACd0E,MAA+B,EACW;IAC1C,MAAM3E,MAAM,GAAG,IAAI,CAAC,CAACwC,aAAa,IAAI,IAAI;IAE1C,IAAI;MACF,IAAI;QAAExB,IAAI;QAAEwB;MAAc,CAAC,GAAG,MAAMG,SAAS,CAAC0C,SAAS,CAAC;QACtDC,cAAc,EAAE,IAAI,CAAC,CAAC9C,aAAa;QACnC+C,SAAS,EAAE,IAAI,CAACC,OAAO,CAACC,QAAQ;QAChC;QACA;QACA,IAAIC,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC,CAACjD,OAAO,CAAC,CAACmC,MAAM,GAAG,CAAC,GACrC;UAAEe,QAAQ,EAAE,IAAI,CAAC,CAAClD;QAAQ,CAAC,GAC3B,CAAC,CAAC;MACR,CAAC,CAAC;MAEF,IAAIiC,MAAM,EAAEkB,OAAO,EAAE;QACnB;MACF;MAEA,IAAI,CAAC,CAACrD,aAAa,GAAGA,aAAa;;MAEnC;MACA;MACA,IAAI,IAAI,CAAC,CAACJ,IAAI,KAAK,WAAW,EAAE;QAC9BpB,IAAI,GAAG,MAAM8E,uBAAuB,CAAC,IAAI,CAACjE,KAAK,CAACoB,MAAM,EAAEjC,IAAI,CAAC;MAC/D;MAEA,MAAM;QAAE+E;MAAO,CAAC,GAAG,IAAI,CAAClE,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;QACjD,OAAO,IAAI,CAACJ,WAAW,CACrBP,kBAAkB,CAAC,IAAI,CAACsC,KAAK,EAAEb,IAAI,EAAEd,KAAK,CAAC,EAC3CF,MAAM,EACNwC,aAAa,GAAGvC,MAAM,GAAG,QAAQ,EACjCC,KACF,CAAC;MACH,CAAC,CAAC;MAEF,OAAO6F,MAAM;IACf,CAAC,CAAC,OAAOC,CAAC,EAAE;MACV,IAAI,CAAC1F,MAAM,EAAE2F,KAAK,CAAC,OAAO,EAAED,CAAC,CAAC;MAC9B,IAAI,CAACnE,KAAK,CAACiC,UAAU,CAAC,IAAI,CAAC3C,QAAQ,CAAC,CAAC8E,KAAK,CAACD,CAAC,CAAC;;MAE7C;MACA;MACA;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,oBAAoB,GAAG,MACrB7D,OAAe,IACG;IAClB,IAAI,IAAI,CAAC,CAACD,IAAI,KAAK,QAAQ,EAAE;MAC3B,IAAI,IAAI,CAAC,CAACC,OAAO,KAAKA,OAAO,EAAE;QAC7B,MAAM,IAAI,CAAC8D,UAAU,CAAC,WAAY,IAAI,CAAC;QACvC;MACF,CAAC,MAAM;QACL;MACF;IACF;IACA;IACA,MAAMC,cAAc,GAAG,MAAM,IAAI,CAACvE,KAAK,CAACoB,MAAM,CAACoD,aAAa,CAAC;MAC3DjE,IAAI,EAAE,QAAQ;MACdC;IACF,CAAC,CAAC;IAEF,IAAI,IAAI,CAAC,CAACA,OAAO,IAAI+D,cAAc,CAACE,YAAY,EAAE;MAChD,MAAM,IAAI,CAACH,UAAU,CAAC,WAAY,IAAI,CAAC;IAEzC;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEI,wBAAwB,GAAGA,CACzBhF,OAAgB,EAChBiF,YAAsC,KACR;IAC9B,IAAIrG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAA2B,CAAC,CAAC,CAACC,KAAK,CAClErB,2BAA2B,CAACmC,OAAO,CACrC,CAAC;IACH;IAEA,IAAIA,OAAO,CAACkF,QAAQ,CAACC,GAAG,CAAC,IAAI,CAACvF,QAAQ,CAAC,EAAE;IACzC;IACAI,OAAO,CAACkF,QAAQ,CAACE,GAAG,CAAC,IAAI,CAACxF,QAAQ,CAAC;IAEnC,IAAI;MACF,MAAMyF,eAAe,GAAG,IAAI,CAACC,uBAAuB,CAACtF,OAAO,CAAC;MAE7D,IACEqF,eAAe,CAACE,KAAK,CAACC,GAAG,CAAClC,MAAM,KAAK,CAAC,IACnC+B,eAAe,CAACH,QAAQ,CAACM,GAAG,CAAClC,MAAM,KAAK,CAAC,EAC5C;QACA;MACF;;MAEA;MACA;MACA;MACA,MAAM5E,MAAM,GAAGuG,YAAY,IACpBI,eAAe,CAACE,KAAK,CAACE,YAAY,CAACC,IAAI,GAAG,CAAC,IAC3CL,eAAe,CAACH,QAAQ,CAACO,YAAY,CAACC,IAAI,GAAG,CAAC,GACjD,SAAS,GACT,QAAQ;;MAEZ;MACA;;MAEA,MAAMC,OAA8B,GAAG,EAAE;MAEzC,IAAIC,iBAAiB,GAAG,KAAK;MAC7B,IAAI,CAACtF,KAAK,CAAC3B,KAAK,CAAC;QAAEsG,YAAY;QAAEjF;MAAQ,CAAC,EAAGrB,KAAK,IAAK;QACrD,MAAMwB,YAAY,GAAG,IAAI0F,GAAG,CAC1BlH,KAAK,CAACgB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC,EAAEC,KAAK,EAAEJ,IACpC,CAAC;QAED,MAAMqG,KAAK,GAAG,IAAID,GAAG;QACnB;QACAR,eAAe,CAACE,KAAK,CAACQ,aACxB,CAAC;QAED,MAAMC,QAAQ,GAAG,IAAIH,GAAG,CAAiB,CAAC;;QAE1C;QACA,KAAK,MAAMI,GAAG,IAAIZ,eAAe,CAACH,QAAQ,CAACM,GAAG,EAAE;UAC9C,IAAIH,eAAe,CAACH,QAAQ,CAACa,aAAa,CAACZ,GAAG,CAACc,GAAG,CAAC,EAAE;YACnD,MAAM5F,cAAc,GAAG,IAAI,CAACC,KAAK,CAAC4F,WAAW,CAC3C,QAAQ,EACRD,GAAG,CAACE,WAAW,EACfF,GAAG,CAACG,WACN,CAAC;YAED,IAAI,CAACjG,YAAY,CAACgF,GAAG,CAAC9E,cAAc,CAAC,EAAE;cACrC;cACAyF,KAAK,CAACV,GAAG,CAACa,GAAG,CAAC;YAChB;YACA;UACF,CAAC,MAAM,IAAItH,KAAK,CAACyB,eAAe,EAAE;YAChC;YACA;YACA;YACA;UACF,CAAC,MAAM;YACL;YACA,MAAMiG,sBAAsB,GAAG,IAAI,CAAC/F,KAAK,CAAC4F,WAAW,CAGnD,QAAQ,EACRD,GAAG,CAACE,WAAW,EACfF,GAAG,CAACG,WACN,CAAC;YAEDJ,QAAQ,CAACZ,GAAG,CAACiB,sBAAsB,CAAC;YAEpC,IAAIhB,eAAe,CAACH,QAAQ,CAACO,YAAY,CAACN,GAAG,CAACc,GAAG,CAAC,EAAE;cAClD;cACAL,iBAAiB,GAAG,IAAI;YAC1B;UACF;QACF;QAEA,KAAK,MAAMU,GAAG,IAAInG,YAAY,EAAE;UAC9B,IAAI6F,QAAQ,CAACb,GAAG,CAACmB,GAAG,CAAC,EAAE;UACvBX,OAAO,CAACY,IAAI,CAACD,GAAG,CAAC;QACnB;QACA,KAAK,MAAML,GAAG,IAAIH,KAAK,EAAE;UACvBH,OAAO,CAACY,IAAI,CACV,IAAI,CAACjG,KAAK,CAAC4F,WAAW,CACpB,QAAQ,EACRD,GAAG,CAACE,WAAW,EACfF,GAAG,CAACG,WACN,CACF,CAAC;QACH;QAEA,IAAI,CAAC7H,WAAW,CACdoH,OAAO,EACP,YAAa,KAAK,EAClBjH,MAAM,EACNC,KACF,CAAC;MACH,CAAC,CAAC;MAEF,IAAIiH,iBAAiB,EAAE;QACrB,OAAO,IAAI,CAAChB,UAAU,CAAC,IAAI,CAAC;MAC9B;MACA,OAAO7C,SAAS;IAClB,CAAC,SAAS;MACR,IAAInD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;UAAEC,UAAU,EAAE;QAA2B,CAAC,CAAC,CAC3DC,KAAK,CAAC,YAAY,CAAC;MACxB;IACF;EACF,CAAC;EAESoG,uBAAuBA,CAC/BtF,OAAgB,EACc;IAC9B;IACA,MAAMqF,eAAe,GAAG,IAAI,CAAC,CAACxE,IAAI,KAAK,QAAQ,GAC3C,IAAI,CAAC,CAAC2F,mCAAmC,CAACxG,OAAO,CAAC,GAClD,IAAI,CAAC,CAACyG,sCAAsC,CAACzG,OAAO,CAAC;;IAEzD;IACA,KAAK,MAAM0G,KAAK,IAAIvC,MAAM,CAACwC,MAAM,CAACtB,eAAe,CAAC,EAAE;MAClD,KAAK,MAAMY,GAAG,IAAIS,KAAK,CAAClB,GAAG,IAAI,EAAE,EAAE;QACjC;QACA,MAAMoB,WAAW,GAAG7I,wBAAwB,CAC1CkI,GAAG,EACH,IAAI,CAAC,CAAClF,WAAW,EACjB,IACF,CAAC;QAED,IAAI6F,WAAW,EAAE;UACfF,KAAK,CAACX,aAAa,CAACX,GAAG,CAACa,GAAG,CAAC;QAC9B,CAAC,MAAM;UACL;UACA,MAAMY,UAAU,GAAG9I,wBAAwB,CACzCkI,GAAG,EACH,IAAI,CAAC,CAAClF,WAAW,EACjB,KACF,CAAC;UACD,IAAI8F,UAAU,EAAE;YACdH,KAAK,CAACjB,YAAY,CAACL,GAAG,CAACa,GAAG,CAAC;UAC7B;QACF;MACF;IACF;IAEA,OAAOZ,eAAe;EACxB;EAEA,CAACoB,sCAAsCK,CACrC9G,OAAgB,EACc;IAC9B,MAAMuF,KAAK,GAAGwB,KAAK,CAACC,IAAI,CAAChH,OAAO,CAACiH,YAAY,CAAC,CAACC,MAAM,CAAC,CAAC,GAAGC,MAAM,CAAC,KAAK;MACpE,OAAO,IAAI,CAAC,CAACrG,OAAO,IAAIqG,MAAM,CAACzJ,YAAY,CAAC,CAACqH,YAAY;IAC3D,CAAC,CAAC,CAAC3H,GAAG,CAAC,CAAC,GAAG+J,MAAM,CAAC,KAAKA,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAACtG,OAAO,CAAC,CAAC;IAEjD,MAAMoE,QAAQ,GAAG6B,KAAK,CAACC,IAAI,CAAChH,OAAO,CAACqH,eAAe,CAAC,CAACH,MAAM,CACzD,CAAC,GAAGC,MAAM,CAAC,KAAK;MACd,OAAO,IAAI,CAAC,CAACrG,OAAO,IAAIqG,MAAM,CAACzJ,YAAY,CAAC,CAACqH,YAAY;IAC3D,CACF,CAAC,CAAC3H,GAAG,CAAC,CAAC,GAAG+J,MAAM,CAAC,KAAKA,MAAM,CAACC,GAAG,CAAC,IAAI,CAAC,CAACtG,OAAO,CAAC,CAAC;IAEhD,OAAO;MACLyE,KAAK,EAAE;QACLC,GAAG,EAAED,KAAK;QACVQ,aAAa,EAAE,IAAIF,GAAG,CAAC,CAAC;QACxBJ,YAAY,EAAE,IAAII,GAAG,CAAC;MACxB,CAAC;MACDX,QAAQ,EAAE;QACRM,GAAG,EAAEN,QAAQ;QACba,aAAa,EAAE,IAAIF,GAAG,CAAC,CAAC;QACxBJ,YAAY,EAAE,IAAII,GAAG,CAAC;MACxB;IACF,CAAC;EACH;EAEA,CAACW,mCAAmCc,CAClCtH,OAAgB,EACc;IAC9B,OAAO;MACLuF,KAAK,EAAE;QACLC,GAAG,EAAExF,OAAO,CAACiH,YAAY,CAACM,GAAG,CAAC,IAAI,CAAC3H,QAAQ,CAACgC,SAAS,CAAC1D,YAAY,CAAC,CAAC,IAC/D,EAAE;QACP6H,aAAa,EAAE,IAAIF,GAAG,CAAC,CAAC;QACxBJ,YAAY,EAAE,IAAII,GAAG,CAAC;MACxB,CAAC;MACDX,QAAQ,EAAE;QACRM,GAAG,EAAExF,OAAO,CAACqH,eAAe,CAACE,GAAG,CAAC,IAAI,CAAC3H,QAAQ,CAACgC,SAAS,CAAC1D,YAAY,CAAC,CAAC,IAClE,EAAE;QACP6H,aAAa,EAAE,IAAIF,GAAG,CAAC,CAAC;QACxBJ,YAAY,EAAE,IAAII,GAAG,CAAC;MACxB;IACF,CAAC;EACH;EAEAvG,cAAcA,CACZd,eAAiC,EACjCG,KAAmB,EACD;IAClB,IAAIwF,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC,CAACjD,OAAO,CAAC,CAACmC,MAAM,GAAG,CAAC,EAAE;MACzC9E,eAAe,GAAGA,eAAe,CAACgJ,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;QAC/C,KAAK,MAAMC,MAAM,IAAI,IAAI,CAAC,CAACtG,OAAO,EAAE;UAClC,MAAMtB,GAAG,GAAG4H,MAAM,CAChBhJ,KAAK,CAACgB,IAAI,CAAC8H,CAAC,CAAC,EAAE5H,KAAK,EAAEuH,GAAG,CAAC,IAAI,CAAC,CAACtG,OAAO,CAAC,EACxCnC,KAAK,CAACgB,IAAI,CAAC+H,CAAC,CAAC,EAAE7H,KAAK,EAAEuH,GAAG,CAAC,IAAI,CAAC,CAACtG,OAAO,CACzC,CAAC;UACD,IAAIf,GAAG,KAAK,CAAC,EAAE;YACb,OAAOA,GAAG;UACZ;QACF;QACA,OAAO,CAAC;MACV,CAAC,CAAC;IACJ;IACA,OAAOvB,eAAe;EACxB;EAEAoJ,qBAAqBA,CAACC,GAAiB,EAAQ;IAC7C,MAAM9I,MAAM,GAAGH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAChD,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAwB,CAAC,CAAC,GAC3D,IAAI,CAACF,MAAM;IAEf,IAAIH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAc,CAAC,CAAC,CAACgE,IAAI,CAC/C,4BACF,CAAC;IACH;;IAEA;IACA;;IAEA,MAAM6E,qBAAqB,GAAG,IAAI,CAAC,CAAC1G,SAAS,CAAC2G,SAAS,CAAC;MACtDC,QAAQ,EAAE,IAAI,CAAC,CAACC,WAAW,CAACC,IAAI,CAAC,IAAI,CAAC;MACtCC,OAAO,EAAE,IAAI,CAAC,CAACC,UAAU,CAACF,IAAI,CAAC,IAAI,CAAC;MACpCG,WAAW,EAAE,IAAI,CAAC,CAACC,cAAc,CAACJ,IAAI,CAAC,IAAI,CAAC;MAC5CK,wBAAwB,EAAE,IAAI,CAAC,CAACC,2BAA2B,CAACN,IAAI,CAAC,IAAI;IACvE,CAAC,CAAC;IAEFL,GAAG,CAACzC,GAAG,CAAC,MAAM;MACZ,IAAIxG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzCC,MAAM,EAAEC,KAAK,CAAC;UAAEC,UAAU,EAAE;QAAc,CAAC,CAAC,CAACgE,IAAI,CAC/C,8BACF,CAAC;MACH;MAEA6E,qBAAqB,CAACW,WAAW,CAAC,CAAC;IACrC,CAAC,CAAC;EACJ;EAEA,CAACD,2BAA2BE,CAAA,EAAS;IACnC,IAAI9J,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAChB;QAAEC,UAAU,EAAE;MAA2B,CAC3C,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC;IACb;EACF;EAEA,CAACoJ,cAAcK,CAAA,EAAS;IACtB,IAAI/J,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,IAAI,CAACC,MAAM,EAAEC,KAAK,CAChB;QAAEC,UAAU,EAAE;MAAc,CAC9B,CAAC,CAACgE,IAAI,CAAC,EAAE,CAAC;IACZ;EACF;EAEA,CAACmF,UAAUQ,CAACC,MAGX,EAAE;IACD,IAAI,IAAI,CAAC9J,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAU,CAAC,CAAC,CAACyF,KAAK,CACjD,qBAAqB,EACrBmE,MACF,CAAC;IACH;EACF;EAEA,CAACZ,WAAWa,CACV;IAAE3B,MAAM,EAAE4B,UAAU;IAAEC;EAAkD,CAAC,EACnE;IACN,MAAMjK,MAAM,GAAGH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAChD,IAAI,CAACC,MAAM,EAAEC,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAwB,CAAC,CAAC,GAC3D,IAAI,CAACF,MAAM;IAEf,IAAIH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCC,MAAM,EAAEC,KAAK,CAAC;QAAEC,UAAU,EAAE;MAAW,CAAC,CAAC,CAACC,KAAK,CAC7C,0BAA0B8J,KAAK,EAAE,EACjCD,UACF,CAAC;IACH;IAEA,IAAIC,KAAK,KAAK,kBAAkB,EAAE;MAChC,MAAM7B,MAAoB,GACvB4B,UAAU,CAACE,QAAQ,KAAKF,UAAU,CAAC5C,WAAW,GAC3C4C,UAAU,CAAC3B,GAAG,CAAC2B,UAAU,CAAC5C,WAAW,CAAC,GACtC4C,UAAsC;MAE5C,IAAI,CAACzI,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;QAC9BX,kBAAkB,CAAC,IAAI,CAACsC,KAAK,EAAE,CAAC6G,MAAM,CAAuB,EAAExI,KAAK,CAAC;MACvE,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIqK,KAAK,KAAK,SAAS,EAAE;MAC9B,IAAI,CAAC,CAACE,YAAY,CAACH,UAAU,EAAEhK,MAAM,CAAC;IACxC;EACF;EAEA,CAACmK,YAAYC,CACXJ,UAAkE,EAClEhK,MAA0B,EAC1B;IACA,IAAI,CAACuB,KAAK,CAAC3B,KAAK,CAAC,CAAC,CAAC,EAAGA,KAAK,IAAK;MAC9B;MACA,MAAMyK,QAAQ,GAAGzK,KAAK,CAACgB,IAAI,CAAC,IAAI,CAACC,QAAQ,CAAC;MAC1C,CACEwJ,QAAQ,GAAAxK,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBADVtB,SAAS,QAEP,oEAAoE,IAFtEA,SAAS;MAIT,IAAI4L,QAAQ,CAAC1K,MAAM,KAAK,QAAQ,EAAE;QAChC,MAAM2B,cAAc,GAAG,IAAI,CAACC,KAAK,CAAC4F,WAAW,CAC3C,QAAQ,EACR6C,UAAU,CAAC5C,WAAW,EACtB4C,UAAU,CAAC3C,WACb,CAAC;QACD;QACA,MAAMiD,UAAU,GAAGD,QAAQ,CAACvJ,KAAK,EAAEJ,IAAI,CAACyH,MAAM,CAC3CoC,CAAC,IAAKA,CAAC,KAAKjJ,cACf,CAAC;;QAED;QACA;QACA,IAAIgJ,UAAU,EAAE/F,MAAM,KAAK8F,QAAQ,CAACvJ,KAAK,EAAEJ,IAAI,CAAC6D,MAAM,EAAE;UACtD3E,KAAK,CAACqB,OAAO,CAACC,YAAY,CAAC,IAAI,CAACL,QAAQ,CAAC;UACzCjB,KAAK,CAACmB,KAAK,CACT,IAAI,CAACF,QAAQ,EACb;YAAEH,IAAI,EAAE4J,UAAU,IAAI;UAAG,CAAC,EAC1B,QACF,CAAC;UACD;UACA;QACF;QAEA;MACF;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIzK,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzCC,MAAM,EAAEkE,IAAI,CACV,+EAA+E,EAC/EmG,QACF,CAAC;MACH;MAEA,IAAI,CAACxE,UAAU,CAAC,WAAY,IAAI,CAAC,CAAC2E,KAAK,CAAE9E,CAAU,IAAK;QACtD,IAAI1F,MAAM,EAAE;UACVA,MAAM,EAAE2F,KAAK,CAAC,wCAAwC,EAAED,CAAC,CAAC;QAC5D,CAAC,MAAM;UACL;UACA;UACA/D,OAAO,CAACgE,KAAK,CAAC,wCAAwC,EAAED,CAAC,CAAC;QAC5D;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;AACF;AAEA,SAASlF,gBAAgBA,CACvBf,eAAiC,EACjCG,KAAmB,EACnB;EACA,MAAM6K,OAAO,GAAG,IAAI3D,GAAG,CAAiB,CAAC;EACzCrH,eAAe,GAAGA,eAAe,CAAC0I,MAAM,CAAEZ,GAAG,IAAK;IAChD3H,KAAK,CAACgB,IAAI,CAAC2G,GAAG,CAAC;IACf,IAAIkD,OAAO,CAACrE,GAAG,CAACmB,GAAG,CAAC,EAAE;MACpB,OAAO,KAAK;IACd;IACAkD,OAAO,CAACpE,GAAG,CAACkB,GAAG,CAAC;IAChB,OAAO,IAAI;EACb,CAAC,CAAC;EACF,OAAO9H,eAAe;AACxB;AAEA,SAASyD,oBAAoBA,CAC3Bd,OAA8D,EAC9D;EACA,OAAOgD,MAAM,CAACsF,OAAO,CAACtI,OAAO,CAAC,CAAC/D,GAAG,CAAC,CAAC,CAACkJ,GAAG,EAAEoD,KAAK,CAAC,KAAK;IACnD,OAAO,CACLjC,CAA6C,EAC7CC,CAA6C,KAClC;MACX,MAAMiC,MAAM,GAAGlC,CAAC,GAAGnB,GAAG,CAAC;MACvB,MAAMsD,MAAM,GAAGlC,CAAC,GAAGpB,GAAG,CAAC;MAEvB,IAAIqD,MAAM,IAAI,IAAI,IAAIC,MAAM,IAAI,IAAI,EAAE;QACpC,OAAO,CAAC;MACV;MACA,IAAID,MAAM,IAAI,IAAI,EAAE;QAClB,OAAO,CAAC;MACV;MACA,IAAIC,MAAM,IAAI,IAAI,EAAE;QAClB,OAAO,CAAC,CAAC;MACX;MACA,MAAMC,CAAC,GAAGH,KAAK,KAAK,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;MAClC,OAAOC,MAAM,GAAGC,MAAM,GAAGC,CAAC,GAAGF,MAAM,GAAGC,MAAM,GAAG,CAACC,CAAC,GAAG,CAAC;IACvD,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA,eAAetF,uBAAuBA,CACpC7C,MAAc,EACdjC,IAA0B,EAC1B;EACA,MAAMqK,MAAM,GAAG9M,OAAO,CAACyC,IAAI,EAAGoC,CAAC,IAAKA,CAAC,CAACsE,WAAW,CAAC;EAClD,MAAM4D,8BAA8B,GAAG5F,MAAM,CAAC6F,WAAW,CACvD,MAAMxG,OAAO,CAACgC,GAAG,CACfrB,MAAM,CAACsF,OAAO,CAACK,MAAM,CAAC,CAAC1M,GAAG,CAOxB,OAAO,CAAC0D,OAAO,EAAEmJ,OAAO,CAAC,KAAK;IAC9B;IACA;IACA;IACA,MAAMC,SAAS,GAAID,OAAO,CAAC,CAAC,CAAC,CAAkBtM,oBAAoB,CAAC,CAClED,YAAY,CACZ;IACF,MAAMsE,KAAwB,GAAG;MAC/B,CAACkI,SAAS,CAACC,iBAAiB,GAAG;QAC7BC,GAAG,EAAEH,OAAO,CAAC7M,GAAG,CAACyE,CAAC,IAAIA,CAAC,CAACuE,WAAW;MACrC;IACF,CAAC;IAED,MAAMiE,MAAM,GAAG,MAAM3I,MAAM,CACzBwI,SACF,CAAC,CAAClI,KAAK,CAACA,KAAK,CAAC,CAAC8B,SAAS,CAAC,CAAC;IAC1B,OAAO,CACLhD,OAAO,EACPqD,MAAM,CAAC6F,WAAW,CAACK,MAAM,CAAC5K,IAAI,CAACrC,GAAG,CAChCyE,CAAC,IAAI,CAACA,CAAC,CAACuE,WAAW,EAAEvE,CAAC,CACxB,CAAC,CAAC,CACH;EACH,CAAC,CACH,CACF,CAAC;EAEDpC,IAAI,GAAGA,IAAI,CAACrC,GAAG,CAAE6I,GAAG,IAAK;IACvB,CACE8D,8BAA8B,CAAC9D,GAAG,CAACE,WAAW,CAAC,CAACF,GAAG,CAACG,WAAW,CAAC,GAAAxH,OAAA,CAAAC,GAAA,CAAAC,QAAA,oBADlEtB,SAAS,QAEP,yBAAyByI,GAAG,CAACE,WAAW,IAAIF,GAAG,CAACG,WAAW,EAAE,IAF/D5I,SAAS;IAIT,OAAOuM,8BAA8B,CAAC9D,GAAG,CAACE,WAAW,CAAC,CAACF,GAAG,CAACG,WAAW,CAAC;EACzE,CAAC,CAAC;EAEF,OAAO3G,IAAI;AACb;AAEA,OAAO,SAAS6K,cAAcA,CAC5B1K,QAAkB,EACQ;EAC1B,OAAOA,QAAQ,CAACiB,IAAI,KAAK,MAAM;AACjC;;AAEA;AACA;AACA","ignoreList":[]}