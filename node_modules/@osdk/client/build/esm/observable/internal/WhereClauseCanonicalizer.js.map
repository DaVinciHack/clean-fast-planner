{"version":3,"file":"WhereClauseCanonicalizer.js","names":["Trie","deepEqual","invariant","WhereClauseCanonicalizer","cache","WeakMap","trie","existingOptions","Map","canonicalize","where","has","get","keysSet","Set","calculatedCanon","toCanon","cacheKey","lookupArray","Array","from","sort","lookupEntry","options","set","canon","find","ref","deref","push","WeakRef","#toCanon","process","env","NODE_ENV","isArray","$and","Object","keys","length","fromEntries","entries","a","b","localeCompare","map","k","v","add","x"],"sources":["WhereClauseCanonicalizer.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ObjectOrInterfaceDefinition, WhereClause } from \"@osdk/api\";\nimport { Trie } from \"@wry/trie\";\nimport deepEqual from \"fast-deep-equal\";\nimport invariant from \"tiny-invariant\";\nimport type { Canonical } from \"./Canonical.js\";\nimport type { SimpleWhereClause } from \"./SimpleWhereClause.js\";\n\nexport class WhereClauseCanonicalizer {\n  /**\n   * This is a shortcut cache for any WhereClause's that we have\n   * seen and already canonicalized. The theory behind this\n   * is that well behaving React applications will either `useMemo`\n   * their where clause, or store it in state or pass it through as\n   * props such that we are likely to get the same WhereClause\n   * object multiple times and we can skip unnecessary work.\n   */\n  #cache = new WeakMap<\n    WhereClause<any> | SimpleWhereClause,\n    Canonical<SimpleWhereClause>\n  >();\n\n  /**\n   * This is a trie that stores the sorted collapsed keys of a where clause to\n   * the cache key for canonicalized options. In theory this keeps the number of\n   * deepEqual comparisons down to a minimum but its probably overkill.\n   */\n  #trie = new Trie<object>();\n\n  /**\n   * This is a cache from the cacheKey provided by `this.#trie` to the potential\n   * canonicalized options.\n   */\n  #existingOptions: Map<object, {\n    options: WeakRef<Canonical<SimpleWhereClause>>[];\n  }> = new Map();\n\n  public canonicalize<T extends ObjectOrInterfaceDefinition>(\n    where: WhereClause<T> | SimpleWhereClause,\n  ): Canonical<SimpleWhereClause> {\n    // fastest shortcut\n    if (this.#cache.has(where)) {\n      return this.#cache.get(where)!;\n    }\n\n    const keysSet = new Set<string>();\n    const calculatedCanon = this.#toCanon(where, keysSet);\n    const cacheKey = this.#trie.lookupArray(Array.from(keysSet).sort());\n    const lookupEntry = this.#existingOptions.get(cacheKey)\n      ?? { options: [] as WeakRef<Canonical<SimpleWhereClause>>[] };\n    this.#existingOptions.set(cacheKey, lookupEntry);\n\n    const canon =\n      lookupEntry.options.find((ref) => deepEqual(ref.deref(), calculatedCanon))\n        ?.deref()\n        ?? calculatedCanon;\n\n    if (canon === calculatedCanon) {\n      // This means no existing options were found\n      lookupEntry.options.push(new WeakRef(canon));\n    }\n\n    this.#cache.set(where, canon);\n    return canon;\n  }\n\n  #toCanon = <T extends ObjectOrInterfaceDefinition>(\n    where: WhereClause<T> | SimpleWhereClause,\n    set: Set<string> = new Set<string>(),\n  ): Canonical<SimpleWhereClause> => {\n    if (\"$and\" in where) {\n      if (process.env.NODE_ENV !== \"production\") {\n        invariant(Array.isArray(where.$and), \"expected $and to be an array\");\n        invariant(\n          Object.keys(where).length === 1,\n          \"expected only $and to be present\",\n        );\n      }\n      if ((where as { $and: SimpleWhereClause[] }).$and.length === 0) {\n        // empty $and is a no-op\n        return {} as Canonical<SimpleWhereClause>;\n      }\n      if ((where as { $and: SimpleWhereClause[] }).$and.length === 1) {\n        return this.#toCanon(\n          (where as { $and: SimpleWhereClause[] }).$and[0],\n          set,\n        );\n      }\n    }\n    // This is incomplete for all the cases possible but it gets us started\n\n    return Object.fromEntries(\n      Object.entries(where)\n        .sort(([a], [b]) => a.localeCompare(b))\n        .map(([k, v]) => {\n          set.add(k);\n          if (k === \"$and\" || k === \"$or\") {\n            return [k, (v as Array<any>).map(x => this.#toCanon(x, set))];\n          }\n          if (k !== \"$not\" && typeof v === \"object\" && \"$eq\" in v) {\n            return [k, v[\"$eq\"]];\n          }\n          return [k, v];\n        }),\n    ) as Canonical<SimpleWhereClause>;\n  };\n}\n"],"mappings":"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","ignoreList":[]}