{"version":3,"file":"ObservableClient.js","names":["createFetchHeaderMutator","additionalContext","createClientFromContext","OBSERVABLE_USER_AGENT","ObservableClientImpl","Store","ObservableClient","createObservableClient","client","tweakedClient","fetch","headers","set","get","filter","x","length","join"],"sources":["ObservableClient.ts"],"sourcesContent":["/*\n * Copyright 2025 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ActionDefinition,\n  InterfaceDefinition,\n  ObjectTypeDefinition,\n  Osdk,\n  PrimaryKeyType,\n  PropertyKeys,\n  WhereClause,\n} from \"@osdk/api\";\nimport { createFetchHeaderMutator } from \"@osdk/shared.net.fetch\";\nimport type { ActionSignatureFromDef } from \"../actions/applyAction.js\";\nimport { additionalContext, type Client } from \"../Client.js\";\nimport { createClientFromContext } from \"../createClient.js\";\nimport { OBSERVABLE_USER_AGENT } from \"../util/UserAgent.js\";\nimport type { Canonical } from \"./internal/Canonical.js\";\nimport { ObservableClientImpl } from \"./internal/ObservableClientImpl.js\";\nimport { Store } from \"./internal/Store.js\";\nimport type { OptimisticBuilder } from \"./OptimisticBuilder.js\";\n\nexport type Status = \"init\" | \"loading\" | \"loaded\" | \"error\";\n\nexport interface Observer<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport namespace ObservableClient {\n  export interface ApplyActionOptions {\n    optimisticUpdate?: (ctx: OptimisticBuilder) => void;\n  }\n}\n\nexport interface CommonObserveOptions {\n  dedupeInterval?: number;\n}\n\nexport interface ObserveOptions {\n  mode?: \"offline\" | \"force\";\n}\n\nexport interface ObserveObjectOptions<\n  T extends ObjectTypeDefinition | InterfaceDefinition,\n> extends ObserveOptions {\n  select?: PropertyKeys<T>[];\n}\n\nexport type OrderBy<Q extends ObjectTypeDefinition | InterfaceDefinition> = {\n  [K in PropertyKeys<Q>]?: \"asc\" | \"desc\" | undefined;\n};\n\nexport interface ObserveListOptions<\n  Q extends ObjectTypeDefinition | InterfaceDefinition,\n> extends CommonObserveOptions, ObserveOptions {\n  type: Pick<Q, \"apiName\" | \"type\">;\n  where?: WhereClause<Q>;\n  pageSize?: number;\n  orderBy?: OrderBy<Q>;\n  invalidationMode?: \"in-place\" | \"wait\" | \"reset\";\n  expectedLength?: number;\n  streamUpdates?: boolean;\n}\n\nexport interface ObserveObjectArgs<T extends ObjectTypeDefinition> {\n  object: Osdk.Instance<T> | undefined;\n  isOptimistic: boolean;\n  status: Status;\n  lastUpdated: number;\n}\n\nexport interface ObserveObjectsArgs<\n  T extends ObjectTypeDefinition | InterfaceDefinition,\n> {\n  resolvedList: Array<Osdk.Instance<T>>;\n  isOptimistic: boolean;\n  lastUpdated: number;\n  fetchMore: () => Promise<unknown>;\n  hasMore: boolean;\n  status: Status;\n}\n\nexport interface ObservableClient {\n  observeObject<T extends ObjectTypeDefinition>(\n    apiName: T[\"apiName\"] | T,\n    pk: PrimaryKeyType<T>,\n    options: ObserveOptions,\n    subFn: Observer<ObserveObjectArgs<T>>,\n  ): Unsubscribable;\n\n  observeList<T extends ObjectTypeDefinition | InterfaceDefinition>(\n    options: ObserveListOptions<T>,\n    subFn: Observer<ObserveObjectsArgs<T>>,\n  ): Unsubscribable;\n\n  applyAction: <Q extends ActionDefinition<any>>(\n    action: Q,\n    args:\n      | Parameters<ActionSignatureFromDef<Q>[\"applyAction\"]>[0]\n      | Array<Parameters<ActionSignatureFromDef<Q>[\"applyAction\"]>[0]>,\n    opts?: ObservableClient.ApplyActionOptions,\n  ) => Promise<unknown>;\n\n  canonicalizeWhereClause: <\n    T extends ObjectTypeDefinition | InterfaceDefinition,\n  >(\n    where: WhereClause<T>,\n  ) => Canonical<WhereClause<T>>;\n}\n\nexport function createObservableClient(client: Client): ObservableClient {\n  // First we need a modified client that adds an extra header so we know its\n  // an observable client\n  const tweakedClient = createClientFromContext({\n    ...client[additionalContext],\n\n    fetch: createFetchHeaderMutator(\n      client[additionalContext].fetch,\n      (headers) => {\n        headers.set(\n          \"Fetch-User-Agent\",\n          [\n            headers.get(\"Fetch-User-Agent\"),\n            OBSERVABLE_USER_AGENT,\n          ].filter(x => x && x?.length > 0).join(\" \"),\n        );\n        return headers;\n      },\n    ),\n  });\n\n  // Then we use that client instead. Because the `client` does not hold\n  // any real state, this whole thing works.\n  return new ObservableClientImpl(new Store(tweakedClient));\n}\n\nexport interface Unsubscribable {\n  unsubscribe: () => void;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAWA,SAASA,wBAAwB,QAAQ,wBAAwB;AAEjE,SAASC,iBAAiB,QAAqB,cAAc;AAC7D,SAASC,uBAAuB,QAAQ,oBAAoB;AAC5D,SAASC,qBAAqB,QAAQ,sBAAsB;AAE5D,SAASC,oBAAoB,QAAQ,oCAAoC;AACzE,SAASC,KAAK,QAAQ,qBAAqB;AAAC,WAW3BC,gBAAgB;AAkFjC,OAAO,SAASC,sBAAsBA,CAACC,MAAc,EAAoB;EACvE;EACA;EACA,MAAMC,aAAa,GAAGP,uBAAuB,CAAC;IAC5C,GAAGM,MAAM,CAACP,iBAAiB,CAAC;IAE5BS,KAAK,EAAEV,wBAAwB,CAC7BQ,MAAM,CAACP,iBAAiB,CAAC,CAACS,KAAK,EAC9BC,OAAO,IAAK;MACXA,OAAO,CAACC,GAAG,CACT,kBAAkB,EAClB,CACED,OAAO,CAACE,GAAG,CAAC,kBAAkB,CAAC,EAC/BV,qBAAqB,CACtB,CAACW,MAAM,CAACC,CAAC,IAAIA,CAAC,IAAIA,CAAC,EAAEC,MAAM,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAC5C,CAAC;MACD,OAAON,OAAO;IAChB,CACF;EACF,CAAC,CAAC;;EAEF;EACA;EACA,OAAO,IAAIP,oBAAoB,CAAC,IAAIC,KAAK,CAACI,aAAa,CAAC,CAAC;AAC3D","ignoreList":[]}