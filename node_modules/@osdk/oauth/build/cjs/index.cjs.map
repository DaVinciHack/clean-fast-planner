{"version":3,"sources":["../../../../node_modules/.pnpm/oauth4webapi@2.10.4/node_modules/oauth4webapi/build/index.js","../../src/throwIfError.ts","../../src/common.ts","../../src/createConfidentialOauthClient.ts","../../../../node_modules/.pnpm/delay@6.0.0/node_modules/delay/index.js","../../src/utils.ts","../../src/createPublicOauthClient.ts"],"names":["clockSkew","clockTolerance","CustomEvent","TypedEventTarget","invariant","getToken","signal"],"mappings":";;;;;;;;;;AAAA,IAAI,UAAA;AACJ,IAAI,OAAO,cAAc,WAAe,IAAA,CAAC,UAAU,SAAW,EAAA,UAAA,GAAa,cAAc,CAAG,EAAA;AAC1F,EAAA,MAAM,IAAO,GAAA,cAAA;AACb,EAAA,MAAM,OAAU,GAAA,SAAA;AAChB,EAAa,UAAA,GAAA,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA;AACjC;AACA,SAAS,eAAA,CAAgB,OAAO,QAAU,EAAA;AACxC,EAAA,IAAI,SAAS,IAAM,EAAA;AACjB,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA;AACF,IAAA,OAAO,KAAiB,YAAA,QAAA,IAAY,MAAO,CAAA,cAAA,CAAe,KAAK,CAAA,CAAE,MAAO,CAAA,WAAW,CAAM,KAAA,QAAA,CAAS,SAAU,CAAA,MAAA,CAAO,WAAW,CAAA;AAAA,GACxH,CAAA,MAAA;AACN,IAAO,OAAA,KAAA;AAAA;AAEX;AACO,IAAM,YAAY,MAAO,EAAA;AACzB,IAAM,iBAAiB,MAAO,EAAA;AAC9B,IAAM,cAAc,MAAO,EAAA;AAC3B,IAAM,eAAe,MAAO,EAAA;AACnC,IAAM,OAAA,GAAU,IAAI,WAAY,EAAA;AAChC,IAAM,OAAA,GAAU,IAAI,WAAY,EAAA;AAChC,SAAS,IAAI,KAAO,EAAA;AAClB,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAO,OAAA,OAAA,CAAQ,OAAO,KAAK,CAAA;AAAA;AAE7B,EAAO,OAAA,OAAA,CAAQ,OAAO,KAAK,CAAA;AAC7B;AACA,IAAM,UAAa,GAAA,KAAA;AACnB,SAAS,gBAAgB,KAAO,EAAA;AAC9B,EAAA,IAAI,iBAAiB,WAAa,EAAA;AAChC,IAAQ,KAAA,GAAA,IAAI,WAAW,KAAK,CAAA;AAAA;AAE9B,EAAA,MAAM,MAAM,EAAC;AACb,EAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,UAAA,EAAY,KAAK,UAAY,EAAA;AACrD,IAAI,GAAA,CAAA,IAAA,CAAK,MAAO,CAAA,YAAA,CAAa,KAAM,CAAA,IAAA,EAAM,KAAM,CAAA,QAAA,CAAS,CAAG,EAAA,CAAA,GAAI,UAAU,CAAC,CAAC,CAAA;AAAA;AAE7E,EAAA,OAAO,KAAK,GAAI,CAAA,IAAA,CAAK,EAAE,CAAC,EAAE,OAAQ,CAAA,IAAA,EAAM,EAAE,CAAA,CAAE,QAAQ,KAAO,EAAA,GAAG,CAAE,CAAA,OAAA,CAAQ,OAAO,GAAG,CAAA;AACpF;AACA,SAAS,gBAAgB,KAAO,EAAA;AAC9B,EAAI,IAAA;AACF,IAAA,MAAM,MAAS,GAAA,IAAA,CAAK,KAAM,CAAA,OAAA,CAAQ,MAAM,GAAG,CAAA,CAAE,OAAQ,CAAA,IAAA,EAAM,GAAG,CAAA,CAAE,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAC,CAAA;AAClF,IAAA,MAAM,KAAQ,GAAA,IAAI,UAAW,CAAA,MAAA,CAAO,MAAM,CAAA;AAC1C,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,QAAQ,CAAK,EAAA,EAAA;AACtC,MAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAO,CAAA,UAAA,CAAW,CAAC,CAAA;AAAA;AAEhC,IAAO,OAAA,KAAA;AAAA,WACA,KAAO,EAAA;AACd,IAAM,MAAA,IAAI,IAAI,mDAAqD,EAAA;AAAA,MACjE;AAAA,KACD,CAAA;AAAA;AAEL;AACA,SAAS,KAAK,KAAO,EAAA;AACnB,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAA,OAAO,gBAAgB,KAAK,CAAA;AAAA;AAE9B,EAAA,OAAO,gBAAgB,KAAK,CAAA;AAC9B;AACA,IAAM,MAAN,MAAU;AAAA,EACR,YAAY,OAAS,EAAA;AACnB,IAAK,IAAA,CAAA,KAAA,uBAAY,GAAI,EAAA;AACrB,IAAK,IAAA,CAAA,MAAA,uBAAa,GAAI,EAAA;AACtB,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA;AAAA;AACjB,EACA,IAAI,GAAK,EAAA;AACP,IAAA,IAAI,CAAI,GAAA,IAAA,CAAK,KAAM,CAAA,GAAA,CAAI,GAAG,CAAA;AAC1B,IAAA,IAAI,CAAG,EAAA;AACL,MAAO,OAAA,CAAA;AAAA;AAET,IAAA,IAAI,CAAI,GAAA,IAAA,CAAK,MAAO,CAAA,GAAA,CAAI,GAAG,CAAG,EAAA;AAC5B,MAAK,IAAA,CAAA,MAAA,CAAO,KAAK,CAAC,CAAA;AAClB,MAAO,OAAA,CAAA;AAAA;AAET,IAAO,OAAA,SAAA;AAAA;AACT,EACA,IAAI,GAAK,EAAA;AACP,IAAO,OAAA,IAAA,CAAK,MAAM,GAAI,CAAA,GAAG,KAAK,IAAK,CAAA,MAAA,CAAO,IAAI,GAAG,CAAA;AAAA;AACnD,EACA,GAAA,CAAI,KAAK,KAAO,EAAA;AACd,IAAA,IAAI,IAAK,CAAA,KAAA,CAAM,GAAI,CAAA,GAAG,CAAG,EAAA;AACvB,MAAK,IAAA,CAAA,KAAA,CAAM,GAAI,CAAA,GAAA,EAAK,KAAK,CAAA;AAAA,KACpB,MAAA;AACL,MAAK,IAAA,CAAA,MAAA,CAAO,KAAK,KAAK,CAAA;AAAA;AAExB,IAAO,OAAA,IAAA;AAAA;AACT,EACA,OAAO,GAAK,EAAA;AACV,IAAA,IAAI,IAAK,CAAA,KAAA,CAAM,GAAI,CAAA,GAAG,CAAG,EAAA;AACvB,MAAO,OAAA,IAAA,CAAK,KAAM,CAAA,MAAA,CAAO,GAAG,CAAA;AAAA;AAE9B,IAAA,IAAI,IAAK,CAAA,MAAA,CAAO,GAAI,CAAA,GAAG,CAAG,EAAA;AACxB,MAAO,OAAA,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,GAAG,CAAA;AAAA;AAE/B,IAAO,OAAA,KAAA;AAAA;AACT,EACA,MAAA,CAAO,KAAK,KAAO,EAAA;AACjB,IAAK,IAAA,CAAA,KAAA,CAAM,GAAI,CAAA,GAAA,EAAK,KAAK,CAAA;AACzB,IAAA,IAAI,IAAK,CAAA,KAAA,CAAM,IAAQ,IAAA,IAAA,CAAK,OAAS,EAAA;AACnC,MAAA,IAAA,CAAK,SAAS,IAAK,CAAA,KAAA;AACnB,MAAK,IAAA,CAAA,KAAA,uBAAY,GAAI,EAAA;AAAA;AACvB;AAEJ,CAAA;AACO,IAAM,yBAAA,GAAN,cAAwC,KAAM,CAAA;AAAA,EACnD,YAAY,OAAS,EAAA;AACnB,IAAA,KAAA,CAAM,WAAW,yBAAyB,CAAA;AAC1C,IAAK,IAAA,CAAA,IAAA,GAAO,KAAK,WAAY,CAAA,IAAA;AAC7B,IAAM,KAAA,CAAA,iBAAA,GAAoB,IAAM,EAAA,IAAA,CAAK,WAAW,CAAA;AAAA;AAEpD,CAAA;AACO,IAAM,wBAAA,GAAN,cAAuC,KAAM,CAAA;AAAA,EAClD,WAAA,CAAY,SAAS,OAAS,EAAA;AAC5B,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA;AACtB,IAAK,IAAA,CAAA,IAAA,GAAO,KAAK,WAAY,CAAA,IAAA;AAC7B,IAAM,KAAA,CAAA,iBAAA,GAAoB,IAAM,EAAA,IAAA,CAAK,WAAW,CAAA;AAAA;AAEpD,CAAA;AACA,IAAM,GAAM,GAAA,wBAAA;AACZ,IAAM,UAAA,GAAa,IAAI,GAAA,CAAI,GAAG,CAAA;AAC9B,SAAS,YAAY,GAAK,EAAA;AACxB,EAAA,OAAO,GAAe,YAAA,SAAA;AACxB;AACA,SAAS,aAAa,GAAK,EAAA;AACzB,EAAA,OAAO,WAAY,CAAA,GAAG,CAAK,IAAA,GAAA,CAAI,IAAS,KAAA,SAAA;AAC1C;AACA,SAAS,YAAY,GAAK,EAAA;AACxB,EAAA,OAAO,WAAY,CAAA,GAAG,CAAK,IAAA,GAAA,CAAI,IAAS,KAAA,QAAA;AAC1C;AAEA,SAAS,iBAAiB,QAAU,EAAA;AAClC,EAAI,IAAA;AACF,IAAA,MAAM,KAAQ,GAAA,QAAA,CAAS,OAAQ,CAAA,GAAA,CAAI,YAAY,CAAA;AAC/C,IAAA,IAAI,KAAO,EAAA;AACT,MAAA,UAAA,CAAW,IAAI,IAAI,GAAA,CAAI,SAAS,GAAG,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA;AACpD,GACM,CAAA,MAAA;AAAA;AACR,EAAO,OAAA,QAAA;AACT;AAIA,SAAS,aAAa,KAAO,EAAA;AAC3B,EAAI,IAAA,KAAA,KAAU,QAAQ,OAAO,KAAA,KAAU,YAAY,KAAM,CAAA,OAAA,CAAQ,KAAK,CAAG,EAAA;AACvE,IAAO,OAAA,KAAA;AAAA;AAET,EAAO,OAAA,IAAA;AACT;AACA,SAAS,eAAe,KAAO,EAAA;AAC7B,EAAI,IAAA,eAAA,CAAgB,KAAO,EAAA,OAAO,CAAG,EAAA;AACnC,IAAA,KAAA,GAAQ,MAAO,CAAA,WAAA,CAAY,KAAM,CAAA,OAAA,EAAS,CAAA;AAAA;AAE5C,EAAM,MAAA,OAAA,GAAU,IAAI,OAAA,CAAQ,KAAK,CAAA;AACjC,EAAA,IAAI,UAAc,IAAA,CAAC,OAAQ,CAAA,GAAA,CAAI,YAAY,CAAG,EAAA;AAC5C,IAAQ,OAAA,CAAA,GAAA,CAAI,cAAc,UAAU,CAAA;AAAA;AAEtC,EAAI,IAAA,OAAA,CAAQ,GAAI,CAAA,eAAe,CAAG,EAAA;AAChC,IAAM,MAAA,IAAI,UAAU,oEAAoE,CAAA;AAAA;AAE1F,EAAI,IAAA,OAAA,CAAQ,GAAI,CAAA,MAAM,CAAG,EAAA;AACvB,IAAM,MAAA,IAAI,UAAU,2DAA2D,CAAA;AAAA;AAEjF,EAAO,OAAA,OAAA;AACT;AACA,SAAS,OAAO,KAAO,EAAA;AACrB,EAAI,IAAA,OAAO,UAAU,UAAY,EAAA;AAC/B,IAAA,KAAA,GAAQ,KAAM,EAAA;AAAA;AAEhB,EAAI,IAAA,EAAE,iBAAiB,WAAc,CAAA,EAAA;AACnC,IAAM,MAAA,IAAI,UAAU,+DAA+D,CAAA;AAAA;AAErF,EAAO,OAAA,KAAA;AACT;AAiCA,SAAS,eAAe,KAAO,EAAA;AAC7B,EAAA,OAAO,OAAO,KAAA,KAAU,QAAY,IAAA,KAAA,CAAM,MAAW,KAAA,CAAA;AACvD;AA+BA,SAAS,WAAc,GAAA;AACrB,EAAA,OAAO,KAAK,MAAO,CAAA,eAAA,CAAgB,IAAI,UAAW,CAAA,EAAE,CAAC,CAAC,CAAA;AACxD;AACO,SAAS,0BAA6B,GAAA;AAC3C,EAAA,OAAO,WAAY,EAAA;AACrB;AACO,SAAS,mBAAsB,GAAA;AACpC,EAAA,OAAO,WAAY,EAAA;AACrB;AAIA,eAAsB,2BAA2B,YAAc,EAAA;AAC7D,EAAI,IAAA,CAAC,cAAe,CAAA,YAAY,CAAG,EAAA;AACjC,IAAM,MAAA,IAAI,UAAU,2CAA2C,CAAA;AAAA;AAEjE,EAAO,OAAA,IAAA,CAAK,MAAM,MAAO,CAAA,MAAA,CAAO,OAAO,SAAW,EAAA,GAAA,CAAI,YAAY,CAAC,CAAC,CAAA;AACtE;AACA,SAAS,aAAa,KAAO,EAAA;AAC3B,EAAA,IAAI,iBAAiB,SAAW,EAAA;AAC9B,IAAO,OAAA;AAAA,MACL,GAAK,EAAA;AAAA,KACP;AAAA;AAEF,EAAI,IAAA,EAAE,KAAO,EAAA,GAAA,YAAe,SAAY,CAAA,EAAA;AACtC,IAAA,OAAO,EAAC;AAAA;AAEV,EAAA,IAAI,MAAM,GAAQ,KAAA,SAAA,IAAa,CAAC,cAAe,CAAA,KAAA,CAAM,GAAG,CAAG,EAAA;AACzD,IAAM,MAAA,IAAI,UAAU,kCAAkC,CAAA;AAAA;AAExD,EAAO,OAAA;AAAA,IACL,KAAK,KAAM,CAAA,GAAA;AAAA,IACX,KAAK,KAAM,CAAA;AAAA,GACb;AACF;AACA,SAAS,cAAc,KAAO,EAAA;AAC5B,EAAA,OAAO,kBAAmB,CAAA,KAAK,CAAE,CAAA,OAAA,CAAQ,QAAQ,GAAG,CAAA;AACtD;AACA,SAAS,iBAAA,CAAkB,UAAU,YAAc,EAAA;AACjD,EAAM,MAAA,QAAA,GAAW,cAAc,QAAQ,CAAA;AACvC,EAAM,MAAA,QAAA,GAAW,cAAc,YAAY,CAAA;AAC3C,EAAA,MAAM,cAAc,IAAK,CAAA,CAAA,EAAG,QAAQ,CAAA,CAAA,EAAI,QAAQ,CAAE,CAAA,CAAA;AAClD,EAAA,OAAO,SAAS,WAAW,CAAA,CAAA;AAC7B;AACA,SAAS,MAAM,GAAK,EAAA;AAClB,EAAQ,QAAA,GAAA,CAAI,SAAU,CAAA,IAAA,CAAK,IAAM;AAAA,IAC/B,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT;AACE,MAAM,MAAA,IAAI,0BAA0B,6CAA6C,CAAA;AAAA;AAEvF;AACA,SAAS,MAAM,GAAK,EAAA;AAClB,EAAQ,QAAA,GAAA,CAAI,SAAU,CAAA,IAAA,CAAK,IAAM;AAAA,IAC/B,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,SAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT;AACE,MAAM,MAAA,IAAI,0BAA0B,6CAA6C,CAAA;AAAA;AAEvF;AACA,SAAS,MAAM,GAAK,EAAA;AAClB,EAAQ,QAAA,GAAA,CAAI,UAAU,UAAY;AAAA,IAChC,KAAK,OAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,OAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT,KAAK,OAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT;AACE,MAAM,MAAA,IAAI,0BAA0B,uCAAuC,CAAA;AAAA;AAEjF;AACA,SAAS,SAAS,GAAK,EAAA;AACrB,EAAQ,QAAA,GAAA,CAAI,UAAU,IAAM;AAAA,IAC1B,KAAK,SAAA;AACH,MAAA,OAAO,MAAM,GAAG,CAAA;AAAA,IAClB,KAAK,mBAAA;AACH,MAAA,OAAO,MAAM,GAAG,CAAA;AAAA,IAClB,KAAK,OAAA;AACH,MAAA,OAAO,MAAM,GAAG,CAAA;AAAA,IAClB,KAAK,SAAA;AAAA,IACL,KAAK,OAAA;AACH,MAAO,OAAA,OAAA;AAAA,IACT;AACE,MAAM,MAAA,IAAI,0BAA0B,sCAAsC,CAAA;AAAA;AAEhF;AACA,SAAS,aAAa,MAAQ,EAAA;AAC5B,EAAM,MAAA,IAAA,GAAO,SAAS,SAAS,CAAA;AAC/B,EAAA,OAAO,OAAO,IAAS,KAAA,QAAA,IAAY,OAAO,QAAS,CAAA,IAAI,IAAI,IAAO,GAAA,CAAA;AACpE;AACA,SAAS,kBAAkB,MAAQ,EAAA;AACjC,EAAM,MAAA,SAAA,GAAY,SAAS,cAAc,CAAA;AACzC,EAAA,OAAO,OAAO,SAAA,KAAc,QAAY,IAAA,MAAA,CAAO,QAAS,CAAA,SAAS,CAAK,IAAA,IAAA,CAAK,IAAK,CAAA,SAAS,CAAM,KAAA,EAAA,GAAK,SAAY,GAAA,EAAA;AAClH;AACA,SAAS,SAAY,GAAA;AACnB,EAAA,OAAO,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,KAAQ,GAAI,CAAA;AACrC;AACA,SAAS,eAAA,CAAgB,IAAI,MAAQ,EAAA;AACnC,EAAA,MAAM,GAAM,GAAA,SAAA,EAAc,GAAA,YAAA,CAAa,MAAM,CAAA;AAC7C,EAAO,OAAA;AAAA,IACL,KAAK,WAAY,EAAA;AAAA,IACjB,GAAK,EAAA,CAAC,EAAG,CAAA,MAAA,EAAQ,GAAG,cAAc,CAAA;AAAA,IAClC,KAAK,GAAM,GAAA,EAAA;AAAA,IACX,GAAK,EAAA,GAAA;AAAA,IACL,GAAK,EAAA,GAAA;AAAA,IACL,KAAK,MAAO,CAAA,SAAA;AAAA,IACZ,KAAK,MAAO,CAAA;AAAA,GACd;AACF;AACA,eAAe,aAAc,CAAA,EAAA,EAAI,MAAQ,EAAA,GAAA,EAAK,GAAK,EAAA;AACjD,EAAA,OAAO,GAAI,CAAA;AAAA,IACT,GAAA,EAAK,SAAS,GAAG,CAAA;AAAA,IACjB;AAAA,GACC,EAAA,eAAA,CAAgB,EAAI,EAAA,MAAM,GAAG,GAAG,CAAA;AACrC;AACA,SAAS,SAAS,EAAI,EAAA;AACpB,EAAA,IAAI,OAAO,EAAA,KAAO,QAAY,IAAA,EAAA,KAAO,IAAM,EAAA;AACzC,IAAM,MAAA,IAAI,UAAU,wBAAwB,CAAA;AAAA;AAE9C,EAAA,IAAI,CAAC,cAAA,CAAe,EAAG,CAAA,MAAM,CAAG,EAAA;AAC9B,IAAM,MAAA,IAAI,UAAU,iDAAiD,CAAA;AAAA;AAEvE,EAAO,OAAA,IAAA;AACT;AACA,SAAS,aAAa,MAAQ,EAAA;AAC5B,EAAA,IAAI,OAAO,MAAA,KAAW,QAAY,IAAA,MAAA,KAAW,IAAM,EAAA;AACjD,IAAM,MAAA,IAAI,UAAU,4BAA4B,CAAA;AAAA;AAElD,EAAA,IAAI,CAAC,cAAA,CAAe,MAAO,CAAA,SAAS,CAAG,EAAA;AACrC,IAAM,MAAA,IAAI,UAAU,wDAAwD,CAAA;AAAA;AAE9E,EAAO,OAAA,IAAA;AACT;AACA,SAAS,mBAAmB,YAAc,EAAA;AACxC,EAAI,IAAA,CAAC,cAAe,CAAA,YAAY,CAAG,EAAA;AACjC,IAAM,MAAA,IAAI,UAAU,4DAA4D,CAAA;AAAA;AAElF,EAAO,OAAA,YAAA;AACT;AACA,SAAS,wBAAA,CAAyB,kBAAkB,gBAAkB,EAAA;AACpE,EAAA,IAAI,qBAAqB,SAAW,EAAA;AAClC,IAAA,MAAM,IAAI,SAAA,CAAU,CAAiE,8DAAA,EAAA,gBAAgB,CAAwC,sCAAA,CAAA,CAAA;AAAA;AAEjJ;AACA,SAAS,oBAAA,CAAqB,kBAAkB,YAAc,EAAA;AAC5D,EAAA,IAAI,iBAAiB,SAAW,EAAA;AAC9B,IAAA,MAAM,IAAI,SAAA,CAAU,CAA6D,0DAAA,EAAA,gBAAgB,CAAwC,sCAAA,CAAA,CAAA;AAAA;AAE7I;AACA,eAAe,oBAAqB,CAAA,EAAA,EAAI,MAAQ,EAAA,IAAA,EAAM,SAAS,gBAAkB,EAAA;AAC/E,EAAA,IAAA,CAAK,OAAO,eAAe,CAAA;AAC3B,EAAA,IAAA,CAAK,OAAO,uBAAuB,CAAA;AACnC,EAAA,IAAA,CAAK,OAAO,kBAAkB,CAAA;AAC9B,EAAA,QAAQ,OAAO,0BAA4B;AAAA,IACzC,KAAK,SAAA;AAAA,IACL,KAAK,qBACH,EAAA;AACE,MAAA,wBAAA,CAAyB,uBAAuB,gBAAgB,CAAA;AAChE,MAAQ,OAAA,CAAA,GAAA,CAAI,iBAAiB,iBAAkB,CAAA,MAAA,CAAO,WAAW,kBAAmB,CAAA,MAAA,CAAO,aAAa,CAAC,CAAC,CAAA;AAC1G,MAAA;AAAA;AACF,IACF,KAAK,oBACH,EAAA;AACE,MAAA,wBAAA,CAAyB,sBAAsB,gBAAgB,CAAA;AAC/D,MAAK,IAAA,CAAA,GAAA,CAAI,WAAa,EAAA,MAAA,CAAO,SAAS,CAAA;AACtC,MAAA,IAAA,CAAK,GAAI,CAAA,eAAA,EAAiB,kBAAmB,CAAA,MAAA,CAAO,aAAa,CAAC,CAAA;AAClE,MAAA;AAAA;AACF,IACF,KAAK,iBACH,EAAA;AACE,MAAqB,oBAAA,CAAA,iBAAA,EAAmB,OAAO,aAAa,CAAA;AAC5D,MAAA,IAAI,qBAAqB,SAAW,EAAA;AAClC,QAAM,MAAA,IAAI,UAAU,2GAA2G,CAAA;AAAA;AAEjI,MAAM,MAAA;AAAA,QACJ,GAAA;AAAA,QACA;AAAA,OACF,GAAI,aAAa,gBAAgB,CAAA;AACjC,MAAI,IAAA,CAAC,YAAa,CAAA,GAAG,CAAG,EAAA;AACtB,QAAM,MAAA,IAAI,UAAU,4DAA4D,CAAA;AAAA;AAElF,MAAK,IAAA,CAAA,GAAA,CAAI,WAAa,EAAA,MAAA,CAAO,SAAS,CAAA;AACtC,MAAK,IAAA,CAAA,GAAA,CAAI,yBAAyB,wDAAwD,CAAA;AAC1F,MAAK,IAAA,CAAA,GAAA,CAAI,oBAAoB,MAAM,aAAA,CAAc,IAAI,MAAQ,EAAA,GAAA,EAAK,GAAG,CAAC,CAAA;AACtE,MAAA;AAAA;AACF,IACF,KAAK,iBAAA;AAAA,IACL,KAAK,6BAAA;AAAA,IACL,KAAK,MACH,EAAA;AACE,MAAqB,oBAAA,CAAA,MAAA,CAAO,0BAA4B,EAAA,MAAA,CAAO,aAAa,CAAA;AAC5E,MAAyB,wBAAA,CAAA,MAAA,CAAO,4BAA4B,gBAAgB,CAAA;AAC5E,MAAK,IAAA,CAAA,GAAA,CAAI,WAAa,EAAA,MAAA,CAAO,SAAS,CAAA;AACtC,MAAA;AAAA;AACF,IACF;AACE,MAAM,MAAA,IAAI,0BAA0B,+CAA+C,CAAA;AAAA;AAEzF;AACA,eAAe,GAAA,CAAI,MAAQ,EAAA,SAAA,EAAW,GAAK,EAAA;AACzC,EAAA,IAAI,CAAC,GAAA,CAAI,MAAO,CAAA,QAAA,CAAS,MAAM,CAAG,EAAA;AAChC,IAAM,MAAA,IAAI,UAAU,uFAAuF,CAAA;AAAA;AAE7G,EAAA,MAAM,QAAQ,CAAG,EAAA,IAAA,CAAK,IAAI,IAAK,CAAA,SAAA,CAAU,MAAM,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,GAAI,CAAA,IAAA,CAAK,UAAU,SAAS,CAAC,CAAC,CAAC,CAAA,CAAA;AAC1F,EAAA,MAAM,SAAY,GAAA,IAAA,CAAK,MAAM,MAAA,CAAO,MAAO,CAAA,IAAA,CAAK,WAAY,CAAA,GAAG,CAAG,EAAA,GAAA,EAAK,GAAI,CAAA,KAAK,CAAC,CAAC,CAAA;AAClF,EAAO,OAAA,CAAA,EAAG,KAAK,CAAA,CAAA,EAAI,SAAS,CAAA,CAAA;AAC9B;AAwEA,eAAe,aAAa,OAAS,EAAA,OAAA,EAAS,GAAK,EAAA,GAAA,EAAKA,YAAW,WAAa,EAAA;AAC9E,EAAM,MAAA;AAAA,IACJ,UAAA;AAAA,IACA,SAAA;AAAA,IACA,KAAQ,GAAA,UAAA,CAAW,GAAI,CAAA,GAAA,CAAI,MAAM;AAAA,GAC/B,GAAA,OAAA;AACJ,EAAI,IAAA,CAAC,YAAa,CAAA,UAAU,CAAG,EAAA;AAC7B,IAAM,MAAA,IAAI,UAAU,+CAA+C,CAAA;AAAA;AAErE,EAAI,IAAA,CAAC,WAAY,CAAA,SAAS,CAAG,EAAA;AAC3B,IAAM,MAAA,IAAI,UAAU,6CAA6C,CAAA;AAAA;AAEnE,EAAA,IAAI,KAAU,KAAA,SAAA,IAAa,CAAC,cAAA,CAAe,KAAK,CAAG,EAAA;AACjD,IAAM,MAAA,IAAI,UAAU,sDAAsD,CAAA;AAAA;AAE5E,EAAI,IAAA,CAAC,UAAU,WAAa,EAAA;AAC1B,IAAM,MAAA,IAAI,UAAU,2CAA2C,CAAA;AAAA;AAEjE,EAAM,MAAA,GAAA,GAAM,WAAcA,GAAAA,UAAAA;AAC1B,EAAM,MAAA,KAAA,GAAQ,MAAM,GAAI,CAAA;AAAA,IACtB,GAAA,EAAK,SAAS,UAAU,CAAA;AAAA,IACxB,GAAK,EAAA,UAAA;AAAA,IACL,GAAA,EAAK,MAAM,SAAA,CAAU,SAAS;AAAA,GAC7B,EAAA;AAAA,IACD,GAAK,EAAA,GAAA;AAAA,IACL,KAAK,WAAY,EAAA;AAAA,IACjB,GAAA;AAAA,IACA,KAAA;AAAA,IACA,KAAK,CAAG,EAAA,GAAA,CAAI,MAAM,CAAA,EAAG,IAAI,QAAQ,CAAA,CAAA;AAAA,IACjC,GAAK,EAA8E;AAAA,KAClF,UAAU,CAAA;AACb,EAAQ,OAAA,CAAA,GAAA,CAAI,QAAQ,KAAK,CAAA;AAC3B;AACA,IAAI,QAAA;AACJ,eAAe,qBAAqB,GAAK,EAAA;AACvC,EAAM,MAAA;AAAA,IACJ,GAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA;AAAA,MACE,MAAM,MAAA,CAAO,MAAO,CAAA,SAAA,CAAU,OAAO,GAAG,CAAA;AAC5C,EAAA,MAAM,GAAM,GAAA;AAAA,IACV,GAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA,CAAA;AAAA,IACA;AAAA,GACF;AACA,EAAS,QAAA,CAAA,GAAA,CAAI,KAAK,GAAG,CAAA;AACrB,EAAO,OAAA,GAAA;AACT;AACA,eAAe,UAAU,GAAK,EAAA;AAC5B,EAAa,QAAA,KAAA,QAAA,uBAAe,OAAQ,EAAA,CAAA;AACpC,EAAA,OAAO,QAAS,CAAA,GAAA,CAAI,GAAG,CAAA,IAAK,qBAAqB,GAAG,CAAA;AACtD;AACA,SAAS,gBAAA,CAAiB,KAAO,EAAA,QAAA,EAAU,OAAS,EAAA;AAClD,EAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,IAAI,IAAA,OAAA,GAAU,YAAY,CAAG,EAAA;AAC3B,MAAA,MAAM,IAAI,SAAA,CAAU,CAA6B,0BAAA,EAAA,QAAQ,CAAoB,kBAAA,CAAA,CAAA;AAAA;AAE/E,IAAA,MAAM,IAAI,SAAA,CAAU,CAAO,IAAA,EAAA,QAAQ,CAAoB,kBAAA,CAAA,CAAA;AAAA;AAEzD,EAAO,OAAA,IAAI,IAAI,KAAK,CAAA;AACtB;AACA,SAAS,eAAA,CAAgB,EAAI,EAAA,QAAA,EAAU,OAAS,EAAA;AAC9C,EAAA,IAAI,UAAU,YAAY,CAAA,IAAK,GAAG,qBAAyB,IAAA,QAAA,IAAY,GAAG,qBAAuB,EAAA;AAC/F,IAAA,OAAO,iBAAiB,EAAG,CAAA,qBAAA,CAAsB,QAAQ,CAAA,EAAG,UAAU,OAAO,CAAA;AAAA;AAE/E,EAAA,OAAO,gBAAiB,CAAA,EAAA,CAAG,QAAQ,CAAA,EAAG,QAAQ,CAAA;AAChD;AAcO,SAAS,cAAc,KAAO,EAAA;AACnC,EAAA,MAAM,KAAQ,GAAA,KAAA;AACd,EAAI,IAAA,OAAO,UAAU,QAAY,IAAA,KAAA,CAAM,QAAQ,KAAK,CAAA,IAAK,UAAU,IAAM,EAAA;AACvE,IAAO,OAAA,KAAA;AAAA;AAET,EAAA,OAAO,MAAM,KAAU,KAAA,SAAA;AACzB;AAwRA,eAAe,qBAAqB,EAAI,EAAA,MAAA,EAAQ,QAAQ,GAAK,EAAA,IAAA,EAAM,SAAS,OAAS,EAAA;AACnF,EAAA,MAAM,qBAAqB,EAAI,EAAA,MAAA,EAAQ,IAAM,EAAA,OAAA,EAAS,SAAS,gBAAgB,CAAA;AAC/E,EAAQ,OAAA,CAAA,GAAA,CAAI,gBAAgB,iDAAiD,CAAA;AAC7E,EAAA,OAAA,CAAQ,OAAU,GAAA,WAAW,CAAK,IAAA,KAAA,EAAO,IAAI,IAAM,EAAA;AAAA,IACjD,IAAA;AAAA,IACA,OAAS,EAAA,MAAA,CAAO,WAAY,CAAA,OAAA,CAAQ,SAAS,CAAA;AAAA,IAC7C,MAAA;AAAA,IACA,QAAU,EAAA,QAAA;AAAA,IACV,QAAQ,OAAS,EAAA,MAAA,GAAS,MAAO,CAAA,OAAA,CAAQ,MAAM,CAAI,GAAA;AAAA,GACpD,CAAE,CAAA,IAAA,CAAK,gBAAgB,CAAA;AAC1B;AACA,eAAe,oBAAqB,CAAA,EAAA,EAAI,MAAQ,EAAA,SAAA,EAAW,YAAY,OAAS,EAAA;AAC9E,EAAA,MAAM,GAAM,GAAA,eAAA,CAAgB,EAAI,EAAA,gBAAA,EAAkB,OAAO,CAAA;AACzD,EAAW,UAAA,CAAA,GAAA,CAAI,cAAc,SAAS,CAAA;AACtC,EAAM,MAAA,OAAA,GAAU,cAAe,CAAA,OAAA,EAAS,OAAO,CAAA;AAC/C,EAAQ,OAAA,CAAA,GAAA,CAAI,UAAU,kBAAkB,CAAA;AACxC,EAAI,IAAA,OAAA,EAAS,SAAS,SAAW,EAAA;AAC/B,IAAM,MAAA,YAAA,CAAa,SAAS,OAAQ,CAAA,IAAA,EAAM,KAAK,MAAQ,EAAA,YAAA,CAAa,MAAM,CAAC,CAAA;AAAA;AAE7E,EAAA,OAAO,qBAAqB,EAAI,EAAA,MAAA,EAAQ,QAAQ,GAAK,EAAA,UAAA,EAAY,SAAS,OAAO,CAAA;AACnF;AACA,eAAsB,wBAAyB,CAAA,EAAA,EAAI,MAAQ,EAAA,YAAA,EAAc,OAAS,EAAA;AAChF,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAI,IAAA,CAAC,cAAe,CAAA,YAAY,CAAG,EAAA;AACjC,IAAM,MAAA,IAAI,UAAU,2CAA2C,CAAA;AAAA;AAEjE,EAAA,MAAM,UAAa,GAAA,IAAI,eAAgB,CAAA,OAAA,EAAS,oBAAoB,CAAA;AACpE,EAAW,UAAA,CAAA,GAAA,CAAI,iBAAiB,YAAY,CAAA;AAC5C,EAAA,OAAO,oBAAqB,CAAA,EAAA,EAAI,MAAQ,EAAA,eAAA,EAAiB,YAAY,OAAO,CAAA;AAC9E;AACA,IAAM,aAAA,uBAAoB,OAAQ,EAAA;AAWlC,eAAe,kCAAkC,EAAI,EAAA,MAAA,EAAQ,UAAU,aAAgB,GAAA,KAAA,EAAO,qBAAqB,KAAO,EAAA;AACxH,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAA,IAAI,CAAC,eAAA,CAAgB,QAAU,EAAA,QAAQ,CAAG,EAAA;AACxC,IAAM,MAAA,IAAI,UAAU,4CAA4C,CAAA;AAAA;AAElE,EAAI,IAAA,QAAA,CAAS,WAAW,GAAK,EAAA;AAC3B,IAAI,IAAA,GAAA;AACJ,IAAA,IAAI,GAAM,GAAA,MAAM,oBAAqB,CAAA,QAAQ,CAAG,EAAA;AAC9C,MAAO,OAAA,GAAA;AAAA;AAET,IAAM,MAAA,IAAI,IAAI,qDAAqD,CAAA;AAAA;AAErE,EAAA,sBAAA,CAAuB,QAAQ,CAAA;AAC/B,EAAI,IAAA,IAAA;AACJ,EAAI,IAAA;AACF,IAAO,IAAA,GAAA,MAAM,SAAS,IAAK,EAAA;AAAA,WACpB,KAAO,EAAA;AACd,IAAM,MAAA,IAAI,IAAI,yCAA2C,EAAA;AAAA,MACvD;AAAA,KACD,CAAA;AAAA;AAEH,EAAI,IAAA,CAAC,YAAa,CAAA,IAAI,CAAG,EAAA;AACvB,IAAM,MAAA,IAAI,IAAI,4CAA4C,CAAA;AAAA;AAE5D,EAAA,IAAI,CAAC,cAAA,CAAe,IAAK,CAAA,YAAY,CAAG,EAAA;AACtC,IAAM,MAAA,IAAI,IAAI,oEAAoE,CAAA;AAAA;AAEpF,EAAA,IAAI,CAAC,cAAA,CAAe,IAAK,CAAA,UAAU,CAAG,EAAA;AACpC,IAAM,MAAA,IAAI,IAAI,kEAAkE,CAAA;AAAA;AAElF,EAAK,IAAA,CAAA,UAAA,GAAa,IAAK,CAAA,UAAA,CAAW,WAAY,EAAA;AAC9C,EAAA,IAAI,IAAK,CAAA,UAAA,KAAe,MAAU,IAAA,IAAA,CAAK,eAAe,QAAU,EAAA;AAC9D,IAAM,MAAA,IAAI,0BAA0B,gCAAgC,CAAA;AAAA;AAEtE,EAAI,IAAA,IAAA,CAAK,eAAe,SAAc,KAAA,OAAO,KAAK,UAAe,KAAA,QAAA,IAAY,IAAK,CAAA,UAAA,IAAc,CAAI,CAAA,EAAA;AAClG,IAAM,MAAA,IAAI,IAAI,iEAAiE,CAAA;AAAA;AAEjF,EAAI,IAAA,CAAC,sBAAsB,IAAK,CAAA,aAAA,KAAkB,aAAa,CAAC,cAAA,CAAe,IAAK,CAAA,aAAa,CAAG,EAAA;AAClG,IAAM,MAAA,IAAI,IAAI,qEAAqE,CAAA;AAAA;AAErF,EAAA,IAAI,KAAK,KAAU,KAAA,SAAA,IAAa,OAAO,IAAA,CAAK,UAAU,QAAU,EAAA;AAC9D,IAAM,MAAA,IAAI,IAAI,mDAAmD,CAAA;AAAA;AAEnE,EAAA,IAAI,CAAC,aAAe,EAAA;AAClB,IAAA,IAAI,KAAK,QAAa,KAAA,SAAA,IAAa,CAAC,cAAe,CAAA,IAAA,CAAK,QAAQ,CAAG,EAAA;AACjE,MAAM,MAAA,IAAI,IAAI,gEAAgE,CAAA;AAAA;AAEhF,IAAA,IAAI,KAAK,QAAU,EAAA;AACjB,MAAM,MAAA;AAAA,QACJ;AAAA,OACF,GAAI,MAAM,WAAY,CAAA,IAAA,CAAK,UAAU,qBAAsB,CAAA,IAAA,CAAK,SAAW,EAAA,MAAA,CAAO,4BAA8B,EAAA,EAAA,CAAG,qCAAqC,CAAG,EAAA,gBAAA,EAAkB,aAAa,MAAM,CAAA,EAAG,kBAAkB,MAAM,CAAC,CAAE,CAAA,IAAA,CAAK,gBAAiB,CAAA,IAAA,CAAK,WAAW,CAAC,KAAA,EAAO,OAAO,KAAO,EAAA,KAAA,EAAO,KAAK,CAAC,CAAC,CAAE,CAAA,IAAA,CAAK,cAAe,CAAA,IAAA,CAAK,WAAW,EAAG,CAAA,MAAM,CAAC,CAAE,CAAA,IAAA,CAAK,iBAAiB,IAAK,CAAA,SAAA,EAAW,MAAO,CAAA,SAAS,CAAC,CAAA;AACjZ,MAAA,IAAI,KAAM,CAAA,OAAA,CAAQ,MAAO,CAAA,GAAG,CAAK,IAAA,MAAA,CAAO,GAAI,CAAA,MAAA,KAAW,CAAK,IAAA,MAAA,CAAO,GAAQ,KAAA,MAAA,CAAO,SAAW,EAAA;AAC3F,QAAM,MAAA,IAAI,IAAI,0DAA0D,CAAA;AAAA;AAE1E,MAAA,IAAI,MAAO,CAAA,iBAAA,IAAqB,OAAO,MAAA,CAAO,cAAc,QAAU,EAAA;AACpE,QAAM,MAAA,IAAI,IAAI,mEAAmE,CAAA;AAAA;AAEnF,MAAc,aAAA,CAAA,GAAA,CAAI,MAAM,MAAM,CAAA;AAAA;AAChC;AAEF,EAAO,OAAA,IAAA;AACT;AAUA,SAAS,gBAAA,CAAiB,UAAU,MAAQ,EAAA;AAC1C,EAAA,IAAI,KAAM,CAAA,OAAA,CAAQ,MAAO,CAAA,MAAA,CAAO,GAAG,CAAG,EAAA;AACpC,IAAA,IAAI,CAAC,MAAO,CAAA,MAAA,CAAO,GAAI,CAAA,QAAA,CAAS,QAAQ,CAAG,EAAA;AACzC,MAAM,MAAA,IAAI,IAAI,6CAA6C,CAAA;AAAA;AAC7D,GACS,MAAA,IAAA,MAAA,CAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AACzC,IAAM,MAAA,IAAI,IAAI,6CAA6C,CAAA;AAAA;AAE7D,EAAO,OAAA,MAAA;AACT;AAOA,SAAS,cAAA,CAAe,UAAU,MAAQ,EAAA;AACxC,EAAI,IAAA,MAAA,CAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AAClC,IAAM,MAAA,IAAI,IAAI,2CAA2C,CAAA;AAAA;AAE3D,EAAO,OAAA,MAAA;AACT;AACA,IAAM,OAAA,uBAAc,OAAQ,EAAA;AAC5B,SAAS,MAAM,YAAc,EAAA;AAC3B,EAAA,OAAA,CAAQ,IAAI,YAAY,CAAA;AACxB,EAAO,OAAA,YAAA;AACT;AACA,eAAsB,8BAA8B,EAAI,EAAA,MAAA,EAAQ,kBAAoB,EAAA,WAAA,EAAa,cAAc,OAAS,EAAA;AACtH,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAA,IAAI,CAAC,OAAA,CAAQ,GAAI,CAAA,kBAAkB,CAAG,EAAA;AACpC,IAAM,MAAA,IAAI,UAAU,mIAAmI,CAAA;AAAA;AAEzJ,EAAI,IAAA,CAAC,cAAe,CAAA,WAAW,CAAG,EAAA;AAChC,IAAM,MAAA,IAAI,UAAU,0CAA0C,CAAA;AAAA;AAEhE,EAAI,IAAA,CAAC,cAAe,CAAA,YAAY,CAAG,EAAA;AACjC,IAAM,MAAA,IAAI,UAAU,2CAA2C,CAAA;AAAA;AAEjE,EAAM,MAAA,IAAA,GAAO,qBAAsB,CAAA,kBAAA,EAAoB,MAAM,CAAA;AAC7D,EAAA,IAAI,CAAC,IAAM,EAAA;AACT,IAAM,MAAA,IAAI,IAAI,+CAA+C,CAAA;AAAA;AAE/D,EAAA,MAAM,UAAa,GAAA,IAAI,eAAgB,CAAA,OAAA,EAAS,oBAAoB,CAAA;AACpE,EAAW,UAAA,CAAA,GAAA,CAAI,gBAAgB,WAAW,CAAA;AAC1C,EAAW,UAAA,CAAA,GAAA,CAAI,iBAAiB,YAAY,CAAA;AAC5C,EAAW,UAAA,CAAA,GAAA,CAAI,QAAQ,IAAI,CAAA;AAC3B,EAAA,OAAO,oBAAqB,CAAA,EAAA,EAAI,MAAQ,EAAA,oBAAA,EAAsB,YAAY,OAAO,CAAA;AACnF;AACA,IAAM,aAAgB,GAAA;AAAA,EACpB,GAAK,EAAA,UAAA;AAAA,EACL,MAAQ,EAAA,WAAA;AAAA,EACR,SAAW,EAAA,WAAA;AAAA,EACX,GAAK,EAAA,iBAAA;AAAA,EACL,GAAK,EAAA,WAAA;AAAA,EACL,GAAK,EAAA,QAAA;AAAA,EACL,GAAK,EAAA,QAAA;AAAA,EACL,KAAO,EAAA,OAAA;AAAA,EACP,MAAQ,EAAA,YAAA;AAAA,EACR,GAAK,EAAA,SAAA;AAAA,EACL,GAAK,EAAA,mBAAA;AAAA,EACL,GAAK,EAAA,aAAA;AAAA,EACL,GAAK,EAAA,UAAA;AAAA,EACL,GAAK,EAAA;AACP,CAAA;AACA,SAAS,gBAAA,CAAiB,UAAU,MAAQ,EAAA;AAC1C,EAAA,KAAA,MAAW,SAAS,QAAU,EAAA;AAC5B,IAAA,IAAI,MAAO,CAAA,MAAA,CAAO,KAAK,CAAA,KAAM,SAAW,EAAA;AACtC,MAAM,MAAA,IAAI,IAAI,CAAQ,KAAA,EAAA,KAAK,MAAM,aAAc,CAAA,KAAK,CAAC,CAAiB,eAAA,CAAA,CAAA;AAAA;AACxE;AAEF,EAAO,OAAA,MAAA;AACT;AA8CA,eAAsB,sCAAA,CAAuC,EAAI,EAAA,MAAA,EAAQ,QAAU,EAAA;AACjF,EAAA,MAAM,SAAS,MAAM,iCAAA,CAAkC,EAAI,EAAA,MAAA,EAAQ,UAAU,IAAI,CAAA;AACjF,EAAI,IAAA,aAAA,CAAc,MAAM,CAAG,EAAA;AACzB,IAAO,OAAA,MAAA;AAAA;AAET,EAAI,IAAA,MAAA,CAAO,aAAa,SAAW,EAAA;AACjC,IAAA,IAAI,OAAO,MAAO,CAAA,QAAA,KAAa,QAAY,IAAA,MAAA,CAAO,SAAS,MAAQ,EAAA;AACjE,MAAM,MAAA,IAAI,IAAI,mHAAmH,CAAA;AAAA;AAEnI,IAAA,OAAO,MAAO,CAAA,QAAA;AAAA;AAEhB,EAAO,OAAA,MAAA;AACT;AAOA,eAAsB,6BAA8B,CAAA,EAAA,EAAI,MAAQ,EAAA,UAAA,EAAY,OAAS,EAAA;AACnF,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAO,OAAA,oBAAA,CAAqB,IAAI,MAAQ,EAAA,oBAAA,EAAsB,IAAI,eAAgB,CAAA,UAAU,GAAG,OAAO,CAAA;AACxG;AACA,eAAsB,gCAAA,CAAiC,EAAI,EAAA,MAAA,EAAQ,QAAU,EAAA;AAC3E,EAAA,MAAM,SAAS,MAAM,iCAAA,CAAkC,IAAI,MAAQ,EAAA,QAAA,EAAU,MAAM,IAAI,CAAA;AACvF,EAAI,IAAA,aAAA,CAAc,MAAM,CAAG,EAAA;AACzB,IAAO,OAAA,MAAA;AAAA;AAET,EAAO,OAAA,MAAA;AACT;AACA,eAAsB,iBAAkB,CAAA,EAAA,EAAI,MAAQ,EAAA,KAAA,EAAO,OAAS,EAAA;AAClE,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAI,IAAA,CAAC,cAAe,CAAA,KAAK,CAAG,EAAA;AAC1B,IAAM,MAAA,IAAI,UAAU,oCAAoC,CAAA;AAAA;AAE1D,EAAA,MAAM,GAAM,GAAA,eAAA,CAAgB,EAAI,EAAA,qBAAA,EAAuB,OAAO,CAAA;AAC9D,EAAA,MAAM,IAAO,GAAA,IAAI,eAAgB,CAAA,OAAA,EAAS,oBAAoB,CAAA;AAC9D,EAAK,IAAA,CAAA,GAAA,CAAI,SAAS,KAAK,CAAA;AACvB,EAAM,MAAA,OAAA,GAAU,cAAe,CAAA,OAAA,EAAS,OAAO,CAAA;AAC/C,EAAA,OAAA,CAAQ,OAAO,QAAQ,CAAA;AACvB,EAAA,OAAO,qBAAqB,EAAI,EAAA,MAAA,EAAQ,QAAQ,GAAK,EAAA,IAAA,EAAM,SAAS,OAAO,CAAA;AAC7E;AACA,eAAsB,0BAA0B,QAAU,EAAA;AACxD,EAAA,IAAI,CAAC,eAAA,CAAgB,QAAU,EAAA,QAAQ,CAAG,EAAA;AACxC,IAAM,MAAA,IAAI,UAAU,4CAA4C,CAAA;AAAA;AAElE,EAAI,IAAA,QAAA,CAAS,WAAW,GAAK,EAAA;AAC3B,IAAI,IAAA,GAAA;AACJ,IAAA,IAAI,GAAM,GAAA,MAAM,oBAAqB,CAAA,QAAQ,CAAG,EAAA;AAC9C,MAAO,OAAA,GAAA;AAAA;AAET,IAAM,MAAA,IAAI,IAAI,0DAA0D,CAAA;AAAA;AAE1E,EAAO,OAAA,SAAA;AACT;AACA,SAAS,uBAAuB,QAAU,EAAA;AACxC,EAAA,IAAI,SAAS,QAAU,EAAA;AACrB,IAAM,MAAA,IAAI,UAAU,uCAAuC,CAAA;AAAA;AAE/D;AAmGA,eAAe,qBAAqB,QAAU,EAAA;AAC5C,EAAA,IAAI,QAAS,CAAA,MAAA,GAAS,GAAO,IAAA,QAAA,CAAS,SAAS,GAAK,EAAA;AAClD,IAAA,sBAAA,CAAuB,QAAQ,CAAA;AAC/B,IAAI,IAAA;AACF,MAAM,MAAA,IAAA,GAAO,MAAM,QAAA,CAAS,IAAK,EAAA;AACjC,MAAI,IAAA,YAAA,CAAa,IAAI,CAAK,IAAA,OAAO,KAAK,KAAU,KAAA,QAAA,IAAY,IAAK,CAAA,KAAA,CAAM,MAAQ,EAAA;AAC7E,QAAA,IAAI,KAAK,iBAAsB,KAAA,KAAA,CAAA,IAAa,OAAO,IAAA,CAAK,sBAAsB,QAAU,EAAA;AACtF,UAAA,OAAO,IAAK,CAAA,iBAAA;AAAA;AAEd,QAAA,IAAI,KAAK,SAAc,KAAA,KAAA,CAAA,IAAa,OAAO,IAAA,CAAK,cAAc,QAAU,EAAA;AACtE,UAAA,OAAO,IAAK,CAAA,SAAA;AAAA;AAEd,QAAA,IAAI,KAAK,IAAS,KAAA,KAAA,CAAA,IAAa,OAAO,IAAA,CAAK,SAAS,QAAU,EAAA;AAC5D,UAAA,OAAO,IAAK,CAAA,IAAA;AAAA;AAEd,QAAA,IAAI,KAAK,KAAU,KAAA,KAAA,CAAA,IAAa,OAAO,IAAA,CAAK,UAAU,QAAU,EAAA;AAC9D,UAAA,OAAO,IAAK,CAAA,KAAA;AAAA;AAEd,QAAO,OAAA,IAAA;AAAA;AACT,KACM,CAAA,MAAA;AAAA;AAAC;AAEX,EAAO,OAAA,SAAA;AACT;AAOA,SAAS,qBAAqB,SAAW,EAAA;AACvC,EAAA,IAAI,OAAO,SAAU,CAAA,aAAA,KAAkB,QAAY,IAAA,SAAA,CAAU,gBAAgB,IAAM,EAAA;AACjF,IAAA,MAAM,IAAI,GAAA,CAAI,CAAG,EAAA,SAAA,CAAU,IAAI,CAA2C,yCAAA,CAAA,CAAA;AAAA;AAE9E;AACA,SAAS,cAAc,UAAY,EAAA;AACjC,EAAA,QAAQ,UAAY;AAAA,IAClB,KAAK,OAAA;AACH,MAAO,OAAA,SAAA;AAAA,IACT,KAAK,OAAA;AACH,MAAO,OAAA,SAAA;AAAA,IACT,KAAK,OAAA;AACH,MAAO,OAAA,SAAA;AAAA,IACT;AACE,MAAA,MAAM,IAAI,yBAA0B,EAAA;AAAA;AAE1C;AACA,SAAS,YAAY,GAAK,EAAA;AACxB,EAAQ,QAAA,GAAA,CAAI,UAAU,IAAM;AAAA,IAC1B,KAAK,OAAA;AACH,MAAO,OAAA;AAAA,QACL,IAAA,EAAM,IAAI,SAAU,CAAA,IAAA;AAAA,QACpB,IAAM,EAAA,aAAA,CAAc,GAAI,CAAA,SAAA,CAAU,UAAU;AAAA,OAC9C;AAAA,IACF,KAAK,SACH,EAAA;AACE,MAAA,oBAAA,CAAqB,IAAI,SAAS,CAAA;AAClC,MAAQ,QAAA,GAAA,CAAI,SAAU,CAAA,IAAA,CAAK,IAAM;AAAA,QAC/B,KAAK,SAAA;AAAA,QACL,KAAK,SAAA;AAAA,QACL,KAAK,SAAA;AACH,UAAO,OAAA;AAAA,YACL,IAAA,EAAM,IAAI,SAAU,CAAA,IAAA;AAAA,YACpB,UAAA,EAAY,QAAS,CAAA,GAAA,CAAI,SAAU,CAAA,IAAA,CAAK,KAAK,KAAM,CAAA,EAAE,CAAG,EAAA,EAAE,CAAK,IAAA;AAAA,WACjE;AAAA,QACF;AACE,UAAA,MAAM,IAAI,yBAA0B,EAAA;AAAA;AACxC;AACF,IACF,KAAK,mBAAA;AACH,MAAA,oBAAA,CAAqB,IAAI,SAAS,CAAA;AAClC,MAAA,OAAO,IAAI,SAAU,CAAA,IAAA;AAAA,IACvB,KAAK,OAAA;AAAA,IACL,KAAK,SAAA;AACH,MAAA,OAAO,IAAI,SAAU,CAAA,IAAA;AAAA;AAEzB,EAAA,MAAM,IAAI,yBAA0B,EAAA;AACtC;AACA,IAAM,mBAAmB,MAAO,EAAA;AAChC,eAAe,WAAY,CAAA,GAAA,EAAK,QAAU,EAAA,MAAA,EAAQA,YAAWC,eAAgB,EAAA;AAC3E,EAAM,MAAA;AAAA,IACJ,CAAG,EAAA,eAAA;AAAA,IACH,CAAG,EAAA,OAAA;AAAA,IACH,CAAG,EAAA,gBAAA;AAAA,IACH;AAAA,GACF,GAAI,GAAI,CAAA,KAAA,CAAM,GAAG,CAAA;AACjB,EAAA,IAAI,WAAW,CAAG,EAAA;AAChB,IAAM,MAAA,IAAI,0BAA0B,sCAAsC,CAAA;AAAA;AAE5E,EAAA,IAAI,WAAW,CAAG,EAAA;AAChB,IAAM,MAAA,IAAI,IAAI,aAAa,CAAA;AAAA;AAE7B,EAAI,IAAA,MAAA;AACJ,EAAI,IAAA;AACF,IAAA,MAAA,GAAS,KAAK,KAAM,CAAA,GAAA,CAAI,IAAK,CAAA,eAAe,CAAC,CAAC,CAAA;AAAA,WACvC,KAAO,EAAA;AACd,IAAM,MAAA,IAAI,IAAI,2DAA6D,EAAA;AAAA,MACzE;AAAA,KACD,CAAA;AAAA;AAEH,EAAI,IAAA,CAAC,YAAa,CAAA,MAAM,CAAG,EAAA;AACzB,IAAM,MAAA,IAAI,IAAI,uCAAuC,CAAA;AAAA;AAEvD,EAAA,QAAA,CAAS,MAAM,CAAA;AACf,EAAI,IAAA,MAAA,CAAO,SAAS,SAAW,EAAA;AAC7B,IAAM,MAAA,IAAI,IAAI,wCAAwC,CAAA;AAAA;AAExD,EAAM,MAAA,SAAA,GAAY,KAAK,gBAAgB,CAAA;AACvC,EAAI,IAAA,GAAA;AACJ,EAAA,IAAI,WAAW,gBAAkB,EAAA;AAC/B,IAAM,GAAA,GAAA,MAAM,OAAO,MAAM,CAAA;AACzB,IAAA,MAAM,KAAQ,GAAA,CAAA,EAAG,eAAe,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA;AAC3C,IAAA,MAAM,QAAW,GAAA,MAAM,MAAO,CAAA,MAAA,CAAO,MAAO,CAAA,WAAA,CAAY,GAAG,CAAA,EAAG,GAAK,EAAA,SAAA,EAAW,GAAI,CAAA,KAAK,CAAC,CAAA;AACxF,IAAA,IAAI,CAAC,QAAU,EAAA;AACb,MAAM,MAAA,IAAI,IAAI,mCAAmC,CAAA;AAAA;AACnD;AAEF,EAAI,IAAA,MAAA;AACJ,EAAI,IAAA;AACF,IAAA,MAAA,GAAS,KAAK,KAAM,CAAA,GAAA,CAAI,IAAK,CAAA,OAAO,CAAC,CAAC,CAAA;AAAA,WAC/B,KAAO,EAAA;AACd,IAAM,MAAA,IAAI,IAAI,4DAA8D,EAAA;AAAA,MAC1E;AAAA,KACD,CAAA;AAAA;AAEH,EAAI,IAAA,CAAC,YAAa,CAAA,MAAM,CAAG,EAAA;AACzB,IAAM,MAAA,IAAI,IAAI,wCAAwC,CAAA;AAAA;AAExD,EAAM,MAAA,GAAA,GAAM,WAAcD,GAAAA,UAAAA;AAC1B,EAAI,IAAA,MAAA,CAAO,QAAQ,SAAW,EAAA;AAC5B,IAAI,IAAA,OAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AAClC,MAAM,MAAA,IAAI,IAAI,mDAAmD,CAAA;AAAA;AAEnE,IAAI,IAAA,MAAA,CAAO,GAAO,IAAA,GAAA,GAAMC,eAAgB,EAAA;AACtC,MAAM,MAAA,IAAI,IAAI,2EAA2E,CAAA;AAAA;AAC3F;AAEF,EAAI,IAAA,MAAA,CAAO,QAAQ,SAAW,EAAA;AAC5B,IAAI,IAAA,OAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AAClC,MAAM,MAAA,IAAI,IAAI,6CAA6C,CAAA;AAAA;AAC7D;AAEF,EAAI,IAAA,MAAA,CAAO,QAAQ,SAAW,EAAA;AAC5B,IAAI,IAAA,OAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AAClC,MAAM,MAAA,IAAI,IAAI,0CAA0C,CAAA;AAAA;AAC1D;AAEF,EAAI,IAAA,MAAA,CAAO,QAAQ,SAAW,EAAA;AAC5B,IAAI,IAAA,OAAO,MAAO,CAAA,GAAA,KAAQ,QAAU,EAAA;AAClC,MAAM,MAAA,IAAI,IAAI,8CAA8C,CAAA;AAAA;AAE9D,IAAI,IAAA,MAAA,CAAO,GAAM,GAAA,GAAA,GAAMA,eAAgB,EAAA;AACrC,MAAM,MAAA,IAAI,IAAI,qEAAqE,CAAA;AAAA;AACrF;AAEF,EAAI,IAAA,MAAA,CAAO,QAAQ,SAAW,EAAA;AAC5B,IAAI,IAAA,OAAO,OAAO,GAAQ,KAAA,QAAA,IAAY,CAAC,KAAM,CAAA,OAAA,CAAQ,MAAO,CAAA,GAAG,CAAG,EAAA;AAChE,MAAM,MAAA,IAAI,IAAI,4CAA4C,CAAA;AAAA;AAC5D;AAEF,EAAO,OAAA;AAAA,IACL,MAAA;AAAA,IACA,MAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF;AACF;AA0JA,SAAS,qBAAA,CAAsB,MAAQ,EAAA,MAAA,EAAQ,MAAQ,EAAA;AACrD,EAAA,IAAI,WAAW,SAAW,EAAA;AACxB,IAAI,IAAA,MAAA,CAAO,QAAQ,MAAQ,EAAA;AACzB,MAAM,MAAA,IAAI,IAAI,uCAAuC,CAAA;AAAA;AAEvD,IAAA;AAAA;AAEF,EAAI,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CAAG,EAAA;AACzB,IAAA,IAAI,CAAC,MAAA,CAAO,QAAS,CAAA,MAAA,CAAO,GAAG,CAAG,EAAA;AAChC,MAAM,MAAA,IAAI,IAAI,uCAAuC,CAAA;AAAA;AAEvD,IAAA;AAAA;AAEF,EAAI,IAAA,MAAA,CAAO,QAAQ,OAAS,EAAA;AAC1B,IAAM,MAAA,IAAI,IAAI,uCAAuC,CAAA;AAAA;AAEzD;AACA,SAAS,qBAAA,CAAsB,YAAY,IAAM,EAAA;AAC/C,EAAM,MAAA;AAAA,IACJ,CAAG,EAAA,KAAA;AAAA,IACH;AAAA,GACF,GAAI,UAAW,CAAA,MAAA,CAAO,IAAI,CAAA;AAC1B,EAAA,IAAI,SAAS,CAAG,EAAA;AACd,IAAA,MAAM,IAAI,GAAA,CAAI,CAAI,CAAA,EAAA,IAAI,CAAwC,sCAAA,CAAA,CAAA;AAAA;AAEhE,EAAO,OAAA,KAAA;AACT;AACO,IAAM,iBAAiB,MAAO,EAAA;AAC9B,IAAM,gBAAgB,MAAO,EAAA;AAC7B,SAAS,oBAAqB,CAAA,EAAA,EAAI,MAAQ,EAAA,UAAA,EAAY,aAAe,EAAA;AAC1E,EAAA,QAAA,CAAS,EAAE,CAAA;AACX,EAAA,YAAA,CAAa,MAAM,CAAA;AACnB,EAAA,IAAI,sBAAsB,GAAK,EAAA;AAC7B,IAAA,UAAA,GAAa,UAAW,CAAA,YAAA;AAAA;AAE1B,EAAI,IAAA,EAAE,sBAAsB,eAAkB,CAAA,EAAA;AAC5C,IAAM,MAAA,IAAI,UAAU,6DAA6D,CAAA;AAAA;AAEnF,EAAI,IAAA,qBAAA,CAAsB,UAAY,EAAA,UAAU,CAAG,EAAA;AACjD,IAAM,MAAA,IAAI,IAAI,wGAAwG,CAAA;AAAA;AAExH,EAAM,MAAA,GAAA,GAAM,qBAAsB,CAAA,UAAA,EAAY,KAAK,CAAA;AACnD,EAAM,MAAA,KAAA,GAAQ,qBAAsB,CAAA,UAAA,EAAY,OAAO,CAAA;AACvD,EAAI,IAAA,CAAC,GAAO,IAAA,EAAA,CAAG,8CAAgD,EAAA;AAC7D,IAAM,MAAA,IAAI,IAAI,2CAA2C,CAAA;AAAA;AAE3D,EAAI,IAAA,GAAA,IAAO,GAAQ,KAAA,EAAA,CAAG,MAAQ,EAAA;AAC5B,IAAM,MAAA,IAAI,IAAI,oDAAoD,CAAA;AAAA;AAEpE,EAAA,QAAQ,aAAe;AAAA,IACrB,KAAK,SAAA;AAAA,IACL,KAAK,aAAA;AACH,MAAA,IAAI,UAAU,SAAW,EAAA;AACvB,QAAM,MAAA,IAAI,IAAI,mDAAmD,CAAA;AAAA;AAEnE,MAAA;AAAA,IACF,KAAK,cAAA;AACH,MAAA;AAAA,IACF;AACE,MAAI,IAAA,CAAC,cAAe,CAAA,aAAa,CAAG,EAAA;AAClC,QAAM,MAAA,IAAI,IAAI,4CAA4C,CAAA;AAAA;AAE5D,MAAA,IAAI,UAAU,SAAW,EAAA;AACvB,QAAM,MAAA,IAAI,IAAI,oCAAoC,CAAA;AAAA;AAEpD,MAAA,IAAI,UAAU,aAAe,EAAA;AAC3B,QAAM,MAAA,IAAI,IAAI,6CAA6C,CAAA;AAAA;AAC7D;AAEJ,EAAM,MAAA,KAAA,GAAQ,qBAAsB,CAAA,UAAA,EAAY,OAAO,CAAA;AACvD,EAAA,IAAI,KAAO,EAAA;AACT,IAAO,OAAA;AAAA,MACL,KAAA;AAAA,MACA,iBAAA,EAAmB,qBAAsB,CAAA,UAAA,EAAY,mBAAmB,CAAA;AAAA,MACxE,SAAA,EAAW,qBAAsB,CAAA,UAAA,EAAY,WAAW;AAAA,KAC1D;AAAA;AAEF,EAAM,MAAA,QAAA,GAAW,qBAAsB,CAAA,UAAA,EAAY,UAAU,CAAA;AAC7D,EAAM,MAAA,KAAA,GAAQ,qBAAsB,CAAA,UAAA,EAAY,OAAO,CAAA;AACvD,EAAI,IAAA,QAAA,KAAa,SAAa,IAAA,KAAA,KAAU,SAAW,EAAA;AACjD,IAAM,MAAA,IAAI,0BAA0B,6CAA6C,CAAA;AAAA;AAEnF,EAAA,OAAO,KAAM,CAAA,IAAI,eAAgB,CAAA,UAAU,CAAC,CAAA;AAC9C;;;AC3oDO,SAAS,aAAa,MAAQ,EAAA;AACnC,EAAI,IAAA,aAAA,CAAc,MAAM,CAAG,EAAA;AACzB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAwB,qBAAA,EAAA,MAAA,CAAO,KAAK,CAAE,CAAA,CAAA;AAAA;AAExD,EAAO,OAAA,MAAA;AACT;;;ACAA,IAAM,WAAA,GAA0E,WAAW,WAAe,IAAA,MAAMC,qBAAoB,KAAM,CAAA;AAAA,EACxI,OAAA;AAAA,EACA,WAAA,CAAY,MAAM,OAAS,EAAA;AACzB,IAAA,KAAA,CAAM,MAAM,OAAO,CAAA;AACnB,IAAK,IAAA,CAAA,OAAA,GAAU,SAAS,MAAU,IAAA,IAAA;AAAA;AACpC,EACA,IAAI,MAAS,GAAA;AACX,IAAA,OAAO,IAAK,CAAA,OAAA;AAAA;AAEhB,CAAA;AACA,SAAS,gBAAgB,MAAQ,EAAA;AAC/B,EAAO,OAAA,CAAA,wBAAA,EAA2B,OAAO,SAAS,CAAA,CAAA;AACpD;AACO,SAAS,SAAA,CAAU,QAAQ,CAAG,EAAA;AAEnC,EAAW,UAAA,CAAA,YAAA,EAAc,QAAQ,eAAgB,CAAA,MAAM,GAAG,IAAK,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA;AAC7E;AACO,SAAS,YAAY,MAAQ,EAAA;AAElC,EAAA,UAAA,CAAW,YAAc,EAAA,UAAA,CAAW,eAAgB,CAAA,MAAM,CAAC,CAAA;AAC7D;AACO,SAAS,UAAU,MAAQ,EAAA;AAChC,EAAA,OAAO,IAAK,CAAA,KAAA;AAAA;AAAA,IAEZ,WAAW,YAAc,EAAA,OAAA,CAAQ,eAAgB,CAAA,MAAM,CAAC,CAAK,IAAA;AAAA,GAAI;AACnE;AACO,SAAS,WAAA,CAAY,QAAQ,CAAG,EAAA;AAErC,EAAW,UAAA,CAAA,cAAA,EAAgB,QAAQ,eAAgB,CAAA,MAAM,GAAG,IAAK,CAAA,SAAA,CAAU,CAAC,CAAC,CAAA;AAC/E;AACO,SAAS,cAAc,MAAQ,EAAA;AAEpC,EAAA,UAAA,CAAW,cAAgB,EAAA,UAAA,CAAW,eAAgB,CAAA,MAAM,CAAC,CAAA;AAC/D;AACO,SAAS,YAAY,MAAQ,EAAA;AAClC,EAAA,OAAO,IAAK,CAAA,KAAA;AAAA;AAAA,IAEZ,WAAW,cAAgB,EAAA,OAAA,CAAQ,eAAgB,CAAA,MAAM,CAAC,CAAK,IAAA;AAAA,GAAI;AACrE;AACO,SAAS,OAAO,MAAQ,EAAA,EAAA,EAAI,SAAS,gBAAkB,EAAA,OAAA,EAAS,oBAAoB,MAAQ,EAAA;AACjG,EAAI,IAAA,KAAA;AACJ,EAAM,MAAA,WAAA,GAAc,IAAIC,sCAAiB,EAAA;AACzC,EAAS,SAAA,uBAAA,CAAwB,MAAM,IAAM,EAAA;AAC3C,IAAM,MAAA;AAAA,MACJ,aAAA;AAAA,MACA,UAAA;AAAA,MACA;AAAA,KACE,GAAA,IAAA;AACJ,IAAE,EAAA,UAAA,IAAc,IAAQ,CAAA,GAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,KAAa,YAAe,GAAAC,2BAAA,CAAU,KAAK,CAAA,GAAIA,2BAAU,CAAA,KAAK,CAAI,GAAA,SAAA;AACtG,IAAA,SAAA,CAAU,MAAQ,EAAA;AAAA,MAChB,aAAA;AAAA,MACA,kBAAA;AAAA,MACA,eAAiB,EAAA;AAAA,KAClB,CAAA;AACD,IAAQ,KAAA,GAAA;AAAA,MACN,aAAA;AAAA,MACA,UAAA;AAAA,MACA,YAAA;AAAA,MACA,UAAY,EAAA,IAAA,CAAK,GAAI,EAAA,GAAI,UAAa,GAAA;AAAA,KACxC;AACA,IAAA,WAAA,CAAY,kBAAmB,CAAA,IAAA,EAAM,IAAI,WAAA,CAAY,IAAM,EAAA;AAAA,MACzD,MAAQ,EAAA;AAAA,KACT,CAAC,CAAA;AACF,IAAO,OAAA,KAAA;AAAA;AAET,EAAI,IAAA,cAAA;AACJ,EAAA,SAAS,SAAY,GAAA;AACnB,IAAI,IAAA,cAAA,eAA6B,cAAc,CAAA;AAAA;AAEjD,EAAA,SAAS,oBAAoB,GAAK,EAAA;AAChC,IAAA,IAAI,OAAS,EAAA;AACX,MAAU,SAAA,EAAA;AACV,MAAA,cAAA,GAAiB,WAAW,OAAS,EAAA,GAAA,CAAI,OAAO,UAAa,GAAA,GAAA,GAAO,KAAK,GAAI,CAAA;AAAA;AAC/E;AAEF,EAAA,eAAe,OAAU,GAAA;AACvB,IAAC,CAAA,KAAA,GAAQ,OAAQ,CAAA,GAAA,CAAI,QAAa,KAAA,YAAA,GAAeA,2BAAU,CAAA,KAAA,EAAO,eAAe,CAAA,GAAIA,2BAAU,CAAA,KAAK,CAAI,GAAA,SAAA;AACxG,IAAM,MAAA,MAAA,GAAS,MAAM,yBAAA,CAA0B,MAAM,iBAAA,CAAkB,IAAI,MAAQ,EAAA,KAAA,CAAM,YAAc,EAAA,gBAAgB,CAAC,CAAA;AACxH,IAAU,SAAA,EAAA;AAGV,IAAA,WAAA,CAAY,MAAM,CAAA;AAClB,IAAQ,KAAA,GAAA,SAAA;AACR,IAAA,YAAA,CAAa,MAAM,CAAA;AACnB,IAAA,WAAA,CAAY,kBAAmB,CAAA,SAAA,EAAW,IAAI,KAAA,CAAM,SAAS,CAAC,CAAA;AAAA;AAEhE,EAAI,IAAA,aAAA;AACJ,EAAA,eAAe,MAAS,GAAA;AACtB,IAAA,IAAI,aAAe,EAAA;AACjB,MAAO,OAAA,aAAA;AAAA;AAET,IAAI,IAAA;AACF,MAAA,aAAA,GAAgB,OAAQ,EAAA;AACxB,MAAA,OAAO,MAAM,aAAA;AAAA,KACb,SAAA;AACA,MAAgB,aAAA,GAAA,SAAA;AAAA;AAClB;AAEF,EAAY,WAAA,CAAA,gBAAA,CAAiB,UAAU,mBAAmB,CAAA;AAC1D,EAAY,WAAA,CAAA,gBAAA,CAAiB,WAAW,mBAAmB,CAAA;AAC3D,EAAA,SAAS,mBAAsB,GAAA;AAC7B,IAAA,IAAI,CAAC,KAAS,IAAA,IAAA,CAAK,GAAI,EAAA,IAAK,MAAM,UAAY,EAAA;AAC5C,MAAO,OAAA,SAAA;AAAA;AAET,IAAA,OAAO,KAAO,EAAA,YAAA;AAAA;AAEhB,EAAA,MAAM,QAAW,GAAA,MAAA,CAAO,MAAO,CAAA,eAAeC,SAAW,GAAA;AACvD,IAAA,IAAI,CAAC,KAAS,IAAA,IAAA,CAAK,GAAI,EAAA,IAAK,MAAM,UAAY,EAAA;AAC5C,MAAA,KAAA,GAAQ,MAAM,MAAO,EAAA;AAAA;AAEvB,IAAA,OAAO,KAAO,EAAA,YAAA;AAAA,GACb,EAAA;AAAA,IACD,MAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,IACA,mBAAA;AAAA,IACA,gBAAkB,EAAA,WAAA,CAAY,gBAAiB,CAAA,IAAA,CAAK,WAAW,CAAA;AAAA,IAC/D,mBAAqB,EAAA,WAAA,CAAY,mBAAoB,CAAA,IAAA,CAAK,WAAW;AAAA,GACtE,CAAA;AACD,EAAO,OAAA;AAAA,IACL,QAAA;AAAA,IACA;AAAA,GACF;AACF;AACO,SAAS,yBAAA,CAA0B,SAAS,GAAK,EAAA;AACtD,EAAA,MAAM,MAAS,GAAA,CAAA,EAAG,IAAI,GAAA,CAAI,OAAS,EAAA,GAAA,CAAI,QAAS,CAAA,GAAG,CAAI,GAAA,GAAA,GAAM,GAAM,GAAA,GAAG,CAAC,CAAA,CAAA;AACvE,EAAO,OAAA;AAAA,IACL,cAAA,EAAgB,GAAG,MAAM,CAAA,iBAAA,CAAA;AAAA,IACzB,sBAAA,EAAwB,GAAG,MAAM,CAAA,qBAAA,CAAA;AAAA,IACjC,mBAAA,EAAqB,GAAG,MAAM,CAAA,wBAAA,CAAA;AAAA,IAC9B;AAAA,GACF;AACF;;;AC9HO,SAAS,6BAA8B,CAAA,SAAA,EAAW,aAAe,EAAA,GAAA,EAAK,SAAS,CAAC,eAAA,EAAiB,gBAAkB,EAAA,yBAAA,EAA2B,0BAA0B,CAAG,EAAA,OAAA,GAAU,UAAW,CAAA,KAAA,EAAO,UAAU,WAAa,EAAA;AACnO,EAAA,MAAM,MAAS,GAAA;AAAA,IACb,SAAA;AAAA,IACA;AAAA,GACF;AACA,EAAM,MAAA,UAAA,GAAa,yBAA0B,CAAA,OAAA,EAAS,GAAG,CAAA;AACzD,EAAA,MAAM,gBAAmB,GAAA;AAAA,IACvB,CAAC,WAAW,GAAG;AAAA,GACjB;AACA,EAAM,MAAA,YAAA,GAAe,MAAO,CAAA,IAAA,CAAK,GAAG,CAAA;AACpC,EAAM,MAAA;AAAA,IACJ,QAAA;AAAA,IACA;AAAA,GACF,GAAI,OAAO,MAAQ,EAAA,UAAA,EAAY,SAAS,gBAAkB,EAAA,SAAA,EAAW,WAAW,YAAY,CAAA;AAC5F,EAAA,eAAe,OAAU,GAAA;AACvB,IAAO,OAAA,uBAAA,CAAwB,YAAa,CAAA,MAAM,gCAAiC,CAAA,UAAA,EAAY,MAAQ,EAAA,MAAM,6BAA8B,CAAA,UAAA,EAAY,MAAQ,EAAA,IAAI,eAAgB,CAAA;AAAA,MACjL,KAAO,EAAA;AAAA,KACR,CAAG,EAAA,gBAAgB,CAAC,CAAC,GAAG,QAAQ,CAAA;AAAA;AAEnC,EAAO,OAAA,QAAA;AACT;;;AC/CA,IAAM,mBAAmB,MAAM;AAC7B,EAAM,MAAA,KAAA,GAAQ,IAAI,KAAA,CAAM,eAAe,CAAA;AACvC,EAAA,KAAA,CAAM,IAAO,GAAA,YAAA;AACb,EAAO,OAAA,KAAA;AACT,CAAA;AACA,IAAM,YAAA,uBAAmB,OAAQ,EAAA;AAC1B,SAAS,WAAY,CAAA;AAAA,EAC1B,YAAc,EAAA,YAAA;AAAA,EACd,UAAY,EAAA;AACd,CAAA,GAAI,EAAI,EAAA;AAEN,EAAA,OAAO,CAAC,YAAc,EAAA;AAAA,IACpB,KAAA;AAAA,IACA,MAAAC,EAAAA;AAAA,GACF,GAAI,EAAO,KAAA;AAET,IAAA,IAAIA,SAAQ,OAAS,EAAA;AACnB,MAAO,OAAA,OAAA,CAAQ,MAAO,CAAA,gBAAA,EAAkB,CAAA;AAAA;AAE1C,IAAI,IAAA,SAAA;AACJ,IAAI,IAAA,MAAA;AACJ,IAAI,IAAA,cAAA;AACJ,IAAA,MAAM,QAAQ,YAAgB,IAAA,YAAA;AAC9B,IAAA,MAAM,iBAAiB,MAAM;AAC3B,MAAA,KAAA,CAAM,SAAS,CAAA;AACf,MAAA,cAAA,CAAe,kBAAkB,CAAA;AAAA,KACnC;AACA,IAAA,MAAM,UAAU,MAAM;AACpB,MAAA,IAAIA,OAAQ,EAAA;AACV,QAAAA,OAAAA,CAAO,mBAAoB,CAAA,OAAA,EAAS,cAAc,CAAA;AAAA;AACpD,KACF;AACA,IAAA,MAAM,YAAe,GAAA,IAAI,OAAQ,CAAA,CAAC,SAAS,MAAW,KAAA;AACpD,MAAA,MAAA,GAAS,MAAM;AACb,QAAQ,OAAA,EAAA;AACR,QAAA,OAAA,CAAQ,KAAK,CAAA;AAAA,OACf;AACA,MAAiB,cAAA,GAAA,MAAA;AACjB,MAAa,SAAA,GAAA,CAAA,UAAA,IAAc,UAAY,EAAA,MAAA,EAAQ,YAAY,CAAA;AAAA,KAC5D,CAAA;AACD,IAAA,IAAIA,OAAQ,EAAA;AACV,MAAAA,OAAAA,CAAO,gBAAiB,CAAA,OAAA,EAAS,cAAgB,EAAA;AAAA,QAC/C,IAAM,EAAA;AAAA,OACP,CAAA;AAAA;AAEH,IAAa,YAAA,CAAA,GAAA,CAAI,cAAc,MAAM;AACnC,MAAA,KAAA,CAAM,SAAS,CAAA;AACf,MAAY,SAAA,GAAA,IAAA;AACZ,MAAO,MAAA,EAAA;AAAA,KACR,CAAA;AACD,IAAO,OAAA,YAAA;AAAA,GACT;AACF;AACA,IAAM,QAAQ,WAAY,EAAA;AAC1B,IAAO,aAAQ,GAAA,KAAA;ACvCR,SAAS,+BAAA,CAAgC,KAAK,YAAc,EAAA,UAAA,EAAY,WAAW,aAAe,EAAA,MAAA,EAAQ,SAAS,OAAS,EAAA;AACjI,EAAA,IAAI,UAAU,EAAC;AACf,EAAI,IAAA,OAAO,eAAe,QAAU,EAAA;AAClC,IAAE,EAAA,CAAC,aAAa,CAAC,aAAA,IAAiB,CAAC,MAAU,IAAA,CAAC,WAAW,CAAC,OAAA,CAAA,GAAW,QAAQ,GAAI,CAAA,QAAA,KAAa,eAAeF,2BAAU,CAAA,KAAA,EAAO,kEAAkE,CAAIA,GAAAA,2BAAAA,CAAU,KAAK,CAAI,GAAA,SAAA;AACvN,IAAU,OAAA,GAAA,UAAA;AAAA,GACL,MAAA;AACL,IAAU,OAAA,GAAA;AAAA,MACR,UAAA;AAAA,MACA,SAAA;AAAA,MACA,aAAA;AAAA,MACA,MAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACF;AAAA;AAEF,EAAC,CAAA,GAAA,GAAM,OAAQ,CAAA,GAAA,CAAI,QAAa,KAAA,YAAA,GAAeA,2BAAU,CAAA,KAAA,EAAO,iBAAiB,CAAA,GAAIA,2BAAU,CAAA,KAAK,CAAI,GAAA,SAAA;AACxG,EAAC,CAAA,YAAA,GAAe,OAAQ,CAAA,GAAA,CAAI,QAAa,KAAA,YAAA,GAAeA,2BAAU,CAAA,KAAA,EAAO,yBAAyB,CAAA,GAAIA,2BAAU,CAAA,KAAK,CAAI,GAAA,SAAA;AAGzH,EAAO,OAAA;AAAA,IACL,UAAA,EAAY,QAAQ,UAAc,IAAA,IAAA;AAAA,IAClC,WAAW,OAAQ,CAAA,SAAA;AAAA,IACnB,aAAe,EAAA,OAAA,CAAQ,aAAiB,IAAA,MAAA,CAAO,SAAS,QAAS,EAAA;AAAA,IACjE,YAAc,EAAA,CAAC,GAAI,OAAA,CAAQ,UAAU,CAAC,eAAA,EAAiB,gBAAkB,EAAA,yBAAA,EAA2B,0BAA0B,CAAE,CAAA,CAAE,IAAK,EAAA,CAAE,KAAK,GAAG,CAAA;AAAA,IACjJ,OAAA,EAAS,OAAQ,CAAA,OAAA,IAAW,UAAW,CAAA,KAAA;AAAA,IACvC,OAAA,EAAS,QAAQ,OAAW,IAAA,WAAA;AAAA,IAC5B,oBAAoB,OAAQ,CAAA;AAAA,GAC9B;AACF;;;ACEO,SAAS,uBAAA,CAAwB,WAAW,GAAK,EAAA,YAAA,EAAc,YAAY,SAAW,EAAA,aAAA,EAAe,MAAQ,EAAA,OAAA,EAAS,OAAS,EAAA;AACpI,EAAI,IAAA,kBAAA;AACJ,EAAI,IAAA,YAAA;AACJ,EAAC,CAAA;AAAA,IACC,UAAA;AAAA,IACA,SAAA;AAAA,IACA,aAAA;AAAA,IACA,YAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA;AAAA,IACA;AAAA,GACF,GAAI,gCAAgC,GAAK,EAAA,YAAA,EAAc,YAAY,SAAW,EAAA,aAAA,EAAe,MAAQ,EAAA,OAAA,EAAS,OAAO,CAAA;AACrH,EAAA,MAAM,MAAS,GAAA;AAAA,IACb,SAAA;AAAA,IACA,0BAA4B,EAAA;AAAA,GAC9B;AACA,EAAM,MAAA,UAAA,GAAa,yBAA0B,CAAA,OAAA,EAAS,GAAG,CAAA;AACzD,EAAA,MAAM,gBAAmB,GAAA;AAAA,IACvB,CAAC,WAAW,GAAG;AAAA,GACjB;AACA,EAAM,MAAA;AAAA,IACJ,uBAAA;AAAA,IACA;AAAA,GACE,GAAA,MAAA,CAAO,MAAQ,EAAA,UAAA,EAAY,OAAS,EAAA,gBAAA,EAAkB,YAAa,CAAA,IAAA,CAAK,UAAY,EAAA,IAAI,CAAG,EAAA,kBAAA,EAAoB,YAAY,CAAA;AAG/H,EAAM,MAAA,EAAA,GAAK,OAAM,CAAK,KAAA;AACpB,IAAA,IAAI,UAAY,EAAA;AACd,MAAA,MAAA,CAAO,OAAQ,CAAA,YAAA,CAAa,EAAC,EAAG,IAAI,CAAC,CAAA;AACrC,MAAA;AAAA,KACK,MAAA,MAAA,CAAO,QAAS,CAAA,MAAA,CAAO,CAAC,CAAA;AAC/B,IAAA,MAAM,cAAM,GAAI,CAAA;AAChB,IAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA;AAAA,GACtC;AACA,EAAA,eAAe,aAAa,kBAAoB,EAAA;AAC9C,IAAM,MAAA;AAAA,MACJ,aAAA;AAAA,MACA,kBAAoB,EAAA,sBAAA;AAAA,MACpB,eAAiB,EAAA;AAAA,KACnB,GAAI,UAAU,MAAM,CAAA;AACpB,IAAM,MAAA,cAAA,GAAiB,sBAA0B,IAAA,IAAA,IAAQ,YAAiB,KAAA,sBAAA;AAC1E,IAAA,IAAI,CAAC,aAAA,IAAiB,sBAA2B,KAAA,kBAAA,IAAsB,CAAC,cAAgB,EAAA;AACtF,MAAA,IAAI,kBAAoB,EAAA,MAAM,IAAI,KAAA,CAAM,wBAAwB,CAAA;AAChE,MAAA;AAAA;AAEF,IAAI,IAAA;AAGF,MAAA,MAAM,SAAS,uBAAwB,CAAA,YAAA,CAAa,MAAM,sCAAA,CAAuC,YAAY,MAAQ,EAAA,MAAM,wBAAyB,CAAA,UAAA,EAAY,QAAQ,aAAe,EAAA,gBAAgB,CAAC,CAAC,GAAG,SAAS,CAAA;AACrN,MAAI,IAAA,MAAA,IAAU,OAAO,QAAS,CAAA,QAAA,KAAa,IAAI,GAAI,CAAA,YAAY,EAAE,QAAU,EAAA;AACzE,QAAM,MAAA;AAAA,UACJ;AAAA,SACF,GAAI,YAAY,MAAM,CAAA;AAEtB,QAAK,KAAA,EAAA,CAAG,UAAU,GAAG,CAAA;AAAA;AAEvB,MAAO,OAAA,MAAA;AAAA,aACA,CAAG,EAAA;AACV,MAAI,IAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,KAAa,YAAc,EAAA;AAEzC,QAAQ,OAAA,CAAA,IAAA,CAAK,8DAA8D,CAAC,CAAA;AAAA;AAE9E,MAAA,WAAA,CAAY,MAAM,CAAA;AAClB,MAAA,IAAI,kBAAoB,EAAA;AACtB,QAAM,MAAA,IAAI,MAAM,yBAAyB,CAAA;AAAA;AAC3C;AACF;AAEF,EAAA,eAAe,qBAAwB,GAAA;AACrC,IAAM,MAAA;AAAA,MACJ,KAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACF,GAAI,YAAY,MAAM,CAAA;AACtB,IAAA,IAAI,CAAC,YAAc,EAAA;AACnB,IAAI,IAAA;AACF,MAAA,MAAM,GAAM,GAAA,uBAAA,CAAwB,YAAa,CAAA,MAAM,sCAAuC,CAAA,UAAA,EAAY,MAAQ,EAAA,MAAM,6BAA8B,CAAA,UAAA,EAAY,MAAQ,EAAA,YAAA,CAAa,qBAAqB,UAAY,EAAA,MAAA,EAAQ,IAAI,GAAA,CAAI,MAAO,CAAA,QAAA,CAAS,IAAI,CAAA,EAAG,KAAK,CAAC,CAAG,EAAA,YAAA,EAAc,YAAc,EAAA,gBAAgB,CAAC,CAAC,GAAG,QAAQ,CAAA;AACjU,MAAA,KAAK,GAAG,MAAM,CAAA;AACd,MAAO,OAAA,GAAA;AAAA,aACA,CAAG,EAAA;AACV,MAAI,IAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,KAAa,YAAc,EAAA;AAEzC,QAAQ,OAAA,CAAA,IAAA,CAAK,qFAAqF,CAAC,CAAA;AAAA;AAErG,MAAA,WAAA,CAAY,MAAM,CAAA;AAClB,MAAA,aAAA,CAAc,MAAM,CAAA;AACpB,MAAM,MAAA,CAAA;AAAA;AACR;AAIF,EAAA,MAAM,wBAAwB,YAAY;AACxC,IAAI,IAAA,SAAA,IAAa,OAAO,QAAS,CAAA,IAAA,KAAS,aAAa,MAAO,CAAA,QAAA,CAAS,aAAa,SAAW,EAAA;AAC7F,MAAU,SAAA,CAAA,MAAA,EAAQ,EAAE,CAAA;AACpB,MAAA,WAAA,CAAY,MAAQ,EAAA;AAAA,QAClB,MAAQ,EAAA;AAAA,OACT,CAAA;AACD,MAAA,MAAM,GAAG,SAAS,CAAA;AAClB,MAAA;AAAA;AAEF,IAAA,MAAM,QAAQ,mBAAoB,EAAA;AAClC,IAAA,MAAM,eAAe,0BAA2B,EAAA;AAChD,IAAA,MAAM,SAAS,WAAY,CAAA,MAAM,EAAE,MAAU,IAAA,MAAA,CAAO,SAAS,QAAS,EAAA;AACtE,IAAU,SAAA,CAAA,MAAA,EAAQ,EAAE,CAAA;AACpB,IAAA,WAAA,CAAY,MAAQ,EAAA;AAAA,MAClB,YAAA;AAAA,MACA,KAAA;AAAA,MACA;AAAA,KACD,CAAA;AACD,IAAA,MAAA,CAAO,SAAS,MAAO,CAAA,CAAA,EAAG,WAAW,sBAAsB,CAAA,CAAA,EAAI,IAAI,eAAgB,CAAA;AAAA,MACjF,SAAA;AAAA,MACA,aAAe,EAAA,MAAA;AAAA,MACf,KAAA;AAAA,MACA,YAAA;AAAA,MACA,cAAA,EAAgB,MAAM,0BAAA,CAA2B,YAAY,CAAA;AAAA,MAC7D,qBAAuB,EAAA,MAAA;AAAA,MACvB,KAAA,EAAO,kBAAkB,YAAY,CAAA;AAAA,KACtC,CAAC,CAAE,CAAA,CAAA;AAGJ,IAAA,MAAM,cAAM,GAAI,CAAA;AAChB,IAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA;AAAA,GACtC;AAGA,EAAA,eAAe,OAAU,GAAA;AAEvB,IAAA,OAAQ,MAAM,YAAa,EAAA,IAErB,MAAM,qBAAsB,EAAA,IAE9B,MAAM,qBAAsB,EAAA;AAAA;AAElC,EAAO,OAAA,QAAA;AACT","file":"index.cjs","sourcesContent":["let USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n  const NAME = 'oauth4webapi';\n  const VERSION = 'v2.10.4';\n  USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n  if (input == null) {\n    return false;\n  }\n  try {\n    return input instanceof expected || Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag];\n  } catch {\n    return false;\n  }\n}\nexport const clockSkew = Symbol();\nexport const clockTolerance = Symbol();\nexport const customFetch = Symbol();\nexport const useMtlsAlias = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n  if (typeof input === 'string') {\n    return encoder.encode(input);\n  }\n  return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n  if (input instanceof ArrayBuffer) {\n    input = new Uint8Array(input);\n  }\n  const arr = [];\n  for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {\n    arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n  }\n  return btoa(arr.join('')).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction decodeBase64Url(input) {\n  try {\n    const binary = atob(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, ''));\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n  } catch (cause) {\n    throw new OPE('The input to be decoded is not correctly encoded.', {\n      cause\n    });\n  }\n}\nfunction b64u(input) {\n  if (typeof input === 'string') {\n    return decodeBase64Url(input);\n  }\n  return encodeBase64Url(input);\n}\nclass LRU {\n  constructor(maxSize) {\n    this.cache = new Map();\n    this._cache = new Map();\n    this.maxSize = maxSize;\n  }\n  get(key) {\n    let v = this.cache.get(key);\n    if (v) {\n      return v;\n    }\n    if (v = this._cache.get(key)) {\n      this.update(key, v);\n      return v;\n    }\n    return undefined;\n  }\n  has(key) {\n    return this.cache.has(key) || this._cache.has(key);\n  }\n  set(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value);\n    } else {\n      this.update(key, value);\n    }\n    return this;\n  }\n  delete(key) {\n    if (this.cache.has(key)) {\n      return this.cache.delete(key);\n    }\n    if (this._cache.has(key)) {\n      return this._cache.delete(key);\n    }\n    return false;\n  }\n  update(key, value) {\n    this.cache.set(key, value);\n    if (this.cache.size >= this.maxSize) {\n      this._cache = this.cache;\n      this.cache = new Map();\n    }\n  }\n}\nexport class UnsupportedOperationError extends Error {\n  constructor(message) {\n    super(message ?? 'operation not supported');\n    this.name = this.constructor.name;\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n}\nexport class OperationProcessingError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.name = this.constructor.name;\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n  return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n  return isCryptoKey(key) && key.type === 'private';\n}\nfunction isPublicKey(key) {\n  return isCryptoKey(key) && key.type === 'public';\n}\nconst SUPPORTED_JWS_ALGS = ['PS256', 'ES256', 'RS256', 'PS384', 'ES384', 'RS384', 'PS512', 'ES512', 'RS512', 'EdDSA'];\nfunction processDpopNonce(response) {\n  try {\n    const nonce = response.headers.get('dpop-nonce');\n    if (nonce) {\n      dpopNonces.set(new URL(response.url).origin, nonce);\n    }\n  } catch {}\n  return response;\n}\nfunction normalizeTyp(value) {\n  return value.toLowerCase().replace(/^application\\//, '');\n}\nfunction isJsonObject(input) {\n  if (input === null || typeof input !== 'object' || Array.isArray(input)) {\n    return false;\n  }\n  return true;\n}\nfunction prepareHeaders(input) {\n  if (looseInstanceOf(input, Headers)) {\n    input = Object.fromEntries(input.entries());\n  }\n  const headers = new Headers(input);\n  if (USER_AGENT && !headers.has('user-agent')) {\n    headers.set('user-agent', USER_AGENT);\n  }\n  if (headers.has('authorization')) {\n    throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n  }\n  if (headers.has('dpop')) {\n    throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n  }\n  return headers;\n}\nfunction signal(value) {\n  if (typeof value === 'function') {\n    value = value();\n  }\n  if (!(value instanceof AbortSignal)) {\n    throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n  }\n  return value;\n}\nexport async function discoveryRequest(issuerIdentifier, options) {\n  if (!(issuerIdentifier instanceof URL)) {\n    throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n  }\n  if (issuerIdentifier.protocol !== 'https:' && issuerIdentifier.protocol !== 'http:') {\n    throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n  }\n  const url = new URL(issuerIdentifier.href);\n  switch (options?.algorithm) {\n    case undefined:\n    case 'oidc':\n      url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace('//', '/');\n      break;\n    case 'oauth2':\n      if (url.pathname === '/') {\n        url.pathname = '.well-known/oauth-authorization-server';\n      } else {\n        url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace('//', '/');\n      }\n      break;\n    default:\n      throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n  }\n  const headers = prepareHeaders(options?.headers);\n  headers.set('accept', 'application/json');\n  return (options?.[customFetch] || fetch)(url.href, {\n    headers: Object.fromEntries(headers.entries()),\n    method: 'GET',\n    redirect: 'manual',\n    signal: options?.signal ? signal(options.signal) : null\n  }).then(processDpopNonce);\n}\nfunction validateString(input) {\n  return typeof input === 'string' && input.length !== 0;\n}\nexport async function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n  if (!(expectedIssuerIdentifier instanceof URL)) {\n    throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n  }\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.issuer)) {\n    throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n  }\n  if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n    throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n  }\n  return json;\n}\nfunction randomBytes() {\n  return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nexport function generateRandomCodeVerifier() {\n  return randomBytes();\n}\nexport function generateRandomState() {\n  return randomBytes();\n}\nexport function generateRandomNonce() {\n  return randomBytes();\n}\nexport async function calculatePKCECodeChallenge(codeVerifier) {\n  if (!validateString(codeVerifier)) {\n    throw new TypeError('\"codeVerifier\" must be a non-empty string');\n  }\n  return b64u(await crypto.subtle.digest('SHA-256', buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n  if (input instanceof CryptoKey) {\n    return {\n      key: input\n    };\n  }\n  if (!(input?.key instanceof CryptoKey)) {\n    return {};\n  }\n  if (input.kid !== undefined && !validateString(input.kid)) {\n    throw new TypeError('\"kid\" must be a non-empty string');\n  }\n  return {\n    key: input.key,\n    kid: input.kid\n  };\n}\nfunction formUrlEncode(token) {\n  return encodeURIComponent(token).replace(/%20/g, '+');\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n  const username = formUrlEncode(clientId);\n  const password = formUrlEncode(clientSecret);\n  const credentials = btoa(`${username}:${password}`);\n  return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n  switch (key.algorithm.hash.name) {\n    case 'SHA-256':\n      return 'PS256';\n    case 'SHA-384':\n      return 'PS384';\n    case 'SHA-512':\n      return 'PS512';\n    default:\n      throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n  }\n}\nfunction rsAlg(key) {\n  switch (key.algorithm.hash.name) {\n    case 'SHA-256':\n      return 'RS256';\n    case 'SHA-384':\n      return 'RS384';\n    case 'SHA-512':\n      return 'RS512';\n    default:\n      throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n  }\n}\nfunction esAlg(key) {\n  switch (key.algorithm.namedCurve) {\n    case 'P-256':\n      return 'ES256';\n    case 'P-384':\n      return 'ES384';\n    case 'P-521':\n      return 'ES512';\n    default:\n      throw new UnsupportedOperationError('unsupported EcKeyAlgorithm namedCurve');\n  }\n}\nfunction keyToJws(key) {\n  switch (key.algorithm.name) {\n    case 'RSA-PSS':\n      return psAlg(key);\n    case 'RSASSA-PKCS1-v1_5':\n      return rsAlg(key);\n    case 'ECDSA':\n      return esAlg(key);\n    case 'Ed25519':\n    case 'Ed448':\n      return 'EdDSA';\n    default:\n      throw new UnsupportedOperationError('unsupported CryptoKey algorithm name');\n  }\n}\nfunction getClockSkew(client) {\n  const skew = client?.[clockSkew];\n  return typeof skew === 'number' && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n  const tolerance = client?.[clockTolerance];\n  return typeof tolerance === 'number' && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1 ? tolerance : 30;\n}\nfunction epochTime() {\n  return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n  const now = epochTime() + getClockSkew(client);\n  return {\n    jti: randomBytes(),\n    aud: [as.issuer, as.token_endpoint],\n    exp: now + 60,\n    iat: now,\n    nbf: now,\n    iss: client.client_id,\n    sub: client.client_id\n  };\n}\nasync function privateKeyJwt(as, client, key, kid) {\n  return jwt({\n    alg: keyToJws(key),\n    kid\n  }, clientAssertion(as, client), key);\n}\nfunction assertAs(as) {\n  if (typeof as !== 'object' || as === null) {\n    throw new TypeError('\"as\" must be an object');\n  }\n  if (!validateString(as.issuer)) {\n    throw new TypeError('\"as.issuer\" property must be a non-empty string');\n  }\n  return true;\n}\nfunction assertClient(client) {\n  if (typeof client !== 'object' || client === null) {\n    throw new TypeError('\"client\" must be an object');\n  }\n  if (!validateString(client.client_id)) {\n    throw new TypeError('\"client.client_id\" property must be a non-empty string');\n  }\n  return true;\n}\nfunction assertClientSecret(clientSecret) {\n  if (!validateString(clientSecret)) {\n    throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n  }\n  return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n  if (clientPrivateKey !== undefined) {\n    throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n  }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n  if (clientSecret !== undefined) {\n    throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n  }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n  body.delete('client_secret');\n  body.delete('client_assertion_type');\n  body.delete('client_assertion');\n  switch (client.token_endpoint_auth_method) {\n    case undefined:\n    case 'client_secret_basic':\n      {\n        assertNoClientPrivateKey('client_secret_basic', clientPrivateKey);\n        headers.set('authorization', clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n        break;\n      }\n    case 'client_secret_post':\n      {\n        assertNoClientPrivateKey('client_secret_post', clientPrivateKey);\n        body.set('client_id', client.client_id);\n        body.set('client_secret', assertClientSecret(client.client_secret));\n        break;\n      }\n    case 'private_key_jwt':\n      {\n        assertNoClientSecret('private_key_jwt', client.client_secret);\n        if (clientPrivateKey === undefined) {\n          throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n        }\n        const {\n          key,\n          kid\n        } = getKeyAndKid(clientPrivateKey);\n        if (!isPrivateKey(key)) {\n          throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n        }\n        body.set('client_id', client.client_id);\n        body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');\n        body.set('client_assertion', await privateKeyJwt(as, client, key, kid));\n        break;\n      }\n    case 'tls_client_auth':\n    case 'self_signed_tls_client_auth':\n    case 'none':\n      {\n        assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n        assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n        body.set('client_id', client.client_id);\n        break;\n      }\n    default:\n      throw new UnsupportedOperationError('unsupported client token_endpoint_auth_method');\n  }\n}\nasync function jwt(header, claimsSet, key) {\n  if (!key.usages.includes('sign')) {\n    throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n  }\n  const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(claimsSet)))}`;\n  const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n  return `${input}.${signature}`;\n}\nexport async function issueRequestObject(as, client, parameters, privateKey) {\n  assertAs(as);\n  assertClient(client);\n  parameters = new URLSearchParams(parameters);\n  const {\n    key,\n    kid\n  } = getKeyAndKid(privateKey);\n  if (!isPrivateKey(key)) {\n    throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n  }\n  parameters.set('client_id', client.client_id);\n  const now = epochTime() + getClockSkew(client);\n  const claims = {\n    ...Object.fromEntries(parameters.entries()),\n    jti: randomBytes(),\n    aud: as.issuer,\n    exp: now + 60,\n    iat: now,\n    nbf: now,\n    iss: client.client_id\n  };\n  let resource;\n  if (parameters.has('resource') && (resource = parameters.getAll('resource')) && resource.length > 1) {\n    claims.resource = resource;\n  }\n  {\n    let value = parameters.get('max_age');\n    if (value !== null) {\n      claims.max_age = parseInt(value, 10);\n      if (!Number.isFinite(claims.max_age)) {\n        throw new OPE('\"max_age\" parameter must be a number');\n      }\n    }\n  }\n  {\n    let value = parameters.get('claims');\n    if (value !== null) {\n      try {\n        claims.claims = JSON.parse(value);\n      } catch (cause) {\n        throw new OPE('failed to parse the \"claims\" parameter as JSON', {\n          cause\n        });\n      }\n      if (!isJsonObject(claims.claims)) {\n        throw new OPE('\"claims\" parameter must be a JSON with a top level object');\n      }\n    }\n  }\n  {\n    let value = parameters.get('authorization_details');\n    if (value !== null) {\n      try {\n        claims.authorization_details = JSON.parse(value);\n      } catch (cause) {\n        throw new OPE('failed to parse the \"authorization_details\" parameter as JSON', {\n          cause\n        });\n      }\n      if (!Array.isArray(claims.authorization_details)) {\n        throw new OPE('\"authorization_details\" parameter must be a JSON with a top level array');\n      }\n    }\n  }\n  return jwt({\n    alg: keyToJws(key),\n    typ: 'oauth-authz-req+jwt',\n    kid\n  }, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n  const {\n    privateKey,\n    publicKey,\n    nonce = dpopNonces.get(url.origin)\n  } = options;\n  if (!isPrivateKey(privateKey)) {\n    throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n  }\n  if (!isPublicKey(publicKey)) {\n    throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n  }\n  if (nonce !== undefined && !validateString(nonce)) {\n    throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n  }\n  if (!publicKey.extractable) {\n    throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n  }\n  const now = epochTime() + clockSkew;\n  const proof = await jwt({\n    alg: keyToJws(privateKey),\n    typ: 'dpop+jwt',\n    jwk: await publicJwk(publicKey)\n  }, {\n    iat: now,\n    jti: randomBytes(),\n    htm,\n    nonce,\n    htu: `${url.origin}${url.pathname}`,\n    ath: accessToken ? b64u(await crypto.subtle.digest('SHA-256', buf(accessToken))) : undefined\n  }, privateKey);\n  headers.set('dpop', proof);\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key) {\n  const {\n    kty,\n    e,\n    n,\n    x,\n    y,\n    crv\n  } = await crypto.subtle.exportKey('jwk', key);\n  const jwk = {\n    kty,\n    e,\n    n,\n    x,\n    y,\n    crv\n  };\n  jwkCache.set(key, jwk);\n  return jwk;\n}\nasync function publicJwk(key) {\n  jwkCache || (jwkCache = new WeakMap());\n  return jwkCache.get(key) || getSetPublicJwkCache(key);\n}\nfunction validateEndpoint(value, endpoint, options) {\n  if (typeof value !== 'string') {\n    if (options?.[useMtlsAlias]) {\n      throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n    }\n    throw new TypeError(`\"as.${endpoint}\" must be a string`);\n  }\n  return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, options) {\n  if (options?.[useMtlsAlias] && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n    return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, options);\n  }\n  return validateEndpoint(as[endpoint], endpoint);\n}\nexport async function pushedAuthorizationRequest(as, client, parameters, options) {\n  assertAs(as);\n  assertClient(client);\n  const url = resolveEndpoint(as, 'pushed_authorization_request_endpoint', options);\n  const body = new URLSearchParams(parameters);\n  body.set('client_id', client.client_id);\n  const headers = prepareHeaders(options?.headers);\n  headers.set('accept', 'application/json');\n  if (options?.DPoP !== undefined) {\n    await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n  }\n  return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport function isOAuth2Error(input) {\n  const value = input;\n  if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n    return false;\n  }\n  return value.error !== undefined;\n}\nfunction unquote(value) {\n  if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n    return value.slice(1, -1);\n  }\n  return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n  const arr = params.split(SPLIT_REGEXP).slice(1);\n  if (!arr.length) {\n    return {\n      scheme: scheme.toLowerCase(),\n      parameters: {}\n    };\n  }\n  arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, '');\n  const parameters = {};\n  for (let i = 1; i < arr.length; i += 2) {\n    const idx = i;\n    if (arr[idx][0] === '\"') {\n      while (arr[idx].slice(-1) !== '\"' && ++i < arr.length) {\n        arr[idx] += arr[i];\n      }\n    }\n    const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, '').toLowerCase();\n    parameters[key] = unquote(arr[idx]);\n  }\n  return {\n    scheme: scheme.toLowerCase(),\n    parameters\n  };\n}\nexport function parseWwwAuthenticateChallenges(response) {\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  const header = response.headers.get('www-authenticate');\n  if (header === null) {\n    return undefined;\n  }\n  const result = [];\n  for (const {\n    1: scheme,\n    index\n  } of header.matchAll(SCHEMES_REGEXP)) {\n    result.push([scheme, index]);\n  }\n  if (!result.length) {\n    return undefined;\n  }\n  const challenges = result.map(([scheme, indexOf], i, others) => {\n    const next = others[i + 1];\n    let parameters;\n    if (next) {\n      parameters = header.slice(indexOf, next[1]);\n    } else {\n      parameters = header.slice(indexOf);\n    }\n    return wwwAuth(scheme, parameters);\n  });\n  return challenges;\n}\nexport async function processPushedAuthorizationResponse(as, client, response) {\n  assertAs(as);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 201) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.request_uri)) {\n    throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n  }\n  if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n    throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n  }\n  return json;\n}\nexport async function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n  if (!validateString(accessToken)) {\n    throw new TypeError('\"accessToken\" must be a non-empty string');\n  }\n  if (!(url instanceof URL)) {\n    throw new TypeError('\"url\" must be an instance of URL');\n  }\n  headers = prepareHeaders(headers);\n  if (options?.DPoP === undefined) {\n    headers.set('authorization', `Bearer ${accessToken}`);\n  } else {\n    await dpopProofJwt(headers, options.DPoP, url, 'GET', getClockSkew({\n      [clockSkew]: options?.[clockSkew]\n    }), accessToken);\n    headers.set('authorization', `DPoP ${accessToken}`);\n  }\n  return (options?.[customFetch] || fetch)(url.href, {\n    body,\n    headers: Object.fromEntries(headers.entries()),\n    method,\n    redirect: 'manual',\n    signal: options?.signal ? signal(options.signal) : null\n  }).then(processDpopNonce);\n}\nexport async function userInfoRequest(as, client, accessToken, options) {\n  assertAs(as);\n  assertClient(client);\n  const url = resolveEndpoint(as, 'userinfo_endpoint', options);\n  const headers = prepareHeaders(options?.headers);\n  if (client.userinfo_signed_response_alg) {\n    headers.set('accept', 'application/jwt');\n  } else {\n    headers.set('accept', 'application/json');\n    headers.append('accept', 'application/jwt');\n  }\n  return protectedResourceRequest(accessToken, 'GET', url, headers, null, {\n    ...options,\n    [clockSkew]: getClockSkew(client)\n  });\n}\nlet jwksCache;\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n  const {\n    alg,\n    kid\n  } = header;\n  checkSupportedJwsAlg(alg);\n  let jwks;\n  let age;\n  jwksCache || (jwksCache = new WeakMap());\n  if (jwksCache.has(as)) {\n    ;\n    ({\n      jwks,\n      age\n    } = jwksCache.get(as));\n    if (age >= 300) {\n      jwksCache.delete(as);\n      return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    }\n  } else {\n    jwks = await jwksRequest(as, options).then(processJwksResponse);\n    age = 0;\n    jwksCache.set(as, {\n      jwks,\n      iat: epochTime(),\n      get age() {\n        return epochTime() - this.iat;\n      }\n    });\n  }\n  let kty;\n  switch (alg.slice(0, 2)) {\n    case 'RS':\n    case 'PS':\n      kty = 'RSA';\n      break;\n    case 'ES':\n      kty = 'EC';\n      break;\n    case 'Ed':\n      kty = 'OKP';\n      break;\n    default:\n      throw new UnsupportedOperationError();\n  }\n  const candidates = jwks.keys.filter(jwk => {\n    if (jwk.kty !== kty) {\n      return false;\n    }\n    if (kid !== undefined && kid !== jwk.kid) {\n      return false;\n    }\n    if (jwk.alg !== undefined && alg !== jwk.alg) {\n      return false;\n    }\n    if (jwk.use !== undefined && jwk.use !== 'sig') {\n      return false;\n    }\n    if (jwk.key_ops?.includes('verify') === false) {\n      return false;\n    }\n    switch (true) {\n      case alg === 'ES256' && jwk.crv !== 'P-256':\n      case alg === 'ES384' && jwk.crv !== 'P-384':\n      case alg === 'ES512' && jwk.crv !== 'P-521':\n      case alg === 'EdDSA' && !(jwk.crv === 'Ed25519' || jwk.crv === 'Ed448'):\n        return false;\n    }\n    return true;\n  });\n  const {\n    0: jwk,\n    length\n  } = candidates;\n  if (!length) {\n    if (age >= 60) {\n      jwksCache.delete(as);\n      return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    }\n    throw new OPE('error when selecting a JWT verification key, no applicable keys found');\n  }\n  if (length !== 1) {\n    throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n  }\n  const key = await importJwk(alg, jwk);\n  if (key.type !== 'public') {\n    throw new OPE('jwks_uri must only contain public keys');\n  }\n  return key;\n}\nexport const skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n  return response.headers.get('content-type')?.split(';')[0];\n}\nexport async function processUserInfoResponse(as, client, expectedSubject, response) {\n  assertAs(as);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n  }\n  let json;\n  if (getContentType(response) === 'application/jwt') {\n    assertReadableResponse(response);\n    const {\n      claims\n    } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validateOptionalAudience.bind(undefined, client.client_id)).then(validateOptionalIssuer.bind(undefined, as.issuer));\n    json = claims;\n  } else {\n    if (client.userinfo_signed_response_alg) {\n      throw new OPE('JWT UserInfo Response expected');\n    }\n    assertReadableResponse(response);\n    try {\n      json = await response.json();\n    } catch (cause) {\n      throw new OPE('failed to parse \"response\" body as JSON', {\n        cause\n      });\n    }\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.sub)) {\n    throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n  }\n  switch (expectedSubject) {\n    case skipSubjectCheck:\n      break;\n    default:\n      if (!validateString(expectedSubject)) {\n        throw new OPE('\"expectedSubject\" must be a non-empty string');\n      }\n      if (json.sub !== expectedSubject) {\n        throw new OPE('unexpected \"response\" body \"sub\" value');\n      }\n  }\n  return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n  await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n  headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n  return (options?.[customFetch] || fetch)(url.href, {\n    body,\n    headers: Object.fromEntries(headers.entries()),\n    method,\n    redirect: 'manual',\n    signal: options?.signal ? signal(options.signal) : null\n  }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n  const url = resolveEndpoint(as, 'token_endpoint', options);\n  parameters.set('grant_type', grantType);\n  const headers = prepareHeaders(options?.headers);\n  headers.set('accept', 'application/json');\n  if (options?.DPoP !== undefined) {\n    await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n  }\n  return authenticatedRequest(as, client, 'POST', url, parameters, headers, options);\n}\nexport async function refreshTokenGrantRequest(as, client, refreshToken, options) {\n  assertAs(as);\n  assertClient(client);\n  if (!validateString(refreshToken)) {\n    throw new TypeError('\"refreshToken\" must be a non-empty string');\n  }\n  const parameters = new URLSearchParams(options?.additionalParameters);\n  parameters.set('refresh_token', refreshToken);\n  return tokenEndpointRequest(as, client, 'refresh_token', parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nexport function getValidatedIdTokenClaims(ref) {\n  if (!ref.id_token) {\n    return undefined;\n  }\n  const claims = idTokenClaims.get(ref);\n  if (!claims) {\n    throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n  }\n  return claims;\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n  assertAs(as);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Token Endpoint response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.access_token)) {\n    throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n  }\n  if (!validateString(json.token_type)) {\n    throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n  }\n  json.token_type = json.token_type.toLowerCase();\n  if (json.token_type !== 'dpop' && json.token_type !== 'bearer') {\n    throw new UnsupportedOperationError('unsupported `token_type` value');\n  }\n  if (json.expires_in !== undefined && (typeof json.expires_in !== 'number' || json.expires_in <= 0)) {\n    throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n  }\n  if (!ignoreRefreshToken && json.refresh_token !== undefined && !validateString(json.refresh_token)) {\n    throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n  }\n  if (json.scope !== undefined && typeof json.scope !== 'string') {\n    throw new OPE('\"response\" body \"scope\" property must be a string');\n  }\n  if (!ignoreIdToken) {\n    if (json.id_token !== undefined && !validateString(json.id_token)) {\n      throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    if (json.id_token) {\n      const {\n        claims\n      } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, ['aud', 'exp', 'iat', 'iss', 'sub'])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n      if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n        throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n      }\n      if (client.require_auth_time && typeof claims.auth_time !== 'number') {\n        throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n      }\n      idTokenClaims.set(json, claims);\n    }\n  }\n  return json;\n}\nexport async function processRefreshTokenResponse(as, client, response) {\n  return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n  if (result.claims.aud !== undefined) {\n    return validateAudience(expected, result);\n  }\n  return result;\n}\nfunction validateAudience(expected, result) {\n  if (Array.isArray(result.claims.aud)) {\n    if (!result.claims.aud.includes(expected)) {\n      throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n  } else if (result.claims.aud !== expected) {\n    throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n  }\n  return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n  if (result.claims.iss !== undefined) {\n    return validateIssuer(expected, result);\n  }\n  return result;\n}\nfunction validateIssuer(expected, result) {\n  if (result.claims.iss !== expected) {\n    throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n  }\n  return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n  branded.add(searchParams);\n  return searchParams;\n}\nexport async function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n  assertAs(as);\n  assertClient(client);\n  if (!branded.has(callbackParameters)) {\n    throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n  }\n  if (!validateString(redirectUri)) {\n    throw new TypeError('\"redirectUri\" must be a non-empty string');\n  }\n  if (!validateString(codeVerifier)) {\n    throw new TypeError('\"codeVerifier\" must be a non-empty string');\n  }\n  const code = getURLSearchParameter(callbackParameters, 'code');\n  if (!code) {\n    throw new OPE('no authorization code in \"callbackParameters\"');\n  }\n  const parameters = new URLSearchParams(options?.additionalParameters);\n  parameters.set('redirect_uri', redirectUri);\n  parameters.set('code_verifier', codeVerifier);\n  parameters.set('code', code);\n  return tokenEndpointRequest(as, client, 'authorization_code', parameters, options);\n}\nconst jwtClaimNames = {\n  aud: 'audience',\n  c_hash: 'code hash',\n  client_id: 'client id',\n  exp: 'expiration time',\n  iat: 'issued at',\n  iss: 'issuer',\n  jti: 'jwt id',\n  nonce: 'nonce',\n  s_hash: 'state hash',\n  sub: 'subject',\n  ath: 'access token hash',\n  htm: 'http method',\n  htu: 'http uri',\n  cnf: 'confirmation'\n};\nfunction validatePresence(required, result) {\n  for (const claim of required) {\n    if (result.claims[claim] === undefined) {\n      throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n    }\n  }\n  return result;\n}\nexport const expectNoNonce = Symbol();\nexport const skipAuthTimeCheck = Symbol();\nexport async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n  const result = await processGenericAccessTokenResponse(as, client, response);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  if (!validateString(result.id_token)) {\n    throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n  }\n  maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n  const claims = getValidatedIdTokenClaims(result);\n  if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n    throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n  }\n  if (maxAge !== skipAuthTimeCheck) {\n    if (typeof maxAge !== 'number' || maxAge < 0) {\n      throw new TypeError('\"options.max_age\" must be a non-negative number');\n    }\n    const now = epochTime() + getClockSkew(client);\n    const tolerance = getClockTolerance(client);\n    if (claims.auth_time + maxAge < now - tolerance) {\n      throw new OPE('too much time has elapsed since the last End-User authentication');\n    }\n  }\n  switch (expectedNonce) {\n    case undefined:\n    case expectNoNonce:\n      if (claims.nonce !== undefined) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n      }\n      break;\n    default:\n      if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n      }\n      if (claims.nonce === undefined) {\n        throw new OPE('ID Token \"nonce\" claim missing');\n      }\n      if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n      }\n  }\n  return result;\n}\nexport async function processAuthorizationCodeOAuth2Response(as, client, response) {\n  const result = await processGenericAccessTokenResponse(as, client, response, true);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  if (result.id_token !== undefined) {\n    if (typeof result.id_token === 'string' && result.id_token.length) {\n      throw new OPE('Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing');\n    }\n    delete result.id_token;\n  }\n  return result;\n}\nfunction checkJwtType(expected, result) {\n  if (typeof result.header.typ !== 'string' || normalizeTyp(result.header.typ) !== expected) {\n    throw new OPE('unexpected JWT \"typ\" header parameter value');\n  }\n  return result;\n}\nexport async function clientCredentialsGrantRequest(as, client, parameters, options) {\n  assertAs(as);\n  assertClient(client);\n  return tokenEndpointRequest(as, client, 'client_credentials', new URLSearchParams(parameters), options);\n}\nexport async function processClientCredentialsResponse(as, client, response) {\n  const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  return result;\n}\nexport async function revocationRequest(as, client, token, options) {\n  assertAs(as);\n  assertClient(client);\n  if (!validateString(token)) {\n    throw new TypeError('\"token\" must be a non-empty string');\n  }\n  const url = resolveEndpoint(as, 'revocation_endpoint', options);\n  const body = new URLSearchParams(options?.additionalParameters);\n  body.set('token', token);\n  const headers = prepareHeaders(options?.headers);\n  headers.delete('accept');\n  return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processRevocationResponse(response) {\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n  }\n  return undefined;\n}\nfunction assertReadableResponse(response) {\n  if (response.bodyUsed) {\n    throw new TypeError('\"response\" body has been used already');\n  }\n}\nexport async function introspectionRequest(as, client, token, options) {\n  assertAs(as);\n  assertClient(client);\n  if (!validateString(token)) {\n    throw new TypeError('\"token\" must be a non-empty string');\n  }\n  const url = resolveEndpoint(as, 'introspection_endpoint', options);\n  const body = new URLSearchParams(options?.additionalParameters);\n  body.set('token', token);\n  const headers = prepareHeaders(options?.headers);\n  if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n    headers.set('accept', 'application/token-introspection+jwt');\n  } else {\n    headers.set('accept', 'application/json');\n  }\n  return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processIntrospectionResponse(as, client, response) {\n  assertAs(as);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n  }\n  let json;\n  if (getContentType(response) === 'application/token-introspection+jwt') {\n    assertReadableResponse(response);\n    const {\n      claims\n    } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client)).then(checkJwtType.bind(undefined, 'token-introspection+jwt')).then(validatePresence.bind(undefined, ['aud', 'iat', 'iss'])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n    json = claims.token_introspection;\n    if (!isJsonObject(json)) {\n      throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n    }\n  } else {\n    assertReadableResponse(response);\n    try {\n      json = await response.json();\n    } catch (cause) {\n      throw new OPE('failed to parse \"response\" body as JSON', {\n        cause\n      });\n    }\n    if (!isJsonObject(json)) {\n      throw new OPE('\"response\" body must be a top level object');\n    }\n  }\n  if (typeof json.active !== 'boolean') {\n    throw new OPE('\"response\" body \"active\" property must be a boolean');\n  }\n  return json;\n}\nasync function jwksRequest(as, options) {\n  assertAs(as);\n  const url = resolveEndpoint(as, 'jwks_uri');\n  const headers = prepareHeaders(options?.headers);\n  headers.set('accept', 'application/json');\n  headers.append('accept', 'application/jwk-set+json');\n  return (options?.[customFetch] || fetch)(url.href, {\n    headers: Object.fromEntries(headers.entries()),\n    method: 'GET',\n    redirect: 'manual',\n    signal: options?.signal ? signal(options.signal) : null\n  }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!Array.isArray(json.keys)) {\n    throw new OPE('\"response\" body \"keys\" property must be an array');\n  }\n  if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n    throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n  }\n  return json;\n}\nasync function handleOAuthBodyError(response) {\n  if (response.status > 399 && response.status < 500) {\n    assertReadableResponse(response);\n    try {\n      const json = await response.json();\n      if (isJsonObject(json) && typeof json.error === 'string' && json.error.length) {\n        if (json.error_description !== undefined && typeof json.error_description !== 'string') {\n          delete json.error_description;\n        }\n        if (json.error_uri !== undefined && typeof json.error_uri !== 'string') {\n          delete json.error_uri;\n        }\n        if (json.algs !== undefined && typeof json.algs !== 'string') {\n          delete json.algs;\n        }\n        if (json.scope !== undefined && typeof json.scope !== 'string') {\n          delete json.scope;\n        }\n        return json;\n      }\n    } catch {}\n  }\n  return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n  if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n    throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n  }\n  return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n  if (typeof algorithm.modulusLength !== 'number' || algorithm.modulusLength < 2048) {\n    throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n  }\n}\nfunction ecdsaHashName(namedCurve) {\n  switch (namedCurve) {\n    case 'P-256':\n      return 'SHA-256';\n    case 'P-384':\n      return 'SHA-384';\n    case 'P-521':\n      return 'SHA-512';\n    default:\n      throw new UnsupportedOperationError();\n  }\n}\nfunction keyToSubtle(key) {\n  switch (key.algorithm.name) {\n    case 'ECDSA':\n      return {\n        name: key.algorithm.name,\n        hash: ecdsaHashName(key.algorithm.namedCurve)\n      };\n    case 'RSA-PSS':\n      {\n        checkRsaKeyAlgorithm(key.algorithm);\n        switch (key.algorithm.hash.name) {\n          case 'SHA-256':\n          case 'SHA-384':\n          case 'SHA-512':\n            return {\n              name: key.algorithm.name,\n              saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3\n            };\n          default:\n            throw new UnsupportedOperationError();\n        }\n      }\n    case 'RSASSA-PKCS1-v1_5':\n      checkRsaKeyAlgorithm(key.algorithm);\n      return key.algorithm.name;\n    case 'Ed448':\n    case 'Ed25519':\n      return key.algorithm.name;\n  }\n  throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance) {\n  const {\n    0: protectedHeader,\n    1: payload,\n    2: encodedSignature,\n    length\n  } = jws.split('.');\n  if (length === 5) {\n    throw new UnsupportedOperationError('JWE structure JWTs are not supported');\n  }\n  if (length !== 3) {\n    throw new OPE('Invalid JWT');\n  }\n  let header;\n  try {\n    header = JSON.parse(buf(b64u(protectedHeader)));\n  } catch (cause) {\n    throw new OPE('failed to parse JWT Header body as base64url encoded JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(header)) {\n    throw new OPE('JWT Header must be a top level object');\n  }\n  checkAlg(header);\n  if (header.crit !== undefined) {\n    throw new OPE('unexpected JWT \"crit\" header parameter');\n  }\n  const signature = b64u(encodedSignature);\n  let key;\n  if (getKey !== noSignatureCheck) {\n    key = await getKey(header);\n    const input = `${protectedHeader}.${payload}`;\n    const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n    if (!verified) {\n      throw new OPE('JWT signature verification failed');\n    }\n  }\n  let claims;\n  try {\n    claims = JSON.parse(buf(b64u(payload)));\n  } catch (cause) {\n    throw new OPE('failed to parse JWT Payload body as base64url encoded JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(claims)) {\n    throw new OPE('JWT Payload must be a top level object');\n  }\n  const now = epochTime() + clockSkew;\n  if (claims.exp !== undefined) {\n    if (typeof claims.exp !== 'number') {\n      throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n    }\n    if (claims.exp <= now - clockTolerance) {\n      throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n    }\n  }\n  if (claims.iat !== undefined) {\n    if (typeof claims.iat !== 'number') {\n      throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n    }\n  }\n  if (claims.iss !== undefined) {\n    if (typeof claims.iss !== 'string') {\n      throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n    }\n  }\n  if (claims.nbf !== undefined) {\n    if (typeof claims.nbf !== 'number') {\n      throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n    }\n    if (claims.nbf > now + clockTolerance) {\n      throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n    }\n  }\n  if (claims.aud !== undefined) {\n    if (typeof claims.aud !== 'string' && !Array.isArray(claims.aud)) {\n      throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n    }\n  }\n  return {\n    header,\n    claims,\n    signature,\n    key\n  };\n}\nexport async function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n  assertAs(as);\n  assertClient(client);\n  if (parameters instanceof URL) {\n    parameters = parameters.searchParams;\n  }\n  if (!(parameters instanceof URLSearchParams)) {\n    throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n  }\n  const response = getURLSearchParameter(parameters, 'response');\n  if (!response) {\n    throw new OPE('\"parameters\" does not contain a JARM response');\n  }\n  if (typeof as.jwks_uri !== 'string') {\n    throw new TypeError('\"as.jwks_uri\" must be a string');\n  }\n  const {\n    claims\n  } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, ['aud', 'exp', 'iss'])).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(claims)) {\n    if (typeof value === 'string' && key !== 'aud') {\n      result.set(key, value);\n    }\n  }\n  return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n  let algorithm;\n  switch (alg) {\n    case 'RS256':\n    case 'PS256':\n    case 'ES256':\n      algorithm = 'SHA-256';\n      break;\n    case 'RS384':\n    case 'PS384':\n    case 'ES384':\n      algorithm = 'SHA-384';\n      break;\n    case 'RS512':\n    case 'PS512':\n    case 'ES512':\n      algorithm = 'SHA-512';\n      break;\n    case 'EdDSA':\n      if (key.algorithm.name === 'Ed25519') {\n        algorithm = 'SHA-512';\n        break;\n      }\n      throw new UnsupportedOperationError();\n    default:\n      throw new UnsupportedOperationError();\n  }\n  const digest = await crypto.subtle.digest(algorithm, buf(data));\n  return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n  const expected = await idTokenHash(alg, data, key);\n  return actual === expected;\n}\nexport async function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n  assertAs(as);\n  assertClient(client);\n  if (parameters instanceof URL) {\n    if (!parameters.hash.length) {\n      throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n    }\n    parameters = new URLSearchParams(parameters.hash.slice(1));\n  }\n  if (!(parameters instanceof URLSearchParams)) {\n    throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n  }\n  parameters = new URLSearchParams(parameters);\n  const id_token = getURLSearchParameter(parameters, 'id_token');\n  parameters.delete('id_token');\n  switch (expectedState) {\n    case undefined:\n    case expectNoState:\n      break;\n    default:\n      if (!validateString(expectedState)) {\n        throw new TypeError('\"expectedState\" must be a non-empty string');\n      }\n  }\n  const result = validateAuthResponse({\n    ...as,\n    authorization_response_iss_parameter_supported: false\n  }, client, parameters, expectedState);\n  if (isOAuth2Error(result)) {\n    return result;\n  }\n  if (!id_token) {\n    throw new OPE('\"parameters\" does not contain an ID Token');\n  }\n  const code = getURLSearchParameter(parameters, 'code');\n  if (!code) {\n    throw new OPE('\"parameters\" does not contain an Authorization Code');\n  }\n  if (typeof as.jwks_uri !== 'string') {\n    throw new TypeError('\"as.jwks_uri\" must be a string');\n  }\n  const requiredClaims = ['aud', 'exp', 'iat', 'iss', 'sub', 'nonce', 'c_hash'];\n  if (typeof expectedState === 'string') {\n    requiredClaims.push('s_hash');\n  }\n  const {\n    claims,\n    header,\n    key\n  } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client)).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, client.client_id));\n  const clockSkew = getClockSkew(client);\n  const now = epochTime() + clockSkew;\n  if (claims.iat < now - 3600) {\n    throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n  }\n  if (typeof claims.c_hash !== 'string' || (await idTokenHashMatches(code, claims.c_hash, header.alg, key)) !== true) {\n    throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n  }\n  if (claims.s_hash !== undefined && typeof expectedState !== 'string') {\n    throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n  }\n  if (typeof expectedState === 'string' && (typeof claims.s_hash !== 'string' || (await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key)) !== true)) {\n    throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n  }\n  if (client.require_auth_time !== undefined && typeof claims.auth_time !== 'number') {\n    throw new OPE('unexpected ID Token \"auth_time\" (authentication time) claim value');\n  }\n  maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n  if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) && claims.auth_time === undefined) {\n    throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n  }\n  if (maxAge !== skipAuthTimeCheck) {\n    if (typeof maxAge !== 'number' || maxAge < 0) {\n      throw new TypeError('\"options.max_age\" must be a non-negative number');\n    }\n    const now = epochTime() + getClockSkew(client);\n    const tolerance = getClockTolerance(client);\n    if (claims.auth_time + maxAge < now - tolerance) {\n      throw new OPE('too much time has elapsed since the last End-User authentication');\n    }\n  }\n  if (!validateString(expectedNonce)) {\n    throw new TypeError('\"expectedNonce\" must be a non-empty string');\n  }\n  if (claims.nonce !== expectedNonce) {\n    throw new OPE('unexpected ID Token \"nonce\" claim value');\n  }\n  if (Array.isArray(claims.aud) && claims.aud.length !== 1 && claims.azp !== client.client_id) {\n    throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n  }\n  return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n  if (client !== undefined) {\n    if (header.alg !== client) {\n      throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n    return;\n  }\n  if (Array.isArray(issuer)) {\n    if (!issuer.includes(header.alg)) {\n      throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n    return;\n  }\n  if (header.alg !== 'RS256') {\n    throw new OPE('unexpected JWT \"alg\" header parameter');\n  }\n}\nfunction getURLSearchParameter(parameters, name) {\n  const {\n    0: value,\n    length\n  } = parameters.getAll(name);\n  if (length > 1) {\n    throw new OPE(`\"${name}\" parameter must be provided only once`);\n  }\n  return value;\n}\nexport const skipStateCheck = Symbol();\nexport const expectNoState = Symbol();\nexport function validateAuthResponse(as, client, parameters, expectedState) {\n  assertAs(as);\n  assertClient(client);\n  if (parameters instanceof URL) {\n    parameters = parameters.searchParams;\n  }\n  if (!(parameters instanceof URLSearchParams)) {\n    throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n  }\n  if (getURLSearchParameter(parameters, 'response')) {\n    throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n  }\n  const iss = getURLSearchParameter(parameters, 'iss');\n  const state = getURLSearchParameter(parameters, 'state');\n  if (!iss && as.authorization_response_iss_parameter_supported) {\n    throw new OPE('response parameter \"iss\" (issuer) missing');\n  }\n  if (iss && iss !== as.issuer) {\n    throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n  }\n  switch (expectedState) {\n    case undefined:\n    case expectNoState:\n      if (state !== undefined) {\n        throw new OPE('unexpected \"state\" response parameter encountered');\n      }\n      break;\n    case skipStateCheck:\n      break;\n    default:\n      if (!validateString(expectedState)) {\n        throw new OPE('\"expectedState\" must be a non-empty string');\n      }\n      if (state === undefined) {\n        throw new OPE('response parameter \"state\" missing');\n      }\n      if (state !== expectedState) {\n        throw new OPE('unexpected \"state\" response parameter value');\n      }\n  }\n  const error = getURLSearchParameter(parameters, 'error');\n  if (error) {\n    return {\n      error,\n      error_description: getURLSearchParameter(parameters, 'error_description'),\n      error_uri: getURLSearchParameter(parameters, 'error_uri')\n    };\n  }\n  const id_token = getURLSearchParameter(parameters, 'id_token');\n  const token = getURLSearchParameter(parameters, 'token');\n  if (id_token !== undefined || token !== undefined) {\n    throw new UnsupportedOperationError('implicit and hybrid flows are not supported');\n  }\n  return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n  switch (alg) {\n    case 'PS256':\n    case 'PS384':\n    case 'PS512':\n      return {\n        name: 'RSA-PSS',\n        hash: `SHA-${alg.slice(-3)}`\n      };\n    case 'RS256':\n    case 'RS384':\n    case 'RS512':\n      return {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: `SHA-${alg.slice(-3)}`\n      };\n    case 'ES256':\n    case 'ES384':\n      return {\n        name: 'ECDSA',\n        namedCurve: `P-${alg.slice(-3)}`\n      };\n    case 'ES512':\n      return {\n        name: 'ECDSA',\n        namedCurve: 'P-521'\n      };\n    case 'EdDSA':\n      {\n        switch (crv) {\n          case 'Ed25519':\n          case 'Ed448':\n            return crv;\n          default:\n            throw new UnsupportedOperationError();\n        }\n      }\n    default:\n      throw new UnsupportedOperationError();\n  }\n}\nasync function importJwk(alg, jwk) {\n  const {\n    ext,\n    key_ops,\n    use,\n    ...key\n  } = jwk;\n  return crypto.subtle.importKey('jwk', key, algToSubtle(alg, jwk.crv), true, ['verify']);\n}\nexport async function deviceAuthorizationRequest(as, client, parameters, options) {\n  assertAs(as);\n  assertClient(client);\n  const url = resolveEndpoint(as, 'device_authorization_endpoint', options);\n  const body = new URLSearchParams(parameters);\n  body.set('client_id', client.client_id);\n  const headers = prepareHeaders(options?.headers);\n  headers.set('accept', 'application/json');\n  return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processDeviceAuthorizationResponse(as, client, response) {\n  assertAs(as);\n  assertClient(client);\n  if (!looseInstanceOf(response, Response)) {\n    throw new TypeError('\"response\" must be an instance of Response');\n  }\n  if (response.status !== 200) {\n    let err;\n    if (err = await handleOAuthBodyError(response)) {\n      return err;\n    }\n    throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n  }\n  assertReadableResponse(response);\n  let json;\n  try {\n    json = await response.json();\n  } catch (cause) {\n    throw new OPE('failed to parse \"response\" body as JSON', {\n      cause\n    });\n  }\n  if (!isJsonObject(json)) {\n    throw new OPE('\"response\" body must be a top level object');\n  }\n  if (!validateString(json.device_code)) {\n    throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n  }\n  if (!validateString(json.user_code)) {\n    throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n  }\n  if (!validateString(json.verification_uri)) {\n    throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n  }\n  if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n    throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n  }\n  if (json.verification_uri_complete !== undefined && !validateString(json.verification_uri_complete)) {\n    throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n  }\n  if (json.interval !== undefined && (typeof json.interval !== 'number' || json.interval <= 0)) {\n    throw new OPE('\"response\" body \"interval\" property must be a positive number');\n  }\n  return json;\n}\nexport async function deviceCodeGrantRequest(as, client, deviceCode, options) {\n  assertAs(as);\n  assertClient(client);\n  if (!validateString(deviceCode)) {\n    throw new TypeError('\"deviceCode\" must be a non-empty string');\n  }\n  const parameters = new URLSearchParams(options?.additionalParameters);\n  parameters.set('device_code', deviceCode);\n  return tokenEndpointRequest(as, client, 'urn:ietf:params:oauth:grant-type:device_code', parameters, options);\n}\nexport async function processDeviceCodeResponse(as, client, response) {\n  return processGenericAccessTokenResponse(as, client, response);\n}\nexport async function generateKeyPair(alg, options) {\n  if (!validateString(alg)) {\n    throw new TypeError('\"alg\" must be a non-empty string');\n  }\n  const algorithm = algToSubtle(alg, alg === 'EdDSA' ? options?.crv ?? 'Ed25519' : undefined);\n  if (alg.startsWith('PS') || alg.startsWith('RS')) {\n    Object.assign(algorithm, {\n      modulusLength: options?.modulusLength ?? 2048,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01])\n    });\n  }\n  return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, ['sign', 'verify']);\n}\nfunction normalizeHtu(htu) {\n  const url = new URL(htu);\n  url.search = '';\n  url.hash = '';\n  return url.href;\n}\nasync function validateDPoP(as, request, accessToken, accessTokenClaims, options) {\n  const header = request.headers.get('dpop');\n  if (header === null) {\n    throw new OPE('operation indicated DPoP use but the request has no DPoP HTTP Header');\n  }\n  if (request.headers.get('authorization')?.toLowerCase().startsWith('dpop ') === false) {\n    throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n  }\n  if (typeof accessTokenClaims.cnf?.jkt !== 'string') {\n    throw new OPE('operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim');\n  }\n  const clockSkew = getClockSkew(options);\n  const proof = await validateJwt(header, checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({\n    jwk,\n    alg\n  }) => {\n    if (!jwk) {\n      throw new OPE('DPoP Proof is missing the jwk header parameter');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== 'public') {\n      throw new OPE('DPoP Proof jwk header parameter must contain a public key');\n    }\n    return key;\n  }, clockSkew, getClockTolerance(options)).then(checkJwtType.bind(undefined, 'dpop+jwt')).then(validatePresence.bind(undefined, ['iat', 'jti', 'ath', 'htm', 'htu']));\n  const now = epochTime() + clockSkew;\n  const diff = Math.abs(now - proof.claims.iat);\n  if (diff > 300) {\n    throw new OPE('DPoP Proof iat is not recent enough');\n  }\n  if (proof.claims.htm !== request.method) {\n    throw new OPE('DPoP Proof htm mismatch');\n  }\n  if (typeof proof.claims.htu !== 'string' || normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n    throw new OPE('DPoP Proof htu mismatch');\n  }\n  {\n    const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(accessToken)));\n    if (proof.claims.ath !== expected) {\n      throw new OPE('DPoP Proof ath mismatch');\n    }\n  }\n  {\n    let components;\n    switch (proof.header.jwk.kty) {\n      case 'EC':\n        components = {\n          crv: proof.header.jwk.crv,\n          kty: proof.header.jwk.kty,\n          x: proof.header.jwk.x,\n          y: proof.header.jwk.y\n        };\n        break;\n      case 'OKP':\n        components = {\n          crv: proof.header.jwk.crv,\n          kty: proof.header.jwk.kty,\n          x: proof.header.jwk.x\n        };\n        break;\n      case 'RSA':\n        components = {\n          e: proof.header.jwk.e,\n          kty: proof.header.jwk.kty,\n          n: proof.header.jwk.n\n        };\n        break;\n      default:\n        throw new UnsupportedOperationError();\n    }\n    const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(JSON.stringify(components))));\n    if (accessTokenClaims.cnf.jkt !== expected) {\n      throw new OPE('JWT Access Token confirmation mismatch');\n    }\n  }\n}\nexport async function validateJwtAccessToken(as, request, expectedAudience, options) {\n  assertAs(as);\n  if (!looseInstanceOf(request, Request)) {\n    throw new TypeError('\"request\" must be an instance of Request');\n  }\n  if (!validateString(expectedAudience)) {\n    throw new OPE('\"expectedAudience\" must be a non-empty string');\n  }\n  const authorization = request.headers.get('authorization');\n  if (authorization === null) {\n    throw new OPE('\"request\" is missing an Authorization HTTP Header');\n  }\n  let {\n    0: scheme,\n    1: accessToken,\n    length\n  } = authorization.split(' ');\n  scheme = scheme.toLowerCase();\n  switch (scheme) {\n    case 'dpop':\n    case 'bearer':\n      break;\n    default:\n      throw new UnsupportedOperationError('unsupported Authorization HTTP Header scheme');\n  }\n  if (length !== 2) {\n    throw new OPE('invalid Authorization HTTP Header format');\n  }\n  const requiredClaims = ['iss', 'exp', 'aud', 'sub', 'iat', 'jti', 'client_id'];\n  if (options?.requireDPoP || scheme === 'dpop' || request.headers.has('dpop')) {\n    requiredClaims.push('cnf');\n  }\n  const {\n    claims\n  } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options)).then(checkJwtType.bind(undefined, 'at+jwt')).then(validatePresence.bind(undefined, requiredClaims)).then(validateIssuer.bind(undefined, as.issuer)).then(validateAudience.bind(undefined, expectedAudience));\n  for (const claim of ['client_id', 'jti', 'sub']) {\n    if (typeof claims[claim] !== 'string') {\n      throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n    }\n  }\n  if ('cnf' in claims) {\n    if (!isJsonObject(claims.cnf)) {\n      throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n    }\n    const {\n      0: cnf,\n      length\n    } = Object.keys(claims.cnf);\n    if (length) {\n      if (length !== 1) {\n        throw new UnsupportedOperationError('multiple confirmation claims are not supported');\n      }\n      if (cnf !== 'jkt') {\n        throw new UnsupportedOperationError('unsupported JWT Confirmation method');\n      }\n    }\n  }\n  if (options?.requireDPoP || scheme === 'dpop' || claims.cnf?.jkt !== undefined || request.headers.has('dpop')) {\n    await validateDPoP(as, request, accessToken, claims, options);\n  }\n  return claims;\n}\nexport const experimentalCustomFetch = customFetch;\nexport const experimental_customFetch = customFetch;\nexport const experimentalUseMtlsAlias = useMtlsAlias;\nexport const experimental_useMtlsAlias = useMtlsAlias;\nexport const experimental_validateDetachedSignatureResponse = validateDetachedSignatureResponse;\nexport const experimental_validateJwtAccessToken = validateJwtAccessToken;","/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isOAuth2Error } from \"oauth4webapi\";\nexport function throwIfError(result) {\n  if (isOAuth2Error(result)) {\n    throw new Error(`Failed to get token: ${result.error}`);\n  }\n  return result;\n}","/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { processRevocationResponse, revocationRequest } from \"oauth4webapi\";\nimport invariant from \"tiny-invariant\";\nimport { TypedEventTarget } from \"typescript-event-target\";\nimport { throwIfError } from \"./throwIfError.js\";\n// Node 18 is supposed to have a `CustomEvent` but it is not exposed on `globalThis`\n// which creates a problem for making a single codebase for node and browser. This polyfill works around it\nconst CustomEvent = process.env.TARGET === \"browser\" ? globalThis.CustomEvent : globalThis.CustomEvent ?? class CustomEvent extends Event {\n  #detail;\n  constructor(type, options) {\n    super(type, options);\n    this.#detail = options?.detail ?? null;\n  }\n  get detail() {\n    return this.#detail;\n  }\n};\nfunction localStorageKey(client) {\n  return `@osdk/oauth : refresh : ${client.client_id}`;\n}\nexport function saveLocal(client, x) {\n  // MUST `localStorage?` as nodejs does not have localStorage\n  globalThis.localStorage?.setItem(localStorageKey(client), JSON.stringify(x));\n}\nexport function removeLocal(client) {\n  // MUST `localStorage?` as nodejs does not have localStorage\n  globalThis.localStorage?.removeItem(localStorageKey(client));\n}\nexport function readLocal(client) {\n  return JSON.parse(\n  // MUST `localStorage?` as nodejs does not have localStorage\n  globalThis.localStorage?.getItem(localStorageKey(client)) ?? \"{}\");\n}\nexport function saveSession(client, x) {\n  // MUST `sessionStorage?` as nodejs does not have sessionStorage\n  globalThis.sessionStorage?.setItem(localStorageKey(client), JSON.stringify(x));\n}\nexport function removeSession(client) {\n  // MUST `sessionStorage?` as nodejs does not have sessionStorage\n  globalThis.sessionStorage?.removeItem(localStorageKey(client));\n}\nexport function readSession(client) {\n  return JSON.parse(\n  // MUST `sessionStorage?` as nodejs does not have sessionStorage\n  globalThis.sessionStorage?.getItem(localStorageKey(client)) ?? \"{}\");\n}\nexport function common(client, as, _signIn, oauthHttpOptions, refresh, refreshTokenMarker, scopes) {\n  let token;\n  const eventTarget = new TypedEventTarget();\n  function makeTokenAndSaveRefresh(resp, type) {\n    const {\n      refresh_token,\n      expires_in,\n      access_token\n    } = resp;\n    !(expires_in != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false) : invariant(false) : void 0;\n    saveLocal(client, {\n      refresh_token,\n      refreshTokenMarker,\n      requestedScopes: scopes\n    });\n    token = {\n      refresh_token,\n      expires_in,\n      access_token,\n      expires_at: Date.now() + expires_in * 1000\n    };\n    eventTarget.dispatchTypedEvent(type, new CustomEvent(type, {\n      detail: token\n    }));\n    return token;\n  }\n  let refreshTimeout;\n  function rmTimeout() {\n    if (refreshTimeout) clearTimeout(refreshTimeout);\n  }\n  function restartRefreshTimer(evt) {\n    if (refresh) {\n      rmTimeout();\n      refreshTimeout = setTimeout(refresh, evt.detail.expires_in * 1000 - 60 * 1000);\n    }\n  }\n  async function signOut() {\n    !token ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"not signed in\") : invariant(false) : void 0;\n    const result = await processRevocationResponse(await revocationRequest(as, client, token.access_token, oauthHttpOptions));\n    rmTimeout();\n\n    // Clean up\n    removeLocal(client);\n    token = undefined;\n    throwIfError(result);\n    eventTarget.dispatchTypedEvent(\"signOut\", new Event(\"signOut\"));\n  }\n  let pendingSignIn;\n  async function signIn() {\n    if (pendingSignIn) {\n      return pendingSignIn;\n    }\n    try {\n      pendingSignIn = _signIn();\n      return await pendingSignIn;\n    } finally {\n      pendingSignIn = undefined;\n    }\n  }\n  eventTarget.addEventListener(\"signIn\", restartRefreshTimer);\n  eventTarget.addEventListener(\"refresh\", restartRefreshTimer);\n  function getTokenOrUndefined() {\n    if (!token || Date.now() >= token.expires_at) {\n      return undefined;\n    }\n    return token?.access_token;\n  }\n  const getToken = Object.assign(async function getToken() {\n    if (!token || Date.now() >= token.expires_at) {\n      token = await signIn();\n    }\n    return token?.access_token;\n  }, {\n    signIn,\n    refresh,\n    signOut,\n    rmTimeout,\n    getTokenOrUndefined,\n    addEventListener: eventTarget.addEventListener.bind(eventTarget),\n    removeEventListener: eventTarget.removeEventListener.bind(eventTarget)\n  });\n  return {\n    getToken,\n    makeTokenAndSaveRefresh\n  };\n}\nexport function createAuthorizationServer(ctxPath, url) {\n  const issuer = `${new URL(ctxPath, url.endsWith(\"/\") ? url : url + \"/\")}`;\n  return {\n    token_endpoint: `${issuer}/api/oauth2/token`,\n    authorization_endpoint: `${issuer}/api/oauth2/authorize`,\n    revocation_endpoint: `${issuer}/api/oauth2/revoke_token`,\n    issuer\n  };\n}","/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { clientCredentialsGrantRequest, customFetch, processClientCredentialsResponse } from \"oauth4webapi\";\nimport { common, createAuthorizationServer } from \"./common.js\";\nimport { throwIfError } from \"./throwIfError.js\";\n\n/**\n * @param client_id\n * @param client_secret\n * @param url the base url of your foundry server\n * @param scopes\n * @param fetchFn\n * @param ctxPath\n * @returns which can be used as a token provider\n */\nexport function createConfidentialOauthClient(client_id, client_secret, url, scopes = [\"api:read-data\", \"api:write-data\", \"api:use-ontologies-read\", \"api:use-ontologies-write\"], fetchFn = globalThis.fetch, ctxPath = \"multipass\") {\n  const client = {\n    client_id,\n    client_secret\n  };\n  const authServer = createAuthorizationServer(ctxPath, url);\n  const oauthHttpOptions = {\n    [customFetch]: fetchFn\n  };\n  const joinedScopes = scopes.join(\" \");\n  const {\n    getToken,\n    makeTokenAndSaveRefresh\n  } = common(client, authServer, _signIn, oauthHttpOptions, undefined, undefined, joinedScopes);\n  async function _signIn() {\n    return makeTokenAndSaveRefresh(throwIfError(await processClientCredentialsResponse(authServer, client, await clientCredentialsGrantRequest(authServer, client, new URLSearchParams({\n      scope: joinedScopes\n    }), oauthHttpOptions))), \"signIn\");\n  }\n  return getToken;\n}","// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);\nconst createAbortError = () => {\n  const error = new Error('Delay aborted');\n  error.name = 'AbortError';\n  return error;\n};\nconst clearMethods = new WeakMap();\nexport function createDelay({\n  clearTimeout: defaultClear,\n  setTimeout: defaultSet\n} = {}) {\n  // We cannot use `async` here as we need the promise identity.\n  return (milliseconds, {\n    value,\n    signal\n  } = {}) => {\n    // TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n    if (signal?.aborted) {\n      return Promise.reject(createAbortError());\n    }\n    let timeoutId;\n    let settle;\n    let rejectFunction;\n    const clear = defaultClear ?? clearTimeout;\n    const signalListener = () => {\n      clear(timeoutId);\n      rejectFunction(createAbortError());\n    };\n    const cleanup = () => {\n      if (signal) {\n        signal.removeEventListener('abort', signalListener);\n      }\n    };\n    const delayPromise = new Promise((resolve, reject) => {\n      settle = () => {\n        cleanup();\n        resolve(value);\n      };\n      rejectFunction = reject;\n      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n    });\n    if (signal) {\n      signal.addEventListener('abort', signalListener, {\n        once: true\n      });\n    }\n    clearMethods.set(delayPromise, () => {\n      clear(timeoutId);\n      timeoutId = null;\n      settle();\n    });\n    return delayPromise;\n  };\n}\nconst delay = createDelay();\nexport default delay;\nexport async function rangeDelay(minimum, maximum, options = {}) {\n  return delay(randomInteger(minimum, maximum), options);\n}\nexport function clearDelay(promise) {\n  clearMethods.get(promise)?.();\n}","/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport invariant from \"tiny-invariant\";\nexport function processOptionsAndAssignDefaults(url, redirect_uri, useHistory, loginPage, postLoginPage, scopes, fetchFn, ctxPath) {\n  let options = {};\n  if (typeof useHistory === \"object\") {\n    !(!loginPage && !postLoginPage && !scopes && !fetchFn && !ctxPath) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"If useHistory is an object, other options should not be provided\") : invariant(false) : void 0;\n    options = useHistory;\n  } else {\n    options = {\n      useHistory,\n      loginPage,\n      postLoginPage,\n      scopes,\n      fetchFn,\n      ctxPath\n    };\n  }\n  !url ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"url is required\") : invariant(false) : void 0;\n  !redirect_uri ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"redirectUrl is required\") : invariant(false) : void 0;\n\n  // Assign defaults\n  return {\n    useHistory: options.useHistory ?? true,\n    loginPage: options.loginPage,\n    postLoginPage: options.postLoginPage || window.location.toString(),\n    joinedScopes: [...(options.scopes ?? [\"api:read-data\", \"api:write-data\", \"api:use-ontologies-read\", \"api:use-ontologies-write\"])].sort().join(\" \"),\n    fetchFn: options.fetchFn ?? globalThis.fetch,\n    ctxPath: options.ctxPath ?? \"multipass\",\n    refreshTokenMarker: options.refreshTokenMarker\n  };\n}","/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport delay from \"delay\";\nimport { authorizationCodeGrantRequest, calculatePKCECodeChallenge, customFetch, generateRandomCodeVerifier, generateRandomState, processAuthorizationCodeOAuth2Response, refreshTokenGrantRequest, validateAuthResponse } from \"oauth4webapi\";\nimport { common, createAuthorizationServer, readLocal, readSession, removeLocal, removeSession, saveLocal, saveSession } from \"./common.js\";\nimport { throwIfError } from \"./throwIfError.js\";\nimport { processOptionsAndAssignDefaults } from \"./utils.js\";\n\n/**\n * Creates a PublicOauthClient for authentication.\n *\n * @param {string} clientId - The client_id from the OAuth configuration on the server\n * @param {string} url - The base URL of your Foundry server\n * @param {string} redirectUrl - The URL configured for redirect in the OAuth configuration on the server\n * @param {PublicOauthClientOptions} options - Additional options for the client\n * @returns {PublicOauthClient} A client that can be used as a token provider\n */\n\n/**\n * Creates a PublicOauthClient for authentication.\n *\n * @param {string} clientId - The client_id from the OAuth configuration on the server\n * @param {string} url - The base URL of your Foundry server\n * @param {string} redirectUrl - The URL configured for redirect in the OAuth configuration on the server\n * @param {boolean} useHistory - If true, uses `history.replaceState()`, otherwise uses `window.location.assign()` (defaults to true)\n * @param {string} loginPage - Custom landing page URL prior to logging in\n * @param {string} postLoginPage - URL to return to after completed authentication cycle (defaults to `window.location.toString()`)\n * @param {string[]} scopes - OAuth scopes to request. If not provided, defaults to `[\"api:read-data\", \"api:write-data\", \"api:use-ontologies-read\", \"api:use-ontologies-write\"]`\n * @param {typeof globalThis.fetch} fetchFn - Custom fetch function to use for requests (defaults to `globalThis.fetch`)\n * @param {string} ctxPath - Context path for the authorization server (defaults to \"multipass\")\n * @returns {PublicOauthClient} A client that can be used as a token provider\n */\n\nexport function createPublicOauthClient(client_id, url, redirect_uri, useHistory, loginPage, postLoginPage, scopes, fetchFn, ctxPath) {\n  let refreshTokenMarker;\n  let joinedScopes;\n  ({\n    useHistory,\n    loginPage,\n    postLoginPage,\n    joinedScopes,\n    fetchFn,\n    ctxPath,\n    refreshTokenMarker\n  } = processOptionsAndAssignDefaults(url, redirect_uri, useHistory, loginPage, postLoginPage, scopes, fetchFn, ctxPath));\n  const client = {\n    client_id,\n    token_endpoint_auth_method: \"none\"\n  };\n  const authServer = createAuthorizationServer(ctxPath, url);\n  const oauthHttpOptions = {\n    [customFetch]: fetchFn\n  };\n  const {\n    makeTokenAndSaveRefresh,\n    getToken\n  } = common(client, authServer, _signIn, oauthHttpOptions, maybeRefresh.bind(globalThis, true), refreshTokenMarker, joinedScopes);\n\n  // as an arrow function, `useHistory` is known to be a boolean\n  const go = async x => {\n    if (useHistory) {\n      window.history.replaceState({}, \"\", x);\n      return;\n    } else window.location.assign(x);\n    await delay(1000);\n    throw new Error(\"Unable to redirect\");\n  };\n  async function maybeRefresh(expectRefreshToken) {\n    const {\n      refresh_token,\n      refreshTokenMarker: lastRefreshTokenMarker,\n      requestedScopes: initialRequestedScopes\n    } = readLocal(client);\n    const areScopesEqual = initialRequestedScopes != null && joinedScopes === initialRequestedScopes;\n    if (!refresh_token || lastRefreshTokenMarker !== refreshTokenMarker || !areScopesEqual) {\n      if (expectRefreshToken) throw new Error(\"No refresh token found\");\n      return;\n    }\n    try {\n      // note, we don't use processRefreshTokenResponse because the mp oauth implementation\n      // doesn't do refresh tokens quite right and this lets us skip the id check\n      const result = makeTokenAndSaveRefresh(throwIfError(await processAuthorizationCodeOAuth2Response(authServer, client, await refreshTokenGrantRequest(authServer, client, refresh_token, oauthHttpOptions))), \"refresh\");\n      if (result && window.location.pathname === new URL(redirect_uri).pathname) {\n        const {\n          oldUrl\n        } = readSession(client);\n        // don't block on the redirect\n        void go(oldUrl ?? \"/\");\n      }\n      return result;\n    } catch (e) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(\"Failed to get OAuth2 refresh token. Removing refresh token\", e);\n      }\n      removeLocal(client);\n      if (expectRefreshToken) {\n        throw new Error(\"Could not refresh token\");\n      }\n    }\n  }\n  async function maybeHandleAuthReturn() {\n    const {\n      state,\n      oldUrl,\n      codeVerifier\n    } = readSession(client);\n    if (!codeVerifier) return;\n    try {\n      const ret = makeTokenAndSaveRefresh(throwIfError(await processAuthorizationCodeOAuth2Response(authServer, client, await authorizationCodeGrantRequest(authServer, client, throwIfError(validateAuthResponse(authServer, client, new URL(window.location.href), state)), redirect_uri, codeVerifier, oauthHttpOptions))), \"signIn\");\n      void go(oldUrl);\n      return ret;\n    } catch (e) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(\"Failed to get OAuth2 token using PKCE, removing PKCE and starting a new auth flow\", e);\n      }\n      removeLocal(client);\n      removeSession(client);\n      throw e;\n    }\n  }\n\n  // As an arrow function, `scopes` and `postLoginPage` are known at compile time\n  const initiateLoginRedirect = async () => {\n    if (loginPage && window.location.href !== loginPage && window.location.pathname !== loginPage) {\n      saveLocal(client, {});\n      saveSession(client, {\n        oldUrl: postLoginPage\n      });\n      await go(loginPage);\n      return;\n    }\n    const state = generateRandomState();\n    const codeVerifier = generateRandomCodeVerifier();\n    const oldUrl = readSession(client).oldUrl ?? window.location.toString();\n    saveLocal(client, {});\n    saveSession(client, {\n      codeVerifier,\n      state,\n      oldUrl\n    });\n    window.location.assign(`${authServer.authorization_endpoint}?${new URLSearchParams({\n      client_id,\n      response_type: \"code\",\n      state,\n      redirect_uri,\n      code_challenge: await calculatePKCECodeChallenge(codeVerifier),\n      code_challenge_method: \"S256\",\n      scope: `offline_access ${joinedScopes}`\n    })}`);\n\n    // Give time for redirect to happen\n    await delay(1000);\n    throw new Error(\"Unable to redirect\");\n  };\n\n  /** Will throw if there is no token! */\n  async function _signIn() {\n    // 1. Check if we have a refresh token in local storage\n    return (await maybeRefresh()\n    // 2. If there is no refresh token we are likely trying to perform the callback\n    ) ?? (await maybeHandleAuthReturn())\n    // 3. If we haven't been able to load the token from one of the two above ways, we need to make the initial auth request\n    ?? (await initiateLoginRedirect());\n  }\n  return getToken;\n}"]}