{"version":3,"file":"wireQueryDataTypeToQueryDataTypeDefinition.js","names":["isNullableQueryDataType","wireQueryDataTypeToQueryDataTypeDefinition","input","type","nullable","object","objectTypeApiName","objectSet","subType","multiplicity","set","allowNulls","unionTypes","length","nonNull","find","t","union","reduce","acc","push","struct","Object","fromEntries","fields","map","f","name","fieldType","twoDimensionalAggregation","get2DQueryAggregationProps","threeDimensionalAggregation","get3DQueryAggregationProps","keyType","validMapKeyTypes","includes","Error","toString","valueType","keySubtype","guardInvalidKeyTypes","key"],"sources":["wireQueryDataTypeToQueryDataTypeDefinition.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  QueryDataTypeDefinition,\n  ThreeDimensionalQueryAggregationDefinition,\n  TwoDimensionalQueryAggregationDefinition,\n} from \"@osdk/api\";\nimport type {\n  QueryAggregationKeyType,\n  QueryDataType,\n  ThreeDimensionalAggregation,\n  TwoDimensionalAggregation,\n} from \"@osdk/foundry.ontologies\";\nimport { isNullableQueryDataType } from \"./isNullableQueryDataType.js\";\n\nexport function wireQueryDataTypeToQueryDataTypeDefinition<\n  K extends string,\n>(\n  input: QueryDataType,\n): QueryDataTypeDefinition {\n  switch (input.type) {\n    case \"double\":\n    case \"float\":\n    case \"integer\":\n    case \"long\":\n    case \"attachment\":\n    case \"boolean\":\n    case \"date\":\n    case \"string\":\n    case \"timestamp\":\n      return {\n        type: input.type,\n        nullable: false,\n      };\n\n    case \"object\":\n      return {\n        type: \"object\",\n        object: input.objectTypeApiName as K,\n        nullable: false,\n      };\n\n    case \"objectSet\":\n      return {\n        type: \"objectSet\",\n        objectSet: input.objectTypeApiName as K,\n        nullable: false,\n      };\n\n    case \"array\":\n      return {\n        ...wireQueryDataTypeToQueryDataTypeDefinition(input.subType),\n        multiplicity: true,\n      };\n\n    case \"set\":\n      return {\n        type: \"set\",\n        set: wireQueryDataTypeToQueryDataTypeDefinition(input.subType),\n        nullable: false,\n      };\n\n    case \"union\":\n      const allowNulls = isNullableQueryDataType(input);\n\n      // special case for a union where one half is nullable to skip the union step and just allow nulls directly\n      if (allowNulls && input.unionTypes.length === 2) {\n        const nonNull = input.unionTypes.find(t => t.type != null);\n        if (nonNull) {\n          return {\n            ...wireQueryDataTypeToQueryDataTypeDefinition(nonNull),\n            nullable: true,\n          };\n        }\n      }\n\n      return {\n        type: \"union\",\n        union: input.unionTypes.reduce<QueryDataTypeDefinition[]>((acc, t) => {\n          if (t.type === \"null\") {\n            return acc;\n          }\n          acc.push(wireQueryDataTypeToQueryDataTypeDefinition(t));\n          return acc;\n        }, []),\n        nullable: allowNulls,\n      };\n\n    case \"struct\":\n      return {\n        type: \"struct\",\n        struct: Object.fromEntries(input.fields.map(f => [\n          f.name,\n          wireQueryDataTypeToQueryDataTypeDefinition(f.fieldType),\n        ])),\n        nullable: false,\n      };\n\n    case \"twoDimensionalAggregation\":\n      return {\n        type: \"twoDimensionalAggregation\",\n        twoDimensionalAggregation: get2DQueryAggregationProps(input),\n        nullable: false,\n      };\n\n    case \"threeDimensionalAggregation\":\n      return {\n        type: \"threeDimensionalAggregation\",\n        threeDimensionalAggregation: get3DQueryAggregationProps(input),\n        nullable: false,\n      };\n\n    case \"entrySet\":\n      const keyType = wireQueryDataTypeToQueryDataTypeDefinition(input.keyType);\n\n      if (!validMapKeyTypes.includes(keyType.type)) {\n        throw new Error(\n          \"Map types with a key type of \" + keyType.type + \" are not supported\"\n            + validMapKeyTypes.toString(),\n        );\n      }\n\n      if (keyType.multiplicity === true) {\n        throw new Error(\n          \"Map types cannot have keys as arrays\",\n        );\n      }\n\n      return {\n        type: \"map\",\n        nullable: false,\n        keyType,\n        valueType: wireQueryDataTypeToQueryDataTypeDefinition(input.valueType),\n      };\n\n    case \"null\":\n    case \"unsupported\":\n      throw new Error(\n        `Unable to process query because the server indicated an unsupported QueryDataType.type: ${input.type}. Please check that your query is using supported types.`,\n      );\n\n    default:\n      const _: never = input;\n      throw new Error(`Unsupported QueryDataType.type ${(input as any).type}`);\n  }\n}\n\nfunction get2DQueryAggregationProps(\n  input: TwoDimensionalAggregation,\n): TwoDimensionalQueryAggregationDefinition {\n  if (input.keyType.type === \"range\") {\n    return {\n      keyType: input.keyType.type,\n      keySubtype: input.keyType.subType.type,\n      valueType: input.valueType.type,\n    };\n  } else {\n    if (guardInvalidKeyTypes(input.keyType)) {\n      return {\n        keyType: input.keyType.type,\n        valueType: input.valueType.type,\n      };\n    }\n    throw new Error(\n      `Cannot create 2D aggregation with ${input.keyType.type} as its type`,\n    );\n  }\n}\n\nfunction get3DQueryAggregationProps(\n  input: ThreeDimensionalAggregation,\n): ThreeDimensionalQueryAggregationDefinition {\n  if (input.keyType.type === \"range\") {\n    return {\n      keyType: input.keyType.type,\n      keySubtype: input.keyType.subType.type,\n      valueType: get2DQueryAggregationProps(input.valueType),\n    };\n  } else {\n    if (guardInvalidKeyTypes(input.keyType)) {\n      return {\n        keyType: input.keyType.type,\n        valueType: get2DQueryAggregationProps(input.valueType),\n      };\n    }\n    throw new Error(\n      `Cannot create 3D aggregation with ${input.keyType.type} as its type`,\n    );\n  }\n}\n\n/**\n * Guard against aggregation key types that are allowed by the backend types but are illegal to actually use\n */\nfunction guardInvalidKeyTypes(\n  key: QueryAggregationKeyType,\n): key is QueryAggregationKeyType & ({ type: \"string\" | \"boolean\" }) {\n  return key.type === \"string\" || key.type === \"boolean\";\n}\n\n/**\n * The set of all valid key types for maps. This includes all types that are represented by strings or numbers in the OSDK, and  Ontology Objects.\n */\nconst validMapKeyTypes = [\n  \"string\",\n  \"object\",\n  \"double\",\n  \"float\",\n  \"integer\",\n  \"long\",\n  \"date\",\n  \"timestamp\",\n  \"byte\",\n  \"datetime\",\n  \"decimal\",\n  \"marking\",\n  \"short\",\n  \"objectType\",\n];\n"],"mappings":"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","ignoreList":[]}