{"version":3,"file":"timeseries.js","names":["TimeDurationMapping","TimeseriesDurationMapping"],"sources":["timeseries.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TimeDurationMapping } from \"../mapping/DurationMapping.js\";\n\nexport type TimeSeriesQuery =\n  | {\n    $before: number;\n    $unit: keyof typeof TimeseriesDurationMapping;\n    $after?: never;\n    $startTime?: never;\n    $endTime?: never;\n  }\n  | {\n    $after: number;\n    $unit: keyof typeof TimeseriesDurationMapping;\n    $before?: never;\n    $startTime?: never;\n    $endTime?: never;\n  }\n  | {\n    $startTime: string;\n    $endTime?: string;\n    $before?: never;\n    $after?: never;\n    $unit?: never;\n  }\n  | {\n    $startTime?: string;\n    $endTime: string;\n    $before?: never;\n    $after?: never;\n    $unit?: never;\n  };\n\nexport type TimeseriesDurationUnits =\n  | \"YEARS\"\n  | \"MONTHS\"\n  | \"WEEKS\"\n  | \"DAYS\"\n  | \"HOURS\"\n  | \"MINUTES\"\n  | \"SECONDS\"\n  | \"MILLISECONDS\";\n\nexport const TimeseriesDurationMapping: {\n  sec: \"SECONDS\";\n  seconds: \"SECONDS\";\n  min: \"MINUTES\";\n  minute: \"MINUTES\";\n  minutes: \"MINUTES\";\n  hr: \"HOURS\";\n  hrs: \"HOURS\";\n  hour: \"HOURS\";\n  hours: \"HOURS\";\n  day: \"DAYS\";\n  days: \"DAYS\";\n  wk: \"WEEKS\";\n  week: \"WEEKS\";\n  weeks: \"WEEKS\";\n  mos: \"MONTHS\";\n  month: \"MONTHS\";\n  months: \"MONTHS\";\n  yr: \"YEARS\";\n  year: \"YEARS\";\n  years: \"YEARS\";\n  ms: \"MILLISECONDS\";\n  milliseconds: \"MILLISECONDS\";\n} = {\n  \"ms\": \"MILLISECONDS\",\n  \"milliseconds\": \"MILLISECONDS\",\n  ...TimeDurationMapping,\n} satisfies Record<string, TimeseriesDurationUnits>;\n\nexport interface TimeSeriesPoint<T extends string | number | GeoJSON.Point> {\n  time: string;\n  value: T;\n}\n\nexport interface TimeSeriesProperty<T extends number | string> {\n  /**\n   * Queries the first point of the Timeseries\n   */\n  readonly getFirstPoint: () => Promise<TimeSeriesPoint<T>>;\n  /**\n   * Queries the last point of the Timeseries\n   */\n  readonly getLastPoint: () => Promise<TimeSeriesPoint<T>>;\n  /**\n     * Loads all points, within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const points = await employee.employeeStatus?.getAllPoints({\n        $after: 1,\n        $unit: \"month\",\n      });\n     */\n  readonly getAllPoints: (\n    query?: TimeSeriesQuery,\n  ) => Promise<Array<TimeSeriesPoint<T>>>;\n  /**\n     * Returns an async iterator to load all points\n     * within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const iterator = employee.employeeStatus?.asyncIter({\n        $after: 1,\n        $unit: \"month\",\n      });\n      for await (const point of iterator) {\n          // Handle time series point\n      }\n     */\n  readonly asyncIterPoints: (\n    query?: TimeSeriesQuery,\n  ) => AsyncGenerator<TimeSeriesPoint<T>>;\n}\n\nexport interface GeotimeSeriesProperty<T extends GeoJSON.Point> {\n  /**\n   * Queries the last point of the Geotime series\n   */\n  readonly getLatestValue: () => Promise<TimeSeriesPoint<T> | undefined>;\n  /**\n     * Loads all points, within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const points = await employee.employeeStatus?.getAllPoints({\n        $after: 1,\n        $unit: \"month\",\n      });\n     */\n  readonly getAllValues: (\n    query?: TimeSeriesQuery,\n  ) => Promise<Array<TimeSeriesPoint<T>>>;\n  /**\n     * Returns an async iterator to load all points\n     * within the given time range if that's provided\n     * @param query - a query representing either an absolute or relative range of time\n     * @example\n     *  const iterator = employee.employeeStatus?.asyncIter({\n        $after: 1,\n        $unit: \"month\",\n      });\n      for await (const point of iterator) {\n          // Handle time series point\n      }\n     */\n  readonly asyncIterValues: (\n    query?: TimeSeriesQuery,\n  ) => AsyncGenerator<TimeSeriesPoint<T>>;\n\n  /**\n   * The most recently fetched value for the latest point in the GTSR.\n   * This will not be loaded automatically upon object load, but will be refreshed every time\n   * getLatestValue() is called\n   */\n  readonly lastFetchedValue: TimeSeriesPoint<T> | undefined;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,mBAAmB,QAAQ,+BAA+B;AA0CnE,OAAO,MAAMC,yBAuBZ,GAAG;EACF,IAAI,EAAE,cAAc;EACpB,cAAc,EAAE,cAAc;EAC9B,GAAGD;AACL,CAAmD","ignoreList":[]}