{"version":3,"file":"ObjectSet.js","names":[],"sources":["ObjectSet.ts"],"sourcesContent":["/*\n * Copyright 2023 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { AggregateOpts } from \"../aggregate/AggregateOpts.js\";\nimport type { AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy } from \"../aggregate/AggregateOptsThatErrors.js\";\nimport type { AggregationsResults } from \"../aggregate/AggregationsResults.js\";\nimport type { WhereClause } from \"../aggregate/WhereClause.js\";\nimport type { DerivedPropertyCreator } from \"../derivedProperties/DerivedProperty.js\";\nimport type {\n  AsyncIterArgs,\n  Augments,\n  FetchPageArgs,\n  NullabilityAdherence,\n  ObjectSetArgs,\n  SelectArg,\n} from \"../object/FetchPageArgs.js\";\nimport type { Result } from \"../object/Result.js\";\nimport type {\n  DerivedObjectOrInterfaceDefinition,\n  ObjectOrInterfaceDefinition,\n  PropertyKeys,\n} from \"../ontology/ObjectOrInterface.js\";\nimport type {\n  CompileTimeMetadata,\n  ObjectTypeDefinition,\n} from \"../ontology/ObjectTypeDefinition.js\";\nimport type { SimplePropertyDef } from \"../ontology/SimplePropertyDef.js\";\nimport type { PrimaryKeyType } from \"../OsdkBase.js\";\nimport type {\n  ExtractAllPropertiesOption,\n  ExtractOptions,\n  ExtractRidOption,\n  Osdk,\n} from \"../OsdkObjectFrom.js\";\nimport type { PageResult } from \"../PageResult.js\";\nimport type { LinkedType, LinkNames } from \"../util/LinkUtils.js\";\nimport type { BaseObjectSet } from \"./BaseObjectSet.js\";\nimport type { ObjectSetSubscription } from \"./ObjectSetListener.js\";\n\ntype MergeObjectSet<\n  Q extends ObjectOrInterfaceDefinition,\n  D extends Record<string, SimplePropertyDef> = {},\n> = DerivedObjectOrInterfaceDefinition.WithDerivedProperties<Q, D>;\n\ntype ExtractRdp<\n  D extends\n    | BaseObjectSet<any>\n    | Record<string, SimplePropertyDef>,\n> = [D] extends [never] ? {}\n  : D extends BaseObjectSet<any> ? {}\n  : D extends Record<string, SimplePropertyDef> ? D\n  : {};\n\ntype MaybeSimplifyPropertyKeys<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends PropertyKeys<Q>,\n> = PropertyKeys<Q> extends L ? PropertyKeys<Q> : L;\n\ntype SubSelectKeysHelper<\n  Q extends ObjectOrInterfaceDefinition,\n  L extends string,\n> = [L] extends [never] ? PropertyKeys<Q>\n  : PropertyKeys<Q> extends L ? PropertyKeys<Q>\n  : L & PropertyKeys<Q>;\n\ntype SubSelectKeys<\n  Q extends ObjectOrInterfaceDefinition,\n  X extends SelectArg<Q, PropertyKeys<Q>, any, any> = never,\n> = SubSelectKeysHelper<Q, Extract$Select<X>>;\n\ntype NOOP<T> = T extends (...args: any[]) => any ? T\n  : T extends abstract new(...args: any[]) => any ? T\n  : { [K in keyof T]: T[K] };\n\ntype SubSelectRDPsHelper<\n  X extends ValidFetchPageArgs<any, any> | ValidAsyncIterArgs<any, any>,\n  DEFAULT extends string,\n> = [X] extends [never] ? DEFAULT\n  : (X[\"$select\"] & string[])[number] & DEFAULT;\n\ntype SubSelectRDPs<\n  RDPs extends Record<string, SimplePropertyDef>,\n  X extends ValidFetchPageArgs<any, RDPs> | ValidAsyncIterArgs<any, RDPs>,\n> = [RDPs] extends [never] ? never\n  : NOOP<{ [K in SubSelectRDPsHelper<X, string & keyof RDPs>]: RDPs[K] }>;\n\nexport interface MinimalObjectSet<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> extends\n  BaseObjectSet<Q>,\n  FetchPage<Q, RDPs>,\n  AsyncIter<Q, RDPs>,\n  Where<Q, RDPs>\n{\n}\n\nexport type ExtractOptions2<\n  X extends FetchPageArgs<any, any, any, any, any, any, any>,\n> = [X] extends [never] ? never\n  :\n    | ExtractRidOption<X[\"$includeRid\"] extends true ? true : false>\n    | ExtractAllPropertiesOption<\n      X[\"$includeAllBaseObjectProperties\"] extends true ? true : false\n    >;\n\ntype Extract$Select<X extends FetchPageArgs<any, any>> = NonNullable<\n  X[\"$select\"]\n>[number];\n\ninterface FetchPage<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  readonly fetchPage: FetchPageSignature<Q, RDPs>;\n  readonly fetchPageWithErrors: FetchPageWithErrorsSignature<Q, RDPs>;\n}\n\ntype ValidFetchPageArgs<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef>,\n> =\n  | ObjectSetArgs.FetchPage<\n    Q,\n    PropertyKeys<Q>,\n    false,\n    string & keyof RDPs\n  >\n  | ObjectSetArgs.FetchPage<\n    Q,\n    never,\n    true,\n    string & keyof RDPs\n  >;\n\ntype ValidAsyncIterArgs<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef>,\n> =\n  | ObjectSetArgs.AsyncIter<\n    Q,\n    PropertyKeys<Q>,\n    false,\n    string & keyof RDPs\n  >\n  | AsyncIterArgs<\n    Q,\n    never,\n    any,\n    any,\n    any,\n    true,\n    string & keyof RDPs\n  >;\n\ninterface FetchPageSignature<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  /**\n   * Gets a page of objects of this type, with a result wrapper\n   * @param args - Args to specify next page token and page size, if applicable\n   * @example\n   *  const myObjs = await objectSet.fetchPage({\n      $pageSize: 10,\n      $nextPageToken: \"nextPage\"\n    });\n     const myObjsResult = myObjs.data;\n\n   * @returns a page of objects\n   */\n  <const X extends ValidFetchPageArgs<Q, RDPs> = never>(\n    args?: X,\n  ): Promise<\n    PageResult<\n      Osdk.Instance<\n        Q,\n        ExtractOptions2<X>,\n        SubSelectKeys<Q, X>,\n        SubSelectRDPs<RDPs, X>\n      >\n    >\n  >;\n\n  /**\n   * Gets a page of objects of this type, with a result wrapper\n   * @param args - Args to specify next page token and page size, if applicable\n   * @example\n   *  const myObjs = await objectSet.fetchPage({\n      $pageSize: 10,\n      $nextPageToken: \"nextPage\"\n    });\n     const myObjsResult = myObjs.data;\n\n   * @returns a page of objects\n   */\n  <\n    L extends PropertyKeys<Q>,\n    R extends boolean,\n    const A extends Augments,\n    S extends NullabilityAdherence = NullabilityAdherence.Default,\n    T extends boolean = false,\n  >(\n    args?: FetchPageArgs<Q, L, R, A, S, T>,\n  ): Promise<\n    PageResult<\n      Osdk.Instance<\n        Q,\n        ExtractOptions<R, S, T>,\n        MaybeSimplifyPropertyKeys<Q, L>\n      >\n    >\n  >;\n}\n\ninterface FetchPageWithErrorsSignature<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  /**\n   * Gets a page of objects of this type, with a result wrapper\n   * @param args - Args to specify next page token and page size, if applicable\n   * @example\n   *  const myObjs = await objectSet.fetchPage({\n      $pageSize: 10,\n      $nextPageToken: \"nextPage\"\n    });\n\n     if(isOk(myObjs)){\n     const myObjsResult = myObjs.value.data;\n    }\n   * @returns a page of objects, wrapped in a result wrapper\n   */\n  <X extends ValidFetchPageArgs<Q, RDPs> = never>(\n    args?: X,\n  ): Promise<\n    Result<\n      PageResult<\n        Osdk.Instance<\n          Q,\n          ExtractOptions2<X>,\n          SubSelectKeys<Q, X>,\n          SubSelectRDPs<RDPs, X>\n        >\n      >\n    >\n  >;\n\n  /**\n   * Gets a page of objects of this type, with a result wrapper\n   * @param args - Args to specify next page token and page size, if applicable\n   * @example\n   *  const myObjs = await objectSet.fetchPage({\n      $pageSize: 10,\n      $nextPageToken: \"nextPage\"\n    });\n\n     if(isOk(myObjs)){\n     const myObjsResult = myObjs.value.data;\n    }\n   * @returns a page of objects, wrapped in a result wrapper\n   */\n  <\n    L extends PropertyKeys<Q>,\n    R extends boolean,\n    const A extends Augments,\n    S extends NullabilityAdherence = NullabilityAdherence.Default,\n    T extends boolean = false,\n  >(\n    args?: FetchPageArgs<Q, L, R, A, S, T>,\n  ): Promise<\n    Result<\n      PageResult<\n        Osdk.Instance<\n          Q,\n          ExtractOptions<R, S, T>,\n          MaybeSimplifyPropertyKeys<Q, L>\n        >\n      >\n    >\n  >;\n}\n\n// TODO MOVE THIS\ninterface Where<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  /**\n * Allows you to filter an object set with a given clause\n * @param clause - Takes a filter clause\n * @example\n * await client(Office).where({\n    meetingRooms: { $contains: \"Grand Central\" },\n    meetingRoomCapacities: { $contains: 30 },\n});\n* @returns an objectSet\n  */\n  readonly where: (\n    clause: WhereClause<MergeObjectSet<Q, RDPs>>,\n  ) => this;\n}\n\ninterface AsyncIterSignature<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  /**\n   * Returns an async iterator to load all objects of this type\n   * @example\n   * for await (const obj of myObjectSet.asyncIter()){\n   * // Handle obj\n   * }\n   * @returns an async iterator to load all objects\n   */\n  <X extends ValidAsyncIterArgs<Q, RDPs> = never>(\n    args?: X,\n  ): AsyncIterableIterator<\n    Osdk.Instance<\n      Q,\n      ExtractOptions2<X>,\n      SubSelectKeys<Q, X>,\n      SubSelectRDPs<RDPs, X>\n    >\n  >;\n\n  /**\n   * Returns an async iterator to load all objects of this type\n   * @example\n   * for await (const obj of myObjectSet.asyncIter()){\n   * // Handle obj\n   * }\n   * @returns an async iterator to load all objects\n   */\n  <\n    L extends PropertyKeys<Q>,\n    R extends boolean,\n    const A extends Augments,\n    S extends NullabilityAdherence = NullabilityAdherence.Default,\n    T extends boolean = false,\n  >(\n    args?: AsyncIterArgs<Q, L, R, A, S, T>,\n  ): AsyncIterableIterator<\n    Osdk.Instance<\n      Q,\n      ExtractOptions<R, S, T>,\n      MaybeSimplifyPropertyKeys<Q, L>\n    >\n  >;\n}\n\ninterface AsyncIter<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  asyncIter: AsyncIterSignature<Q, RDPs>;\n}\n\ninterface WithProperties<\n  Q extends ObjectOrInterfaceDefinition = any,\n  RDPs extends Record<string, SimplePropertyDef> = {},\n> {\n  readonly withProperties: <\n    NEW extends Record<string, SimplePropertyDef>,\n  >(\n    clause: { [K in keyof NEW]: DerivedPropertyCreator<Q, NEW[K]> },\n  ) => ObjectSet<\n    Q,\n    {\n      [NN in keyof NEW | keyof RDPs]: NN extends keyof NEW ? NEW[NN]\n        : NN extends keyof RDPs ? RDPs[NN]\n        : never;\n    }\n  >;\n}\n\nexport interface ObjectSet<\n  Q extends ObjectOrInterfaceDefinition = any,\n  // Generated code has what is basically ObjectSet<Q> set in here\n  // but we never used it so I am repurposing it for RDP\n  UNUSED_OR_RDP extends\n    | BaseObjectSet<Q>\n    | Record<string, SimplePropertyDef> = never,\n> extends\n  ObjectSetCleanedTypes<\n    Q,\n    ExtractRdp<UNUSED_OR_RDP>,\n    MergeObjectSet<Q, ExtractRdp<UNUSED_OR_RDP>>\n  >\n{\n}\n\n// Q is the merged type here! Not renaming to keep diff small. Rename in follow up\ninterface Aggregate<\n  Q extends ObjectOrInterfaceDefinition,\n> {\n  /**\n   * Aggregate on a field in an object type\n   * @param req - an aggregation request where you can select fields and choose how to aggregate, e.g., max, min, avg, and also choose\n   * whether or not you order your results. You can also specify a groupBy field to group your aggregations\n   * @example\n   * const testAggregateCountWithGroups = await client(BoundariesUsState)\n    .aggregate({\n      $select: {\n        $count: \"unordered\",\n        \"latitude:max\": \"unordered\",\n        \"latitude:min\": \"unordered\",\n        \"latitude:avg\": \"unordered\",\n      },\n      $groupBy: {\n        usState: \"exact\",\n        longitude: {\n          $fixedWidth: 10,\n        },\n      },\n    });\n\n   * @returns aggregation results, sorted in the groups based on the groupBy clause (if applicable)\n   */\n  readonly aggregate: <AO extends AggregateOpts<Q>>(\n    req: AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy<Q, AO>,\n  ) => Promise<AggregationsResults<Q, AO>>;\n}\n\n// Q is the merged type here! Not renaming to keep diff small. Rename in follow up\ninterface SetArithmetic<\n  Q extends ObjectOrInterfaceDefinition,\n> {\n  /**\n   * Unions object sets together\n   * @param objectSets - objectSets you want to union with\n   * @example\n   * const unionObjectSet = complexFilteredEmployeeObjectSet.union(\n    simpleFilteredEmployeeObjectSet,\n  );\n   * @returns the unioned object set\n   */\n  readonly union: (\n    ...objectSets: ReadonlyArray<CompileTimeMetadata<Q>[\"objectSet\"]>\n  ) => this;\n\n  /**\n   * Computes the intersection of object sets\n   * @param objectSets - objectSets you want to intersect with\n   * @example\n   * const intersectedObjectSet = complexFilteredEmployeeObjectSet.intersect(\n    simpleFilteredEmployeeObjectSet,\n  );\n   * @returns the intersected object set\n   */\n  readonly intersect: (\n    ...objectSets: ReadonlyArray<CompileTimeMetadata<Q>[\"objectSet\"]>\n  ) => this;\n\n  /**\n   * Computes the subtraction of object sets\n   * @param objectSets - objectSets you want to subtract from\n   * @example\n   * const subtractObjectSet = complexFilteredEmployeeObjectSet.subtract(\n    simpleFilteredEmployeeObjectSet,\n  );\n   * @returns the subtract object set\n   */\n  readonly subtract: (\n    ...objectSets: ReadonlyArray<CompileTimeMetadata<Q>[\"objectSet\"]>\n  ) => this;\n}\n\n// Q is the merged type here! Not renaming to keep diff small. Rename in follow up\ninterface PivotTo<\n  Q extends ObjectOrInterfaceDefinition,\n> {\n  /**\n   * Pivots the object set over to all its linked objects of the specified type\n   * @param type - The linked object type you want to pivot to\n   * @returns an object set of the specified linked type\n   */\n  readonly pivotTo: <L extends LinkNames<Q>>(\n    type: L,\n  ) => ObjectSet<LinkedType<Q, L>>;\n}\n\ninterface FetchOneSignature<\n  Q extends ObjectTypeDefinition,\n  RDPs extends Record<string, SimplePropertyDef>,\n> {\n  /**\n   * Fetches one object with the specified primary key, without a result wrapper\n   */\n  <\n    X extends ObjectSetArgs.Select<PropertyKeys<Q>, string & keyof RDPs> =\n      never,\n  >(\n    primaryKey: PrimaryKeyType<Q>,\n    options?: X,\n  ): Promise<\n    Osdk.Instance<\n      Q,\n      ExtractOptions2<X>,\n      SubSelectKeys<Q, X>,\n      SubSelectRDPs<RDPs, X>\n    >\n  >;\n\n  /**\n   * Fetches one object with the specified primary key, without a result wrapper\n   */\n  <\n    const L extends PropertyKeys<Q>,\n    const R extends boolean,\n    const S extends false | \"throw\" = NullabilityAdherence.Default,\n  >(\n    primaryKey: PrimaryKeyType<Q>,\n    options?: SelectArg<Q, L, R, S>,\n  ): Promise<\n    Osdk.Instance<\n      Q,\n      ExtractOptions<R, S>,\n      MaybeSimplifyPropertyKeys<Q, L>\n    >\n  >;\n}\n\ninterface FetchOneWithErrorsSignature<\n  Q extends ObjectTypeDefinition,\n  RDPs extends Record<string, SimplePropertyDef>,\n> {\n  /**\n   * Fetches one object with the specified primary key, with a result wrapper\n   */\n  <X extends ObjectSetArgs.Select<PropertyKeys<Q>, string & keyof RDPs>>(\n    primaryKey: PrimaryKeyType<Q>,\n    options?: X,\n  ): Promise<\n    Result<\n      Osdk.Instance<\n        Q,\n        ExtractOptions2<X>,\n        SubSelectKeys<Q, X>,\n        SubSelectRDPs<RDPs, X>\n      >\n    >\n  >;\n\n  /**\n   * Fetches one object with the specified primary key, with a result wrapper\n   */\n  <\n    const L extends PropertyKeys<Q>,\n    const R extends boolean,\n    const S extends false | \"throw\" = NullabilityAdherence.Default,\n  >(\n    primaryKey: PrimaryKeyType<Q>,\n    options?: SelectArg<Q, L, R, S>,\n  ): Promise<\n    Result<\n      Osdk.Instance<\n        Q,\n        ExtractOptions<R, S>,\n        MaybeSimplifyPropertyKeys<Q, L>\n      >\n    >\n  >;\n}\n\ninterface FetchOne<\n  Q extends ObjectOrInterfaceDefinition,\n  RDPs extends Record<string, SimplePropertyDef>,\n> {\n  fetchOne: Q extends ObjectTypeDefinition ? FetchOneSignature<Q, RDPs> : never;\n  fetchOneWithErrors: Q extends ObjectTypeDefinition\n    ? FetchOneWithErrorsSignature<Q, RDPs>\n    : never;\n}\n\n// Q is the merged type here! Not renaming to keep diff small. Rename in follow up\ninterface Subscribe<\n  Q extends ObjectOrInterfaceDefinition,\n> {\n  /**\n   * Request updates when the objects in an object set are added, updated, or removed.\n   * @param listener - The handlers to be executed during the lifecycle of the subscription.\n   * @param opts - Options to modify what properties are returned on subscription updates.\n   * @returns an object containing a function to unsubscribe.\n   */\n  readonly subscribe: <\n    const P extends PropertyKeys<Q>,\n  >(\n    listener: ObjectSetSubscription.Listener<Q, P>,\n    opts?: ObjectSetSubscription.Options<Q, P>,\n  ) => { unsubscribe: () => void };\n}\n\ninterface ObjectSetCleanedTypes<\n  Q extends ObjectOrInterfaceDefinition,\n  D extends Record<string, SimplePropertyDef>,\n  MERGED extends ObjectOrInterfaceDefinition & Q,\n> extends\n  MinimalObjectSet<Q, D>,\n  WithProperties<Q, D>,\n  Aggregate<MERGED>,\n  SetArithmetic<MERGED>,\n  PivotTo<Q>,\n  FetchOne<Q, D>,\n  Subscribe<MERGED>\n{\n}\n"],"mappings":"","ignoreList":[]}