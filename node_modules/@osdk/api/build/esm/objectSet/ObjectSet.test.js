/*
 * Copyright 2025 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expectTypeOf, it, test, vi } from "vitest";
export function createMockObjectSet() {
  let fauxObject, fauxResults, fauxObjectSet;

  // eslint-disable-next-line prefer-const
  fauxObject = {
    $link: {
      peeps: {
        $objectSetInternals: {
          def: {}
        }
      }
    }
  };
  fauxResults = {
    data: [fauxObject]
  };
  fauxObjectSet = {
    where: vi.fn(() => {
      return fauxObjectSet;
    }),
    withProperties: vi.fn(() => {
      return fauxObjectSet;
    }),
    fetchPage: vi.fn(() => Promise.resolve(fauxResults)),
    fetchOne: vi.fn(() => fauxObject),
    asyncIter: vi.fn(() => {
      return {};
    }),
    aggregate: vi.fn(() => {
      return {};
    }),
    pivotTo: vi.fn(() => {
      return fauxObjectSet;
    })
  };
  return fauxObjectSet;
}
describe("ObjectSet", () => {
  const fauxObjectSet = createMockObjectSet();
  describe("normal", () => {
    test("select none", async () => {
      await fauxObjectSet.fetchPage();
      expectTypeOf().toEqualTypeOf();

      // Do it again but be explicit about the params to be sure
      // we don't break them
      await fauxObjectSet.fetchPage();
    });
    test("select one", async () => {
      await fauxObjectSet.fetchPage({
        "$select": ["fullName"]
      });
      expectTypeOf().toEqualTypeOf();
    });
  });
  describe("includeAllBaseObjectProperties", () => {
    it("has the right types if you pass true", async () => {
      const fetchPageResult = await fauxObjectSet.where({
        class: "idk"
      }).fetchPage({
        $includeAllBaseObjectProperties: true
      });
      expectTypeOf(fetchPageResult).toEqualTypeOf();
      const asyncIterResult = fauxObjectSet.where({
        class: "idk"
      }).asyncIter({
        $includeAllBaseObjectProperties: true
      });
      expectTypeOf(asyncIterResult).toEqualTypeOf();
    });
    it("does not let you pass partial $select and true", async () => {
      await fauxObjectSet.where({
        class: "idk"
      }).fetchPage({
        // @ts-expect-error
        $includeAllBaseObjectProperties: true,
        $select: ["attachment"]
      });
      fauxObjectSet.where({
        class: "idk"
      }).asyncIter({
        // @ts-expect-error
        $includeAllBaseObjectProperties: true,
        $select: ["attachment"]
      });
    });
    it("does let you pass full select options and false", async () => {
      await fauxObjectSet.where({
        class: "idk"
      }).fetchPage({
        $includeAllBaseObjectProperties: true,
        // this select list is intended to represent all properties on `EmployeeApiTest`,
        // so if you get an error here later and you added properties to that object,
        // be sure to add them here too.
        $select: ["attachment", "class", "employeeId", "fullName", "geopoint", "geotimeSeriesReference", "isActive", "mediaReference", "timeseries", "dateOfJoining", "hourlyRate", "yearsOfExperience", "rank", "performanceScore", "mediaReference", "lastUpdated"]
      });
      await fauxObjectSet.where({
        class: "idk"
      }).fetchPage({
        $includeAllBaseObjectProperties: true,
        // this select list is intended to represent all properties on `EmployeeApiTest`,
        // so if you get an error here later and you added properties to that object,
        // be sure to add them here too.
        $select: ["attachment", "class", "employeeId", "fullName", "geopoint", "geotimeSeriesReference", "isActive", "mediaReference", "timeseries", "dateOfJoining", "hourlyRate", "yearsOfExperience", "rank", "performanceScore", "mediaReference", "lastUpdated"]
      });
    });
  });
  test("includeRid", async () => {
    const x = await fauxObjectSet.where({
      class: "idk"
    }).fetchPage({
      $includeRid: true
    });
    expectTypeOf(x).toEqualTypeOf();
  });
  test("pivotTo", async () => {
    await fauxObjectSet.pivotTo("peeps").fetchPage({});
    const subselect = await fauxObjectSet.pivotTo("peeps").fetchPage({
      $select: ["employeeId", "class"]
    });
    expectTypeOf(subselect).toEqualTypeOf();
  });
  describe(".withProperties", () => {
    test("single property", async () => {
      const withA = fauxObjectSet.withProperties({
        "a": base => {
          return base.pivotTo("lead").aggregate("class:exactDistinct");
        }
      });
      expectTypeOf(withA).toEqualTypeOf();
      await withA.fetchPage();
      expectTypeOf().toEqualTypeOf();
      expectTypeOf().toEqualTypeOf();
    });
    it("can be sub-selected", () => {
      fauxObjectSet.withProperties({
        "derivedPropertyName": base => base.pivotTo("lead").selectProperty("employeeId")
      }).fetchOne(3, {
        $select: ["derivedPropertyName"]
      });
    });
    test("multiple properties", async () => {
      const withFamily = fauxObjectSet.withProperties({
        "mom": base => base.pivotTo("lead").aggregate("$count"),
        "dad": base => base.pivotTo("lead").selectProperty("fullName"),
        "sister": base => base.pivotTo("lead").aggregate("class:collectList")
      });
      expectTypeOf(withFamily).toEqualTypeOf();
      await withFamily.fetchPage();
      expectTypeOf().toEqualTypeOf();
      expectTypeOf().toEqualTypeOf();
      expectTypeOf().toEqualTypeOf();
      expectTypeOf().toEqualTypeOf();
    });
    describe("called in succession", () => {
      test("independently", () => {
        const withMom = fauxObjectSet.withProperties({
          "mom": base => base.pivotTo("lead").aggregate("$count")
        });
        const withParents = withMom.withProperties({
          "dad": base => base.pivotTo("lead").selectProperty("fullName")
        });
        expectTypeOf(withParents).toEqualTypeOf();
      });
      test.todo("with calculated properties");
    });
    describe("nullability", () => {
      it("count, exactDistinct, and approximateDistinct aren't nullable", async () => {
        const withFamily = fauxObjectSet.withProperties({
          "mom": base => base.pivotTo("lead").aggregate("$count"),
          "dad": base => base.pivotTo("lead").aggregate("class:exactDistinct"),
          "sis": base => base.pivotTo("lead").aggregate("class:approximateDistinct")
        });
        await withFamily.fetchPage();
        expectTypeOf().toEqualTypeOf();
      });
      it("collectToSet, collectToList, selectProperty, and numeric aggregations are nullable", async () => {
        const withAggregations = fauxObjectSet.withProperties({
          "collectSet": base => base.pivotTo("lead").aggregate("class:collectSet"),
          "select": base => base.pivotTo("lead").selectProperty("fullName"),
          "collectList": base => base.pivotTo("lead").aggregate("class:collectList"),
          "min": base => base.pivotTo("lead").aggregate("employeeId:max"),
          "max": base => base.pivotTo("lead").aggregate("employeeId:min"),
          "sum": base => base.pivotTo("lead").aggregate("employeeId:sum"),
          "avg": base => base.pivotTo("lead").aggregate("employeeId:avg"),
          "approximatePercentile": base => base.pivotTo("lead").aggregate("employeeId:approximatePercentile")
        });
        await withAggregations.fetchPage();
        expectTypeOf().toEqualTypeOf();
      });
    });
    describe("fetch functions return correct Osdk.Instance", () => {
      const withFamily = fauxObjectSet.withProperties({
        "mom": base => base.pivotTo("lead").aggregate("$count"),
        "dad": base => base.pivotTo("lead").selectProperty("fullName"),
        "sister": base => base.pivotTo("lead").aggregate("class:collectList")
      });
      it("works with .where", async () => {
        const where = withFamily.where({
          "mom": 1
        });
        const whereResults = await where.fetchPage();

        // Checks that if you did an `await where.fetchPage()` that you can then
        // pass/assign it to something explicit.
        // Checks that if you did an `await where.fetchPage()` that you can then
        // pass/assign it to something explicit.
        whereResults.data[0];
        whereResults.data[0].$link.peeps.$objectSetInternals.def; // same as above but with expectTypeOf
        expectTypeOf().toEqualTypeOf();
        expectTypeOf().toEqualTypeOf();

        // Checks that when you directly assign, it infers correctly.
        // Sometimes an explicit assignment can affect how typescript infers
        // types.
        await where.fetchPage();
        await withFamily.fetchOne(1);
        await withFamily.fetchOne(1);
      });
      it("works with .async", () => {
        withFamily.asyncIter();
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with no select", async () => {
        await withFamily.fetchPage();
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with selecting all RDPs", async () => {
        await withFamily.fetchPage({
          $select: ["mom", "dad", "sister"]
        });
        expectTypeOf().toEqualTypeOf();
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with selecting some RDPs", async () => {
        await withFamily.fetchPage({
          $select: ["mom"]
        });
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with selecting all non-RDP's", async () => {
        await withFamily.fetchPage({
          $select: ["employeeId", "fullName", "class", "attachment", "geopoint", "timeseries", "mediaReference", "geotimeSeriesReference", "isActive", "yearsOfExperience", "rank", "performanceScore", "hourlyRate", "dateOfJoining", "lastUpdated"]
        });
        expectTypeOf().toEqualTypeOf();
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with selecting some non-RDP's", async () => {
        await withFamily.fetchPage({
          $select: ["class"]
        });
        expectTypeOf().toEqualTypeOf();
      });
      it("Works with selecting a mix", async () => {
        await withFamily.fetchPage({
          $select: ["class", "mom"]
        });
        expectTypeOf().toEqualTypeOf();
      });
    });
    it("allows extracting the type", () => {
      fauxObjectSet.withProperties({
        "mom": base => base.pivotTo("lead").aggregate("$count")
      });
      expectTypeOf().toEqualTypeOf();
      fauxObjectSet.withProperties({
        "mom": base => base.pivotTo("lead").aggregate("$count")
      });
    });
    it("Defining the Type", () => {
      fauxObjectSet.withProperties({
        "mom": base => base.pivotTo("lead").aggregate("$count")
      });
    });
    it("has correct aggregation keys", () => {
      fauxObjectSet.withProperties({
        "integer": base => base.pivotTo("lead").aggregate("$count"),
        "integerNumericAgg": base => base.pivotTo("lead").aggregate("employeeId:sum"),
        "string": base => base.pivotTo("lead").aggregate("class:collectList"),
        "stringDoesNotHaveNumericAgg": base =>
        // @ts-expect-error
        base.pivotTo("lead").aggregate("class:sum"),
        "isActive": base => base.pivotTo("lead").aggregate("isActive:approximateDistinct"),
        "attachment": base => base.pivotTo("lead").aggregate("attachment:collectList"),
        "geopoint": base => base.pivotTo("lead").aggregate("geopoint:collectList"),
        "numericTimeseries": base =>
        // @ts-expect-error
        base.pivotTo("lead").aggregate("timeseries:sum"),
        "numericTimeseriesExactDistinct": base => base.pivotTo("lead").aggregate("timeseries:exactDistinct"),
        "mediaReference": base =>
        // @ts-expect-error
        base.pivotTo("lead").aggregate("mediaReference:avg"),
        "mediaReferenceExactDistinct": base => base.pivotTo("lead").aggregate("mediaReference:exactDistinct"),
        "geotimeSeriesReference": base =>
        // @ts-expect-error
        base.pivotTo("lead").aggregate("geotimeSeriesReference:sum"),
        "geotimeSeriesReferenceExactDistinct": base => base.pivotTo("lead").aggregate("geotimeSeriesReference:exactDistinct"),
        "lastUpdated": base => {
          base.pivotTo("lead").aggregate("lastUpdated:approximateDistinct");
          base.pivotTo("lead").aggregate("lastUpdated:exactDistinct");
          base.pivotTo("lead").aggregate("lastUpdated:max");
          base.pivotTo("lead").aggregate("lastUpdated:min");
          base.pivotTo("lead").aggregate("lastUpdated:collectList");
          return base.pivotTo("lead").aggregate("lastUpdated:collectSet");
        },
        "dateOfJoining": base => {
          base.pivotTo("lead").aggregate("dateOfJoining:approximateDistinct");
          base.pivotTo("lead").aggregate("dateOfJoining:exactDistinct");
          base.pivotTo("lead").aggregate("dateOfJoining:max");
          base.pivotTo("lead").aggregate("dateOfJoining:min");
          base.pivotTo("lead").aggregate("dateOfJoining:collectList");
          return base.pivotTo("lead").aggregate("dateOfJoining:collectSet");
        }
      });
    });
    it("has correct aggregation return types", async () => {
      const aggTestObjectSet = fauxObjectSet.withProperties({
        "maxHasSameType": base => base.pivotTo("lead").aggregate("dateOfJoining:max"),
        "minHasSameType": base => base.pivotTo("lead").aggregate("dateOfJoining:min"),
        "approximateDistinctNumberNoUndefined": base => base.pivotTo("lead").aggregate("employeeId:approximateDistinct"),
        "exactDistinctNumberNoUndefined": base => base.pivotTo("lead").aggregate("employeeId:exactDistinct"),
        "countNumberNoUndefined": base => base.pivotTo("lead").aggregate("$count"),
        "sumNumber": base => base.pivotTo("lead").aggregate("employeeId:sum"),
        "avgNumber": base => base.pivotTo("lead").aggregate("employeeId:avg")
      }).fetchPage();
      const result = (await aggTestObjectSet).data[0];
      expectTypeOf((await aggTestObjectSet).data[0]).toEqualTypeOf();
      expectTypeOf(result.maxHasSameType).toEqualTypeOf();
      expectTypeOf(result.minHasSameType).toEqualTypeOf();
      expectTypeOf(result.approximateDistinctNumberNoUndefined).toEqualTypeOf();
      expectTypeOf(result.exactDistinctNumberNoUndefined).toEqualTypeOf();
      expectTypeOf(result.countNumberNoUndefined).toEqualTypeOf();
      expectTypeOf(result.sumNumber).toEqualTypeOf();
      expectTypeOf(result.avgNumber).toEqualTypeOf();
    });
    it("Merged object type is equivalent to original", () => {
      // should be assignable. testing explicitly due to break in 2.2 release.

      expectTypeOf().branded.toEqualTypeOf();
    });
  });
  describe("aggregate", () => {
    it("has correct aggregation keys", () => {
      void fauxObjectSet.aggregate({
        "$select": {
          "lastUpdated:max": "asc",
          "lastUpdated:min": "desc",
          "lastUpdated:approximateDistinct": "asc",
          "lastUpdated:exactDistinct": "desc",
          "dateOfJoining:max": "desc",
          "dateOfJoining:min": "asc",
          "dateOfJoining:approximateDistinct": "asc",
          "dateOfJoining:exactDistinct": "desc"
        }
      });
    });
  });
  describe("expressions", () => {
    "Test all property types";

    describe("numeric expressions", () => {
      it("provides correct methods off of selected numeric derived property definitions", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const selectedInteger = base.pivotTo("lead").selectProperty("employeeId");
            expectTypeOf(selectedInteger).toEqualTypeOf;
            selectedInteger.add(1);
            selectedInteger.subtract(1);
            selectedInteger.multiply(1);
            selectedInteger.divide(1);
            selectedInteger.abs();
            selectedInteger.negate();
            selectedInteger.max(1);
            selectedInteger.min(1);

            // @ts-expect-error
            selectedInteger.extractPart("1");
            expectTypeOf(base.pivotTo("lead").selectProperty("performanceScore")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("rank")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("yearsOfExperience")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("hourlyRate")).toEqualTypeOf();
            return selectedInteger;
          }
        });
      });
      it("provides correct methods off of selection definitions", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const selectedInteger = base.pivotTo("lead").selectProperty("employeeId");
            expectTypeOf(selectedInteger).toEqualTypeOf;
            selectedInteger.add(1);
            selectedInteger.subtract(1);
            selectedInteger.multiply(1);
            selectedInteger.divide(1);
            selectedInteger.abs();
            selectedInteger.negate();
            selectedInteger.max(1);
            selectedInteger.min(1);

            // @ts-expect-error
            selectedInteger.extractPart("1");
            expectTypeOf(base.pivotTo("lead").selectProperty("performanceScore")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("rank")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("yearsOfExperience")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("lead").selectProperty("hourlyRate")).toEqualTypeOf();
            return selectedInteger;
          }
        });
      });
      it("provides correct methods off of aggregated properties", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const maxAggregation = base.pivotTo("lead").aggregate("employeeId:max");
            expectTypeOf(maxAggregation).toEqualTypeOf;
            maxAggregation.add(1);
            maxAggregation.subtract(1);
            maxAggregation.multiply(1);
            maxAggregation.divide(1);
            maxAggregation.abs();
            maxAggregation.negate();
            maxAggregation.max(1);
            maxAggregation.min(1);
            expectTypeOf(base.pivotTo("peeps").aggregate("employeeId:sum")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("peeps").aggregate("employeeId:avg")).toEqualTypeOf();
            expectTypeOf(base.pivotTo("peeps").aggregate("employeeId:min")).toEqualTypeOf();
            const collectList = base.pivotTo("peeps").aggregate("employeeId:collectList");
            expectTypeOf(collectList).toEqualTypeOf();

            // @ts-expect-error
            collectList.plus(1);
            expectTypeOf(base.pivotTo("peeps").aggregate("employeeId:collectList")).toEqualTypeOf();
            return maxAggregation;
          }
        });
      });
      it("correctly coerces numeric types", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const intAndLong = base.pivotTo("lead").selectProperty("employeeId").add(base.selectProperty("yearsOfExperience")).add(base.selectProperty("employeeId"));
            expectTypeOf(intAndLong).toEqualTypeOf();
            const intAndDouble = base.pivotTo("lead").selectProperty("employeeId").add(base.selectProperty("performanceScore")).add(base.selectProperty("employeeId"));
            expectTypeOf(intAndDouble).toEqualTypeOf();
            const longAndDouble = base.pivotTo("lead").selectProperty("yearsOfExperience").add(base.selectProperty("performanceScore")).add(base.selectProperty("yearsOfExperience"));
            expectTypeOf(longAndDouble).toEqualTypeOf();
            const longAndLong = base.pivotTo("lead").selectProperty("yearsOfExperience").add(base.selectProperty("yearsOfExperience"));
            expectTypeOf(longAndLong).toEqualTypeOf();
            const intAndInt = base.pivotTo("lead").selectProperty("employeeId").add(base.selectProperty("employeeId"));
            expectTypeOf(intAndInt).toEqualTypeOf();
            const intLongDoubleChain = base.pivotTo("lead").selectProperty("employeeId").add(base.selectProperty("yearsOfExperience")).add(base.selectProperty("employeeId")).add(base.selectProperty("performanceScore")).add(base.selectProperty("employeeId"));
            expectTypeOf(intLongDoubleChain).toEqualTypeOf();
            const shortAndIntReturnsInt = base.pivotTo("lead").selectProperty("rank").add(base.selectProperty("employeeId"));
            expectTypeOf(shortAndIntReturnsInt).toEqualTypeOf();
            const shortAndFloatReturnsDouble = base.pivotTo("lead").selectProperty("rank").add(base.selectProperty("hourlyRate"));
            expectTypeOf(shortAndFloatReturnsDouble).toEqualTypeOf();
            return intLongDoubleChain;
          }
        });
      });
      it("allows adding number literals as a double", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const plus = base.pivotTo("lead").selectProperty("employeeId").add(1);
            expectTypeOf(plus).toEqualTypeOf();
            return plus;
          }
        });
      });
      it("allows adding literals via base.constant", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const plus = base.pivotTo("lead").selectProperty("employeeId").add(base.constant.double(1));
            expectTypeOf(plus).toEqualTypeOf();
            const intPlusIntReturnsInt = base.pivotTo("lead").selectProperty("employeeId").add(base.constant.integer(1));
            expectTypeOf(intPlusIntReturnsInt).toEqualTypeOf();
            return plus;
          }
        });
      });
      it("allows correctly typed nested property definitions", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const nested = base.pivotTo("lead").selectProperty("employeeId").add(base.pivotTo("peeps").aggregate("employeeId:sum"));
            expectTypeOf(nested).toEqualTypeOf();
            return nested;
          }
        });
      });
      it("allows correctly types property keys off the linked OT", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const nested = base.pivotTo("lead").selectProperty("employeeId").add(base.selectProperty("performanceScore"));
            expectTypeOf(nested).toEqualTypeOf();
            return nested;
          }
        });
      });

      // it("allows correctly types property keys off the base OT", () => {});
    });
    describe("datetime expressions", () => {
      it("provides correct methods off of datetime selections", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const selectedDatetime = base.pivotTo("lead").selectProperty("dateOfJoining");
            expectTypeOf(selectedDatetime).toEqualTypeOf();
            selectedDatetime.max(base.selectProperty("dateOfJoining"));
            selectedDatetime.min(base.selectProperty("lastUpdated"));
            expectTypeOf(base.pivotTo("lead").selectProperty("lastUpdated")).toEqualTypeOf();
            return selectedDatetime;
          }
        });
      });
      it("correctly coerces datetime types", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const max = base.pivotTo("lead").selectProperty("dateOfJoining").max(base.selectProperty("lastUpdated"));
            expectTypeOf(max).toEqualTypeOf();
            const min = base.pivotTo("lead").selectProperty("dateOfJoining").min(base.selectProperty("dateOfJoining"));
            expectTypeOf(min).toEqualTypeOf();
            return max;
          }
        });
      });
      it("allows adding literals via base.constant", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const dateAndDateReturnDate = base.pivotTo("lead").selectProperty("dateOfJoining").min(base.constant.datetime("2025-01-01T00:00:00Z"));
            expectTypeOf(dateAndDateReturnDate).toEqualTypeOf();
            const dateAndTimeReturnTime = base.pivotTo("lead").selectProperty("dateOfJoining").min(base.constant.timestamp("2025-01-01T00:00:00Z"));
            expectTypeOf(dateAndTimeReturnTime).toEqualTypeOf();
            return dateAndTimeReturnTime;
          }
        });
      });
      it("allows correctly typed nested property definitions", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const nested = base.pivotTo("lead").selectProperty("dateOfJoining").min(base.pivotTo("lead").pivotTo("lead").selectProperty("lastUpdated"));
            expectTypeOf(nested).toEqualTypeOf();
            return nested;
          }
        });
      });
      it("allows correctly typed property keys off the linked OT", () => {
        fauxObjectSet.withProperties({
          "myProp1": base => {
            const nested = base.pivotTo("lead").selectProperty("dateOfJoining").min(base.selectProperty("lastUpdated"));
            expectTypeOf(nested).toEqualTypeOf();
            return nested;
          }
        });
      });

      // it("allows correctly typed property keys off the base OT", () => {});
    });
  });
});
//# sourceMappingURL=ObjectSet.test.js.map