{"version":3,"file":"DerivedProperty.js","names":["DerivedProperty"],"sources":["DerivedProperty.ts"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ValidAggregationKeys } from \"../aggregate/AggregatableKeys.js\";\nimport type { WhereClause } from \"../aggregate/WhereClause.js\";\nimport type {\n  ObjectOrInterfaceDefinition,\n  PropertyKeys,\n} from \"../ontology/ObjectOrInterface.js\";\nimport type { CompileTimeMetadata } from \"../ontology/ObjectTypeDefinition.js\";\nimport type { SimplePropertyDef } from \"../ontology/SimplePropertyDef.js\";\nimport type { LinkedType, LinkNames } from \"../util/LinkUtils.js\";\nimport type {\n  DatetimeExpressions,\n  DefinitionForType,\n  NumericExpressions,\n} from \"./Expressions.js\";\nimport type {\n  CollectWithPropAggregations,\n  MinMaxWithPropAggregateOption,\n} from \"./WithPropertiesAggregationOptions.js\";\n\ndeclare const DerivedPropertyDefinitionBrand: unique symbol;\n\nexport namespace DerivedProperty {\n  export interface Definition<\n    T extends SimplePropertyDef,\n    Q extends ObjectOrInterfaceDefinition,\n  > {\n    readonly [DerivedPropertyDefinitionBrand]: true;\n  }\n\n  export interface NumericPropertyDefinition<\n    T extends SimplePropertyDef,\n    Q extends ObjectOrInterfaceDefinition,\n  > extends Definition<T, Q>, NumericExpressions<Q, T> {}\n\n  export interface DatetimePropertyDefinition<\n    T extends SimplePropertyDef,\n    Q extends ObjectOrInterfaceDefinition,\n  > extends Definition<T, Q>, DatetimeExpressions<Q, T> {}\n\n  export type Clause<\n    Q extends ObjectOrInterfaceDefinition,\n  > = {\n    [key: string]: DerivedPropertyCreator<Q, SimplePropertyDef>;\n  };\n\n  interface BaseBuilder<\n    Q extends ObjectOrInterfaceDefinition,\n    CONSTRAINED extends boolean,\n  > extends Filterable<Q, CONSTRAINED>, Pivotable<Q, CONSTRAINED> {\n  }\n\n  export interface Builder<\n    Q extends ObjectOrInterfaceDefinition,\n    CONSTRAINED extends boolean,\n  > extends BaseBuilder<Q, CONSTRAINED>, Selectable<Q>, Constant<Q> {\n  }\n\n  export interface AggregateBuilder<\n    Q extends ObjectOrInterfaceDefinition,\n    CONSTRAINED extends boolean,\n  > extends BaseBuilder<Q, CONSTRAINED>, Aggregatable<Q> {\n  }\n\n  export interface SelectPropertyBuilder<\n    Q extends ObjectOrInterfaceDefinition,\n    CONSTRAINED extends boolean,\n  > extends AggregateBuilder<Q, CONSTRAINED>, Selectable<Q> {\n  }\n\n  export type ValidParts = \"DAYS\" | \"MONTHS\" | \"QUARTERS\" | \"YEARS\";\n}\n\nexport type DerivedPropertyCreator<\n  Q extends ObjectOrInterfaceDefinition,\n  T extends SimplePropertyDef,\n> = (\n  baseObjectSet: DerivedProperty.Builder<Q, false>,\n) =>\n  | DerivedProperty.Definition<T, Q>\n  | DerivedProperty.NumericPropertyDefinition<T, Q>\n  | DerivedProperty.DatetimePropertyDefinition<T, Q>;\n\ntype BuilderTypeFromConstraint<\n  Q extends ObjectOrInterfaceDefinition,\n  CONSTRAINED extends boolean,\n> = CONSTRAINED extends true ? DerivedProperty.AggregateBuilder<Q, true>\n  : DerivedProperty.SelectPropertyBuilder<Q, false>;\n\ntype Filterable<\n  Q extends ObjectOrInterfaceDefinition,\n  CONSTRAINED extends boolean,\n> = {\n  readonly where: (\n    clause: WhereClause<Q>,\n  ) => BuilderTypeFromConstraint<Q, CONSTRAINED>;\n};\n\ntype Pivotable<\n  Q extends ObjectOrInterfaceDefinition,\n  CONSTRAINED extends boolean,\n> = {\n  readonly pivotTo: <L extends LinkNames<Q>>(\n    type: L,\n  ) => CONSTRAINED extends true\n    ? DerivedProperty.AggregateBuilder<LinkedType<Q, L>, true>\n    : NonNullable<CompileTimeMetadata<Q>[\"links\"][L][\"multiplicity\"]> extends\n      true ? DerivedProperty.AggregateBuilder<LinkedType<Q, L>, true>\n    : DerivedProperty.SelectPropertyBuilder<LinkedType<Q, L>, false>;\n};\n\ntype Constant<Q extends ObjectOrInterfaceDefinition> = {\n  readonly constant: {\n    readonly double: (\n      value: number,\n    ) => DerivedProperty.NumericPropertyDefinition<\n      SimplePropertyDef.Make<\"double\", \"non-nullable\", \"single\">,\n      Q\n    >;\n\n    readonly integer: (\n      value: number,\n    ) => DerivedProperty.NumericPropertyDefinition<\n      SimplePropertyDef.Make<\"integer\", \"non-nullable\", \"single\">,\n      Q\n    >;\n    readonly long: (\n      value: string,\n    ) => DerivedProperty.NumericPropertyDefinition<\n      SimplePropertyDef.Make<\"long\", \"non-nullable\", \"single\">,\n      Q\n    >;\n\n    readonly datetime: (\n      value: string,\n    ) => DerivedProperty.DatetimePropertyDefinition<\n      SimplePropertyDef.Make<\"datetime\", \"non-nullable\", \"single\">,\n      Q\n    >;\n    readonly timestamp: (\n      value: string,\n    ) => DerivedProperty.DatetimePropertyDefinition<\n      SimplePropertyDef.Make<\"timestamp\", \"non-nullable\", \"single\">,\n      Q\n    >;\n  };\n};\n\ntype Aggregatable<\n  Q extends ObjectOrInterfaceDefinition,\n> = {\n  readonly aggregate: <\n    V extends ValidAggregationKeys<\n      Q,\n      \"withPropertiesAggregate\"\n    >,\n  >(\n    aggregationSpecifier: V,\n    opts?: V extends `${any}:${infer P}`\n      ? P extends CollectWithPropAggregations ? { limit: number }\n      : P extends \"approximatePercentile\" ? { percentile: number }\n      : never\n      : never,\n  ) => DefinitionForType<\n    Q,\n    V extends `${infer N}:${infer P}`\n      ? P extends CollectWithPropAggregations ? SimplePropertyDef.Make<\n          CompileTimeMetadata<Q>[\"properties\"][N][\"type\"],\n          \"nullable\",\n          \"array\"\n        >\n      : P extends MinMaxWithPropAggregateOption ? SimplePropertyDef.Make<\n          CompileTimeMetadata<Q>[\"properties\"][N][\"type\"],\n          \"nullable\",\n          \"single\"\n        >\n      : P extends \"approximateDistinct\" | \"exactDistinct\"\n        ? SimplePropertyDef.Make<\n          \"integer\",\n          \"non-nullable\",\n          \"single\"\n        >\n      : SimplePropertyDef.Make<\n        \"double\",\n        \"nullable\",\n        \"single\"\n      >\n      : V extends \"$count\" ? SimplePropertyDef.Make<\n          \"integer\",\n          \"non-nullable\",\n          \"single\"\n        >\n      : never\n  >;\n};\n\ntype Selectable<Q extends ObjectOrInterfaceDefinition> = {\n  readonly selectProperty: <R extends PropertyKeys<Q>>(\n    propertyName: R,\n  ) => DefinitionForType<\n    Q,\n    SimplePropertyDef.Make<\n      CompileTimeMetadata<Q>[\"properties\"][R][\"type\"],\n      CompileTimeMetadata<Q>[\"properties\"][R][\"nullable\"] extends true\n        ? \"nullable\"\n        : \"non-nullable\",\n      CompileTimeMetadata<Q>[\"properties\"][R][\"multiplicity\"] extends true\n        ? \"array\"\n        : \"single\"\n    >\n  >;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA,WAqCiBA,eAAe","ignoreList":[]}