import { A as AttachmentUpload, M as MediaReference, a as MediaUpload, b as Attachment, O as ObjectTypeDefinition, c as ObjectIdentifiers, d as OsdkObjectPrimaryKeyType, e as ObjectSet, I as InterfaceDefinition, C as CompileTimeMetadata, f as OsdkMetadata, R as ReleaseStatus, P as PropertyValueWireToClient, g as PrimaryKeyTypes, h as OsdkBase } from './ObjectSet-C67LQ5JX.cjs';
export { i as AggregateOpts, j as AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy, m as AggregationClause, k as AggregationResultsWithGroups, l as AggregationResultsWithoutGroups, n as AggregationsResults, v as AllGroupByValues, y as AsyncIterArgs, z as Augment, B as Augments, X as BaseObjectSet, a4 as BaseWirePropertyTypes, a7 as ConvertProps, t as DerivedProperty, D as DistanceUnitMapping, u as DurationMapping, F as FetchPageArgs, J as FetchPageResult, G as GeoFilterOptions, o as GeoFilter_Intersects, p as GeoFilter_Within, ab as GeotimeSeriesProperty, w as GroupByClause, x as GroupByRange, Z as InterfaceMetadata, ag as LinkNames, af as LinkedType, L as Media, Q as MediaMetadata, N as NullabilityAdherence, a1 as ObjectMetadata, _ as ObjectOrInterfaceDefinition, Y as ObjectSetSubscription, a0 as ObjectSpecifier, a8 as Osdk, s as OsdkObjectLinksObject, r as OsdkObjectPropertyType, a9 as PageResult, q as PossibleWhereClauseFilters, a6 as PrimaryKeyType, a2 as PropertyDef, $ as PropertyKeys, U as Result, E as SelectArg, H as SelectArgToKeys, S as SingleLinkAccessor, K as SingleOsdkResult, ac as TimeSeriesPoint, ad as TimeSeriesProperty, ae as TimeSeriesQuery, aa as TimeseriesDurationMapping, V as ValidAggregationKeys, a3 as VersionBound, W as WhereClause, a5 as WirePropertyTypes, T as isOk } from './ObjectSet-C67LQ5JX.cjs';
import 'type-fest';
import 'geojson';

/**
 * Map from the DataValue type to the typescript type that we return
 */
interface DataValueWireToClient {
    attachment: Attachment;
    boolean: boolean;
    byte: number;
    datetime: string;
    date: string;
    decimal: string;
    float: number;
    double: number;
    integer: number;
    long: string;
    marking: string;
    null: null;
    short: number;
    string: string;
    timestamp: string;
    mediaReference: MediaReference;
    twoDimensionalAggregation: {
        key: AllowedBucketKeyTypes$1;
        value: AllowedBucketTypes$1;
    }[];
    threeDimensionalAggregation: {
        key: AllowedBucketKeyTypes$1;
        groups: {
            key: AllowedBucketKeyTypes$1;
            value: AllowedBucketTypes$1;
        }[];
    }[];
    struct: Record<string, any>;
    set: Set<any>;
    objectType: string;
    geohash: GeoJSON.Point;
    geoshape: GeoJSON.GeoJSON;
}
/**
 * Map from the DataValue type to the typescript type that we accept
 */
interface DataValueClientToWire {
    attachment: string | AttachmentUpload | Blob & {
        readonly name: string;
    };
    boolean: boolean;
    byte: number;
    datetime: string;
    date: string;
    decimal: string | number;
    float: number;
    double: number;
    integer: number;
    long: string | number;
    marking: string;
    null: null;
    short: number;
    string: string;
    timestamp: string;
    set: Set<any>;
    mediaReference: MediaReference | MediaUpload;
    twoDimensionalAggregation: {
        key: AllowedBucketKeyTypes$1;
        value: AllowedBucketTypes$1;
    }[];
    threeDimensionalAggregation: {
        key: AllowedBucketKeyTypes$1;
        groups: {
            key: AllowedBucketKeyTypes$1;
            value: AllowedBucketTypes$1;
        }[];
    }[];
    struct: Record<string, any>;
    objectType: string;
    geohash: GeoJSON.Point;
    geoshape: GeoJSON.GeoJSON;
}
type AllowedBucketTypes$1 = string | number | boolean;
type AllowedBucketKeyTypes$1 = AllowedBucketTypes$1 | {
    startValue: AllowedBucketTypes$1;
    endValue: AllowedBucketTypes$1;
};

type ActionResults = (ObjectEdits | LargeScaleObjectEdits) & {
    editedObjectTypes: Array<String>;
};
interface ObjectEdits {
    type: "edits";
    addedObjects: Array<ObjectReference>;
    modifiedObjects: Array<ObjectReference>;
    deletedObjects?: Array<ObjectReference>;
    addedLinks: Array<LinkReference>;
    deletedLinks?: Array<LinkReference>;
    deletedObjectsCount: number;
    deletedLinksCount: number;
}
interface LargeScaleObjectEdits {
    type: "largeScaleEdits";
    addedObjects?: never;
    modifiedObjects?: never;
    deletedObjects?: never;
    addedLinks?: never;
    deletedLinks?: never;
    deletedObjectsCount?: never;
    deletedLinksCount?: never;
}
type LinkReference = {
    linkTypeApiNameAtoB: string;
    linkTypeApiNameBtoA: string;
    aSideObject: ObjectReference;
    bSideObject: ObjectReference;
};
interface ObjectReference {
    primaryKey: string | number;
    objectType: string;
}
interface ValidateActionResponseV2 {
    result: "VALID" | "INVALID";
    submissionCriteria: Array<{
        configuredFailureMessage?: string;
        result: "VALID" | "INVALID";
    }>;
    parameters: Record<string, {
        result: "VALID" | "INVALID";
        evaluatedConstraints: Array<ParameterEvaluatedConstraint>;
        required: boolean;
    }>;
}
type ParameterEvaluatedConstraint = {
    type: "arraySize";
    lt?: any;
    lte?: any;
    gt?: any;
    gte?: any;
} | {
    type: "groupMember";
} | {
    type: "objectPropertyValue";
} | {
    type: "objectQueryResult";
} | {
    type: "oneOf";
    options: Array<{
        displayName?: string;
        value?: any;
    }>;
    otherValuesAllowed: boolean;
} | {
    type: "range";
    lt?: any;
    lte?: any;
    gt?: any;
    gte?: any;
} | {
    type: "stringLength";
    lt?: any;
    lte?: any;
    gt?: any;
    gte?: any;
} | {
    type: "stringRegexMatch";
    regex: string;
    configuredFailureMessage?: string;
} | {
    type: "unevaluable";
};

type ApplyActionOptions = {
    $returnEdits?: true;
    $validateOnly?: false;
} | {
    $validateOnly?: true;
    $returnEdits?: false;
};
type ApplyBatchActionOptions = {
    $returnEdits?: boolean;
};
/**
 * Helper types for converting action definition parameter types to typescript types
 */
declare namespace ActionParam {
    /**
     * Helper type to convert action definition parameter primitives to typescript types
     */
    type PrimitiveType<T extends keyof DataValueClientToWire> = DataValueClientToWire[T];
    /**
     * Helper type to convert action definition parameter object types to typescript types
     */
    type ObjectType<T extends ObjectTypeDefinition> = ObjectIdentifiers<T> | OsdkObjectPrimaryKeyType<T>;
    /**
     * Helper type to convert action definition parameter object sets to typescript types
     */
    type ObjectSetType<T extends ObjectTypeDefinition> = ObjectSet<T>;
    /**
     * Helper type to convert action definition parameter interface types to typescript types
     */
    type InterfaceType<T extends InterfaceDefinition> = {
        $objectType: CompileTimeMetadata<T> extends {
            implementedBy: infer U;
        } ? (U extends ReadonlyArray<never> ? string : U extends ReadonlyArray<string> ? U[number] : string) : string;
        $primaryKey: string | number;
    };
    type StructType<T extends Record<string, keyof DataValueClientToWire>> = {
        [K in keyof T]: DataValueClientToWire[T[K]];
    };
}
type ActionEditResponse = ActionResults;
type ActionValidationResponse = ValidateActionResponseV2;

type ActionReturnTypeForOptions<Op extends ApplyActionOptions | ApplyBatchActionOptions> = Op extends {
    $validateOnly: true;
} ? ActionValidationResponse : Op extends {
    $returnEdits: true;
} ? ActionEditResponse : undefined;

interface ActionMetadata {
    type: "action";
    apiName: string;
    description?: string;
    displayName?: string;
    parameters: Record<any, ActionMetadata.Parameter<any>>;
    modifiedEntities?: Partial<Record<any, {
        created: boolean;
        modified: boolean;
    }>>;
    status: ReleaseStatus | undefined;
    rid: string;
}
declare namespace ActionMetadata {
    interface Parameter<T_Target extends ObjectTypeDefinition = never> {
        type: DataType.BaseActionParameterTypes | DataType.Object<any> | DataType.ObjectSet<any> | DataType.Interface<any> | DataType.Struct<any>;
        description?: string;
        multiplicity?: boolean;
        nullable?: boolean;
    }
    namespace DataType {
        type BaseActionParameterTypes = "boolean" | "string" | "integer" | "long" | "double" | "datetime" | "timestamp" | "attachment" | "marking" | "mediaReference" | "objectType" | "geoshape" | "geohash";
        interface Object<T_Target extends ObjectTypeDefinition = never> {
            __OsdkTargetType?: T_Target;
            type: "object";
            object: T_Target["apiName"];
        }
        interface Interface<T_Target extends InterfaceDefinition = never> {
            __OsdkTargetType?: T_Target;
            type: "interface";
            interface: T_Target["apiName"];
        }
        interface ObjectSet<T_Target extends ObjectTypeDefinition = never> {
            __OsdkTargetType?: T_Target;
            type: "objectSet";
            objectSet: T_Target["apiName"];
        }
        interface Struct<T extends Record<string, DataType.BaseActionParameterTypes>> {
            type: "struct";
            struct: T;
        }
    }
}
interface ActionCompileTimeMetadata<T> {
    signatures: T;
}
interface ActionDefinition<T_signatures = never> {
    type: "action";
    apiName: string;
    osdkMetadata?: OsdkMetadata;
    __DefinitionMetadata?: ActionCompileTimeMetadata<T_signatures> & ActionMetadata;
}

interface OntologyMetadata<_NEVER_USED_KEPT_FOR_BACKCOMPAT = any> {
    expectsClientVersion?: _NEVER_USED_KEPT_FOR_BACKCOMPAT;
    ontologyRid: string;
    ontologyApiName: string;
    userAgent: string;
}

interface QueryMetadata {
    type: "query";
    apiName: string;
    description?: string;
    displayName?: string;
    version: string;
    parameters: Record<string, QueryParameterDefinition<any>>;
    output: QueryDataTypeDefinition;
    rid: string;
}
interface QueryCompileTimeMetadata<T> {
    signature: T;
}
interface QueryDefinition<T = any> {
    type: "query";
    apiName: string;
    version?: string;
    isFixedVersion?: boolean;
    osdkMetadata?: OsdkMetadata;
    __DefinitionMetadata?: QueryCompileTimeMetadata<T> & QueryMetadata;
}
type QueryParameterDefinition<T_Target extends ObjectTypeDefinition = any> = {
    description?: string;
} & QueryDataTypeDefinition<T_Target>;
type QueryDataTypeDefinition<T_Target extends ObjectTypeDefinition = any> = PrimitiveDataType | ObjectQueryDataType<T_Target> | ObjectSetQueryDataType<T_Target> | SetQueryDataType | UnionQueryDataType | StructQueryDataType | TwoDimensionalAggregationDataType | ThreeDimensionalAggregationDataType | MapDataType;
type BaseQueryDataTypeDefinition<T extends string> = {
    multiplicity?: boolean;
    nullable?: boolean;
    type: T;
};
type WireQueryDataTypes = "double" | "float" | "integer" | "long" | "boolean" | "string" | "date" | "timestamp" | "attachment";
type PrimitiveDataType<Q extends WireQueryDataTypes = WireQueryDataTypes> = BaseQueryDataTypeDefinition<Q>;
interface ObjectQueryDataType<T_Target extends ObjectTypeDefinition = never> extends BaseQueryDataTypeDefinition<"object"> {
    object: string;
    __OsdkTargetType?: T_Target;
}
interface ObjectSetQueryDataType<T_Target extends ObjectTypeDefinition = never> extends BaseQueryDataTypeDefinition<"objectSet"> {
    objectSet: string;
    __OsdkTargetType?: T_Target;
}
interface SetQueryDataType extends BaseQueryDataTypeDefinition<"set"> {
    set: QueryDataTypeDefinition;
}
interface UnionQueryDataType extends BaseQueryDataTypeDefinition<"union"> {
    union: ReadonlyArray<QueryDataTypeDefinition>;
}
interface StructQueryDataType extends BaseQueryDataTypeDefinition<"struct"> {
    struct: Record<string, QueryDataTypeDefinition>;
}
interface TwoDimensionalAggregationDataType extends BaseQueryDataTypeDefinition<"twoDimensionalAggregation"> {
    twoDimensionalAggregation: TwoDimensionalQueryAggregationDefinition;
}
interface ThreeDimensionalAggregationDataType extends BaseQueryDataTypeDefinition<"threeDimensionalAggregation"> {
    threeDimensionalAggregation: ThreeDimensionalQueryAggregationDefinition;
}
interface MapDataType extends BaseQueryDataTypeDefinition<"map"> {
    keyType: QueryDataTypeDefinition;
    valueType: QueryDataTypeDefinition;
}
type AggregationKeyDataType<V = any> = SimpleAggregationKeyDataType<V> | RangeAggregationKeyDataType<V>;
interface SimpleAggregationKeyDataType<V = any> {
    keyType: Exclude<AggregationKeyTypes, "range">;
    valueType: V;
}
interface RangeAggregationKeyDataType<V = any> {
    keyType: "range";
    keySubtype: AggregationRangeKeyTypes;
    valueType: V;
}
type TwoDimensionalQueryAggregationDefinition = AggregationKeyDataType<AggregationValueTypes>;
type ThreeDimensionalQueryAggregationDefinition = AggregationKeyDataType<TwoDimensionalQueryAggregationDefinition>;
type AggregationKeyTypes = "boolean" | "string" | "date" | "double" | "integer" | "timestamp" | "range";
type AggregationRangeKeyTypes = "date" | "double" | "integer" | "timestamp";
type AggregationValueTypes = "date" | "double" | "timestamp";

/**
 * @deprecated Use OsdkBase
 */
type OsdkObject<N extends string> = {
    readonly $apiName: N;
    readonly $objectType: string;
    readonly $primaryKey: PropertyValueWireToClient[PrimaryKeyTypes];
};

type Range<T extends AllowedBucketTypes> = {
    startValue?: T;
    endValue: T;
} | {
    startValue: T;
    endValue?: T;
};
type AllowedBucketTypes = string | number | boolean;
type AllowedBucketKeyTypes = AllowedBucketTypes | Range<AllowedBucketTypes>;
type TwoDimensionalAggregation<T extends AllowedBucketKeyTypes, U extends AllowedBucketTypes> = {
    key: T;
    value: U;
}[];
type ThreeDimensionalAggregation<T extends AllowedBucketKeyTypes, U extends AllowedBucketKeyTypes, V extends AllowedBucketTypes> = {
    key: T;
    groups: {
        key: U;
        value: V;
    }[];
}[];
type AggKeyWireToClient<T extends AggregationKeyTypes, S extends AggregationRangeKeyTypes = never> = T extends keyof DataValueWireToClient ? DataValueWireToClient[T] : T extends "range" ? S extends keyof DataValueWireToClient ? Range<DataValueWireToClient[S]> : never : never;
type AggKeyClientToWire<T extends AggregationKeyTypes, S extends AggregationRangeKeyTypes = never> = T extends keyof DataValueClientToWire ? DataValueClientToWire[T] : T extends "range" ? S extends keyof DataValueClientToWire ? Range<DataValueClientToWire[S]> : never : never;
type AggValueWireToClient<T extends AggregationValueTypes> = T extends keyof DataValueWireToClient ? DataValueWireToClient[T] : never;
type AggValueClientToWire<T extends AggregationValueTypes> = T extends keyof DataValueClientToWire ? DataValueClientToWire[T] : never;

/**
 * Helper types for converting query definition parameter types to typescript types
 */
declare namespace QueryParam {
    /**
     * Helper type to convert action definition parameter primitives to typescript types
     */
    type PrimitiveType<T extends keyof DataValueClientToWire> = DataValueClientToWire[T];
    /**
     * Helper type to convert action definition parameter object types to typescript types
     */
    type ObjectType<T extends ObjectTypeDefinition> = ObjectIdentifiers<T> | OsdkObjectPrimaryKeyType<T>;
    /**
     * Helper type to convert action definition parameter object sets to typescript types
     */
    type ObjectSetType<T extends ObjectTypeDefinition> = ObjectSet<T>;
    type RangeKey<T extends AggregationRangeKeyTypes> = AggKeyClientToWire<"range", T>;
    type TwoDimensionalAggregationType<T extends AggregationKeyTypes | RangeKey<any>, V extends AggregationValueTypes> = TwoDimensionalAggregation<T extends AggregationKeyTypes ? AggKeyClientToWire<T> : T, AggValueClientToWire<V>>;
    type ThreeDimensionalAggregationType<OUT extends AggregationKeyTypes | RangeKey<any>, IN extends AggregationKeyTypes | RangeKey<any>, V extends AggregationValueTypes> = ThreeDimensionalAggregation<OUT extends AggregationKeyTypes ? AggKeyClientToWire<OUT> : OUT, IN extends AggregationKeyTypes ? AggKeyClientToWire<IN> : IN, AggValueClientToWire<V>>;
}
/**
 * Helper types for converting query result types to typescript types
 */
declare namespace QueryResult {
    /**
     * Helper type to convert action definition parameter primitives to typescript types
     */
    type PrimitiveType<T extends keyof DataValueClientToWire> = DataValueWireToClient[T];
    /**
     * Helper type to convert action definition parameter object types to typescript types
     */
    type ObjectType<T extends ObjectTypeDefinition> = OsdkBase<T>;
    /**
     * Helper type to convert action definition parameter object sets to typescript types
     */
    type ObjectSetType<T extends ObjectTypeDefinition> = ObjectSet<T>;
    type RangeKey<T extends AggregationRangeKeyTypes> = AggKeyWireToClient<"range", T>;
    type TwoDimensionalAggregationType<T extends AggregationKeyTypes | RangeKey<any>, V extends AggregationValueTypes> = TwoDimensionalAggregation<T extends AggregationKeyTypes ? AggKeyWireToClient<T> : T, AggValueWireToClient<V>>;
    type ThreeDimensionalAggregationType<OUT extends AggregationKeyTypes | RangeKey<any>, IN extends AggregationKeyTypes | RangeKey<any>, V extends AggregationValueTypes> = ThreeDimensionalAggregation<OUT extends AggregationKeyTypes ? AggKeyWireToClient<OUT> : OUT, IN extends AggregationKeyTypes ? AggKeyWireToClient<IN> : IN, AggValueWireToClient<V>>;
}

interface Logger {
    trace: Logger.LogFn;
    debug: Logger.LogFn;
    fatal: Logger.LogFn;
    error: Logger.LogFn;
    warn: Logger.LogFn;
    info: Logger.LogFn;
    isLevelEnabled(level: string): boolean;
    child(bindings: Record<string, any>, options?: {
        level?: string;
        msgPrefix?: string;
    }): Logger;
}
declare namespace Logger {
    interface LogFn {
        (obj: unknown, msg?: string, ...args: any[]): void;
        (msg: string, ...args: any[]): void;
    }
}

export { type ActionDefinition, type ActionEditResponse, ActionMetadata, ActionParam, type ActionReturnTypeForOptions, type ActionValidationResponse, type AllowedBucketKeyTypes$1 as AllowedBucketKeyTypes, type AllowedBucketTypes$1 as AllowedBucketTypes, type ApplyActionOptions, type ApplyBatchActionOptions, Attachment, AttachmentUpload, CompileTimeMetadata, type DataValueClientToWire, type DataValueWireToClient, InterfaceDefinition, Logger, MediaReference, MediaUpload, ObjectIdentifiers, type ObjectQueryDataType, type ObjectSet, type ObjectSetQueryDataType, ObjectTypeDefinition, type OntologyMetadata, OsdkBase, type OsdkObject, PrimaryKeyTypes, PropertyValueWireToClient, type QueryDataTypeDefinition, type QueryDefinition, type QueryMetadata, QueryParam, type QueryParameterDefinition, QueryResult, type Range, type ThreeDimensionalAggregation, type ThreeDimensionalQueryAggregationDefinition, type TwoDimensionalAggregation, type TwoDimensionalQueryAggregationDefinition };
